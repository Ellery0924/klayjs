var klayregister;
var klaycallback;
(function(){
var $wnd, $doc;if(typeof(window) !== 'undefined'){ $wnd = window; $doc = $wnd.document; }
else { $wnd = { Array: function(){} }; }
var $intern_0 = {3:1, 8:1, 5:1, 6:1}, $intern_1 = {3:1, 46:1}, $intern_2 = {3:1, 54:1, 46:1}, $intern_3 = 2147483647, $intern_4 = {181:1, 3:1, 54:1, 46:1}, $intern_5 = 65536, $intern_6 = 65535, $intern_7 = {3:1, 54:1, 29:1, 46:1}, $intern_8 = -2147483648, $intern_9 = {56:1}, $intern_10 = {23:1, 145:1, 185:1}, $intern_11 = {3:1, 5:1}, $intern_12 = {3:1, 5:1, 6:1}, $intern_13 = {3:1, 8:1, 5:1, 11:1, 6:1}, $intern_14 = {68:1, 136:1, 3:1, 23:1, 17:1}, $intern_15 = {108:1, 35:1}, $intern_16 = {108:1, 35:1, 96:1}, $intern_17 = {144:1, 3:1}, $intern_18 = {35:1}, $intern_19 = {57:1}, $intern_20 = {22:1, 19:1}, $intern_21 = {22:1, 19:1, 18:1}, $intern_22 = {22:1, 19:1, 20:1}, $intern_23 = {22:1, 19:1, 20:1, 67:1}, $intern_24 = {35:1, 96:1}, $intern_25 = {22:1, 19:1, 18:1, 137:1}, $intern_26 = {21:1}, $intern_27 = {207:1, 22:1, 19:1}, $intern_28 = {159:1, 3:1, 23:1, 17:1}, $intern_29 = 1073741824, $intern_30 = {22:1}, $intern_31 = {3:1, 22:1, 19:1}, $intern_32 = {89:1, 3:1, 22:1, 19:1, 20:1, 67:1}, $intern_33 = {3:1, 57:1}, $intern_34 = {3:1, 22:1, 19:1, 18:1}, $intern_35 = {63:1}, $intern_36 = {63:1, 188:1, 3:1, 23:1, 17:1}, $intern_37 = {52:1, 3:1, 5:1}, $intern_38 = {205:1, 3:1, 23:1, 17:1}, $intern_39 = 1.0E-4, $intern_40 = 4194303, $intern_41 = 1048575, $intern_42 = 4194304, $intern_43 = 17592186044416, $intern_44 = -17592186044416, $intern_45 = -1.7976931348623157E308, $intern_46 = {79:1, 23:1}, $intern_47 = {286:1, 121:1, 3:1, 5:1}, $intern_48 = {34:1, 3:1, 8:1, 5:1, 6:1}, $intern_49 = {38:1, 40:1, 42:1, 51:1, 71:1, 3:1, 8:1, 5:1, 6:1}, $intern_50 = Infinity, $intern_51 = -Infinity, $intern_52 = {68:1}, $intern_53 = {3:1, 5:1, 22:1, 13:1, 19:1, 20:1, 67:1}, $intern_54 = 1.600000023841858, $intern_55 = 0.001, $intern_56 = {31:1}, $intern_57 = {38:1, 40:1, 47:1, 42:1, 3:1, 8:1, 5:1, 6:1}, $intern_58 = 3.4028234663852886E38, $intern_59 = {38:1, 40:1, 42:1, 346:1, 71:1, 3:1, 8:1, 5:1, 6:1}, $intern_60 = 1.7976931348623157E308, $intern_61 = {250:1, 3:1, 5:1}, $intern_62 = 1.0E-8, $intern_63 = {227:1, 3:1, 5:1}, $intern_64 = {106:1, 31:1}, $intern_65 = 5.9604644775390625E-8, $intern_66 = 0.30000001192092896, $intern_67 = 0.699999988079071, $intern_68 = 0.8999999761581421, $intern_69 = {624:1, 3:1, 5:1, 6:1}, $intern_70 = 1.0E-6, $intern_71 = -1.0E-6, $intern_72 = 0.09999999999999998, $intern_73 = {3:1, 22:1, 19:1, 20:1, 67:1}, $intern_74 = {3:1, 5:1, 57:1}, $intern_75 = {3:1, 5:1, 22:1, 19:1, 50:1, 18:1}, $intern_76 = 15525485, $intern_77 = 16777216, $intern_78 = 16777215, $intern_79 = {3:1, 5:1, 22:1, 19:1, 20:1, 67:1}, $intern_80 = {3:1, 23:1, 17:1, 138:1};
var _, prototypesByTypeId_0, initFnList_0, permutationId = -1;
function setGwtProperty(propertyName, propertyValue){
  typeof window === 'object' && typeof window['$gwt'] === 'object' && (window['$gwt'][propertyName] = propertyValue);
}

function gwtOnLoad_0(errFn, modName, modBase, softPermutationId){
  ensureModuleInit();
  var initFnList = initFnList_0;
  $moduleName = modName;
  $moduleBase = modBase;
  permutationId = softPermutationId;
  function initializeModules(){
    for (var i = 0; i < initFnList.length; i++) {
      initFnList[i]();
    }
  }

  if (errFn) {
    try {
      $entry(initializeModules)();
    }
     catch (e) {
      errFn(modName, e);
    }
  }
   else {
    $entry(initializeModules)();
  }
}

function ensureModuleInit(){
  initFnList_0 == null && (initFnList_0 = []);
}

function addInitFunctions(){
  ensureModuleInit();
  var initFnList = initFnList_0;
  for (var i = 0; i < arguments.length; i++) {
    initFnList.push(arguments[i]);
  }
}

function typeMarkerFn(){
}

function portableObjCreate(obj){
  function F(){
  }

  ;
  F.prototype = obj || {};
  return new F;
}

function emptyMethod(){
}

function defineClass(typeId, superTypeIdOrPrototype, castableTypeMap){
  var prototypesByTypeId = prototypesByTypeId_0, superPrototype;
  var prototype_0 = prototypesByTypeId[typeId];
  var clazz = prototype_0 instanceof Array?prototype_0[0]:null;
  if (prototype_0 && !clazz) {
    _ = prototype_0;
  }
   else {
    _ = (superPrototype = superTypeIdOrPrototype && superTypeIdOrPrototype.prototype , !superPrototype && (superPrototype = prototypesByTypeId_0[superTypeIdOrPrototype]) , portableObjCreate(superPrototype));
    _.castableTypeMap = castableTypeMap;
    _.constructor = _;
    !superTypeIdOrPrototype && (_.typeMarker = typeMarkerFn);
    prototypesByTypeId[typeId] = _;
  }
  for (var i = 3; i < arguments.length; ++i) {
    arguments[i].prototype = _;
  }
  clazz && (_.___clazz = clazz);
}

function bootstrap(){
  prototypesByTypeId_0 = {};
  !Array.isArray && (Array.isArray = function(vArg){
    return Object.prototype.toString.call(vArg) === '[object Array]';
  }
  );
}

bootstrap();
function $toString(this$static){
  return $getName_1(getClass__Ljava_lang_Class___devirtual$(this$static)) + '@' + (hashCode__I__devirtual$(this$static) >>> 0).toString(16);
}

function Object_0(){
}

function equals_Ljava_lang_Object__Z__devirtual$(this$static, other){
  return instanceOfString(this$static)?$equals_5(this$static, other):instanceOfDouble(this$static)?(checkCriticalNotNull(this$static) , this$static === other):instanceOfBoolean(this$static)?(checkCriticalNotNull(this$static) , this$static === other):hasJavaObjectVirtualDispatch(this$static)?this$static.equals(other):isJavaArray(this$static)?this$static === other:this$static === other;
}

function getClass__Ljava_lang_Class___devirtual$(this$static){
  return instanceOfString(this$static)?Ljava_lang_String_2_classLit:instanceOfDouble(this$static)?Ljava_lang_Double_2_classLit:instanceOfBoolean(this$static)?Ljava_lang_Boolean_2_classLit:hasJavaObjectVirtualDispatch(this$static)?this$static.___clazz:isJavaArray(this$static)?this$static.___clazz:this$static.___clazz || Lcom_google_gwt_core_client_JavaScriptObject_2_classLit;
}

function hashCode__I__devirtual$(this$static){
  return instanceOfString(this$static)?getHashCode_0(this$static):instanceOfDouble(this$static)?round_int((checkCriticalNotNull(this$static) , this$static)):instanceOfBoolean(this$static)?unsafeCast((checkCriticalNotNull(this$static) , this$static))?1231:1237:hasJavaObjectVirtualDispatch(this$static)?this$static.hashCode_0():isJavaArray(this$static)?getObjectIdentityHashCode(this$static):getObjectIdentityHashCode(this$static);
}

function toString__Ljava_lang_String___devirtual$(this$static){
  return instanceOfString(this$static)?this$static:instanceOfDouble(this$static)?toString_74((checkCriticalNotNull(this$static) , this$static)):instanceOfBoolean(this$static)?toString_72(unsafeCast((checkCriticalNotNull(this$static) , this$static))):hasJavaObjectVirtualDispatch(this$static)?this$static.toString_0():isJavaArray(this$static)?$toString(this$static):this$static.toString?this$static.toString():'[JavaScriptObject]';
}

defineClass(1, null, {}, Object_0);
_.equals = function equals(other){
  return this === other;
}
;
_.getClass_0 = function getClass_0(){
  return this.___clazz;
}
;
_.hashCode_0 = function hashCode_0(){
  return getObjectIdentityHashCode(this);
}
;
_.toString_0 = function toString_0(){
  return $toString(this);
}
;
_.toString = function(){
  return this.toString_0();
}
;
function $fillInStackTrace(this$static){
  this$static.stackTrace = null;
  captureStackTrace(this$static, this$static.detailMessage);
  return this$static;
}

function $printStackTraceImpl(this$static, out, ident){
  var t, t$array, t$index, t$max, theCause;
  $printStackTraceItems(this$static);
  for (t$array = (this$static.suppressedExceptions == null && (this$static.suppressedExceptions = initUnidimensionalArray(Ljava_lang_Throwable_2_classLit, $intern_0, 46, 0, 0, 1)) , this$static.suppressedExceptions) , t$index = 0 , t$max = t$array.length; t$index < t$max; ++t$index) {
    t = t$array[t$index];
    $printStackTraceImpl(t, out, '\t' + ident);
  }
  theCause = this$static.cause;
  !!theCause && $printStackTraceImpl(theCause, out, ident);
}

function $printStackTraceItems(this$static){
  var element$array, element$index, element$max;
  for (element$array = (this$static.stackTrace == null && (this$static.stackTrace = constructJavaStackTrace(this$static)) , this$static.stackTrace) , element$index = 0 , element$max = element$array.length; element$index < element$max; ++element$index)
  ;
}

defineClass(46, 1, $intern_1);
_.getMessage = function getMessage(){
  return this.detailMessage;
}
;
_.toString_0 = function toString_33(){
  var className, msg;
  return className = $getName_1(this.___clazz) , msg = this.getMessage() , msg != null?className + ': ' + msg:className;
}
;
function Exception(message){
  this.detailMessage = message;
  $fillInStackTrace(this);
}

defineClass(54, 46, $intern_2);
function RuntimeException(){
  $fillInStackTrace(this);
}

function RuntimeException_0(message){
  Exception.call(this, message);
}

defineClass(72, 54, $intern_2, RuntimeException_0);
function $clinit_JavaScriptException(){
  $clinit_JavaScriptException = emptyMethod;
  NOT_SET = new Object_0;
}

function $ensureInit(this$static){
  var exception;
  if (this$static.message_0 == null) {
    exception = maskUndefined(this$static.e) === maskUndefined(NOT_SET)?null:this$static.e;
    this$static.name_0 = exception == null?'null':instanceOfJso(exception)?getExceptionName0(castToJso(exception)):instanceOfString(exception)?'String':$getName_1(getClass__Ljava_lang_Class___devirtual$(exception));
    this$static.description = this$static.description + ': ' + (instanceOfJso(exception)?getExceptionDescription0(castToJso(exception)):exception + '');
    this$static.message_0 = '(' + this$static.name_0 + ') ' + this$static.description;
  }
}

function JavaScriptException(e){
  $clinit_JavaScriptException();
  this.cause = null;
  this.detailMessage = null;
  this.description = '';
  this.e = e;
  this.description = '';
}

function getExceptionDescription0(e){
  return e == null?null:e.message;
}

function getExceptionName0(e){
  return e == null?null:e.name;
}

defineClass(164, 72, {164:1, 3:1, 54:1, 46:1}, JavaScriptException);
_.getMessage = function getMessage_0(){
  $ensureInit(this);
  return this.message_0;
}
;
_.getThrown = function getThrown(){
  return maskUndefined(this.e) === maskUndefined(NOT_SET)?null:this.e;
}
;
var NOT_SET;
function $clinit_StackTraceCreator(){
  $clinit_StackTraceCreator = emptyMethod;
  var c, enforceLegacy;
  enforceLegacy = !(!!Error.stackTraceLimit || 'stack' in new Error);
  c = new StackTraceCreator$CollectorModernNoSourceMap;
  collector = enforceLegacy?new StackTraceCreator$CollectorLegacy:c;
}

function captureStackTrace(throwable, reference){
  $clinit_StackTraceCreator();
  collector.collect(throwable, reference);
}

function constructJavaStackTrace(thrown){
  $clinit_StackTraceCreator();
  var stackTrace;
  stackTrace = collector.getStackTrace(thrown);
  return dropInternalFrames(stackTrace);
}

function dropInternalFrames(stackTrace){
  var dropFrameUntilFnName, i, numberOfFrameToSearch;
  dropFrameUntilFnName = 'captureStackTrace';
  numberOfFrameToSearch = min_3(stackTrace.length, 5);
  for (i = 0; i < numberOfFrameToSearch; i++) {
    if ($equals_5(stackTrace[i].methodName, dropFrameUntilFnName)) {
      stackTrace.length >= i + 1 && (stackTrace.splice(0, i + 1) , undefined);
      break;
    }
  }
  return stackTrace;
}

function extractFunctionName(fnName){
  var fnRE = /function(?:\s+([\w$]+))?\s*\(/;
  var match_0 = fnRE.exec(fnName);
  return match_0 && match_0[1] || 'anonymous';
}

function parseInt_0(number){
  $clinit_StackTraceCreator();
  return parseInt(number) || -1;
}

var collector;
defineClass(641, 1, {});
function StackTraceCreator$CollectorLegacy(){
}

defineClass(356, 641, {}, StackTraceCreator$CollectorLegacy);
_.collect = function collect(t, thrownIgnored){
  var seen = {}, name_1;
  var fnStack = [];
  t.__gwt$backingJsError = {'fnStack':fnStack};
  var callee = arguments.callee.caller;
  while (callee) {
    var name_0 = ($clinit_StackTraceCreator() , callee.name || (callee.name = extractFunctionName(callee.toString())));
    fnStack.push(name_0);
    var keyName = ':' + name_0;
    var withThisName = seen[keyName];
    if (withThisName) {
      var i, j;
      for (i = 0 , j = withThisName.length; i < j; i++) {
        if (withThisName[i] === callee) {
          return;
        }
      }
    }
    (withThisName || (seen[keyName] = [])).push(callee);
    callee = callee.caller;
  }
}
;
_.getStackTrace = function getStackTrace(t){
  var i, length_0, stack_0, stackTrace, e;
  stack_0 = ($clinit_StackTraceCreator() , e = t.__gwt$backingJsError , e && e.fnStack?e.fnStack:[]);
  length_0 = stack_0.length;
  stackTrace = initUnidimensionalArray(Ljava_lang_StackTraceElement_2_classLit, $intern_0, 146, length_0, 0, 1);
  for (i = 0; i < length_0; i++) {
    stackTrace[i] = new StackTraceElement(stack_0[i], null, -1);
  }
  return stackTrace;
}
;
function $clinit_StackTraceCreator$CollectorModern(){
  $clinit_StackTraceCreator$CollectorModern = emptyMethod;
  Error.stackTraceLimit = 64;
}

function $parse(this$static, stString){
  var closeParen, col, endFileUrlIndex, fileName, index_0, lastColonIndex, line, location_0, toReturn;
  if (($clinit_String() , stString.length) == 0) {
    return this$static.createSte('Unknown', 'anonymous', -1, -1);
  }
  toReturn = $trim(stString);
  $equals_5(toReturn.substr(0, 3), 'at ') && (toReturn = __substr(toReturn, 3, toReturn.length - 3));
  toReturn = toReturn.replace(/\[.*?\]/g, '');
  index_0 = toReturn.indexOf('(');
  if (index_0 == -1) {
    index_0 = toReturn.indexOf('@');
    if (index_0 == -1) {
      location_0 = toReturn;
      toReturn = '';
    }
     else {
      location_0 = $trim(__substr(toReturn, index_0 + 1, toReturn.length - (index_0 + 1)));
      toReturn = $trim(toReturn.substr(0, index_0));
    }
  }
   else {
    closeParen = toReturn.indexOf(')', index_0);
    location_0 = toReturn.substr(index_0 + 1, closeParen - (index_0 + 1));
    toReturn = $trim(toReturn.substr(0, index_0));
  }
  index_0 = indexOf_0(toReturn, fromCodePoint(46));
  index_0 != -1 && (toReturn = __substr(toReturn, index_0 + 1, toReturn.length - (index_0 + 1)));
  (toReturn.length == 0 || $equals_5(toReturn, 'Anonymous function')) && (toReturn = 'anonymous');
  lastColonIndex = lastIndexOf(location_0, fromCodePoint(58));
  endFileUrlIndex = lastIndexOf_0(location_0, fromCodePoint(58), lastColonIndex - 1);
  line = -1;
  col = -1;
  fileName = 'Unknown';
  if (lastColonIndex != -1 && endFileUrlIndex != -1) {
    fileName = location_0.substr(0, endFileUrlIndex);
    line = parseInt_0(location_0.substr(endFileUrlIndex + 1, lastColonIndex - (endFileUrlIndex + 1)));
    col = parseInt_0(__substr(location_0, lastColonIndex + 1, location_0.length - (lastColonIndex + 1)));
  }
  return this$static.createSte(fileName, toReturn, line, col);
}

defineClass(642, 641, {});
_.collect = function collect_0(t, jsThrown){
  function fixIE(e){
    if (!('stack' in e)) {
      try {
        throw e;
      }
       catch (ignored) {
      }
    }
    return e;
  }

  var backingJsError;
  typeof jsThrown == 'string'?(backingJsError = fixIE(new Error(jsThrown.replace('\n', ' ')))):jsThrown && typeof jsThrown == 'object' && 'stack' in jsThrown?(backingJsError = jsThrown):(backingJsError = fixIE(new Error));
  t.__gwt$backingJsError = backingJsError;
}
;
_.createSte = function createSte(fileName, method, line, col){
  return new StackTraceElement(method, fileName + '@' + col, line < 0?-1:line);
}
;
_.getStackTrace = function getStackTrace_0(t){
  var addIndex, i, length_0, stack_0, stackTrace, ste, e;
  stack_0 = ($clinit_StackTraceCreator() , e = t.__gwt$backingJsError , e && e.stack?e.stack.split('\n'):[]);
  stackTrace = initUnidimensionalArray(Ljava_lang_StackTraceElement_2_classLit, $intern_0, 146, 0, 0, 1);
  addIndex = 0;
  length_0 = stack_0.length;
  if (length_0 == 0) {
    return stackTrace;
  }
  ste = $parse(this, stack_0[0]);
  $equals_5(ste.methodName, 'anonymous') || (stackTrace[addIndex++] = ste);
  for (i = 1; i < length_0; i++) {
    stackTrace[addIndex++] = $parse(this, stack_0[i]);
  }
  return stackTrace;
}
;
function StackTraceCreator$CollectorModernNoSourceMap(){
  $clinit_StackTraceCreator$CollectorModern();
}

defineClass(357, 642, {}, StackTraceCreator$CollectorModernNoSourceMap);
_.createSte = function createSte_0(fileName, method, line, col){
  return new StackTraceElement(method, fileName, -1);
}
;
function canSet(array, value_0){
  switch (getElementTypeCategory(array)) {
    case 5:
      return instanceOfString(value_0);
    case 6:
      return instanceOfDouble(value_0);
    case 7:
      return instanceOfBoolean(value_0);
    case 0:
      return canCast(value_0, array.__elementTypeId$);
    case 2:
      return isJsObjectOrFunction(value_0) && !(value_0.typeMarker === typeMarkerFn);
    case 1:
      return isJsObjectOrFunction(value_0) && !(value_0.typeMarker === typeMarkerFn) || canCast(value_0, array.__elementTypeId$);
    default:return true;
  }
}

function getClassLiteralForArray(clazz, dimensions){
  return getClassLiteralForArray_0(clazz, dimensions);
}

function getElementTypeCategory(array){
  return array.__elementTypeCategory$ == null?9:array.__elementTypeCategory$;
}

function initMultidimensionalArray(leafClassLiteral, castableTypeMapExprs, elementTypeIds, leafElementTypeCategory, dimExprs, count){
  return initMultidimensionalArray_0(leafClassLiteral, castableTypeMapExprs, elementTypeIds, leafElementTypeCategory, dimExprs, 0, count);
}

function initMultidimensionalArray_0(leafClassLiteral, castableTypeMapExprs, elementTypeIds, leafElementTypeCategory, dimExprs, index_0, count){
  var elementTypeCategory, i, isLastDimension, length_0, result;
  length_0 = dimExprs[index_0];
  isLastDimension = index_0 == count - 1;
  elementTypeCategory = isLastDimension?leafElementTypeCategory:0;
  result = initializeArrayElementsWithDefaults(elementTypeCategory, length_0);
  leafElementTypeCategory != 9 && stampJavaTypeInfo(getClassLiteralForArray(leafClassLiteral, count - index_0), castableTypeMapExprs[index_0], elementTypeIds[index_0], elementTypeCategory, result);
  if (!isLastDimension) {
    ++index_0;
    for (i = 0; i < length_0; ++i) {
      result[i] = initMultidimensionalArray_0(leafClassLiteral, castableTypeMapExprs, elementTypeIds, leafElementTypeCategory, dimExprs, index_0, count);
    }
  }
  return result;
}

function initUnidimensionalArray(leafClassLiteral, castableTypeMap, elementTypeId, length_0, elementTypeCategory, dimensions){
  var result;
  result = initializeArrayElementsWithDefaults(elementTypeCategory, length_0);
  elementTypeCategory != 9 && stampJavaTypeInfo(getClassLiteralForArray(leafClassLiteral, dimensions), castableTypeMap, elementTypeId, elementTypeCategory, result);
  return result;
}

function initializeArrayElementsWithDefaults(elementTypeCategory, length_0){
  var array = new Array(length_0);
  var initValue;
  switch (elementTypeCategory) {
    case 11:
    case 12:
      initValue = 0;
      break;
    case 13:
      initValue = false;
      break;
    default:return array;
  }
  for (var i = 0; i < length_0; ++i) {
    array[i] = initValue;
  }
  return array;
}

function isJavaArray(src_0){
  return Array.isArray(src_0) && src_0.typeMarker === typeMarkerFn;
}

function setCheck(array, index_0, value_0){
  checkCriticalArrayType(value_0 == null || canSet(array, value_0));
  return array[index_0] = value_0;
}

function stampJavaTypeInfo(arrayClass, castableTypeMap, elementTypeId, elementTypeCategory, array){
  array.___clazz = arrayClass;
  array.castableTypeMap = castableTypeMap;
  array.typeMarker = typeMarkerFn;
  array.__elementTypeId$ = elementTypeId;
  array.__elementTypeCategory$ = elementTypeCategory;
  return array;
}

function stampJavaTypeInfo_0(array, referenceType){
  getElementTypeCategory(referenceType) != 9 && stampJavaTypeInfo(getClass__Ljava_lang_Class___devirtual$(referenceType), referenceType.castableTypeMap, referenceType.__elementTypeId$, getElementTypeCategory(referenceType), array);
  return array;
}

function canCast(src_0, dstId){
  if (instanceOfString(src_0)) {
    return !!stringCastMap[dstId];
  }
   else if (src_0.castableTypeMap) {
    return !!src_0.castableTypeMap[dstId];
  }
   else if (instanceOfDouble(src_0)) {
    return !!doubleCastMap[dstId];
  }
   else if (instanceOfBoolean(src_0)) {
    return !!booleanCastMap[dstId];
  }
  return false;
}

function castTo(src_0, dstId){
  checkCriticalType(src_0 == null || canCast(src_0, dstId));
  return src_0;
}

function castToBoolean(src_0){
  checkCriticalType(src_0 == null || instanceOfBoolean(src_0));
  return src_0;
}

function castToDouble(src_0){
  checkCriticalType(src_0 == null || instanceOfDouble(src_0));
  return src_0;
}

function castToJso(src_0){
  checkCriticalType(src_0 == null || isJsObjectOrFunction(src_0) && !(src_0.typeMarker === typeMarkerFn));
  return src_0;
}

function castToString(src_0){
  checkCriticalType(src_0 == null || instanceOfString(src_0));
  return src_0;
}

function charToString(x_0){
  return String.fromCharCode(x_0);
}

function hasJavaObjectVirtualDispatch(src_0){
  return !Array.isArray(src_0) && src_0.typeMarker === typeMarkerFn;
}

function instanceOf(src_0, dstId){
  return src_0 != null && canCast(src_0, dstId);
}

function instanceOfBoolean(src_0){
  return typeof src_0 === 'boolean';
}

function instanceOfDouble(src_0){
  return typeof src_0 === 'number';
}

function instanceOfJso(src_0){
  return src_0 != null && isJsObjectOrFunction(src_0) && !(src_0.typeMarker === typeMarkerFn);
}

function instanceOfString(src_0){
  return typeof src_0 === 'string';
}

function isJsObjectOrFunction(src_0){
  return typeof src_0 === 'object' || typeof src_0 === 'function';
}

function maskUndefined(src_0){
  return src_0 == null?null:src_0;
}

function round_int(x_0){
  return Math.max(Math.min(x_0, $intern_3), -2147483648) | 0;
}

function throwClassCastExceptionUnlessNull(o){
  checkCriticalType(o == null);
  return o;
}

var booleanCastMap, doubleCastMap, stringCastMap;
function cacheJavaScriptException(e, jse){
  if (e && typeof e == 'object') {
    try {
      e.__gwt$exception = jse;
    }
     catch (ignored) {
    }
  }
}

function unwrap_5(e){
  var jse;
  if (instanceOf(e, 164)) {
    jse = castTo(e, 164);
    if (maskUndefined(jse.e) !== maskUndefined(($clinit_JavaScriptException() , NOT_SET))) {
      return maskUndefined(jse.e) === maskUndefined(NOT_SET)?null:jse.e;
    }
  }
  return e;
}

function wrap(e){
  var jse;
  if (instanceOf(e, 46)) {
    return e;
  }
  jse = e && e.__gwt$exception;
  if (!jse) {
    jse = new JavaScriptException(e);
    captureStackTrace(jse, e);
    cacheJavaScriptException(e, jse);
  }
  return jse;
}

defineClass(181, 54, $intern_4);
function UnsupportedEncodingException(msg){
  Exception.call(this, msg);
}

defineClass(351, 181, $intern_4, UnsupportedEncodingException);
function digit(c){
  if (c >= 48 && c < 58) {
    return c - 48;
  }
  if (c >= 97 && c < 97) {
    return c - 97 + 10;
  }
  if (c >= 65 && c < 65) {
    return c - 65 + 10;
  }
  return -1;
}

function toChars(codePoint, dst, dstIndex){
  checkCriticalArgument(codePoint >= 0 && codePoint <= 1114111);
  if (codePoint >= $intern_5) {
    dst[dstIndex++] = 55296 + (codePoint - $intern_5 >> 10 & 1023) & $intern_6;
    dst[dstIndex] = 56320 + (codePoint - $intern_5 & 1023) & $intern_6;
    return 2;
  }
   else {
    dst[dstIndex] = codePoint & $intern_6;
    return 1;
  }
}

function $ensureNamesAreInitialized(this$static){
  if (this$static.typeName != null) {
    return;
  }
  initializeNames(this$static);
}

function $getEnumConstants(this$static){
  return this$static.enumConstantsFunc && this$static.enumConstantsFunc();
}

function $getName_1(this$static){
  $ensureNamesAreInitialized(this$static);
  return this$static.typeName;
}

function $getSimpleName(this$static){
  $ensureNamesAreInitialized(this$static);
  return this$static.simpleName;
}

function Class(){
  ++nextSequentialId;
  this.typeName = null;
  this.simpleName = null;
  this.packageName = null;
  this.compoundName = null;
  this.canonicalName = null;
  this.typeId = null;
  this.arrayLiterals = null;
}

function createClassObject(packageName, compoundClassName){
  var clazz;
  clazz = new Class;
  clazz.packageName = packageName;
  clazz.compoundName = compoundClassName;
  return clazz;
}

function createForClass(packageName, compoundClassName, typeId){
  var clazz;
  clazz = createClassObject(packageName, compoundClassName);
  maybeSetClassLiteral(typeId, clazz);
  return clazz;
}

function createForEnum(packageName, compoundClassName, typeId, superclass, enumConstantsFunc){
  var clazz;
  clazz = createClassObject(packageName, compoundClassName);
  maybeSetClassLiteral(typeId, clazz);
  clazz.modifiers = enumConstantsFunc?8:0;
  clazz.enumSuperclass = superclass;
  clazz.enumConstantsFunc = enumConstantsFunc;
  return clazz;
}

function createForInterface(packageName, compoundClassName){
  var clazz;
  clazz = createClassObject(packageName, compoundClassName);
  clazz.modifiers = 2;
  return clazz;
}

function createForPrimitive(className, primitiveTypeId){
  var clazz;
  clazz = createClassObject('', className);
  clazz.typeId = primitiveTypeId;
  clazz.modifiers = 1;
  return clazz;
}

function getClassLiteralForArray_0(leafClass, dimensions){
  var arrayLiterals = leafClass.arrayLiterals = leafClass.arrayLiterals || [];
  return arrayLiterals[dimensions] || (arrayLiterals[dimensions] = leafClass.createClassLiteralForArray(dimensions));
}

function getPrototypeForClass(clazz){
  if (clazz.isPrimitive()) {
    return null;
  }
  var typeId = clazz.typeId;
  var prototype_0 = prototypesByTypeId_0[typeId];
  return prototype_0;
}

function initializeNames(clazz){
  if (clazz.isArray_1()) {
    var componentType = clazz.componentType;
    componentType.isPrimitive()?(clazz.typeName = '[' + componentType.typeId):!componentType.isArray_1()?(clazz.typeName = '[L' + componentType.getName() + ';'):(clazz.typeName = '[' + componentType.getName());
    clazz.canonicalName = componentType.getCanonicalName() + '[]';
    clazz.simpleName = componentType.getSimpleName() + '[]';
    return;
  }
  var packageName = clazz.packageName;
  var compoundName = clazz.compoundName;
  compoundName = compoundName.split('/');
  clazz.typeName = join_0('.', [packageName, join_0('$', compoundName)]);
  clazz.canonicalName = join_0('.', [packageName, join_0('.', compoundName)]);
  clazz.simpleName = compoundName[compoundName.length - 1];
}

function join_0(separator, strings){
  var i = 0;
  while (!strings[i] || strings[i] == '') {
    i++;
  }
  var result = strings[i++];
  for (; i < strings.length; i++) {
    if (!strings[i] || strings[i] == '') {
      continue;
    }
    result += separator + strings[i];
  }
  return result;
}

function maybeSetClassLiteral(typeId, clazz){
  var proto;
  if (!typeId) {
    return;
  }
  clazz.typeId = typeId;
  var prototype_0 = getPrototypeForClass(clazz);
  if (!prototype_0) {
    prototypesByTypeId_0[typeId] = [clazz];
    return;
  }
  prototype_0.___clazz = clazz;
}

defineClass(288, 1, {}, Class);
_.createClassLiteralForArray = function createClassLiteralForArray(dimensions){
  var clazz;
  clazz = new Class;
  clazz.modifiers = 4;
  dimensions > 1?(clazz.componentType = getClassLiteralForArray_0(this, dimensions - 1)):(clazz.componentType = this);
  return clazz;
}
;
_.getCanonicalName = function getCanonicalName(){
  $ensureNamesAreInitialized(this);
  return this.canonicalName;
}
;
_.getName = function getName(){
  return $getName_1(this);
}
;
_.getSimpleName = function getSimpleName(){
  return $getSimpleName(this);
}
;
_.isArray_1 = function isArray_1(){
  return (this.modifiers & 4) != 0;
}
;
_.isPrimitive = function isPrimitive(){
  return (this.modifiers & 1) != 0;
}
;
_.toString_0 = function toString_73(){
  return ((this.modifiers & 2) != 0?'interface ':(this.modifiers & 1) != 0?'':'class ') + ($ensureNamesAreInitialized(this) , this.typeName);
}
;
_.modifiers = 0;
var nextSequentialId = 1;
function ClassCastException(){
  RuntimeException.call(this);
}

defineClass(119, 72, {3:1, 119:1, 54:1, 46:1}, ClassCastException);
function IllegalArgumentException(){
  RuntimeException.call(this);
}

function IllegalArgumentException_0(message){
  RuntimeException_0.call(this, message);
}

defineClass(29, 72, $intern_7, IllegalArgumentException, IllegalArgumentException_0);
function IndexOutOfBoundsException(){
  RuntimeException.call(this);
}

function IndexOutOfBoundsException_0(message){
  RuntimeException_0.call(this, message);
}

defineClass(95, 72, $intern_2, IndexOutOfBoundsException, IndexOutOfBoundsException_0);
function __parseAndValidateDouble(s){
  floatRegex == null && (floatRegex = /^\s*[+-]?(NaN|Infinity|((\d+\.?\d*)|(\.\d+))([eE][+-]?\d+)?[dDfF]?)\s*$/);
  if (!regexTest(floatRegex, s)) {
    throw new NumberFormatException_0('For input string: "' + s + '"');
  }
  return parseFloat(s);
}

function __parseAndValidateInt(s){
  var i, isTooLow, length_0, startIndex, toReturn;
  length_0 = ($clinit_String() , s.length);
  startIndex = length_0 > 0 && (s.charCodeAt(0) == 45 || s.charCodeAt(0) == 43)?1:0;
  for (i = startIndex; i < length_0; i++) {
    if (digit(s.charCodeAt(i)) == -1) {
      throw new NumberFormatException_0('For input string: "' + s + '"');
    }
  }
  toReturn = parseInt(s, 10);
  isTooLow = toReturn < $intern_8;
  if (isNaN(toReturn)) {
    throw new NumberFormatException_0('For input string: "' + s + '"');
  }
   else if (isTooLow || toReturn > $intern_3) {
    throw new NumberFormatException_0('For input string: "' + s + '"');
  }
  return toReturn;
}

function regexTest(regex, value_0){
  return regex.test(value_0);
}

defineClass(231, 1, {3:1, 231:1});
var floatRegex;
function $compareTo_14(this$static, b){
  return compare_32(this$static.value_0, b.value_0);
}

function Integer(value_0){
  this.value_0 = value_0;
}

function compare_32(x_0, y_0){
  return x_0 < y_0?-1:x_0 > y_0?1:0;
}

function reverse_2(i){
  var nibbles;
  nibbles = ($clinit_Integer$ReverseNibbles() , reverseNibbles);
  return nibbles[i >>> 28] | nibbles[i >> 24 & 15] << 4 | nibbles[i >> 20 & 15] << 8 | nibbles[i >> 16 & 15] << 12 | nibbles[i >> 12 & 15] << 16 | nibbles[i >> 8 & 15] << 20 | nibbles[i >> 4 & 15] << 24 | nibbles[i & 15] << 28;
}

function toString_78(value_0){
  return $clinit_String() , '' + value_0;
}

function valueOf_0(i){
  var rebase, result;
  if (i > -129 && i < 128) {
    rebase = i + 128;
    result = ($clinit_Integer$BoxedValues() , boxedValues)[rebase];
    !result && (result = boxedValues[rebase] = new Integer(i));
    return result;
  }
  return new Integer(i);
}

defineClass(24, 231, {3:1, 23:1, 24:1, 231:1}, Integer);
_.compareTo = function compareTo_14(b){
  return $compareTo_14(this, castTo(b, 24));
}
;
_.equals = function equals_39(o){
  return instanceOf(o, 24) && castTo(o, 24).value_0 == this.value_0;
}
;
_.hashCode_0 = function hashCode_39(){
  return this.value_0;
}
;
_.toString_0 = function toString_77(){
  return toString_78(this.value_0);
}
;
_.value_0 = 0;
function $clinit_String(){
  $clinit_String = emptyMethod;
  new String$1;
}

function $compareToIgnoreCase(this$static, other){
  return compareTo_15(($clinit_String() , this$static.toLowerCase()), other.toLowerCase());
}

function $endsWith(this$static, suffix){
  var suffixlength;
  suffixlength = ($clinit_String() , suffix.length);
  return $equals_5(__substr(this$static, this$static.length - suffixlength, suffixlength), suffix);
}

function $equals_5(this$static, other){
  return this$static === other;
}

function $split_1(this$static, regex){
  var compiled, count, lastNonEmpty, lastTrail, matchObj, out, trail;
  compiled = RegExp(regex, 'g');
  out = initUnidimensionalArray(Ljava_lang_String_2_classLit, $intern_0, 2, 0, 5, 1);
  count = 0;
  trail = this$static;
  lastTrail = null;
  while (true) {
    matchObj = compiled.exec(trail);
    if (matchObj == null || trail == '') {
      out[count] = trail;
      break;
    }
     else {
      out[count] = $substring_0(trail, 0, matchObj.index);
      trail = $substring_0(trail, matchObj.index + matchObj[0].length, ($clinit_String() , trail.length));
      compiled.lastIndex = 0;
      if (lastTrail == trail) {
        out[count] = trail.substr(0, 1);
        trail = __substr(trail, 1, trail.length - 1);
      }
      lastTrail = trail;
      ++count;
    }
  }
  if (($clinit_String() , this$static.length) > 0) {
    lastNonEmpty = out.length;
    while (lastNonEmpty > 0 && out[lastNonEmpty - 1] == '') {
      --lastNonEmpty;
    }
    lastNonEmpty < out.length && (out.length = lastNonEmpty , undefined);
  }
  return out;
}

function $substring_0(this$static, beginIndex, endIndex){
  return $clinit_String() , this$static.substr(beginIndex, endIndex - beginIndex);
}

function $trim(this$static){
  var end, length_0, start_0;
  length_0 = ($clinit_String() , this$static.length);
  start_0 = 0;
  while (start_0 < length_0 && this$static.charCodeAt(start_0) <= 32) {
    ++start_0;
  }
  end = length_0;
  while (end > start_0 && this$static.charCodeAt(end - 1) <= 32) {
    --end;
  }
  return start_0 > 0 || end < length_0?this$static.substr(start_0, end - start_0):this$static;
}

function __substr(str, beginIndex, len){
  $clinit_String();
  return str.substr(beginIndex, len);
}

function charAt(s, index_0){
  $clinit_String();
  return s.charCodeAt(index_0);
}

function compareTo_15(thisStr, otherStr){
  $clinit_String();
  if (thisStr == otherStr) {
    return 0;
  }
  return thisStr < otherStr?-1:1;
}

function fromCodePoint(codePoint){
  $clinit_String();
  var hiSurrogate, loSurrogate;
  if (codePoint >= $intern_5) {
    hiSurrogate = 55296 + (codePoint - $intern_5 >> 10 & 1023) & $intern_6;
    loSurrogate = 56320 + (codePoint - $intern_5 & 1023) & $intern_6;
    return String.fromCharCode(hiSurrogate) + ('' + String.fromCharCode(loSurrogate));
  }
   else {
    return String.fromCharCode(codePoint & $intern_6);
  }
}

function indexOf_0(s, str){
  $clinit_String();
  return s.indexOf(str);
}

function lastIndexOf(s, str){
  $clinit_String();
  return s.lastIndexOf(str);
}

function lastIndexOf_0(s, str, start_0){
  $clinit_String();
  return s.lastIndexOf(str, start_0);
}

function length_1(s){
  $clinit_String();
  return s.length;
}

function valueOf_1(x_0){
  $clinit_String();
  return x_0 == null?'null':toString__Ljava_lang_String___devirtual$(x_0);
}

stringCastMap = {3:1, 345:1, 23:1, 2:1};
function $compare_16(a, b){
  return compareTo_15(($clinit_String() , a.toLowerCase()), b.toLowerCase());
}

function String$1(){
}

defineClass(350, 1, $intern_9, String$1);
_.compare_0 = function compare_33(a, b){
  return $compare_16(castToString(a), castToString(b));
}
;
function StringIndexOutOfBoundsException(message){
  IndexOutOfBoundsException_0.call(this, message);
}

defineClass(257, 95, $intern_2, StringIndexOutOfBoundsException);
function $compareTo_15(this$static, that){
  return $compareToIgnoreCase(this$static.name_0, that.name_0);
}

defineClass(145, 1, {23:1, 145:1});
_.compareTo = function compareTo_16(that){
  return $compareTo_15(this, castTo(that, 145));
}
;
_.equals = function equals_41(o){
  var that;
  if (o === this) {
    return true;
  }
  if (!instanceOf(o, 145)) {
    return false;
  }
  that = castTo(o, 145);
  return $equals_5(this.name_0, that.name_0);
}
;
_.hashCode_0 = function hashCode_41(){
  return getHashCode_0(this.name_0);
}
;
_.toString_0 = function toString_80(){
  return this.name_0;
}
;
function IllegalCharsetNameException(charsetName){
  IllegalArgumentException_0.call(this, ($clinit_String() , charsetName == null?'null':charsetName));
}

defineClass(358, 29, $intern_7, IllegalCharsetNameException);
function UnsupportedCharsetException(charsetName){
  IllegalArgumentException_0.call(this, ($clinit_String() , charsetName == null?'null':charsetName));
}

defineClass(256, 29, {3:1, 54:1, 29:1, 46:1, 256:1}, UnsupportedCharsetException);
function applySplice(array, index_0, deleteCount, arrayToAdd){
  Array.prototype.splice.apply(array, [index_0, deleteCount].concat(arrayToAdd));
}

function clone_2(array, toIndex){
  var result;
  result = array.slice(0, toIndex);
  return stampJavaTypeInfo_0(result, array);
}

function copy_0(src_0, srcOfs, dest, destOfs, len, overwrite){
  var batchEnd, batchStart, end;
  if (maskUndefined(src_0) === maskUndefined(dest)) {
    src_0 = src_0.slice(srcOfs, srcOfs + len);
    srcOfs = 0;
  }
  for (batchStart = srcOfs , end = srcOfs + len; batchStart < end;) {
    batchEnd = batchStart + 10000 < end?batchStart + 10000:end;
    len = batchEnd - batchStart;
    applySplice(dest, destOfs, overwrite?len:0, src_0.slice(batchStart, batchEnd));
    batchStart = batchEnd;
    destOfs += len;
  }
}

function createFrom(array, length_0){
  var result;
  result = new Array(length_0);
  return stampJavaTypeInfo_0(result, array);
}

function insertTo(array, index_0, value_0){
  array.splice(index_0, 0, value_0);
}

function insertTo_0(array, index_0, values){
  copy_0(values, 0, array, index_0, values.length, false);
}

function removeFrom(array, index_0, deleteCount){
  array.splice(index_0, deleteCount);
}

function $clinit_EmulatedCharset(){
  $clinit_EmulatedCharset = emptyMethod;
  UTF_8 = new EmulatedCharset$UtfCharset;
  ISO_LATIN_1 = new EmulatedCharset$LatinCharset('ISO-LATIN-1');
  ISO_8859_1 = new EmulatedCharset$LatinCharset('ISO-8859-1');
}

function EmulatedCharset(name_0){
  this.name_0 = name_0;
}

defineClass(185, 145, $intern_10);
var ISO_8859_1, ISO_LATIN_1, UTF_8;
function EmulatedCharset$LatinCharset(name_0){
  EmulatedCharset.call(this, name_0);
}

defineClass(289, 185, $intern_10, EmulatedCharset$LatinCharset);
_.decodeString = function decodeString(bytes, ofs, len){
  var chars, i;
  chars = initUnidimensionalArray(C_classLit, $intern_11, 26, len, 12, 1);
  for (i = 0; i < len; ++i) {
    chars[i] = bytes[ofs + i] & 255 & $intern_6;
  }
  return chars;
}
;
function EmulatedCharset$UtfCharset(){
  EmulatedCharset.call(this, 'UTF-8');
}

defineClass(355, 185, $intern_10, EmulatedCharset$UtfCharset);
_.decodeString = function decodeString_0(bytes, ofs, len){
  var b, ch_0, charCount, chars, count, i, i0, outIdx;
  charCount = 0;
  for (i0 = 0; i0 < len;) {
    ++charCount;
    ch_0 = bytes[ofs + i0];
    if ((ch_0 & 192) == 128) {
      throw new IllegalArgumentException_0('Invalid UTF8 sequence');
    }
     else if ((ch_0 & 128) == 0) {
      ++i0;
    }
     else if ((ch_0 & 224) == 192) {
      i0 += 2;
    }
     else if ((ch_0 & 240) == 224) {
      i0 += 3;
    }
     else if ((ch_0 & 248) == 240) {
      i0 += 4;
    }
     else {
      throw new IllegalArgumentException_0('Invalid UTF8 sequence');
    }
    if (i0 > len) {
      throw new IndexOutOfBoundsException_0('Invalid UTF8 sequence');
    }
  }
  chars = initUnidimensionalArray(C_classLit, $intern_11, 26, charCount, 12, 1);
  outIdx = 0;
  count = 0;
  for (i = 0; i < len;) {
    ch_0 = bytes[ofs + i++];
    if ((ch_0 & 128) == 0) {
      count = 1;
      ch_0 &= 127;
    }
     else if ((ch_0 & 224) == 192) {
      count = 2;
      ch_0 &= 31;
    }
     else if ((ch_0 & 240) == 224) {
      count = 3;
      ch_0 &= 15;
    }
     else if ((ch_0 & 248) == 240) {
      count = 4;
      ch_0 &= 7;
    }
     else if ((ch_0 & 252) == 248) {
      count = 5;
      ch_0 &= 3;
    }
    while (--count > 0) {
      b = bytes[ofs + i++];
      if ((b & 192) != 128) {
        throw new IllegalArgumentException_0('Invalid UTF8 sequence at ' + (ofs + i - 1) + ', byte=' + (b >>> 0).toString(16));
      }
      ch_0 = ch_0 << 6 | b & 63;
    }
    outIdx += toChars(ch_0, chars, outIdx);
  }
  return chars;
}
;
function checkCritcalState(expression){
  if (!expression) {
    throw new IllegalStateException;
  }
}

function checkCriticalArgument(expression){
  if (!expression) {
    throw new IllegalArgumentException;
  }
}

function checkCriticalArgument_0(expression, errorMessage){
  if (!expression) {
    throw new IllegalArgumentException_0(($clinit_String() , errorMessage));
  }
}

function checkCriticalArgument_1(expression, errorMessageTemplate, errorMessageArgs){
  if (!expression) {
    throw new IllegalArgumentException_0(format_0(errorMessageTemplate, errorMessageArgs));
  }
}

function checkCriticalArraySize(size_0){
  if (size_0 < 0) {
    throw new NegativeArraySizeException('Negative array size: ' + size_0);
  }
}

function checkCriticalArrayType(expression){
  if (!expression) {
    throw new ArrayStoreException;
  }
}

function checkCriticalArrayType_0(expression, errorMessage){
  if (!expression) {
    throw new ArrayStoreException_0(($clinit_String() , errorMessage));
  }
}

function checkCriticalElement(expression){
  if (!expression) {
    throw new NoSuchElementException;
  }
}

function checkCriticalElementIndex(index_0, size_0){
  if (index_0 < 0 || index_0 >= size_0) {
    throw new IndexOutOfBoundsException_0('Index: ' + index_0 + ', Size: ' + size_0);
  }
}

function checkCriticalNotNull(reference){
  if (reference == null) {
    throw new NullPointerException;
  }
  return reference;
}

function checkCriticalNotNull_0(reference, errorMessage){
  if (reference == null) {
    throw new NullPointerException_0(($clinit_String() , errorMessage));
  }
}

function checkCriticalPositionIndex(index_0, size_0){
  if (index_0 < 0 || index_0 > size_0) {
    throw new IndexOutOfBoundsException_0('Index: ' + index_0 + ', Size: ' + size_0);
  }
}

function checkCriticalPositionIndexes(start_0, end, size_0){
  if (start_0 < 0) {
    throw new IndexOutOfBoundsException_0('fromIndex: ' + start_0 + ' < 0');
  }
  if (end > size_0) {
    throw new IndexOutOfBoundsException_0('toIndex: ' + end + ' > size ' + size_0);
  }
  if (start_0 > end) {
    throw new IllegalArgumentException_0('fromIndex: ' + start_0 + ' > toIndex: ' + end);
  }
}

function checkCriticalType(expression){
  if (!expression) {
    throw new ClassCastException;
  }
}

function checkNotNull_1(reference){
  checkCriticalNotNull(reference);
  return reference;
}

function format_0(template, args){
  var builder, i, placeholderStart, templateStart;
  template = ($clinit_String() , template == null?'null':template);
  builder = (template.length + 16 * args.length , new StringBuilder_0);
  templateStart = 0;
  i = 0;
  while (i < args.length) {
    placeholderStart = template.indexOf('%s', templateStart);
    if (placeholderStart == -1) {
      break;
    }
    $append_3(builder, template.substr(templateStart, placeholderStart - templateStart));
    $append_2(builder, args[i++]);
    templateStart = placeholderStart + 2;
  }
  $append_3(builder, __substr(template, templateStart, template.length - templateStart));
  if (i < args.length) {
    builder.string += ' [';
    $append_2(builder, args[i++]);
    while (i < args.length) {
      builder.string += ', ';
      $append_2(builder, args[i++]);
    }
    builder.string += ']';
  }
  return builder.string;
}

var Ljava_lang_Object_2_classLit = createForClass('java.lang', 'Object', 1);
var Ljava_lang_Throwable_2_classLit = createForClass('java.lang', 'Throwable', 46);
var Ljava_lang_Exception_2_classLit = createForClass('java.lang', 'Exception', 54);
var Ljava_lang_RuntimeException_2_classLit = createForClass('java.lang', 'RuntimeException', 72);
var Lcom_google_gwt_core_client_JavaScriptException_2_classLit = createForClass('com.google.gwt.core.client', 'JavaScriptException', 164);
var Lcom_google_gwt_core_client_impl_StackTraceCreator$Collector_2_classLit = createForClass('com.google.gwt.core.client.impl', 'StackTraceCreator/Collector', 641);
var Lcom_google_gwt_core_client_impl_StackTraceCreator$CollectorLegacy_2_classLit = createForClass('com.google.gwt.core.client.impl', 'StackTraceCreator/CollectorLegacy', 356);
var Lcom_google_gwt_core_client_impl_StackTraceCreator$CollectorModern_2_classLit = createForClass('com.google.gwt.core.client.impl', 'StackTraceCreator/CollectorModern', 642);
var Lcom_google_gwt_core_client_impl_StackTraceCreator$CollectorModernNoSourceMap_2_classLit = createForClass('com.google.gwt.core.client.impl', 'StackTraceCreator/CollectorModernNoSourceMap', 357);
var Ljava_io_IOException_2_classLit = createForClass('java.io', 'IOException', 181);
var Ljava_io_UnsupportedEncodingException_2_classLit = createForClass('java.io', 'UnsupportedEncodingException', 351);
var Ljava_lang_Class_2_classLit = createForClass('java.lang', 'Class', 288);
var Ljava_lang_ClassCastException_2_classLit = createForClass('java.lang', 'ClassCastException', 119);
var Ljava_lang_IllegalArgumentException_2_classLit = createForClass('java.lang', 'IllegalArgumentException', 29);
var Ljava_lang_IndexOutOfBoundsException_2_classLit = createForClass('java.lang', 'IndexOutOfBoundsException', 95);
var Ljava_lang_Number_2_classLit = createForClass('java.lang', 'Number', 231);
var Ljava_lang_Integer_2_classLit = createForClass('java.lang', 'Integer', 24);
var Ljava_lang_String_2_classLit = createForClass('java.lang', 'String', 2);
var Ljava_lang_String$1_2_classLit = createForClass('java.lang', 'String/1', 350);
var Ljava_lang_StringIndexOutOfBoundsException_2_classLit = createForClass('java.lang', 'StringIndexOutOfBoundsException', 257);
var Ljava_nio_charset_Charset_2_classLit = createForClass('java.nio.charset', 'Charset', 145);
var Ljava_nio_charset_IllegalCharsetNameException_2_classLit = createForClass('java.nio.charset', 'IllegalCharsetNameException', 358);
var Ljava_nio_charset_UnsupportedCharsetException_2_classLit = createForClass('java.nio.charset', 'UnsupportedCharsetException', 256);
var Ljavaemul_internal_EmulatedCharset_2_classLit = createForClass('javaemul.internal', 'EmulatedCharset', 185);
var Ljavaemul_internal_EmulatedCharset$LatinCharset_2_classLit = createForClass('javaemul.internal', 'EmulatedCharset/LatinCharset', 289);
var Ljavaemul_internal_EmulatedCharset$UtfCharset_2_classLit = createForClass('javaemul.internal', 'EmulatedCharset/UtfCharset', 355);
defineClass(668, 1, {3:1});
var Lcom_google_common_base_Optional_2_classLit = createForClass('com.google.common.base', 'Optional', 668);
function $clinit_Absent(){
  $clinit_Absent = emptyMethod;
  INSTANCE = new Absent;
}

function Absent(){
}

defineClass(600, 668, {3:1}, Absent);
_.equals = function equals_0(object){
  return object === this;
}
;
_.hashCode_0 = function hashCode_1(){
  return 2040732332;
}
;
_.toString_0 = function toString_1(){
  return 'Optional.absent()';
}
;
_.transform = function transform(function_0){
  checkNotNull(function_0);
  return $clinit_Absent() , INSTANCE;
}
;
var INSTANCE;
var Lcom_google_common_base_Absent_2_classLit = createForClass('com.google.common.base', 'Absent', 600);
var Lcom_google_common_base_Function_2_classLit = createForInterface('com.google.common.base', 'Function');
function $appendTo(this$static, appendable, parts){
  checkNotNull(appendable);
  if (parts.hasNext_0()) {
    $append_0(appendable, this$static.toString_1(parts.next_1()));
    while (parts.hasNext_0()) {
      $append_0(appendable, this$static.separator);
      $append_0(appendable, this$static.toString_1(parts.next_1()));
    }
  }
  return appendable;
}

function $appendTo_0(this$static, builder, parts){
  var impossible;
  try {
    $appendTo(this$static, builder, parts);
  }
   catch ($e0) {
    $e0 = wrap($e0);
    if (instanceOf($e0, 181)) {
      impossible = $e0;
      throw new AssertionError_0(impossible);
    }
     else 
      throw unwrap_5($e0);
  }
  return builder;
}

function $join(this$static, parts){
  return $appendTo_0(this$static, new StringBuilder, parts).string;
}

function $toString_0(part){
  checkNotNull(part);
  return instanceOf(part, 345)?castTo(part, 345):toString__Ljava_lang_String___devirtual$(part);
}

function $useForNull(this$static){
  checkNotNull('null');
  return new Joiner$1(this$static, this$static);
}

function Joiner(separator){
  this.separator = castToString(checkNotNull(separator));
}

defineClass(208, 1, {}, Joiner);
_.toString_1 = function toString_2(part){
  return $toString_0(part);
}
;
var Lcom_google_common_base_Joiner_2_classLit = createForClass('com.google.common.base', 'Joiner', 208);
function $toString_1(this$static, part){
  return part == null?this$static.val$nullText3:$toString_0(part);
}

function Joiner$1(this$0, $anonymous0){
  this.this$01 = this$0;
  this.val$nullText3 = 'null';
  this.separator = $anonymous0.separator;
}

defineClass(363, 208, {}, Joiner$1);
_.toString_1 = function toString_3(part){
  return $toString_1(this, part);
}
;
var Lcom_google_common_base_Joiner$1_2_classLit = createForClass('com.google.common.base', 'Joiner/1', 363);
function $appendTo_1(this$static, appendable, parts){
  var e, entry;
  checkNotNull(appendable);
  if (parts.hasNext_0()) {
    entry = castTo(parts.next_1(), 21);
    $append_0(appendable, $toString_1(this$static.joiner, entry.getKey()));
    $append_0(appendable, this$static.keyValueSeparator);
    $append_0(appendable, $toString_1(this$static.joiner, entry.getValue()));
    while (parts.hasNext_0()) {
      $append_0(appendable, this$static.joiner.separator);
      e = castTo(parts.next_1(), 21);
      $append_0(appendable, $toString_1(this$static.joiner, e.getKey()));
      $append_0(appendable, this$static.keyValueSeparator);
      $append_0(appendable, $toString_1(this$static.joiner, e.getValue()));
    }
  }
  return appendable;
}

function $appendTo_2(this$static, builder, entries){
  var impossible;
  try {
    $appendTo_1(this$static, builder, entries);
  }
   catch ($e0) {
    $e0 = wrap($e0);
    if (instanceOf($e0, 181)) {
      impossible = $e0;
      throw new AssertionError_0(impossible);
    }
     else 
      throw unwrap_5($e0);
  }
  return builder;
}

function Joiner$MapJoiner(joiner){
  this.joiner = joiner;
  this.keyValueSeparator = castToString(checkNotNull('='));
}

defineClass(362, 1, {}, Joiner$MapJoiner);
var Lcom_google_common_base_Joiner$MapJoiner_2_classLit = createForClass('com.google.common.base', 'Joiner/MapJoiner', 362);
function firstNonNull(first, second){
  return first?first:checkNotNull(second);
}

function equal(a, b){
  return maskUndefined(a) === maskUndefined(b) || a != null && equals_Ljava_lang_Object__Z__devirtual$(a, b);
}

function badElementIndex(index_0, size_0){
  if (index_0 < 0) {
    return format('%s (%s) must not be negative', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, ['index', valueOf_0(index_0)]));
  }
   else if (size_0 < 0) {
    throw new IllegalArgumentException_0('negative size: ' + size_0);
  }
   else {
    return format('%s (%s) must be less than size (%s)', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, ['index', valueOf_0(index_0), valueOf_0(size_0)]));
  }
}

function badPositionIndex(index_0, size_0, desc){
  if (index_0 < 0) {
    return format('%s (%s) must not be negative', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [desc, valueOf_0(index_0)]));
  }
   else if (size_0 < 0) {
    throw new IllegalArgumentException_0('negative size: ' + size_0);
  }
   else {
    return format('%s (%s) must not be greater than size (%s)', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [desc, valueOf_0(index_0), valueOf_0(size_0)]));
  }
}

function badPositionIndexes(start_0, end, size_0){
  if (start_0 < 0 || start_0 > size_0) {
    return badPositionIndex(start_0, size_0, 'start index');
  }
  if (end < 0 || end > size_0) {
    return badPositionIndex(end, size_0, 'end index');
  }
  return format('end index (%s) must not be less than start index (%s)', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [valueOf_0(end), valueOf_0(start_0)]));
}

function checkArgument(expression){
  if (!expression) {
    throw new IllegalArgumentException;
  }
}

function checkArgument_0(expression){
  if (!expression) {
    throw new IllegalArgumentException_0(($clinit_String() , 'numberToAdvance must be nonnegative'));
  }
}

function checkArgument_1(b, p1, p2){
  if (!b) {
    throw new IllegalArgumentException_0(format('lowerEndpoint (%s) > upperEndpoint (%s)', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [p1, p2])));
  }
}

function checkElementIndex(index_0, size_0){
  if (index_0 < 0 || index_0 >= size_0) {
    throw new IndexOutOfBoundsException_0(badElementIndex(index_0, size_0));
  }
  return index_0;
}

function checkNotNull(reference){
  if (reference == null) {
    throw new NullPointerException;
  }
  return reference;
}

function checkNotNull_0(reference, errorMessage){
  if (reference == null) {
    throw new NullPointerException_0(($clinit_String() , errorMessage));
  }
  return reference;
}

function checkPositionIndex(index_0, size_0){
  if (index_0 < 0 || index_0 > size_0) {
    throw new IndexOutOfBoundsException_0(badPositionIndex(index_0, size_0, 'index'));
  }
  return index_0;
}

function checkPositionIndexes(start_0, end, size_0){
  if (start_0 < 0 || end < start_0 || end > size_0) {
    throw new IndexOutOfBoundsException_0(badPositionIndexes(start_0, end, size_0));
  }
}

function checkState(expression){
  if (!expression) {
    throw new IllegalStateException;
  }
}

function checkState_0(expression){
  if (!expression) {
    throw new IllegalStateException_0(($clinit_String() , 'no calls to next() since the last call to remove()'));
  }
}

function format(template, args){
  var builder, i, placeholderStart, templateStart;
  template = ($clinit_String() , template == null?'null':template);
  builder = (template.length + 16 * args.length , new StringBuilder_0);
  templateStart = 0;
  i = 0;
  while (i < args.length) {
    placeholderStart = template.indexOf('%s', templateStart);
    if (placeholderStart == -1) {
      break;
    }
    $append0(builder, template, templateStart, placeholderStart);
    $append_2(builder, args[i++]);
    templateStart = placeholderStart + 2;
  }
  $append_1(builder, template, templateStart, template.length);
  if (i < args.length) {
    builder.string += ' [';
    $append_2(builder, args[i++]);
    while (i < args.length) {
      builder.string += ', ';
      $append_2(builder, args[i++]);
    }
    builder.string += ']';
  }
  return builder.string;
}

var Lcom_google_common_base_Predicate_2_classLit = createForInterface('com.google.common.base', 'Predicate');
function $clinit_Predicates(){
  $clinit_Predicates = emptyMethod;
  COMMA_JOINER = new Joiner(',');
}

var COMMA_JOINER;
function Predicates$AndPredicate(components){
  this.components = components;
}

defineClass(244, 1, {68:1, 244:1, 3:1}, Predicates$AndPredicate);
_.apply_1 = function apply_1(t){
  var i;
  for (i = 0; i < this.components.array.length; i++) {
    if (!castTo($get_10(this.components, i), 68).apply_1(t)) {
      return false;
    }
  }
  return true;
}
;
_.equals = function equals_1(obj){
  var that;
  if (instanceOf(obj, 244)) {
    that = castTo(obj, 244);
    return $equals_2(this.components, that.components);
  }
  return false;
}
;
_.hashCode_0 = function hashCode_2(){
  return hashCode_46(this.components) + 306654252;
}
;
_.toString_0 = function toString_4(){
  return 'Predicates.and(' + $join(($clinit_Predicates() , COMMA_JOINER), new AbstractList$IteratorImpl(this.components)) + ')';
}
;
var Lcom_google_common_base_Predicates$AndPredicate_2_classLit = createForClass('com.google.common.base', 'Predicates/AndPredicate', 244);
function Predicates$InPredicate(target){
  this.target = castTo(checkNotNull(target), 19);
}

defineClass(246, 1, {68:1, 246:1, 3:1}, Predicates$InPredicate);
_.apply_1 = function apply_2(t){
  try {
    return this.target.contains(t);
  }
   catch ($e0) {
    $e0 = wrap($e0);
    if (instanceOf($e0, 76)) {
      return false;
    }
     else if (instanceOf($e0, 119)) {
      return false;
    }
     else 
      throw unwrap_5($e0);
  }
}
;
_.equals = function equals_2(obj){
  var that;
  if (instanceOf(obj, 246)) {
    that = castTo(obj, 246);
    return this.target.equals(that.target);
  }
  return false;
}
;
_.hashCode_0 = function hashCode_3(){
  return this.target.hashCode_0();
}
;
_.toString_0 = function toString_5(){
  return 'Predicates.in(' + this.target + ')';
}
;
var Lcom_google_common_base_Predicates$InPredicate_2_classLit = createForClass('com.google.common.base', 'Predicates/InPredicate', 246);
function Predicates$IsEqualToPredicate(target){
  this.target = target;
}

defineClass(245, 1, {68:1, 245:1, 3:1}, Predicates$IsEqualToPredicate);
_.apply_1 = function apply_3(t){
  return equals_Ljava_lang_Object__Z__devirtual$(this.target, t);
}
;
_.equals = function equals_3(obj){
  var that;
  if (instanceOf(obj, 245)) {
    that = castTo(obj, 245);
    return equals_Ljava_lang_Object__Z__devirtual$(this.target, that.target);
  }
  return false;
}
;
_.hashCode_0 = function hashCode_4(){
  return hashCode__I__devirtual$(this.target);
}
;
_.toString_0 = function toString_6(){
  return 'Predicates.equalTo(' + this.target + ')';
}
;
var Lcom_google_common_base_Predicates$IsEqualToPredicate_2_classLit = createForClass('com.google.common.base', 'Predicates/IsEqualToPredicate', 245);
function $compareTo(this$static, other){
  return this$static.ordinal - other.ordinal;
}

function $name(this$static){
  return this$static.name_0 != null?this$static.name_0:'' + this$static.ordinal;
}

function $toString_2(this$static){
  return this$static.name_0 != null?this$static.name_0:'' + this$static.ordinal;
}

function Enum(name_0, ordinal){
  this.name_0 = name_0;
  this.ordinal = ordinal;
}

function createValueOfMap(enumConstants){
  var result, value_0, value$index, value$max;
  result = {};
  for (value$index = 0 , value$max = enumConstants.length; value$index < value$max; ++value$index) {
    value_0 = enumConstants[value$index];
    result[':' + (value_0.name_0 != null?value_0.name_0:'' + value_0.ordinal)] = value_0;
  }
  return result;
}

function valueOf(map_0, name_0){
  var result;
  checkCriticalNotNull(name_0);
  result = map_0[':' + name_0];
  checkCriticalArgument_1(!!result, 'Enum constant undefined: %s', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [name_0]));
  return result;
}

defineClass(17, 1, {3:1, 23:1, 17:1});
_.compareTo = function compareTo(other){
  return $compareTo(this, castTo(other, 17));
}
;
_.equals = function equals_4(other){
  return this === other;
}
;
_.hashCode_0 = function hashCode_5(){
  return getObjectIdentityHashCode(this);
}
;
_.toString_0 = function toString_7(){
  return $toString_2(this);
}
;
_.ordinal = 0;
var Ljava_lang_Enum_2_classLit = createForClass('java.lang', 'Enum', 17);
function $clinit_Predicates$ObjectPredicate(){
  $clinit_Predicates$ObjectPredicate = emptyMethod;
  ALWAYS_TRUE = new Predicates$ObjectPredicate$1;
  ALWAYS_FALSE = new Predicates$ObjectPredicate$2;
  IS_NULL = new Predicates$ObjectPredicate$3;
  NOT_NULL = new Predicates$ObjectPredicate$4;
}

function Predicates$ObjectPredicate(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function values_0(){
  $clinit_Predicates$ObjectPredicate();
  return stampJavaTypeInfo(getClassLiteralForArray(Lcom_google_common_base_Predicates$ObjectPredicate_2_classLit, 1), $intern_13, 136, 0, [ALWAYS_TRUE, ALWAYS_FALSE, IS_NULL, NOT_NULL]);
}

defineClass(136, 17, $intern_14);
var ALWAYS_FALSE, ALWAYS_TRUE, IS_NULL, NOT_NULL;
var Lcom_google_common_base_Predicates$ObjectPredicate_2_classLit = createForEnum('com.google.common.base', 'Predicates/ObjectPredicate', 136, Ljava_lang_Enum_2_classLit, values_0);
function Predicates$ObjectPredicate$1(){
  Predicates$ObjectPredicate.call(this, 'ALWAYS_TRUE', 0);
}

defineClass(591, 136, $intern_14, Predicates$ObjectPredicate$1);
_.apply_1 = function apply_4(o){
  return true;
}
;
_.toString_0 = function toString_8(){
  return 'Predicates.alwaysTrue()';
}
;
var Lcom_google_common_base_Predicates$ObjectPredicate$1_2_classLit = createForEnum('com.google.common.base', 'Predicates/ObjectPredicate/1', 591, Lcom_google_common_base_Predicates$ObjectPredicate_2_classLit, null);
function Predicates$ObjectPredicate$2(){
  Predicates$ObjectPredicate.call(this, 'ALWAYS_FALSE', 1);
}

defineClass(592, 136, $intern_14, Predicates$ObjectPredicate$2);
_.apply_1 = function apply_5(o){
  return false;
}
;
_.toString_0 = function toString_9(){
  return 'Predicates.alwaysFalse()';
}
;
var Lcom_google_common_base_Predicates$ObjectPredicate$2_2_classLit = createForEnum('com.google.common.base', 'Predicates/ObjectPredicate/2', 592, Lcom_google_common_base_Predicates$ObjectPredicate_2_classLit, null);
function Predicates$ObjectPredicate$3(){
  Predicates$ObjectPredicate.call(this, 'IS_NULL', 2);
}

defineClass(593, 136, $intern_14, Predicates$ObjectPredicate$3);
_.apply_1 = function apply_6(o){
  return o == null;
}
;
_.toString_0 = function toString_10(){
  return 'Predicates.isNull()';
}
;
var Lcom_google_common_base_Predicates$ObjectPredicate$3_2_classLit = createForEnum('com.google.common.base', 'Predicates/ObjectPredicate/3', 593, Lcom_google_common_base_Predicates$ObjectPredicate_2_classLit, null);
function Predicates$ObjectPredicate$4(){
  Predicates$ObjectPredicate.call(this, 'NOT_NULL', 3);
}

defineClass(594, 136, $intern_14, Predicates$ObjectPredicate$4);
_.apply_1 = function apply_7(o){
  return o != null;
}
;
_.toString_0 = function toString_11(){
  return 'Predicates.notNull()';
}
;
var Lcom_google_common_base_Predicates$ObjectPredicate$4_2_classLit = createForEnum('com.google.common.base', 'Predicates/ObjectPredicate/4', 594, Lcom_google_common_base_Predicates$ObjectPredicate_2_classLit, null);
function Present(reference){
  this.reference = reference;
}

defineClass(177, 668, {177:1, 3:1}, Present);
_.equals = function equals_5(object){
  var other;
  if (instanceOf(object, 177)) {
    other = castTo(object, 177);
    return equals_Ljava_lang_Object__Z__devirtual$(this.reference, other.reference);
  }
  return false;
}
;
_.hashCode_0 = function hashCode_6(){
  return 1502476572 + hashCode__I__devirtual$(this.reference);
}
;
_.toString_0 = function toString_12(){
  return 'Optional.of(' + this.reference + ')';
}
;
_.transform = function transform_0(function_0){
  return new Present(checkNotNull_0(function_0.apply_0(this.reference), 'the Function passed to Optional.transform() must not return null.'));
}
;
var Lcom_google_common_base_Present_2_classLit = createForClass('com.google.common.base', 'Present', 177);
function $remove(){
  throw new UnsupportedOperationException;
}

defineClass(108, 1, $intern_15);
_.remove = function remove_0(){
  $remove();
}
;
var Lcom_google_common_collect_UnmodifiableIterator_2_classLit = createForClass('com.google.common.collect', 'UnmodifiableIterator', 108);
defineClass(650, 108, $intern_16);
_.add_0 = function add_0(e){
  throw new UnsupportedOperationException;
}
;
_.set_1 = function set_1(e){
  throw new UnsupportedOperationException;
}
;
var Lcom_google_common_collect_UnmodifiableListIterator_2_classLit = createForClass('com.google.common.collect', 'UnmodifiableListIterator', 650);
defineClass(378, 650, $intern_16);
_.hasNext_0 = function hasNext(){
  return this.position < this.size_0;
}
;
_.hasPrevious = function hasPrevious(){
  return this.position > 0;
}
;
_.next_1 = function next_0(){
  if (this.position >= this.size_0) {
    throw new NoSuchElementException;
  }
  return $get_2(this, this.position++);
}
;
_.nextIndex_0 = function nextIndex_0(){
  return this.position;
}
;
_.previous_0 = function previous_0(){
  if (this.position <= 0) {
    throw new NoSuchElementException;
  }
  return $get_2(this, --this.position);
}
;
_.previousIndex = function previousIndex(){
  return this.position - 1;
}
;
_.position = 0;
_.size_0 = 0;
var Lcom_google_common_collect_AbstractIndexedListIterator_2_classLit = createForClass('com.google.common.collect', 'AbstractIndexedListIterator', 378);
function $hasNext(this$static){
  checkState(this$static.state != 3);
  switch (this$static.state) {
    case 2:
      return false;
    case 0:
      return true;
  }
  return $tryToComputeNext(this$static);
}

function $next(this$static){
  var result;
  if (!$hasNext(this$static)) {
    throw new NoSuchElementException;
  }
  this$static.state = 1;
  result = this$static.next_0;
  this$static.next_0 = null;
  return result;
}

function $tryToComputeNext(this$static){
  this$static.state = 3;
  this$static.next_0 = $computeNext(this$static);
  if (this$static.state != 2) {
    this$static.state = 0;
    return true;
  }
  return false;
}

defineClass(428, 108, $intern_15);
_.hasNext_0 = function hasNext_0(){
  return $hasNext(this);
}
;
_.next_1 = function next_1(){
  return $next(this);
}
;
_.state = 1;
var Lcom_google_common_collect_AbstractIterator_2_classLit = createForClass('com.google.common.collect', 'AbstractIterator', 428);
function $containsValue(this$static, value_0){
  var collection, collection$iterator;
  for (collection$iterator = $iterator_2($values_0(this$static.asMap_0())); collection$iterator.backingIterator.hasNext_0();) {
    collection = castTo($transform(collection$iterator, collection$iterator.backingIterator.next_1()), 19);
    if (collection.contains(value_0)) {
      return true;
    }
  }
  return false;
}

function $keySet(this$static){
  var result;
  result = this$static.keySet;
  return !result?(this$static.keySet = this$static.createKeySet()):result;
}

defineClass(652, 1, {144:1});
_.asMap_0 = function asMap(){
  var result;
  return result = this.asMap , !result?(this.asMap = this.createAsMap()):result;
}
;
_.createKeySet = function createKeySet(){
  return new Maps$KeySet(this.asMap_0());
}
;
_.equals = function equals_6(object){
  return equalsImpl_1(this, object);
}
;
_.hashCode_0 = function hashCode_7(){
  return this.asMap_0().hashCode_0();
}
;
_.isEmpty = function isEmpty(){
  return this.size_1() == 0;
}
;
_.keySet_0 = function keySet(){
  return $keySet(this);
}
;
_.toString_0 = function toString_13(){
  return this.asMap_0().toString_0();
}
;
var Lcom_google_common_collect_AbstractMultimap_2_classLit = createForClass('com.google.common.collect', 'AbstractMultimap', 652);
function $clear(this$static){
  var collection, collection$iterator, entry, outerIter;
  for (collection$iterator = (outerIter = (new AbstractMap$2(this$static.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$2$1(outerIter)); collection$iterator.val$outerIter2.hasNext_0();) {
    collection = (entry = castTo(collection$iterator.val$outerIter2.next_1(), 21) , castTo(entry.getValue(), 19));
    collection.clear_0();
  }
  $reset_3(this$static.map_0);
  this$static.totalSize = 0;
}

function $get(this$static, key){
  var collection;
  collection = castTo($get_9(this$static.map_0, key), 19);
  !collection && (collection = this$static.createCollection());
  return instanceOf(collection, 137)?new AbstractMapBasedMultimap$WrappedSortedSet(this$static, key, castTo(collection, 137)):instanceOf(collection, 18)?new AbstractMapBasedMultimap$WrappedSet(this$static, key, castTo(collection, 18)):instanceOf(collection, 20)?$wrapList(this$static, key, castTo(collection, 20), null):new AbstractMapBasedMultimap$WrappedCollection(this$static, key, collection, null);
}

function $iteratorOrListIterator(collection){
  return instanceOf(collection, 20)?castTo(collection, 20).listIterator_0():collection.iterator_0();
}

function $put(this$static, key, value_0){
  var collection;
  collection = castTo($get_9(this$static.map_0, key), 19);
  if (!collection) {
    collection = this$static.createCollection();
    if (collection.add_1(value_0)) {
      ++this$static.totalSize;
      $put_2(this$static.map_0, key, collection);
      return true;
    }
     else {
      throw new AssertionError_0('New Collection violated the Collection spec');
    }
  }
   else if (collection.add_1(value_0)) {
    ++this$static.totalSize;
    return true;
  }
   else {
    return false;
  }
}

function $removeAll(this$static, key){
  var collection, output;
  collection = castTo($remove_9(this$static.map_0, key), 19);
  if (!collection) {
    return this$static.createUnmodifiableEmptyCollection();
  }
  output = this$static.createCollection();
  output.addAll(collection);
  this$static.totalSize -= collection.size_1();
  collection.clear_0();
  return instanceOf(output, 137)?($clinit_Collections() , new Collections$UnmodifiableSortedSet(castTo(output, 137))):instanceOf(output, 18)?($clinit_Collections() , new Collections$UnmodifiableSet(castTo(output, 18))):instanceOf(output, 20)?unmodifiableList(castTo(output, 20)):($clinit_Collections() , new Collections$UnmodifiableCollection(output));
}

function $removeValuesForKey(this$static, key){
  var collection, count;
  collection = castTo(safeRemove(this$static.map_0, key), 19);
  if (collection) {
    count = collection.size_1();
    collection.clear_0();
    this$static.totalSize -= count;
  }
}

function $unmodifiableCollectionSubclass(collection){
  return instanceOf(collection, 137)?($clinit_Collections() , new Collections$UnmodifiableSortedSet(castTo(collection, 137))):instanceOf(collection, 18)?($clinit_Collections() , new Collections$UnmodifiableSet(castTo(collection, 18))):instanceOf(collection, 20)?unmodifiableList(castTo(collection, 20)):($clinit_Collections() , new Collections$UnmodifiableCollection(collection));
}

function $values(this$static){
  var result;
  return result = this$static.values , !result?(this$static.values = new AbstractMultimap$Values(this$static)):result;
}

function $wrapCollection(this$static, key, collection){
  return instanceOf(collection, 137)?new AbstractMapBasedMultimap$WrappedSortedSet(this$static, key, castTo(collection, 137)):instanceOf(collection, 18)?new AbstractMapBasedMultimap$WrappedSet(this$static, key, castTo(collection, 18)):instanceOf(collection, 20)?$wrapList(this$static, key, castTo(collection, 20), null):new AbstractMapBasedMultimap$WrappedCollection(this$static, key, collection, null);
}

function $wrapList(this$static, key, list, ancestor){
  return instanceOf(list, 67)?new AbstractMapBasedMultimap$RandomAccessWrappedList(this$static, key, list, ancestor):new AbstractMapBasedMultimap$WrappedList(this$static, key, list, ancestor);
}

function AbstractMapBasedMultimap(map_0){
  checkArgument(map_0.hashCodeMap.size_0 + map_0.stringMap.size_0 == 0);
  this.map_0 = map_0;
}

defineClass(294, 652, $intern_17);
_.clear_0 = function clear_0(){
  $clear(this);
}
;
_.containsKey = function containsKey(key){
  return $containsKey_1(this.map_0, key);
}
;
_.createAsMap = function createAsMap(){
  return new AbstractMapBasedMultimap$AsMap(this, this.map_0);
}
;
_.createKeySet = function createKeySet_0(){
  return new AbstractMapBasedMultimap$KeySet(this, this.map_0);
}
;
_.createUnmodifiableEmptyCollection = function createUnmodifiableEmptyCollection(){
  return $unmodifiableCollectionSubclass(this.createCollection());
}
;
_.get_0 = function get_0(key){
  return $get(this, key);
}
;
_.removeAll = function removeAll(key){
  return $removeAll(this, key);
}
;
_.size_1 = function size_1(){
  return this.totalSize;
}
;
_.totalSize = 0;
var Lcom_google_common_collect_AbstractMapBasedMultimap_2_classLit = createForClass('com.google.common.collect', 'AbstractMapBasedMultimap', 294);
function AbstractListMultimap(map_0){
  AbstractMapBasedMultimap.call(this, map_0);
}

defineClass(601, 294, $intern_17);
_.createCollection = function createCollection(){
  return new ArrayList_0(this.expectedValuesPerKey);
}
;
_.createUnmodifiableEmptyCollection = function createUnmodifiableEmptyCollection_0(){
  return $clinit_ImmutableList() , $clinit_ImmutableList() , EMPTY;
}
;
_.get_0 = function get_1(key){
  return castTo($get(this, key), 20);
}
;
_.removeAll = function removeAll_0(key){
  return castTo($removeAll(this, key), 20);
}
;
_.asMap_0 = function asMap_0(){
  var result;
  return result = this.asMap , !result?(this.asMap = new AbstractMapBasedMultimap$AsMap(this, this.map_0)):result;
}
;
_.equals = function equals_7(object){
  return equalsImpl_1(this, object);
}
;
var Lcom_google_common_collect_AbstractListMultimap_2_classLit = createForClass('com.google.common.collect', 'AbstractListMultimap', 601);
defineClass(388, 1, $intern_18);
_.hasNext_0 = function hasNext_1(){
  return this.keyIterator.hasNext || this.valueIterator.hasNext_0();
}
;
_.next_1 = function next_2(){
  var mapEntry;
  if (!this.valueIterator.hasNext_0()) {
    mapEntry = $next_6(this.keyIterator);
    mapEntry.getKey();
    this.collection = castTo(mapEntry.getValue(), 19);
    this.valueIterator = this.collection.iterator_0();
  }
  return this.valueIterator.next_1();
}
;
_.remove = function remove_1(){
  this.valueIterator.remove();
  this.collection.isEmpty() && $remove_10(this.keyIterator);
  --this.this$01.totalSize;
}
;
var Lcom_google_common_collect_AbstractMapBasedMultimap$Itr_2_classLit = createForClass('com.google.common.collect', 'AbstractMapBasedMultimap/Itr', 388);
function AbstractMapBasedMultimap$1(this$0){
  this.this$01 = this$0;
  this.keyIterator = new AbstractHashMap$EntrySetIterator((new AbstractHashMap$EntrySet(this$0.map_0)).this$01);
  this.collection = null;
  this.valueIterator = ($clinit_Iterators() , $clinit_Iterators() , EMPTY_MODIFIABLE_ITERATOR);
}

defineClass(389, 388, $intern_18, AbstractMapBasedMultimap$1);
var Lcom_google_common_collect_AbstractMapBasedMultimap$1_2_classLit = createForClass('com.google.common.collect', 'AbstractMapBasedMultimap/1', 389);
function $containsEntry(this$static, entry){
  var key, ourValue, value_0;
  key = entry.getKey();
  value_0 = entry.getValue();
  ourValue = this$static.get_1(key);
  if (!(maskUndefined(value_0) === maskUndefined(ourValue) || value_0 != null && equals_Ljava_lang_Object__Z__devirtual$(value_0, ourValue))) {
    return false;
  }
  if (ourValue == null && !this$static.containsKey(key)) {
    return false;
  }
  return true;
}

function $equals(this$static, obj){
  var entry, entry$iterator, otherMap;
  if (obj === this$static) {
    return true;
  }
  if (!instanceOf(obj, 57)) {
    return false;
  }
  otherMap = castTo(obj, 57);
  if (this$static.size_1() != otherMap.size_1()) {
    return false;
  }
  for (entry$iterator = otherMap.entrySet_0().iterator_0(); entry$iterator.hasNext_0();) {
    entry = castTo(entry$iterator.next_1(), 21);
    if (!this$static.containsEntry(entry)) {
      return false;
    }
  }
  return true;
}

function $implFindEntry(this$static, key, remove){
  var entry, iter, k;
  for (iter = this$static.entrySet_0().iterator_0(); iter.hasNext_0();) {
    entry = castTo(iter.next_1(), 21);
    k = entry.getKey();
    if (maskUndefined(key) === maskUndefined(k) || key != null && equals_Ljava_lang_Object__Z__devirtual$(key, k)) {
      if (remove) {
        entry = new AbstractMap$SimpleEntry(entry.getKey(), entry.getValue());
        iter.remove();
      }
      return entry;
    }
  }
  return null;
}

function $putAll(this$static, map_0){
  var e, e$iterator;
  checkCriticalNotNull(map_0);
  for (e$iterator = map_0.entrySet_0().iterator_0(); e$iterator.hasNext_0();) {
    e = castTo(e$iterator.next_1(), 21);
    this$static.put(e.getKey(), e.getValue());
  }
}

function $toString_3(this$static){
  var comma, entry, entry$iterator, sb;
  sb = new StringBuilder_1('{');
  comma = false;
  for (entry$iterator = this$static.entrySet_0().iterator_0(); entry$iterator.hasNext_0();) {
    entry = castTo(entry$iterator.next_1(), 21);
    comma?(sb.string += ', ' , sb):(comma = true);
    $append_3(sb, $toString_4(this$static, entry.getKey()));
    sb.string += '=';
    $append_3(sb, $toString_4(this$static, entry.getValue()));
  }
  sb.string += '}';
  return sb.string;
}

function $toString_4(this$static, o){
  return o === this$static?'(this Map)':($clinit_String() , o == null?'null':toString__Ljava_lang_String___devirtual$(o));
}

function getEntryKeyOrNull(entry){
  return !entry?null:entry.key;
}

function getEntryValueOrNull(entry){
  return !entry?null:entry.getValue();
}

defineClass(637, 1, $intern_19);
_.clear_0 = function clear_1(){
  this.entrySet_0().clear_0();
}
;
_.containsEntry = function containsEntry(entry){
  return $containsEntry(this, entry);
}
;
_.containsKey = function containsKey_0(key){
  return !!$implFindEntry(this, key, false);
}
;
_.containsValue = function containsValue(value_0){
  var entry, entry$iterator, v;
  for (entry$iterator = this.entrySet_0().iterator_0(); entry$iterator.hasNext_0();) {
    entry = castTo(entry$iterator.next_1(), 21);
    v = entry.getValue();
    if (maskUndefined(value_0) === maskUndefined(v) || value_0 != null && equals_Ljava_lang_Object__Z__devirtual$(value_0, v)) {
      return true;
    }
  }
  return false;
}
;
_.equals = function equals_8(obj){
  return $equals(this, obj);
}
;
_.get_1 = function get_2(key){
  return getEntryValueOrNull($implFindEntry(this, key, false));
}
;
_.hashCode_0 = function hashCode_8(){
  return hashCode_45(this.entrySet_0());
}
;
_.isEmpty = function isEmpty_0(){
  return this.size_1() == 0;
}
;
_.keySet_0 = function keySet_0(){
  return new AbstractMap$1(this);
}
;
_.put = function put(key, value_0){
  throw new UnsupportedOperationException_0('Put not supported on this map');
}
;
_.remove_0 = function remove_2(key){
  return getEntryValueOrNull($implFindEntry(this, key, true));
}
;
_.size_1 = function size_2(){
  return this.entrySet_0().size_1();
}
;
_.toString_0 = function toString_14(){
  return $toString_3(this);
}
;
_.values_0 = function values_1(){
  return new AbstractMap$2(this);
}
;
var Ljava_util_AbstractMap_2_classLit = createForClass('java.util', 'AbstractMap', 637);
function $entrySet(this$static){
  var result;
  result = this$static.entrySet;
  return !result?(this$static.entrySet = this$static.createEntrySet()):result;
}

function $values_0(this$static){
  var result;
  result = this$static.values;
  return !result?(this$static.values = new Maps$Values(this$static)):result;
}

defineClass(653, 637, $intern_19);
_.entrySet_0 = function entrySet(){
  return $entrySet(this);
}
;
_.keySet_0 = function keySet_1(){
  var result;
  result = this.keySet;
  return !result?(this.keySet = new Maps$KeySet(this)):result;
}
;
_.values_0 = function values_2(){
  return $values_0(this);
}
;
var Lcom_google_common_collect_Maps$ViewCachingAbstractMap_2_classLit = createForClass('com.google.common.collect', 'Maps/ViewCachingAbstractMap', 653);
function $get_0(this$static, key){
  var collection;
  collection = castTo(safeGet(this$static.submap, key), 19);
  if (!collection) {
    return null;
  }
  return $wrapCollection(this$static.this$01, key, collection);
}

function $remove_0(this$static, key){
  var collection, output;
  collection = castTo($remove_9(this$static.submap, key), 19);
  if (!collection) {
    return null;
  }
  output = this$static.this$01.createCollection();
  output.addAll(collection);
  this$static.this$01.totalSize -= collection.size_1();
  collection.clear_0();
  return output;
}

function $wrapEntry(this$static, entry){
  var key;
  key = entry.getKey();
  return $clinit_Maps() , new ImmutableEntry(key, $wrapCollection(this$static.this$01, key, castTo(entry.getValue(), 19)));
}

function AbstractMapBasedMultimap$AsMap(this$0, submap){
  this.this$01 = this$0;
  this.submap = submap;
}

defineClass(262, 653, $intern_19, AbstractMapBasedMultimap$AsMap);
_.get_1 = function get_3(key){
  return $get_0(this, key);
}
;
_.remove_0 = function remove_3(key){
  return $remove_0(this, key);
}
;
_.clear_0 = function clear_2(){
  this.submap == this.this$01.map_0?$clear(this.this$01):clear_14(new AbstractMapBasedMultimap$AsMap$AsMapIterator(this));
}
;
_.containsKey = function containsKey_1(key){
  return safeContainsKey(this.submap, key);
}
;
_.createEntrySet_0 = function createEntrySet(){
  return new AbstractMapBasedMultimap$AsMap$AsMapEntries(this);
}
;
_.createEntrySet = function(){
  return this.createEntrySet_0();
}
;
_.equals = function equals_9(object){
  return this === object || $equals(this.submap, object);
}
;
_.hashCode_0 = function hashCode_9(){
  return hashCode_45(new AbstractHashMap$EntrySet(this.submap));
}
;
_.keySet_0 = function keySet_2(){
  return $keySet(this.this$01);
}
;
_.size_1 = function size_3(){
  return $size_0(this.submap);
}
;
_.toString_0 = function toString_15(){
  return $toString_3(this.submap);
}
;
var Lcom_google_common_collect_AbstractMapBasedMultimap$AsMap_2_classLit = createForClass('com.google.common.collect', 'AbstractMapBasedMultimap/AsMap', 262);
function $add(){
  throw new UnsupportedOperationException_0('Add not supported on this collection');
}

function $addAll(this$static, c){
  var changed, e, e$iterator;
  checkCriticalNotNull(c);
  changed = false;
  for (e$iterator = c.iterator_0(); e$iterator.hasNext_0();) {
    e = e$iterator.next_1();
    changed = changed | this$static.add_1(e);
  }
  return changed;
}

function $advanceToFind(this$static, o, remove){
  var e, iter;
  for (iter = this$static.iterator_0(); iter.hasNext_0();) {
    e = iter.next_1();
    if (maskUndefined(o) === maskUndefined(e) || o != null && equals_Ljava_lang_Object__Z__devirtual$(o, e)) {
      remove && iter.remove();
      return true;
    }
  }
  return false;
}

function $clear_0(this$static){
  var iter;
  for (iter = this$static.iterator_0(); iter.hasNext_0();) {
    iter.next_1();
    iter.remove();
  }
}

function $containsAll(this$static, c){
  var e, e$iterator;
  checkCriticalNotNull(c);
  for (e$iterator = c.iterator_0(); e$iterator.hasNext_0();) {
    e = e$iterator.next_1();
    if (!this$static.contains(e)) {
      return false;
    }
  }
  return true;
}

function $toArray(this$static, a){
  var i, it, result, size_0;
  size_0 = this$static.size_1();
  a.length < size_0 && (a = (result = new Array(size_0) , stampJavaTypeInfo_0(result, a)));
  it = this$static.iterator_0();
  for (i = 0; i < size_0; ++i) {
    setCheck(a, i, it.next_1());
  }
  a.length > size_0 && setCheck(a, size_0, null);
  return a;
}

function $toString_5(this$static){
  var comma, e, e$iterator, sb;
  sb = new StringBuilder_1('[');
  comma = false;
  for (e$iterator = this$static.iterator_0(); e$iterator.hasNext_0();) {
    e = e$iterator.next_1();
    comma?(sb.string += ', ' , sb):(comma = true);
    $append_3(sb, e === this$static?'(this Collection)':($clinit_String() , e == null?'null':toString__Ljava_lang_String___devirtual$(e)));
  }
  sb.string += ']';
  return sb.string;
}

defineClass(639, 1, $intern_20);
_.add_1 = function add_1(o){
  return $add();
}
;
_.addAll = function addAll(c){
  return $addAll(this, c);
}
;
_.clear_0 = function clear_3(){
  $clear_0(this);
}
;
_.contains = function contains(o){
  return $advanceToFind(this, o, false);
}
;
_.containsAll = function containsAll(c){
  return $containsAll(this, c);
}
;
_.isEmpty = function isEmpty_1(){
  return this.size_1() == 0;
}
;
_.remove_1 = function remove_4(o){
  return $advanceToFind(this, o, true);
}
;
_.toArray = function toArray(){
  return this.toArray_0(initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, this.size_1(), 4, 1));
}
;
_.toArray_0 = function toArray_0(a){
  return $toArray(this, a);
}
;
_.toString_0 = function toString_16(){
  return $toString_5(this);
}
;
var Ljava_util_AbstractCollection_2_classLit = createForClass('java.util', 'AbstractCollection', 639);
function $equals_0(this$static, o){
  var other;
  if (o === this$static) {
    return true;
  }
  if (!instanceOf(o, 18)) {
    return false;
  }
  other = castTo(o, 18);
  if (other.size_1() != this$static.size_1()) {
    return false;
  }
  return this$static.containsAll(other);
}

defineClass(640, 639, $intern_21);
_.equals = function equals_10(o){
  return $equals_0(this, o);
}
;
_.hashCode_0 = function hashCode_10(){
  return hashCode_45(this);
}
;
var Ljava_util_AbstractSet_2_classLit = createForClass('java.util', 'AbstractSet', 640);
defineClass(648, 640, $intern_21);
var Lcom_google_common_collect_Sets$ImprovedAbstractSet_2_classLit = createForClass('com.google.common.collect', 'Sets/ImprovedAbstractSet', 648);
function $contains(this$static, o){
  var entry, key, value_0;
  if (instanceOf(o, 21)) {
    entry = castTo(o, 21);
    key = entry.getKey();
    value_0 = safeGet(this$static.map_1(), key);
    return equal(value_0, entry.getValue()) && (value_0 != null || this$static.map_1().containsKey(key));
  }
  return false;
}

defineClass(654, 648, $intern_21);
_.clear_0 = function clear_4(){
  this.map_1().clear_0();
}
;
_.contains = function contains_0(o){
  return $contains(this, o);
}
;
_.isEmpty = function isEmpty_2(){
  return this.map_1().isEmpty();
}
;
_.remove_1 = function remove_5(o){
  var entry;
  if (this.contains(o)) {
    entry = castTo(o, 21);
    return this.map_1().keySet_0().remove_1(entry.getKey());
  }
  return false;
}
;
_.size_1 = function size_4(){
  return this.map_1().size_1();
}
;
var Lcom_google_common_collect_Maps$EntrySet_2_classLit = createForClass('com.google.common.collect', 'Maps/EntrySet', 654);
function AbstractMapBasedMultimap$AsMap$AsMapEntries(this$1){
  this.this$11 = this$1;
}

defineClass(387, 654, $intern_21, AbstractMapBasedMultimap$AsMap$AsMapEntries);
_.contains = function contains_1(o){
  return safeContains(new AbstractHashMap$EntrySet(this.this$11.submap), o);
}
;
_.iterator_0 = function iterator_0(){
  return new AbstractMapBasedMultimap$AsMap$AsMapIterator(this.this$11);
}
;
_.map_1 = function map_1(){
  return this.this$11;
}
;
_.remove_1 = function remove_6(o){
  var entry;
  if (!safeContains(new AbstractHashMap$EntrySet(this.this$11.submap), o)) {
    return false;
  }
  entry = castTo(o, 21);
  $removeValuesForKey(this.this$11.this$01, entry.getKey());
  return true;
}
;
var Lcom_google_common_collect_AbstractMapBasedMultimap$AsMap$AsMapEntries_2_classLit = createForClass('com.google.common.collect', 'AbstractMapBasedMultimap/AsMap/AsMapEntries', 387);
function AbstractMapBasedMultimap$AsMap$AsMapIterator(this$1){
  this.this$11 = this$1;
  this.delegateIterator = new AbstractHashMap$EntrySetIterator((new AbstractHashMap$EntrySet(this.this$11.submap)).this$01);
}

defineClass(299, 1, $intern_18, AbstractMapBasedMultimap$AsMap$AsMapIterator);
_.next_1 = function next_3(){
  var entry;
  return entry = $next_6(this.delegateIterator) , this.collection = castTo(entry.getValue(), 19) , $wrapEntry(this.this$11, entry);
}
;
_.hasNext_0 = function hasNext_2(){
  return this.delegateIterator.hasNext;
}
;
_.remove = function remove_7(){
  $remove_10(this.delegateIterator);
  this.this$11.this$01.totalSize -= this.collection.size_1();
  this.collection.clear_0();
}
;
var Lcom_google_common_collect_AbstractMapBasedMultimap$AsMap$AsMapIterator_2_classLit = createForClass('com.google.common.collect', 'AbstractMapBasedMultimap/AsMap/AsMapIterator', 299);
function Maps$KeySet(map_0){
  this.map_0 = castTo(checkNotNull(map_0), 57);
}

defineClass(260, 648, $intern_21, Maps$KeySet);
_.clear_0 = function clear_5(){
  this.map_0.clear_0();
}
;
_.contains = function contains_2(o){
  return this.map_0.containsKey(o);
}
;
_.isEmpty = function isEmpty_3(){
  return this.map_0.isEmpty();
}
;
_.iterator_0 = function iterator_1(){
  return $clinit_Maps() , transform_2(this.map_0.entrySet_0().iterator_0(), ($clinit_Maps$EntryFunction() , KEY));
}
;
_.remove_1 = function remove_8(o){
  if (this.map_0.containsKey(o)) {
    this.map_0.remove_0(o);
    return true;
  }
  return false;
}
;
_.size_1 = function size_5(){
  return this.map_0.size_1();
}
;
var Lcom_google_common_collect_Maps$KeySet_2_classLit = createForClass('com.google.common.collect', 'Maps/KeySet', 260);
function AbstractMapBasedMultimap$KeySet(this$0, subMap){
  this.this$01 = this$0;
  Maps$KeySet.call(this, subMap);
}

defineClass(386, 260, $intern_21, AbstractMapBasedMultimap$KeySet);
_.clear_0 = function clear_6(){
  var entryIterator;
  clear_14((entryIterator = this.map_0.entrySet_0().iterator_0() , new AbstractMapBasedMultimap$KeySet$1(this, entryIterator)));
}
;
_.containsAll = function containsAll_0(c){
  return this.map_0.keySet_0().containsAll(c);
}
;
_.equals = function equals_11(object){
  return this === object || this.map_0.keySet_0().equals(object);
}
;
_.hashCode_0 = function hashCode_11(){
  return this.map_0.keySet_0().hashCode_0();
}
;
_.iterator_0 = function iterator_2(){
  var entryIterator;
  return entryIterator = this.map_0.entrySet_0().iterator_0() , new AbstractMapBasedMultimap$KeySet$1(this, entryIterator);
}
;
_.remove_1 = function remove_9(key){
  var collection, count;
  count = 0;
  collection = castTo(this.map_0.remove_0(key), 19);
  if (collection) {
    count = collection.size_1();
    collection.clear_0();
    this.this$01.totalSize -= count;
  }
  return count > 0;
}
;
var Lcom_google_common_collect_AbstractMapBasedMultimap$KeySet_2_classLit = createForClass('com.google.common.collect', 'AbstractMapBasedMultimap/KeySet', 386);
function AbstractMapBasedMultimap$KeySet$1(this$1, val$entryIterator){
  this.this$11 = this$1;
  this.val$entryIterator2 = val$entryIterator;
}

defineClass(300, 1, $intern_18, AbstractMapBasedMultimap$KeySet$1);
_.hasNext_0 = function hasNext_3(){
  return this.val$entryIterator2.hasNext_0();
}
;
_.next_1 = function next_4(){
  this.entry = castTo(this.val$entryIterator2.next_1(), 21);
  return this.entry.getKey();
}
;
_.remove = function remove_10(){
  var collection;
  checkState_0(!!this.entry);
  collection = castTo(this.entry.getValue(), 19);
  this.val$entryIterator2.remove();
  this.this$11.this$01.totalSize -= collection.size_1();
  collection.clear_0();
}
;
var Lcom_google_common_collect_AbstractMapBasedMultimap$KeySet$1_2_classLit = createForClass('com.google.common.collect', 'AbstractMapBasedMultimap/KeySet/1', 300);
function $add_0(this$static, value_0){
  var changed, wasEmpty;
  $refreshIfEmpty(this$static);
  wasEmpty = this$static.delegate.isEmpty();
  changed = this$static.delegate.add_1(value_0);
  if (changed) {
    ++this$static.this$01_0.totalSize;
    wasEmpty && $addToMap(this$static);
  }
  return changed;
}

function $addAll_0(this$static, collection){
  var changed, newSize, oldSize;
  if (collection.isEmpty()) {
    return false;
  }
  oldSize = this$static.size_1();
  changed = this$static.delegate.addAll(collection);
  if (changed) {
    newSize = this$static.delegate.size_1();
    this$static.this$01_0.totalSize += newSize - oldSize;
    oldSize == 0 && $addToMap(this$static);
  }
  return changed;
}

function $addToMap(this$static){
  this$static.ancestor?$addToMap(this$static.ancestor):$put_2(this$static.this$01_0.map_0, this$static.key, this$static.delegate);
}

function $clear_1(this$static){
  var oldSize;
  oldSize = this$static.size_1();
  if (oldSize == 0) {
    return;
  }
  this$static.delegate.clear_0();
  this$static.this$01_0.totalSize -= oldSize;
  $removeIfEmpty(this$static);
}

function $equals_1(this$static, object){
  if (object === this$static) {
    return true;
  }
  $refreshIfEmpty(this$static);
  return this$static.delegate.equals(object);
}

function $refreshIfEmpty(this$static){
  var newDelegate;
  if (this$static.ancestor) {
    $refreshIfEmpty(this$static.ancestor);
    if (this$static.ancestor.delegate != this$static.ancestorDelegate) {
      throw new ConcurrentModificationException;
    }
  }
   else if (this$static.delegate.isEmpty()) {
    newDelegate = castTo($get_9(this$static.this$01_0.map_0, this$static.key), 19);
    !!newDelegate && (this$static.delegate = newDelegate);
  }
}

function $remove_1(this$static, o){
  var changed;
  $refreshIfEmpty(this$static);
  changed = this$static.delegate.remove_1(o);
  if (changed) {
    --this$static.this$01_0.totalSize;
    $removeIfEmpty(this$static);
  }
  return changed;
}

function $removeIfEmpty(this$static){
  this$static.ancestor?$removeIfEmpty(this$static.ancestor):this$static.delegate.isEmpty() && $remove_9(this$static.this$01_0.map_0, this$static.key);
}

function AbstractMapBasedMultimap$WrappedCollection(this$0, key, delegate, ancestor){
  this.this$01_0 = this$0;
  this.key = key;
  this.delegate = delegate;
  this.ancestor = ancestor;
  this.ancestorDelegate = !ancestor?null:ancestor.delegate;
}

defineClass(216, 639, $intern_20, AbstractMapBasedMultimap$WrappedCollection);
_.add_1 = function add_2(value_0){
  return $add_0(this, value_0);
}
;
_.addAll = function addAll_0(collection){
  return $addAll_0(this, collection);
}
;
_.clear_0 = function clear_7(){
  $clear_1(this);
}
;
_.contains = function contains_3(o){
  return $refreshIfEmpty(this) , this.delegate.contains(o);
}
;
_.containsAll = function containsAll_1(c){
  return $refreshIfEmpty(this) , this.delegate.containsAll(c);
}
;
_.equals = function equals_12(object){
  return $equals_1(this, object);
}
;
_.hashCode_0 = function hashCode_12(){
  return $refreshIfEmpty(this) , this.delegate.hashCode_0();
}
;
_.iterator_0 = function iterator_3(){
  return $refreshIfEmpty(this) , new AbstractMapBasedMultimap$WrappedCollection$WrappedIterator(this);
}
;
_.remove_1 = function remove_11(o){
  return $remove_1(this, o);
}
;
_.size_1 = function size_6(){
  return $refreshIfEmpty(this) , this.delegate.size_1();
}
;
_.toString_0 = function toString_17(){
  $refreshIfEmpty(this);
  return toString__Ljava_lang_String___devirtual$(this.delegate);
}
;
var Lcom_google_common_collect_AbstractMapBasedMultimap$WrappedCollection_2_classLit = createForClass('com.google.common.collect', 'AbstractMapBasedMultimap/WrappedCollection', 216);
var Ljava_util_List_2_classLit = createForInterface('java.util', 'List');
function $size(this$static){
  return $refreshIfEmpty(this$static) , this$static.delegate.size_1();
}

function AbstractMapBasedMultimap$WrappedList(this$0, key, delegate, ancestor){
  this.this$01 = this$0;
  AbstractMapBasedMultimap$WrappedCollection.call(this, this$0, key, delegate, ancestor);
}

defineClass(297, 216, $intern_22, AbstractMapBasedMultimap$WrappedList);
_.add_2 = function add_3(index_0, element){
  var wasEmpty;
  $refreshIfEmpty(this);
  wasEmpty = this.delegate.isEmpty();
  castTo(this.delegate, 20).add_2(index_0, element);
  ++this.this$01.totalSize;
  wasEmpty && $addToMap(this);
}
;
_.get_2 = function get_4(index_0){
  $refreshIfEmpty(this);
  return castTo(this.delegate, 20).get_2(index_0);
}
;
_.listIterator_0 = function listIterator(){
  $refreshIfEmpty(this);
  return new AbstractMapBasedMultimap$WrappedList$WrappedListIterator(this);
}
;
_.listIterator_1 = function listIterator_0(index_0){
  $refreshIfEmpty(this);
  return new AbstractMapBasedMultimap$WrappedList$WrappedListIterator_0(this, index_0);
}
;
_.remove_2 = function remove_12(index_0){
  var value_0;
  $refreshIfEmpty(this);
  value_0 = castTo(this.delegate, 20).remove_2(index_0);
  --this.this$01.totalSize;
  $removeIfEmpty(this);
  return value_0;
}
;
_.set_2 = function set_2(index_0, element){
  $refreshIfEmpty(this);
  return castTo(this.delegate, 20).set_2(index_0, element);
}
;
_.subList = function subList(fromIndex, toIndex){
  $refreshIfEmpty(this);
  return $wrapList(this.this$01, this.key, castTo(this.delegate, 20).subList(fromIndex, toIndex), !this.ancestor?this:this.ancestor);
}
;
var Lcom_google_common_collect_AbstractMapBasedMultimap$WrappedList_2_classLit = createForClass('com.google.common.collect', 'AbstractMapBasedMultimap/WrappedList', 297);
function AbstractMapBasedMultimap$RandomAccessWrappedList(this$0, key, delegate, ancestor){
  AbstractMapBasedMultimap$WrappedList.call(this, this$0, key, delegate, ancestor);
}

defineClass(385, 297, $intern_23, AbstractMapBasedMultimap$RandomAccessWrappedList);
var Lcom_google_common_collect_AbstractMapBasedMultimap$RandomAccessWrappedList_2_classLit = createForClass('com.google.common.collect', 'AbstractMapBasedMultimap/RandomAccessWrappedList', 385);
function $$init(this$static){
  this$static.originalDelegate = this$static.this$11_0.delegate;
}

function $validateIterator(this$static){
  $refreshIfEmpty(this$static.this$11_0);
  if (this$static.this$11_0.delegate != this$static.originalDelegate) {
    throw new ConcurrentModificationException;
  }
}

function AbstractMapBasedMultimap$WrappedCollection$WrappedIterator(this$1){
  this.this$11_0 = this$1;
  $$init(this);
  this.delegateIterator = $iteratorOrListIterator(this$1.delegate);
}

function AbstractMapBasedMultimap$WrappedCollection$WrappedIterator_0(this$1, delegateIterator){
  this.this$11_0 = this$1;
  $$init(this);
  this.delegateIterator = delegateIterator;
}

defineClass(189, 1, $intern_18, AbstractMapBasedMultimap$WrappedCollection$WrappedIterator);
_.hasNext_0 = function hasNext_4(){
  return $validateIterator(this) , this.delegateIterator.hasNext_0();
}
;
_.next_1 = function next_5(){
  return $validateIterator(this) , this.delegateIterator.next_1();
}
;
_.remove = function remove_13(){
  this.delegateIterator.remove();
  --this.this$11_0.this$01_0.totalSize;
  $removeIfEmpty(this.this$11_0);
}
;
var Lcom_google_common_collect_AbstractMapBasedMultimap$WrappedCollection$WrappedIterator_2_classLit = createForClass('com.google.common.collect', 'AbstractMapBasedMultimap/WrappedCollection/WrappedIterator', 189);
function AbstractMapBasedMultimap$WrappedList$WrappedListIterator(this$1){
  this.this$11 = this$1;
  AbstractMapBasedMultimap$WrappedCollection$WrappedIterator.call(this, this$1);
}

function AbstractMapBasedMultimap$WrappedList$WrappedListIterator_0(this$1, index_0){
  this.this$11 = this$1;
  AbstractMapBasedMultimap$WrappedCollection$WrappedIterator_0.call(this, this$1, castTo(this$1.delegate, 20).listIterator_1(index_0));
}

defineClass(298, 189, $intern_24, AbstractMapBasedMultimap$WrappedList$WrappedListIterator, AbstractMapBasedMultimap$WrappedList$WrappedListIterator_0);
_.add_0 = function add_4(value_0){
  var wasEmpty;
  wasEmpty = $size(this.this$11) == 0;
  ($validateIterator(this) , castTo(this.delegateIterator, 96)).add_0(value_0);
  ++this.this$11.this$01.totalSize;
  wasEmpty && $addToMap(this.this$11);
}
;
_.hasPrevious = function hasPrevious_0(){
  return ($validateIterator(this) , castTo(this.delegateIterator, 96)).hasPrevious();
}
;
_.nextIndex_0 = function nextIndex_1(){
  return ($validateIterator(this) , castTo(this.delegateIterator, 96)).nextIndex_0();
}
;
_.previous_0 = function previous_1(){
  return ($validateIterator(this) , castTo(this.delegateIterator, 96)).previous_0();
}
;
_.previousIndex = function previousIndex_0(){
  return ($validateIterator(this) , castTo(this.delegateIterator, 96)).previousIndex();
}
;
_.set_1 = function set_3(value_0){
  ($validateIterator(this) , castTo(this.delegateIterator, 96)).set_1(value_0);
}
;
var Lcom_google_common_collect_AbstractMapBasedMultimap$WrappedList$WrappedListIterator_2_classLit = createForClass('com.google.common.collect', 'AbstractMapBasedMultimap/WrappedList/WrappedListIterator', 298);
function AbstractMapBasedMultimap$WrappedSet(this$0, key, delegate){
  AbstractMapBasedMultimap$WrappedCollection.call(this, this$0, key, delegate, null);
}

defineClass(295, 216, $intern_21, AbstractMapBasedMultimap$WrappedSet);
var Lcom_google_common_collect_AbstractMapBasedMultimap$WrappedSet_2_classLit = createForClass('com.google.common.collect', 'AbstractMapBasedMultimap/WrappedSet', 295);
function AbstractMapBasedMultimap$WrappedSortedSet(this$0, key, delegate){
  AbstractMapBasedMultimap$WrappedCollection.call(this, this$0, key, delegate, null);
}

defineClass(296, 216, $intern_25, AbstractMapBasedMultimap$WrappedSortedSet);
var Lcom_google_common_collect_AbstractMapBasedMultimap$WrappedSortedSet_2_classLit = createForClass('com.google.common.collect', 'AbstractMapBasedMultimap/WrappedSortedSet', 296);
defineClass(667, 1, $intern_26);
_.equals = function equals_13(object){
  var that;
  if (instanceOf(object, 21)) {
    that = castTo(object, 21);
    return equal(this.getKey(), that.getKey()) && equal(this.getValue(), that.getValue());
  }
  return false;
}
;
_.hashCode_0 = function hashCode_13(){
  var k, v;
  k = this.getKey();
  v = this.getValue();
  return (k == null?0:hashCode__I__devirtual$(k)) ^ (v == null?0:hashCode__I__devirtual$(v));
}
;
_.setValue = function setValue(value_0){
  throw new UnsupportedOperationException;
}
;
_.toString_0 = function toString_18(){
  return this.getKey() + '=' + this.getValue();
}
;
var Lcom_google_common_collect_AbstractMapEntry_2_classLit = createForClass('com.google.common.collect', 'AbstractMapEntry', 667);
function AbstractMultimap$Values(this$0){
  this.this$01 = this$0;
}

defineClass(390, 639, $intern_20, AbstractMultimap$Values);
_.clear_0 = function clear_8(){
  $clear(this.this$01);
}
;
_.contains = function contains_4(o){
  return $containsValue(this.this$01, o);
}
;
_.iterator_0 = function iterator_4(){
  return new AbstractMapBasedMultimap$1(this.this$01);
}
;
_.size_1 = function size_7(){
  return this.this$01.totalSize;
}
;
var Lcom_google_common_collect_AbstractMultimap$Values_2_classLit = createForClass('com.google.common.collect', 'AbstractMultimap/Values', 390);
function $entrySet_0(this$static){
  var result;
  result = this$static.entrySet;
  !result && (this$static.entrySet = result = this$static.createEntrySet());
  return result;
}

defineClass(655, 639, $intern_27);
_.add_1 = function add_5(element){
  return this.add_3(element, 1) , true;
}
;
_.add_3 = function add_6(element, occurrences){
  throw new UnsupportedOperationException;
}
;
_.addAll = function addAll_1(elementsToAdd){
  return addAllImpl(this, elementsToAdd);
}
;
_.clear_0 = function clear_9(){
  clear_14(this.entryIterator_0());
}
;
_.contains = function contains_5(element){
  return this.count_0(element) > 0;
}
;
_.count_0 = function count_0(element){
  var entry, entry$iterator;
  for (entry$iterator = $entrySet_0(this).iterator_0(); entry$iterator.hasNext_0();) {
    entry = castTo(entry$iterator.next_1(), 83);
    if (equal(entry.getElement(), element)) {
      return entry.getCount();
    }
  }
  return 0;
}
;
_.createEntrySet = function createEntrySet_0(){
  return new AbstractMultiset$EntrySet(this);
}
;
_.entrySet_0 = function entrySet_0(){
  return $entrySet_0(this);
}
;
_.equals = function equals_14(object){
  return equalsImpl_2(this, object);
}
;
_.hashCode_0 = function hashCode_14(){
  return $entrySet_0(this).hashCode_0();
}
;
_.isEmpty = function isEmpty_4(){
  return $entrySet_0(this).isEmpty();
}
;
_.iterator_0 = function iterator_5(){
  return $clinit_Multisets() , new Multisets$MultisetIteratorImpl(this, $entrySet_0(this).iterator_0());
}
;
_.remove_1 = function remove_14(element){
  return this.remove_3(element, 1) > 0;
}
;
_.remove_3 = function remove_15(element, occurrences){
  throw new UnsupportedOperationException;
}
;
_.setCount = function setCount(element, count){
  var oldCount, delta;
  return $clinit_Multisets() , checkNonnegative(count, 'count') , oldCount = this.count_0(element) , delta = count - oldCount , delta > 0?this.add_3(element, delta):delta < 0 && this.remove_3(element, -delta) , oldCount;
}
;
_.setCount_0 = function setCount_0(element, oldCount, newCount){
  return setCountImpl(this, element, oldCount, newCount);
}
;
_.size_1 = function size_8(){
  return sizeImpl(this);
}
;
_.toString_0 = function toString_19(){
  return toString__Ljava_lang_String___devirtual$($entrySet_0(this));
}
;
var Lcom_google_common_collect_AbstractMultiset_2_classLit = createForClass('com.google.common.collect', 'AbstractMultiset', 655);
defineClass(656, 648, $intern_21);
_.clear_0 = function clear_10(){
  this.multiset_0().clear_0();
}
;
_.contains = function contains_6(o){
  var count, entry;
  if (instanceOf(o, 83)) {
    entry = castTo(o, 83);
    if (entry.getCount() <= 0) {
      return false;
    }
    count = this.multiset_0().count_0(entry.getElement());
    return count == entry.getCount();
  }
  return false;
}
;
_.remove_1 = function remove_16(object){
  var element, entry, entryCount, multiset;
  if (instanceOf(object, 83)) {
    entry = castTo(object, 83);
    element = entry.getElement();
    entryCount = entry.getCount();
    if (entryCount != 0) {
      multiset = this.multiset_0();
      return multiset.setCount_0(element, entryCount, 0);
    }
  }
  return false;
}
;
var Lcom_google_common_collect_Multisets$EntrySet_2_classLit = createForClass('com.google.common.collect', 'Multisets/EntrySet', 656);
function AbstractMultiset$EntrySet(this$0){
  this.this$01 = this$0;
}

defineClass(396, 656, $intern_21, AbstractMultiset$EntrySet);
_.iterator_0 = function iterator_6(){
  return this.this$01.entryIterator_0();
}
;
_.multiset_0 = function multiset_0(){
  return this.this$01;
}
;
_.size_1 = function size_9(){
  return this.this$01.distinctElements_0();
}
;
var Lcom_google_common_collect_AbstractMultiset$EntrySet_2_classLit = createForClass('com.google.common.collect', 'AbstractMultiset/EntrySet', 396);
function AbstractSetMultimap(map_0){
  AbstractMapBasedMultimap.call(this, map_0);
}

defineClass(384, 294, $intern_17);
_.createCollection = function createCollection_0(){
  return new HashSet_0(capacity_0(this.expectedValuesPerKey));
}
;
_.createUnmodifiableEmptyCollection = function createUnmodifiableEmptyCollection_1(){
  return $clinit_ImmutableCollection() , $clinit_RegularImmutableSet() , EMPTY_1;
}
;
_.get_0 = function get_5(key){
  return castTo($get(this, key), 18);
}
;
_.removeAll = function removeAll_1(key){
  return castTo($removeAll(this, key), 18);
}
;
_.asMap_0 = function asMap_1(){
  var result;
  return result = this.asMap , !result?(this.asMap = new AbstractMapBasedMultimap$AsMap(this, this.map_0)):result;
}
;
_.equals = function equals_15(object){
  return equalsImpl_1(this, object);
}
;
var Lcom_google_common_collect_AbstractSetMultimap_2_classLit = createForClass('com.google.common.collect', 'AbstractSetMultimap', 384);
function $subMultiset(this$static, fromElement, fromBoundType, toElement, toBoundType){
  checkNotNull(fromBoundType);
  checkNotNull(toBoundType);
  return $headMultiset(new TreeMultiset(this$static.rootReference, $intersect(this$static.range, new GeneralRange(this$static.comparator, true, fromElement, fromBoundType, false, null, ($clinit_BoundType() , OPEN))), this$static.header), toElement, toBoundType);
}

function AbstractSortedMultiset(comparator){
  this.comparator = castTo(checkNotNull(comparator), 56);
}

defineClass(342, 655, $intern_27);
var Lcom_google_common_collect_AbstractSortedMultiset_2_classLit = createForClass('com.google.common.collect', 'AbstractSortedMultiset', 342);
function ArrayListMultimap(){
  AbstractListMultimap.call(this, new HashMap);
  this.expectedValuesPerKey = 3;
}

defineClass(280, 601, $intern_17, ArrayListMultimap);
_.expectedValuesPerKey = 0;
var Lcom_google_common_collect_ArrayListMultimap_2_classLit = createForClass('com.google.common.collect', 'ArrayListMultimap', 280);
function $clinit_BoundType(){
  $clinit_BoundType = emptyMethod;
  OPEN = new BoundType$1;
  CLOSED = new BoundType$2;
}

function BoundType(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function values_3(){
  $clinit_BoundType();
  return stampJavaTypeInfo(getClassLiteralForArray(Lcom_google_common_collect_BoundType_2_classLit, 1), $intern_13, 159, 0, [OPEN, CLOSED]);
}

defineClass(159, 17, $intern_28);
var CLOSED, OPEN;
var Lcom_google_common_collect_BoundType_2_classLit = createForEnum('com.google.common.collect', 'BoundType', 159, Ljava_lang_Enum_2_classLit, values_3);
function BoundType$1(){
  BoundType.call(this, 'OPEN', 0);
}

defineClass(622, 159, $intern_28, BoundType$1);
var Lcom_google_common_collect_BoundType$1_2_classLit = createForEnum('com.google.common.collect', 'BoundType/1', 622, Lcom_google_common_collect_BoundType_2_classLit, null);
function BoundType$2(){
  BoundType.call(this, 'CLOSED', 1);
}

defineClass(623, 159, $intern_28, BoundType$2);
var Lcom_google_common_collect_BoundType$2_2_classLit = createForEnum('com.google.common.collect', 'BoundType/2', 623, Lcom_google_common_collect_BoundType_2_classLit, null);
function checkEntryNotNull(key, value_0){
  if (key == null) {
    throw new NullPointerException_0('null key in entry: null=' + value_0);
  }
   else if (value_0 == null) {
    throw new NullPointerException_0('null value in entry: ' + key + '=null');
  }
}

function checkNonnegative(value_0, name_0){
  if (value_0 < 0) {
    throw new IllegalArgumentException_0(name_0 + ' cannot be negative but was: ' + value_0);
  }
  return value_0;
}

function $clinit_Collections2(){
  $clinit_Collections2 = emptyMethod;
  STANDARD_JOINER = $useForNull(new Joiner(', '));
}

function newStringBuilderForCollection(size_0){
  $clinit_Collections2();
  checkNonnegative(size_0, 'size');
  return toInt(lt(mul_0(size_0, 8), $intern_29)?mul_0(size_0, 8):$intern_29) , new StringBuilder_0;
}

function safeContains(collection, object){
  $clinit_Collections2();
  checkNotNull(collection);
  try {
    return $contains_2(collection, object);
  }
   catch ($e0) {
    $e0 = wrap($e0);
    if (instanceOf($e0, 119)) {
      return false;
    }
     else if (instanceOf($e0, 76)) {
      return false;
    }
     else 
      throw unwrap_5($e0);
  }
}

var STANDARD_JOINER;
function FluentIterable(){
  $clinit_Absent();
}

function concat(inputs){
  checkNotNull(inputs);
  return new FluentIterable$2(inputs);
}

defineClass(234, 1, $intern_30);
_.toString_0 = function toString_20(){
  return toString_29(castTo(checkNotNull_0(this, 'use Optional.orNull() instead of Optional.or(null)'), 22).iterator_0());
}
;
var Lcom_google_common_collect_FluentIterable_2_classLit = createForClass('com.google.common.collect', 'FluentIterable', 234);
function $iterator(this$static){
  return $clinit_Iterators() , new Iterators$ConcatenatedIterator($iterator_1(transform_1(this$static.val$inputs1, new Iterables$12)));
}

function FluentIterable$2(val$inputs){
  this.val$inputs1 = val$inputs;
  FluentIterable.call(this);
}

defineClass(170, 234, $intern_30, FluentIterable$2);
_.iterator_0 = function iterator_7(){
  return $iterator(this);
}
;
var Lcom_google_common_collect_FluentIterable$2_2_classLit = createForClass('com.google.common.collect', 'FluentIterable/2', 170);
defineClass(663, 1, {});
_.toString_0 = function toString_21(){
  return toString__Ljava_lang_String___devirtual$($entrySet_2(this.this$01.delegate).coll);
}
;
var Lcom_google_common_collect_ForwardingObject_2_classLit = createForClass('com.google.common.collect', 'ForwardingObject', 663);
defineClass(664, 663, $intern_20);
_.add_1 = function add_7(element){
  return $entrySet_2(this.this$01.delegate) , $add_16();
}
;
_.addAll = function addAll_2(collection){
  return $entrySet_2(this.this$01.delegate) , $addAll_7();
}
;
_.clear_0 = function clear_11(){
  $entrySet_2(this.this$01.delegate);
  $clear_4();
}
;
_.contains = function contains_7(object){
  return $contains_4($entrySet_2(this.this$01.delegate), object);
}
;
_.containsAll = function containsAll_2(collection){
  return $containsAll_1($entrySet_2(this.this$01.delegate), collection);
}
;
_.isEmpty = function isEmpty_5(){
  return $entrySet_2(this.this$01.delegate).coll.isEmpty();
}
;
_.iterator_0 = function iterator_8(){
  var it;
  return it = $entrySet_2(this.this$01.delegate).coll.iterator_0() , new Collections$UnmodifiableMap$UnmodifiableEntrySet$1(it);
}
;
_.remove_1 = function remove_17(object){
  return $entrySet_2(this.this$01.delegate) , $remove_13();
}
;
_.size_1 = function size_10(){
  return $entrySet_2(this.this$01.delegate).coll.size_1();
}
;
_.toArray = function toArray_1(){
  return $toArray_4($entrySet_2(this.this$01.delegate));
}
;
_.toArray_0 = function toArray_2(array){
  return $toArray_5($entrySet_2(this.this$01.delegate), array);
}
;
var Lcom_google_common_collect_ForwardingCollection_2_classLit = createForClass('com.google.common.collect', 'ForwardingCollection', 664);
function $clinit_ImmutableCollection(){
  $clinit_ImmutableCollection = emptyMethod;
  new ForwardingImmutableCollection(($clinit_Collections() , $clinit_Collections() , EMPTY_LIST));
}

function $add_1(){
  throw new UnsupportedOperationException;
}

function $addAll_1(){
  throw new UnsupportedOperationException;
}

function $asList(this$static){
  var list;
  list = this$static.asList;
  return !list?(this$static.asList = this$static.createAsList()):list;
}

function $clear_2(){
  throw new UnsupportedOperationException;
}

function $remove_2(){
  throw new UnsupportedOperationException;
}

function $removeAll_0(){
  throw new UnsupportedOperationException;
}

defineClass(659, 639, $intern_31);
_.iterator_0 = function iterator_9(){
  return this.iterator_1();
}
;
_.add_1 = function add_8(e){
  return $add_1();
}
;
_.addAll = function addAll_3(newElements){
  return $addAll_1();
}
;
_.clear_0 = function clear_12(){
  $clear_2();
}
;
_.contains = function contains_8(object){
  return object != null && $advanceToFind(this, object, false);
}
;
_.createAsList = function createAsList(){
  switch (this.size_1()) {
    case 0:
      return $clinit_ImmutableList() , $clinit_ImmutableList() , EMPTY;
    case 1:
      return $clinit_ImmutableList() , new SingletonImmutableList(this.iterator_1().next_1());
    default:return new RegularImmutableAsList_0(this, this.toArray());
  }
}
;
_.remove_1 = function remove_18(object){
  return $remove_2();
}
;
var Lcom_google_common_collect_ImmutableCollection_2_classLit = createForClass('com.google.common.collect', 'ImmutableCollection', 659);
function ForwardingImmutableCollection(delegate){
  $clinit_ImmutableCollection();
  this.delegate = delegate;
}

defineClass(316, 659, $intern_31, ForwardingImmutableCollection);
_.iterator_0 = function iterator_11(){
  return unmodifiableIterator(this.delegate.iterator_0());
}
;
_.contains = function contains_9(object){
  return object != null && this.delegate.contains(object);
}
;
_.containsAll = function containsAll_3(targets){
  return this.delegate.containsAll(targets);
}
;
_.isEmpty = function isEmpty_6(){
  return this.delegate.isEmpty();
}
;
_.iterator_1 = function iterator_10(){
  return unmodifiableIterator(this.delegate.iterator_0());
}
;
_.size_1 = function size_11(){
  return this.delegate.size_1();
}
;
_.toArray = function toArray_3(){
  return this.delegate.toArray();
}
;
_.toArray_0 = function toArray_4(other){
  return this.delegate.toArray_0(other);
}
;
_.toString_0 = function toString_22(){
  return toString__Ljava_lang_String___devirtual$(this.delegate);
}
;
var Lcom_google_common_collect_ForwardingImmutableCollection_2_classLit = createForClass('com.google.common.collect', 'ForwardingImmutableCollection', 316);
function $clinit_ImmutableList(){
  $clinit_ImmutableList = emptyMethod;
  $clinit_ImmutableCollection();
  EMPTY = new RegularImmutableList(($clinit_Collections() , $clinit_Collections() , EMPTY_LIST));
}

function $listIterator(this$static, index_0){
  return new ImmutableList$1(this$static, this$static.size_1(), index_0);
}

function $reverse(this$static){
  var list;
  list = (checkNotNull(this$static) , new ArrayList_1(($clinit_Collections2() , this$static)));
  reverse_3(list);
  return unsafeDelegateList(list);
}

function copyFromCollection(collection){
  var elements, list;
  elements = clone_2(collection.array, collection.array.length);
  switch (elements.length) {
    case 0:
      return EMPTY;
    case 1:
      list = new SingletonImmutableList(elements[0]);
      return list;
    default:return new RegularImmutableList(nullCheckedList(elements));
  }
}

function copyOf(elements){
  $clinit_ImmutableList();
  checkNotNull(elements);
  return elements?copyFromCollection(elements):copyFromCollection(newArrayList_0(new ArrayList$1(null)));
}

function nullCheckedList(array){
  $clinit_ImmutableList();
  var i, len;
  for (i = 0 , len = array.length; i < len; i++) {
    if (array[i] == null) {
      throw new NullPointerException_0('at index ' + i);
    }
  }
  return new Arrays$ArrayList(array);
}

function unsafeDelegateList(list){
  switch (list.size_1()) {
    case 0:
      return EMPTY;
    case 1:
      return new SingletonImmutableList(list.iterator_0().next_1());
    default:return new RegularImmutableList(list);
  }
}

defineClass(89, 659, $intern_32);
_.iterator_0 = function iterator_13(){
  return this.iterator_1();
}
;
_.listIterator_0 = function listIterator_1(){
  return this.listIterator_2(0);
}
;
_.listIterator_1 = function listIterator_3(index_0){
  return this.listIterator_2(index_0);
}
;
_.subList = function subList_1(fromIndex, toIndex){
  return this.subList_0(fromIndex, toIndex);
}
;
_.add_2 = function add_9(index_0, element){
  throw new UnsupportedOperationException;
}
;
_.equals = function equals_16(obj){
  return equalsImpl(this, obj);
}
;
_.hashCode_0 = function hashCode_15(){
  return hashCodeImpl(this);
}
;
_.iterator_1 = function iterator_12(){
  return this.listIterator_2(0);
}
;
_.listIterator_2 = function listIterator_2(index_0){
  return $listIterator(this, index_0);
}
;
_.remove_2 = function remove_19(index_0){
  throw new UnsupportedOperationException;
}
;
_.set_2 = function set_4(index_0, element){
  throw new UnsupportedOperationException;
}
;
_.subList_0 = function subList_0(fromIndex, toIndex){
  var wrapper;
  return unsafeDelegateList((wrapper = new Lists$1(this) , new AbstractList$SubList(wrapper, fromIndex, toIndex)));
}
;
var EMPTY;
var Lcom_google_common_collect_ImmutableList_2_classLit = createForClass('com.google.common.collect', 'ImmutableList', 89);
function $contains_0(this$static, object){
  return object != null && this$static.delegateList_0().contains(object);
}

function $get_1(this$static, index_0){
  return this$static.delegateList_0().get_2(index_0);
}

defineClass(666, 89, $intern_32);
_.iterator_0 = function iterator_15(){
  return unmodifiableIterator(this.delegateList_0().iterator_0());
}
;
_.subList = function subList_3(fromIndex, toIndex){
  return unsafeDelegateList(this.delegateList_0().subList(fromIndex, toIndex));
}
;
_.contains = function contains_10(object){
  return $contains_0(this, object);
}
;
_.containsAll = function containsAll_4(targets){
  return this.delegateList_0().containsAll(targets);
}
;
_.equals = function equals_17(obj){
  return this.delegateList_0().equals(obj);
}
;
_.get_2 = function get_6(index_0){
  return $get_1(this, index_0);
}
;
_.hashCode_0 = function hashCode_16(){
  return this.delegateList_0().hashCode_0();
}
;
_.isEmpty = function isEmpty_7(){
  return this.delegateList_0().isEmpty();
}
;
_.iterator_1 = function iterator_14(){
  return unmodifiableIterator(this.delegateList_0().iterator_0());
}
;
_.size_1 = function size_12(){
  return this.delegateList_0().size_1();
}
;
_.subList_0 = function subList_2(fromIndex, toIndex){
  return unsafeDelegateList(this.delegateList_0().subList(fromIndex, toIndex));
}
;
_.toArray = function toArray_5(){
  return this.delegateList_0().toArray_0(initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, this.delegateList_0().size_1(), 4, 1));
}
;
_.toArray_0 = function toArray_6(other){
  return this.delegateList_0().toArray_0(other);
}
;
_.toString_0 = function toString_23(){
  return toString__Ljava_lang_String___devirtual$(this.delegateList_0());
}
;
var Lcom_google_common_collect_ForwardingImmutableList_2_classLit = createForClass('com.google.common.collect', 'ForwardingImmutableList', 666);
function $entrySet_1(this$static){
  if (this$static.cachedEntrySet) {
    return this$static.cachedEntrySet;
  }
  return this$static.cachedEntrySet = this$static.createEntrySet_1();
}

function $keySet_0(this$static){
  if (this$static.cachedKeySet) {
    return this$static.cachedKeySet;
  }
  return this$static.cachedKeySet = this$static.createKeySet_0();
}

function $put_0(){
  throw new UnsupportedOperationException;
}

function copyOf_0(map_0){
  var e, e$iterator, entry, orderPreservingCopy, size_0;
  size_0 = map_0.hashCodeMap.size_0 + map_0.stringMap.size_0;
  switch (size_0) {
    case 0:
      return $clinit_RegularImmutableBiMap() , EMPTY_0;
    case 1:
      entry = castTo(getOnlyElement(new AbstractHashMap$EntrySetIterator((new AbstractHashMap$EntrySet(map_0)).this$01)), 21);
      return of(entry.getKey(), entry.getValue());
    default:orderPreservingCopy = ($clinit_Maps() , new LinkedHashMap);
      for (e$iterator = new AbstractHashMap$EntrySetIterator((new AbstractHashMap$EntrySet(map_0)).this$01); e$iterator.hasNext;) {
        e = $next_6(e$iterator);
        $put_7(orderPreservingCopy, checkNotNull(e.getKey()), checkNotNull(e.getValue()));
      }

      return new RegularImmutableMap(orderPreservingCopy);
  }
}

function of(k1, v1){
  return checkEntryNotNull(k1, v1) , new SingletonImmutableBiMap(k1, v1);
}

defineClass(524, 1, $intern_33);
_.entrySet_0 = function entrySet_1(){
  return $entrySet_1(this);
}
;
_.keySet_0 = function keySet_3(){
  return $keySet_0(this);
}
;
_.values_0 = function values_5(){
  return this.values_1();
}
;
_.clear_0 = function clear_13(){
  throw new UnsupportedOperationException;
}
;
_.containsKey = function containsKey_2(key){
  return this.get_1(key) != null;
}
;
_.containsValue = function containsValue_0(value_0){
  return this.values_1().contains(value_0);
}
;
_.createKeySet_0 = function createKeySet_1(){
  return new ImmutableMapKeySet(this);
}
;
_.createValues = function createValues(){
  return new ImmutableMapValues(this);
}
;
_.equals = function equals_18(object){
  return equalsImpl_0(this, object);
}
;
_.hashCode_0 = function hashCode_17(){
  return $entrySet_1(this).hashCode_0();
}
;
_.isEmpty = function isEmpty_8(){
  return this.size_1() == 0;
}
;
_.put = function put_0(k, v){
  return $put_0();
}
;
_.remove_0 = function remove_20(o){
  throw new UnsupportedOperationException;
}
;
_.toString_0 = function toString_24(){
  var sb;
  return $clinit_Maps() , sb = $append(newStringBuilderForCollection(this.size_1()), 123) , $appendTo_2(STANDARD_JOINER_0, sb, $entrySet_1(this).iterator_0()) , sb.string += '}' , sb.string;
}
;
_.values_1 = function values_4(){
  if (this.cachedValues) {
    return this.cachedValues;
  }
  return this.cachedValues = this.createValues();
}
;
_.cachedEntrySet = null;
_.cachedKeySet = null;
_.cachedValues = null;
var Lcom_google_common_collect_ImmutableMap_2_classLit = createForClass('com.google.common.collect', 'ImmutableMap', 524);
function ForwardingImmutableMap(delegate){
  this.delegate = ($clinit_Collections() , new Collections$UnmodifiableMap(delegate));
}

defineClass(320, 524, $intern_33);
_.containsKey = function containsKey_3(key){
  return safeContainsKey(this.delegate, key);
}
;
_.containsValue = function containsValue_1(value_0){
  return $containsValue_1(this.delegate, value_0);
}
;
_.createEntrySet_1 = function createEntrySet_1(){
  return unsafeDelegate(new ForwardingImmutableMap$1(this));
}
;
_.createKeySet_0 = function createKeySet_2(){
  return unsafeDelegate($keySet_1(this.delegate));
}
;
_.createValues = function createValues_0(){
  return $clinit_ImmutableCollection() , new ForwardingImmutableCollection($values_1(this.delegate));
}
;
_.equals = function equals_19(object){
  return $equals_6(this.delegate, object);
}
;
_.get_1 = function get_7(key){
  return key == null?null:safeGet(this.delegate, key);
}
;
_.hashCode_0 = function hashCode_18(){
  return this.delegate.map_0.hashCode_0();
}
;
_.isEmpty = function isEmpty_9(){
  return this.delegate.map_0.isEmpty();
}
;
_.size_1 = function size_13(){
  return this.delegate.map_0.size_1();
}
;
_.toString_0 = function toString_25(){
  return toString__Ljava_lang_String___devirtual$(this.delegate.map_0);
}
;
var Lcom_google_common_collect_ForwardingImmutableMap_2_classLit = createForClass('com.google.common.collect', 'ForwardingImmutableMap', 320);
defineClass(665, 664, $intern_21);
_.equals = function equals_20(object){
  return object === this || $equals_7($entrySet_2(this.this$01.delegate), object);
}
;
_.hashCode_0 = function hashCode_19(){
  return $entrySet_2(this.this$01.delegate).coll.hashCode_0();
}
;
var Lcom_google_common_collect_ForwardingSet_2_classLit = createForClass('com.google.common.collect', 'ForwardingSet', 665);
function ForwardingImmutableMap$1(this$0){
  this.this$01 = this$0;
}

defineClass(523, 665, $intern_21, ForwardingImmutableMap$1);
_.contains = function contains_11(object){
  if (instanceOf(object, 21) && castTo(object, 21).getKey() == null) {
    return false;
  }
  try {
    return $contains_4($entrySet_2(this.this$01.delegate), object);
  }
   catch ($e0) {
    $e0 = wrap($e0);
    if (instanceOf($e0, 119)) {
      return false;
    }
     else 
      throw unwrap_5($e0);
  }
}
;
_.toArray_0 = function toArray_7(array){
  var result;
  result = $toArray_5($entrySet_2(this.this$01.delegate), array);
  $entrySet_2(this.this$01.delegate).coll.size_1() < result.length && setCheck(result, $entrySet_2(this.this$01.delegate).coll.size_1(), null);
  return result;
}
;
var Lcom_google_common_collect_ForwardingImmutableMap$1_2_classLit = createForClass('com.google.common.collect', 'ForwardingImmutableMap/1', 523);
function copyOf_1(elements){
  $clinit_ImmutableCollection();
  var delegate, first;
  if (!elements.hasNext_0()) {
    return $clinit_RegularImmutableSet() , EMPTY_1;
  }
  first = elements.next_1();
  if (!elements.hasNext_0()) {
    return new SingletonImmutableSet(first);
  }
  delegate = new LinkedHashSet;
  $add_18(delegate, checkNotNull(first));
  do {
    $add_18(delegate, checkNotNull(elements.next_1()));
  }
   while (elements.hasNext_0());
  return unsafeDelegate(delegate);
}

function create(elements){
  $clinit_ImmutableCollection();
  var element, element$iterator, entry, outerIter, outerIter0, set_0;
  set_0 = new LinkedHashSet;
  addAll_8(set_0, elements);
  for (element$iterator = (outerIter0 = (new AbstractMap$1(set_0.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter0)); element$iterator.val$outerIter2.hasNext_0();) {
    element = (entry = castTo(element$iterator.val$outerIter2.next_1(), 21) , entry.getKey());
    checkNotNull(element);
  }
  switch (set_0.map_0.size_1()) {
    case 0:
      return $clinit_RegularImmutableSet() , EMPTY_1;
    case 1:
      return new SingletonImmutableSet((outerIter = (new AbstractMap$1(set_0.map_0)).this$01.entrySet_0().iterator_0() , entry = castTo((new AbstractMap$1$1(outerIter)).val$outerIter2.next_1(), 21) , entry.getKey()));
    default:return new RegularImmutableSet(set_0);
  }
}

function of_0(e1, e2, e3, e4, e5, e6, others){
  $clinit_ImmutableCollection();
  var all, size_0;
  size_0 = others.length + 6;
  all = new ArrayList_0(size_0);
  addAll_8(all, stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [e1, e2, e3, e4, e5, e6]));
  addAll_8(all, others);
  return copyOf_1(new ArrayList$1(all));
}

function unsafeDelegate(delegate){
  $clinit_ImmutableCollection();
  switch (delegate.size_1()) {
    case 0:
      return $clinit_RegularImmutableSet() , EMPTY_1;
    case 1:
      return new SingletonImmutableSet(delegate.iterator_0().next_1());
    default:return new RegularImmutableSet(delegate);
  }
}

defineClass(662, 659, $intern_34);
_.iterator_0 = function iterator_16(){
  return this.iterator_1();
}
;
_.equals = function equals_21(obj){
  return equalsImpl_3(this, obj);
}
;
_.hashCode_0 = function hashCode_20(){
  return hashCodeImpl_0(this);
}
;
var Lcom_google_common_collect_ImmutableSet_2_classLit = createForClass('com.google.common.collect', 'ImmutableSet', 662);
function ForwardingImmutableSet(delegate){
  $clinit_ImmutableCollection();
  this.delegate = ($clinit_Collections() , new Collections$UnmodifiableSet(delegate));
}

defineClass(315, 662, $intern_34);
_.iterator_0 = function iterator_18(){
  return unmodifiableIterator(new Collections$UnmodifiableCollectionIterator(this.delegate.coll.iterator_0()));
}
;
_.contains = function contains_12(object){
  return object != null && $contains_3(this.delegate, object);
}
;
_.containsAll = function containsAll_5(targets){
  return $containsAll_0(this.delegate, targets);
}
;
_.hashCode_0 = function hashCode_21(){
  return this.delegate.coll.hashCode_0();
}
;
_.isEmpty = function isEmpty_10(){
  return this.delegate.coll.isEmpty();
}
;
_.iterator_1 = function iterator_17(){
  return unmodifiableIterator(new Collections$UnmodifiableCollectionIterator(this.delegate.coll.iterator_0()));
}
;
_.size_1 = function size_14(){
  return this.delegate.coll.size_1();
}
;
_.toArray = function toArray_8(){
  return this.delegate.coll.toArray();
}
;
_.toArray_0 = function toArray_9(other){
  return $toArray_3(this.delegate, other);
}
;
_.toString_0 = function toString_26(){
  return toString__Ljava_lang_String___devirtual$(this.delegate.coll);
}
;
var Lcom_google_common_collect_ForwardingImmutableSet_2_classLit = createForClass('com.google.common.collect', 'ForwardingImmutableSet', 315);
function $contains_1(this$static, t){
  return !$tooLow(this$static, t) && !$tooHigh(this$static, t);
}

function $intersect(this$static, other){
  var cmp, hasLowBound, hasUpBound, lowEnd, lowType, upEnd, upType;
  checkNotNull(other);
  checkArgument(this$static.comparator.equals(other.comparator));
  hasLowBound = this$static.hasLowerBound;
  lowEnd = this$static.lowerEndpoint;
  lowType = this$static.lowerBoundType;
  if (this$static.hasLowerBound) {
    if (other.hasLowerBound) {
      cmp = this$static.comparator.compare_0(this$static.lowerEndpoint, other.lowerEndpoint);
      if (cmp < 0 || cmp == 0 && other.lowerBoundType == ($clinit_BoundType() , OPEN)) {
        lowEnd = other.lowerEndpoint;
        lowType = other.lowerBoundType;
      }
    }
  }
   else {
    hasLowBound = other.hasLowerBound;
    lowEnd = other.lowerEndpoint;
    lowType = other.lowerBoundType;
  }
  hasUpBound = this$static.hasUpperBound;
  upEnd = this$static.upperEndpoint;
  upType = this$static.upperBoundType;
  if (this$static.hasUpperBound) {
    if (other.hasUpperBound) {
      cmp = this$static.comparator.compare_0(this$static.upperEndpoint, other.upperEndpoint);
      if (cmp > 0 || cmp == 0 && other.upperBoundType == ($clinit_BoundType() , OPEN)) {
        upEnd = other.upperEndpoint;
        upType = other.upperBoundType;
      }
    }
  }
   else {
    hasUpBound = other.hasUpperBound;
    upEnd = other.upperEndpoint;
    upType = other.upperBoundType;
  }
  if (hasLowBound && hasUpBound) {
    cmp = this$static.comparator.compare_0(lowEnd, upEnd);
    if (cmp > 0 || cmp == 0 && lowType == ($clinit_BoundType() , OPEN) && upType == ($clinit_BoundType() , OPEN)) {
      lowEnd = upEnd;
      lowType = ($clinit_BoundType() , OPEN);
      upType = CLOSED;
    }
  }
  return new GeneralRange(this$static.comparator, hasLowBound, lowEnd, lowType, hasUpBound, upEnd, upType);
}

function $tooHigh(this$static, t){
  var cmp, ubound;
  if (!this$static.hasUpperBound) {
    return false;
  }
  ubound = this$static.upperEndpoint;
  cmp = this$static.comparator.compare_0(t, ubound);
  return cmp > 0 | cmp == 0 & this$static.upperBoundType == ($clinit_BoundType() , OPEN);
}

function $tooLow(this$static, t){
  var cmp, lbound;
  if (!this$static.hasLowerBound) {
    return false;
  }
  lbound = this$static.lowerEndpoint;
  cmp = this$static.comparator.compare_0(t, lbound);
  return cmp < 0 | cmp == 0 & this$static.lowerBoundType == ($clinit_BoundType() , OPEN);
}

function GeneralRange(comparator, hasLowerBound, lowerEndpoint, lowerBoundType, hasUpperBound, upperEndpoint, upperBoundType){
  var cmp;
  this.comparator = castTo(checkNotNull(comparator), 56);
  this.hasLowerBound = hasLowerBound;
  this.hasUpperBound = hasUpperBound;
  this.lowerEndpoint = lowerEndpoint;
  this.lowerBoundType = castTo(checkNotNull(lowerBoundType), 159);
  this.upperEndpoint = upperEndpoint;
  this.upperBoundType = castTo(checkNotNull(upperBoundType), 159);
  hasLowerBound && comparator.compare_0(lowerEndpoint, lowerEndpoint);
  hasUpperBound && comparator.compare_0(upperEndpoint, upperEndpoint);
  if (hasLowerBound && hasUpperBound) {
    cmp = comparator.compare_0(lowerEndpoint, upperEndpoint);
    checkArgument_1(cmp <= 0, lowerEndpoint, upperEndpoint);
    cmp == 0 && checkArgument(lowerBoundType != ($clinit_BoundType() , OPEN) | upperBoundType != OPEN);
  }
}

function upTo(comparator, endpoint, boundType){
  return new GeneralRange(comparator, false, null, ($clinit_BoundType() , OPEN), true, endpoint, boundType);
}

defineClass(178, 1, {178:1, 3:1}, GeneralRange);
_.equals = function equals_22(obj){
  var r;
  if (instanceOf(obj, 178)) {
    r = castTo(obj, 178);
    return this.comparator.equals(r.comparator) && this.hasLowerBound == r.hasLowerBound && this.hasUpperBound == r.hasUpperBound && this.lowerBoundType == r.lowerBoundType && this.upperBoundType == r.upperBoundType && equal(this.lowerEndpoint, r.lowerEndpoint) && equal(this.upperEndpoint, r.upperEndpoint);
  }
  return false;
}
;
_.hashCode_0 = function hashCode_22(){
  return hashCode_44(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [this.comparator, this.lowerEndpoint, this.lowerBoundType, this.upperEndpoint, this.upperBoundType]));
}
;
_.toString_0 = function toString_27(){
  return this.comparator + ':' + charToString(this.lowerBoundType == ($clinit_BoundType() , CLOSED)?91:40) + (this.hasLowerBound?this.lowerEndpoint:'-\u221E') + ',' + (this.hasUpperBound?this.upperEndpoint:'\u221E') + charToString(this.upperBoundType == CLOSED?93:41);
}
;
_.hasLowerBound = false;
_.hasUpperBound = false;
var Lcom_google_common_collect_GeneralRange_2_classLit = createForClass('com.google.common.collect', 'GeneralRange', 178);
function HashMultimap(){
  AbstractSetMultimap.call(this, new HashMap);
}

defineClass(215, 384, $intern_17, HashMultimap);
_.expectedValuesPerKey = 2;
var Lcom_google_common_collect_HashMultimap_2_classLit = createForClass('com.google.common.collect', 'HashMultimap', 215);
defineClass(660, 89, $intern_32);
_.contains = function contains_13(target){
  return this.delegateCollection().contains(target);
}
;
_.isEmpty = function isEmpty_11(){
  return this.delegateCollection().isEmpty();
}
;
_.size_1 = function size_15(){
  return this.delegateCollection().size_1();
}
;
var Lcom_google_common_collect_ImmutableAsList_2_classLit = createForClass('com.google.common.collect', 'ImmutableAsList', 660);
function ImmutableBiMap(delegate){
  ForwardingImmutableMap.call(this, delegate);
}

defineClass(275, 320, $intern_33);
_.values_1 = function values_6(){
  return this.values_2();
}
;
_.values_0 = function values_8(){
  return this.values_2();
}
;
_.values_2 = function values_7(){
  return $keySet_0(this.inverse_0());
}
;
var Lcom_google_common_collect_ImmutableBiMap_2_classLit = createForClass('com.google.common.collect', 'ImmutableBiMap', 275);
function ImmutableEntry(key, value_0){
  this.key = key;
  this.value_0 = value_0;
}

defineClass(341, 667, {3:1, 21:1}, ImmutableEntry);
_.getKey = function getKey(){
  return this.key;
}
;
_.getValue = function getValue(){
  return this.value_0;
}
;
_.setValue = function setValue_0(value_0){
  throw new UnsupportedOperationException;
}
;
var Lcom_google_common_collect_ImmutableEntry_2_classLit = createForClass('com.google.common.collect', 'ImmutableEntry', 341);
function ImmutableEnumSet(delegate){
  ForwardingImmutableSet.call(this, delegate);
}

function asImmutable(delegate){
  $clinit_ImmutableCollection();
  switch (delegate.size_0) {
    case 0:
      return $clinit_RegularImmutableSet() , EMPTY_1;
    case 1:
      return new SingletonImmutableSet(getOnlyElement(new EnumSet$EnumSetImpl$IteratorImpl(delegate)));
    default:return new ImmutableEnumSet(delegate);
  }
}

defineClass(436, 315, $intern_34, ImmutableEnumSet);
var Lcom_google_common_collect_ImmutableEnumSet_2_classLit = createForClass('com.google.common.collect', 'ImmutableEnumSet', 436);
function $get_2(this$static, index_0){
  return this$static.this$01.get_2(index_0);
}

function ImmutableList$1(this$0, $anonymous0, $anonymous1){
  this.this$01 = this$0;
  checkPositionIndex($anonymous1, $anonymous0);
  this.size_0 = $anonymous0;
  this.position = $anonymous1;
}

defineClass(379, 378, $intern_16, ImmutableList$1);
var Lcom_google_common_collect_ImmutableList$1_2_classLit = createForClass('com.google.common.collect', 'ImmutableList/1', 379);
function ImmutableMap$1(val$entryIterator){
  this.val$entryIterator2 = val$entryIterator;
}

defineClass(266, 108, $intern_15, ImmutableMap$1);
_.hasNext_0 = function hasNext_5(){
  return this.val$entryIterator2.hasNext_0();
}
;
_.next_1 = function next_6(){
  return castTo(this.val$entryIterator2.next_1(), 21).getKey();
}
;
var Lcom_google_common_collect_ImmutableMap$1_2_classLit = createForClass('com.google.common.collect', 'ImmutableMap/1', 266);
defineClass(669, 662, $intern_34);
_.iterator_0 = function iterator_20(){
  var entryIterator;
  return entryIterator = $entrySet_1(this.map_0).iterator_1() , new ImmutableMap$1(entryIterator);
}
;
_.createAsList = function createAsList_0(){
  return new ImmutableSet$Indexed$1(this);
}
;
_.iterator_1 = function iterator_19(){
  var list;
  return (list = this.asList , !list?(this.asList = new ImmutableSet$Indexed$1(this)):list).iterator_1();
}
;
var Lcom_google_common_collect_ImmutableSet$Indexed_2_classLit = createForClass('com.google.common.collect', 'ImmutableSet/Indexed', 669);
function $get_3(this$static, index_0){
  return castTo($asList($entrySet_1(this$static.map_0)).get_2(index_0), 21).getKey();
}

function ImmutableMapKeySet(map_0){
  $clinit_ImmutableCollection();
  this.map_0 = map_0;
}

defineClass(605, 669, $intern_34, ImmutableMapKeySet);
_.iterator_0 = function iterator_22(){
  var entryIterator;
  return entryIterator = $entrySet_1(this.map_0).iterator_1() , new ImmutableMap$1(entryIterator);
}
;
_.contains = function contains_14(object){
  return this.map_0.containsKey(object);
}
;
_.iterator_1 = function iterator_21(){
  var entryIterator;
  return entryIterator = $entrySet_1(this.map_0).iterator_1() , new ImmutableMap$1(entryIterator);
}
;
_.size_1 = function size_16(){
  return this.map_0.size_1();
}
;
var Lcom_google_common_collect_ImmutableMapKeySet_2_classLit = createForClass('com.google.common.collect', 'ImmutableMapKeySet', 605);
function ImmutableMapValues(map_0){
  $clinit_ImmutableCollection();
  this.map_0 = map_0;
}

defineClass(604, 659, $intern_31, ImmutableMapValues);
_.iterator_0 = function iterator_24(){
  return new ImmutableMapValues$1(this);
}
;
_.contains = function contains_15(object){
  return object != null && ($clinit_Iterators() , $clinit_Iterators() , indexOf(new ImmutableMapValues$1(this), ($clinit_Predicates() , object == null?($clinit_Predicates$ObjectPredicate() , IS_NULL):new Predicates$IsEqualToPredicate(object))) != -1);
}
;
_.iterator_1 = function iterator_23(){
  return new ImmutableMapValues$1(this);
}
;
_.size_1 = function size_17(){
  return this.map_0.size_1();
}
;
var Lcom_google_common_collect_ImmutableMapValues_2_classLit = createForClass('com.google.common.collect', 'ImmutableMapValues', 604);
function ImmutableMapValues$1(this$0){
  this.this$01 = this$0;
  this.entryItr = $entrySet_1(this.this$01.map_0).iterator_1();
}

defineClass(282, 108, $intern_15, ImmutableMapValues$1);
_.hasNext_0 = function hasNext_6(){
  return this.entryItr.hasNext_0();
}
;
_.next_1 = function next_7(){
  return castTo(this.entryItr.next_1(), 21).getValue();
}
;
var Lcom_google_common_collect_ImmutableMapValues$1_2_classLit = createForClass('com.google.common.collect', 'ImmutableMapValues/1', 282);
function ImmutableSet$Indexed$1(this$1){
  $clinit_ImmutableList();
  this.this$11 = this$1;
}

defineClass(311, 660, $intern_32, ImmutableSet$Indexed$1);
_.delegateCollection = function delegateCollection(){
  return this.this$11;
}
;
_.get_2 = function get_8(index_0){
  return $get_3(this.this$11, index_0);
}
;
var Lcom_google_common_collect_ImmutableSet$Indexed$1_2_classLit = createForClass('com.google.common.collect', 'ImmutableSet/Indexed/1', 311);
function addAll_4(addTo, elementsToAdd){
  var c;
  if (instanceOf(elementsToAdd, 19)) {
    c = ($clinit_Collections2() , castTo(elementsToAdd, 19));
    return addTo.addAll(c);
  }
  return addAll_5(addTo, castTo(checkNotNull(elementsToAdd), 22).iterator_0());
}

function all_0(iterable, predicate){
  return all_1(iterable.iterator_0(), predicate);
}

function any(iterable, predicate){
  return $clinit_Iterators() , indexOf(new ArrayList$1(iterable), predicate) != -1;
}

function filter_0(unfiltered, retainIfTrue){
  checkNotNull(unfiltered);
  checkNotNull(retainIfTrue);
  return new Iterables$4(unfiltered, retainIfTrue);
}

function get_9(iterable){
  checkNotNull(iterable);
  return get_10(($clinit_Iterators() , new Iterators$ConcatenatedIterator($iterator_1(transform_1(iterable.val$inputs1, new Iterables$12)))));
}

function getLast(iterable){
  if (iterable) {
    if (iterable.isEmpty()) {
      throw new NoSuchElementException;
    }
    return iterable.get_2(iterable.size_1() - 1);
  }
  return getLast_0(null.iterator_0());
}

function isEmpty_12(iterable){
  if (instanceOf(iterable, 19)) {
    return castTo(iterable, 19).isEmpty();
  }
  return !iterable.iterator_0().hasNext_0();
}

function size_18(iterable){
  return instanceOf(iterable, 19)?castTo(iterable, 19).size_1():size_19(iterable.iterator_0());
}

function transform_1(fromIterable, function_0){
  checkNotNull(fromIterable);
  checkNotNull(function_0);
  return new Iterables$5(fromIterable, function_0);
}

function Iterables$1(val$iterable){
  this.val$iterable1 = val$iterable;
  FluentIterable.call(this);
}

defineClass(414, 234, $intern_30, Iterables$1);
_.iterator_0 = function iterator_25(){
  return cycle(this.val$iterable1);
}
;
_.toString_0 = function toString_28(){
  return $toString_5(this.val$iterable1) + ' (cycled)';
}
;
var Lcom_google_common_collect_Iterables$1_2_classLit = createForClass('com.google.common.collect', 'Iterables/1', 414);
function Iterables$12(){
}

defineClass(105, 1, $intern_35, Iterables$12);
_.apply_0 = function apply_8(iterable){
  return castTo(iterable, 22).iterator_0();
}
;
var Lcom_google_common_collect_Iterables$12_2_classLit = createForClass('com.google.common.collect', 'Iterables/12', 105);
function $iterator_0(this$static){
  return filter_1(this$static.val$unfiltered1.iterator_0(), this$static.val$retainIfTrue2);
}

function Iterables$4(val$unfiltered, val$retainIfTrue){
  this.val$unfiltered1 = val$unfiltered;
  this.val$retainIfTrue2 = val$retainIfTrue;
  FluentIterable.call(this);
}

defineClass(415, 234, $intern_30, Iterables$4);
_.iterator_0 = function iterator_26(){
  return $iterator_0(this);
}
;
var Lcom_google_common_collect_Iterables$4_2_classLit = createForClass('com.google.common.collect', 'Iterables/4', 415);
function $iterator_1(this$static){
  return transform_2(this$static.val$fromIterable1.iterator_0(), this$static.val$function2);
}

function Iterables$5(val$fromIterable, val$function){
  this.val$fromIterable1 = val$fromIterable;
  this.val$function2 = val$function;
  FluentIterable.call(this);
}

defineClass(416, 234, $intern_30, Iterables$5);
_.iterator_0 = function iterator_27(){
  return $iterator_1(this);
}
;
var Lcom_google_common_collect_Iterables$5_2_classLit = createForClass('com.google.common.collect', 'Iterables/5', 416);
function $clinit_Iterators(){
  $clinit_Iterators = emptyMethod;
  EMPTY_LIST_ITERATOR = new Iterators$1;
  EMPTY_MODIFIABLE_ITERATOR = new Iterators$2;
}

function addAll_5(addTo, iterator){
  $clinit_Iterators();
  var wasModified;
  checkNotNull(addTo);
  checkNotNull(iterator);
  wasModified = false;
  while (iterator.hasNext_0()) {
    wasModified = wasModified | addTo.add_1(iterator.next_1());
  }
  return wasModified;
}

function advance(iterator){
  var i;
  checkNotNull(iterator);
  checkArgument_0(true);
  for (i = 0; i < 0 && $hasNext_0(iterator); i++) {
    $next_2(iterator);
  }
  return i;
}

function all_1(iterator, predicate){
  $clinit_Iterators();
  var element;
  checkNotNull(predicate);
  while (iterator.hasNext_0()) {
    element = iterator.next_1();
    if (!$apply_10(castTo(element, 9))) {
      return false;
    }
  }
  return true;
}

function clear_14(iterator){
  $clinit_Iterators();
  checkNotNull(iterator);
  while (iterator.hasNext_0()) {
    iterator.next_1();
    iterator.remove();
  }
}

function cycle(iterable){
  $clinit_Iterators();
  checkNotNull(iterable);
  return new Iterators$4(iterable);
}

function elementsEqual(iterator1, iterator2){
  $clinit_Iterators();
  var o1, o2;
  while (iterator1.hasNext_0()) {
    if (!iterator2.hasNext_0()) {
      return false;
    }
    o1 = iterator1.next_1();
    o2 = iterator2.next_1();
    if (!(maskUndefined(o1) === maskUndefined(o2) || o1 != null && equals_Ljava_lang_Object__Z__devirtual$(o1, o2))) {
      return false;
    }
  }
  return !iterator2.hasNext_0();
}

function filter_1(unfiltered, retainIfTrue){
  $clinit_Iterators();
  checkNotNull(unfiltered);
  checkNotNull(retainIfTrue);
  return new Iterators$6(unfiltered, retainIfTrue);
}

function get_10(iterator){
  $clinit_Iterators();
  var skipped;
  skipped = advance(iterator);
  if (!$hasNext_0(iterator)) {
    throw new IndexOutOfBoundsException_0('position (0) must be less than the number of elements that remained (' + skipped + ')');
  }
  return $next_2(iterator);
}

function getLast_0(iterator){
  $clinit_Iterators();
  var current;
  while (true) {
    current = iterator.next_1();
    if (!iterator.hasNext_0()) {
      return current;
    }
  }
}

function getOnlyElement(iterator){
  $clinit_Iterators();
  var first, i, sb;
  first = iterator.next_1();
  if (!iterator.hasNext_0()) {
    return first;
  }
  sb = $append_2($append_3(new StringBuilder, 'expected one element but was: <'), first);
  for (i = 0; i < 4 && iterator.hasNext_0(); i++) {
    $append_2((sb.string += ', ' , sb), iterator.next_1());
  }
  iterator.hasNext_0() && (sb.string += ', ...' , sb);
  sb.string += '>';
  throw new IllegalArgumentException_0(sb.string);
}

function indexOf(iterator, predicate){
  $clinit_Iterators();
  var current, i;
  checkNotNull_0(predicate, 'predicate');
  for (i = 0; iterator.hasNext_0(); i++) {
    current = iterator.next_1();
    if (predicate.apply_1(current)) {
      return i;
    }
  }
  return -1;
}

function size_19(iterator){
  $clinit_Iterators();
  var count;
  count = 0;
  while (iterator.hasNext_0()) {
    iterator.next_1();
    count = add_20(count, 1);
  }
  return saturatedCast(count);
}

function toString_29(iterator){
  $clinit_Iterators();
  return $append($appendTo_0(($clinit_Collections2() , STANDARD_JOINER), $append(new StringBuilder, 91), iterator), 93).string;
}

function transform_2(fromIterator, function_0){
  $clinit_Iterators();
  checkNotNull(function_0);
  return new Iterators$7(fromIterator, function_0);
}

function unmodifiableIterator(iterator){
  $clinit_Iterators();
  var result;
  checkNotNull(iterator);
  if (instanceOf(iterator, 108)) {
    result = castTo(iterator, 108);
    return result;
  }
  return new Iterators$3(iterator);
}

var EMPTY_LIST_ITERATOR, EMPTY_MODIFIABLE_ITERATOR;
function Iterators$1(){
}

defineClass(424, 650, $intern_16, Iterators$1);
_.hasNext_0 = function hasNext_7(){
  return false;
}
;
_.hasPrevious = function hasPrevious_1(){
  return false;
}
;
_.next_1 = function next_8(){
  throw new NoSuchElementException;
}
;
_.nextIndex_0 = function nextIndex_2(){
  return 0;
}
;
_.previous_0 = function previous_2(){
  throw new NoSuchElementException;
}
;
_.previousIndex = function previousIndex_1(){
  return -1;
}
;
var Lcom_google_common_collect_Iterators$1_2_classLit = createForClass('com.google.common.collect', 'Iterators/1', 424);
function Iterators$11(val$value){
  this.val$value1 = val$value;
}

defineClass(264, 108, $intern_15, Iterators$11);
_.hasNext_0 = function hasNext_8(){
  return !this.done_0;
}
;
_.next_1 = function next_9(){
  if (this.done_0) {
    throw new NoSuchElementException;
  }
  this.done_0 = true;
  return this.val$value1;
}
;
_.done_0 = false;
var Lcom_google_common_collect_Iterators$11_2_classLit = createForClass('com.google.common.collect', 'Iterators/11', 264);
function Iterators$2(){
}

defineClass(425, 1, $intern_18, Iterators$2);
_.hasNext_0 = function hasNext_9(){
  return false;
}
;
_.next_1 = function next_10(){
  throw new NoSuchElementException;
}
;
_.remove = function remove_21(){
  checkState_0(false);
}
;
var Lcom_google_common_collect_Iterators$2_2_classLit = createForClass('com.google.common.collect', 'Iterators/2', 425);
function Iterators$3(val$iterator){
  this.val$iterator1 = val$iterator;
}

defineClass(426, 108, $intern_15, Iterators$3);
_.hasNext_0 = function hasNext_10(){
  return this.val$iterator1.hasNext_0();
}
;
_.next_1 = function next_11(){
  return this.val$iterator1.next_1();
}
;
var Lcom_google_common_collect_Iterators$3_2_classLit = createForClass('com.google.common.collect', 'Iterators/3', 426);
function $next_0(this$static){
  if (!this$static.iterator.hasNext_0()) {
    this$static.iterator = this$static.val$iterable1.iterator_0();
    if (!this$static.iterator.hasNext_0()) {
      throw new NoSuchElementException;
    }
  }
  return this$static.iterator.next_1();
}

function Iterators$4(val$iterable){
  this.val$iterable1 = val$iterable;
  this.iterator = ($clinit_Iterators() , $clinit_Iterators() , EMPTY_MODIFIABLE_ITERATOR);
}

defineClass(427, 1, $intern_18, Iterators$4);
_.hasNext_0 = function hasNext_11(){
  return this.iterator.hasNext_0() || this.val$iterable1.iterator_0().hasNext_0();
}
;
_.next_1 = function next_12(){
  return $next_0(this);
}
;
_.remove = function remove_22(){
  this.iterator.remove();
}
;
var Lcom_google_common_collect_Iterators$4_2_classLit = createForClass('com.google.common.collect', 'Iterators/4', 427);
function $computeNext(this$static){
  var element;
  while (this$static.val$unfiltered1.hasNext_0()) {
    element = this$static.val$unfiltered1.next_1();
    if (this$static.val$retainIfTrue2.apply_1(element)) {
      return element;
    }
  }
  return this$static.state = 2 , null;
}

function Iterators$6(val$unfiltered, val$retainIfTrue){
  this.val$unfiltered1 = val$unfiltered;
  this.val$retainIfTrue2 = val$retainIfTrue;
}

defineClass(429, 428, $intern_15, Iterators$6);
var Lcom_google_common_collect_Iterators$6_2_classLit = createForClass('com.google.common.collect', 'Iterators/6', 429);
function $next_1(this$static){
  return this$static.transform_0(this$static.backingIterator.next_1());
}

function TransformedIterator(backingIterator){
  this.backingIterator = castTo(checkNotNull(backingIterator), 35);
}

defineClass(261, 1, $intern_18);
_.hasNext_0 = function hasNext_12(){
  return this.backingIterator.hasNext_0();
}
;
_.next_1 = function next_13(){
  return $next_1(this);
}
;
_.remove = function remove_23(){
  this.backingIterator.remove();
}
;
var Lcom_google_common_collect_TransformedIterator_2_classLit = createForClass('com.google.common.collect', 'TransformedIterator', 261);
function $transform(this$static, from){
  return this$static.val$function2.apply_0(from);
}

function Iterators$7($anonymous0, val$function){
  this.val$function2 = val$function;
  TransformedIterator.call(this, $anonymous0);
}

defineClass(430, 261, $intern_18, Iterators$7);
_.transform_0 = function transform_3(from){
  return $transform(this, from);
}
;
var Lcom_google_common_collect_Iterators$7_2_classLit = createForClass('com.google.common.collect', 'Iterators/7', 430);
function $hasNext_0(this$static){
  checkNotNull(this$static.current);
  if (this$static.current.hasNext_0()) {
    return true;
  }
  while (this$static.backingIterator.hasNext_0()) {
    checkNotNull(this$static.current = this$static.transform_1(this$static.backingIterator.next_1()));
    if (this$static.current.hasNext_0()) {
      return true;
    }
  }
  return false;
}

function $next_2(this$static){
  if (!$hasNext_0(this$static)) {
    throw new NoSuchElementException;
  }
  this$static.removeFrom = this$static.current;
  return this$static.current.next_1();
}

function MultitransformedIterator(backingIterator){
  this.current = ($clinit_Iterators() , $clinit_Iterators() , $clinit_Iterators() , EMPTY_LIST_ITERATOR);
  this.backingIterator = castTo(checkNotNull(backingIterator), 35);
}

defineClass(313, 1, $intern_18);
_.hasNext_0 = function hasNext_13(){
  return $hasNext_0(this);
}
;
_.next_1 = function next_14(){
  return $next_2(this);
}
;
_.remove = function remove_24(){
  checkState_0(!!this.removeFrom);
  this.removeFrom.remove();
  this.removeFrom = null;
}
;
var Lcom_google_common_collect_MultitransformedIterator_2_classLit = createForClass('com.google.common.collect', 'MultitransformedIterator', 313);
function Iterators$ConcatenatedIterator(iterators){
  MultitransformedIterator.call(this, new Iterators$ConcatenatedIterator$1(iterators));
}

defineClass(90, 313, {90:1, 35:1}, Iterators$ConcatenatedIterator);
_.transform_1 = function transform_4(iterator){
  return castTo(iterator, 35);
}
;
var Lcom_google_common_collect_Iterators$ConcatenatedIterator_2_classLit = createForClass('com.google.common.collect', 'Iterators/ConcatenatedIterator', 90);
function $transform_0(iterator){
  var concatIterator;
  if (instanceOf(iterator, 90)) {
    concatIterator = castTo(iterator, 90);
    return new Iterators$ConcatenatedIterator$1(concatIterator.backingIterator);
  }
   else {
    return $clinit_Iterators() , new Iterators$11(iterator);
  }
}

function Iterators$ConcatenatedIterator$1($anonymous0){
  MultitransformedIterator.call(this, $anonymous0);
}

defineClass(314, 313, $intern_18, Iterators$ConcatenatedIterator$1);
_.transform_1 = function transform_5(iterator){
  return $transform_0(castTo(iterator, 35));
}
;
var Lcom_google_common_collect_Iterators$ConcatenatedIterator$1_2_classLit = createForClass('com.google.common.collect', 'Iterators/ConcatenatedIterator/1', 314);
function $addNode(this$static, key, value_0, nextSibling){
  var keyList, keyTail, node;
  node = new LinkedListMultimap$Node(key, value_0);
  if (!this$static.head) {
    this$static.head = this$static.tail = node;
    $put_2(this$static.keyToKeyList, key, new LinkedListMultimap$KeyList(node));
    ++this$static.modCount;
  }
   else if (!nextSibling) {
    this$static.tail.next_0 = node;
    node.previous = this$static.tail;
    this$static.tail = node;
    keyList = castTo($get_9(this$static.keyToKeyList, key), 126);
    if (!keyList) {
      $put_2(this$static.keyToKeyList, key, new LinkedListMultimap$KeyList(node));
      ++this$static.modCount;
    }
     else {
      ++keyList.count;
      keyTail = keyList.tail;
      keyTail.nextSibling = node;
      node.previousSibling = keyTail;
      keyList.tail = node;
    }
  }
   else {
    keyList = castTo($get_9(this$static.keyToKeyList, key), 126);
    ++keyList.count;
    node.previous = nextSibling.previous;
    node.previousSibling = nextSibling.previousSibling;
    node.next_0 = nextSibling;
    node.nextSibling = nextSibling;
    !nextSibling.previousSibling?(castTo($get_9(this$static.keyToKeyList, key), 126).head = node):(nextSibling.previousSibling.nextSibling = node);
    !nextSibling.previous?(this$static.head = node):(nextSibling.previous.next_0 = node);
    nextSibling.previous = node;
    nextSibling.previousSibling = node;
  }
  ++this$static.size_0;
  return node;
}

function $asMap(this$static){
  var result;
  return result = this$static.asMap , !result?(this$static.asMap = new Multimaps$AsMap(this$static)):result;
}

function $clear_3(this$static){
  this$static.head = null;
  this$static.tail = null;
  $reset_3(this$static.keyToKeyList);
  this$static.size_0 = 0;
  ++this$static.modCount;
}

function $containsKey(this$static, key){
  return $containsKey_1(this$static.keyToKeyList, key);
}

function $entries(this$static){
  var result;
  return result = this$static.entries_0 , castTo(!result?(this$static.entries_0 = new LinkedListMultimap$1EntriesImpl(this$static)):result, 20);
}

function $removeAll_1(this$static, key){
  var oldValues;
  oldValues = unmodifiableList(newArrayList_0(new LinkedListMultimap$ValueForKeyIterator(this$static, key)));
  clear_14(new LinkedListMultimap$ValueForKeyIterator(this$static, key));
  return oldValues;
}

function $removeNode(this$static, node){
  var keyList;
  node.previous?(node.previous.next_0 = node.next_0):(this$static.head = node.next_0);
  node.next_0?(node.next_0.previous = node.previous):(this$static.tail = node.previous);
  if (!node.previousSibling && !node.nextSibling) {
    keyList = castTo($remove_9(this$static.keyToKeyList, node.key), 126);
    keyList.count = 0;
    ++this$static.modCount;
  }
   else {
    keyList = castTo($get_9(this$static.keyToKeyList, node.key), 126);
    --keyList.count;
    !node.previousSibling?(keyList.head = node.nextSibling):(node.previousSibling.nextSibling = node.nextSibling);
    !node.nextSibling?(keyList.tail = node.previousSibling):(node.nextSibling.previousSibling = node.previousSibling);
  }
  --this$static.size_0;
}

function LinkedListMultimap(){
  this.keyToKeyList = ($clinit_Maps() , new HashMap);
}

function checkElement(node){
  if (!node) {
    throw new NoSuchElementException;
  }
}

defineClass(329, 652, $intern_17, LinkedListMultimap);
_.get_0 = function get_11(key){
  return new LinkedListMultimap$1(this, key);
}
;
_.removeAll = function removeAll_2(key){
  return $removeAll_1(this, key);
}
;
_.clear_0 = function clear_15(){
  $clear_3(this);
}
;
_.containsKey = function containsKey_4(key){
  return $containsKey(this, key);
}
;
_.createAsMap = function createAsMap_0(){
  return new Multimaps$AsMap(this);
}
;
_.createKeySet = function createKeySet_3(){
  return new LinkedListMultimap$1KeySetImpl(this);
}
;
_.isEmpty = function isEmpty_13(){
  return !this.head;
}
;
_.size_1 = function size_20(){
  return this.size_0;
}
;
_.modCount = 0;
_.size_0 = 0;
var Lcom_google_common_collect_LinkedListMultimap_2_classLit = createForClass('com.google.common.collect', 'LinkedListMultimap', 329);
function $equals_2(this$static, o){
  var elem, elem$iterator, elemOther, iterOther, other;
  if (o === this$static) {
    return true;
  }
  if (!instanceOf(o, 20)) {
    return false;
  }
  other = castTo(o, 20);
  if (this$static.size_1() != other.size_1()) {
    return false;
  }
  iterOther = other.iterator_0();
  for (elem$iterator = this$static.iterator_0(); elem$iterator.hasNext_0();) {
    elem = elem$iterator.next_1();
    elemOther = iterOther.next_1();
    if (!(maskUndefined(elem) === maskUndefined(elemOther) || elem != null && equals_Ljava_lang_Object__Z__devirtual$(elem, elemOther))) {
      return false;
    }
  }
  return true;
}

function $indexOf(this$static, toFind){
  var i, n;
  for (i = 0 , n = this$static.size_1(); i < n; ++i) {
    if (equals_50(toFind, this$static.get_2(i))) {
      return i;
    }
  }
  return -1;
}

defineClass(646, 639, $intern_22);
_.add_2 = function add_10(index_0, element){
  throw new UnsupportedOperationException_0('Add not supported on this list');
}
;
_.add_1 = function add_11(obj){
  this.add_2(this.size_1(), obj);
  return true;
}
;
_.clear_0 = function clear_16(){
  this.removeRange(0, this.size_1());
}
;
_.equals = function equals_23(o){
  return $equals_2(this, o);
}
;
_.hashCode_0 = function hashCode_23(){
  return hashCode_46(this);
}
;
_.iterator_0 = function iterator_28(){
  return new AbstractList$IteratorImpl(this);
}
;
_.listIterator_0 = function listIterator_4(){
  return this.listIterator_1(0);
}
;
_.listIterator_1 = function listIterator_5(from){
  return new AbstractList$ListIteratorImpl(this, from);
}
;
_.remove_2 = function remove_25(index_0){
  throw new UnsupportedOperationException_0('Remove not supported on this list');
}
;
_.removeRange = function removeRange(fromIndex, endIndex){
  var i, iter;
  iter = this.listIterator_1(fromIndex);
  for (i = fromIndex; i < endIndex; ++i) {
    iter.next_1();
    iter.remove();
  }
}
;
_.set_2 = function set_5(index_0, o){
  throw new UnsupportedOperationException_0('Set not supported on this list');
}
;
_.subList = function subList_4(fromIndex, toIndex){
  return new AbstractList$SubList(this, fromIndex, toIndex);
}
;
_.modCount = 0;
var Ljava_util_AbstractList_2_classLit = createForClass('java.util', 'AbstractList', 646);
function $add_2(this$static, index_0, element){
  var iter;
  iter = this$static.listIterator_1(index_0);
  iter.add_0(element);
}

function $addAll_2(this$static, index_0, c){
  var e, e$iterator, iter, modified;
  checkCriticalNotNull(c);
  modified = false;
  iter = $listIterator_2(this$static, index_0);
  for (e$iterator = $listIterator_2(c, 0); e$iterator.currentNode != e$iterator.this$01.tail;) {
    e = $next_11(e$iterator);
    $add_19(iter, e);
    modified = true;
  }
  return modified;
}

function $get_4(this$static, index_0){
  var iter;
  iter = this$static.listIterator_1(index_0);
  try {
    return iter.next_1();
  }
   catch ($e0) {
    $e0 = wrap($e0);
    if (instanceOf($e0, 74)) {
      throw new IndexOutOfBoundsException_0("Can't get element " + index_0);
    }
     else 
      throw unwrap_5($e0);
  }
}

function $remove_3(this$static, index_0){
  var iter, old;
  iter = this$static.listIterator_1(index_0);
  try {
    old = iter.next_1();
    iter.remove();
    return old;
  }
   catch ($e0) {
    $e0 = wrap($e0);
    if (instanceOf($e0, 74)) {
      throw new IndexOutOfBoundsException_0("Can't remove element " + index_0);
    }
     else 
      throw unwrap_5($e0);
  }
}

defineClass(647, 646, $intern_22);
_.add_2 = function add_12(index_0, element){
  $add_2(this, index_0, element);
}
;
_.get_2 = function get_12(index_0){
  return $get_4(this, index_0);
}
;
_.iterator_0 = function iterator_29(){
  return this.listIterator_1(0);
}
;
_.remove_2 = function remove_26(index_0){
  return $remove_3(this, index_0);
}
;
_.set_2 = function set_6(index_0, element){
  var iter, old;
  iter = this.listIterator_1(index_0);
  try {
    old = iter.next_1();
    iter.set_1(element);
    return old;
  }
   catch ($e0) {
    $e0 = wrap($e0);
    if (instanceOf($e0, 74)) {
      throw new IndexOutOfBoundsException_0("Can't set element " + index_0);
    }
     else 
      throw unwrap_5($e0);
  }
}
;
var Ljava_util_AbstractSequentialList_2_classLit = createForClass('java.util', 'AbstractSequentialList', 647);
function $listIterator_0(this$static, index_0){
  return new LinkedListMultimap$ValueForKeyIterator_0(this$static.this$01, this$static.val$key2, index_0);
}

function LinkedListMultimap$1(this$0, val$key){
  this.this$01 = this$0;
  this.val$key2 = val$key;
}

defineClass(276, 647, $intern_22, LinkedListMultimap$1);
_.listIterator_1 = function listIterator_6(index_0){
  return $listIterator_0(this, index_0);
}
;
_.size_1 = function size_21(){
  var keyList;
  keyList = castTo($get_9(this.this$01.keyToKeyList, this.val$key2), 126);
  return !keyList?0:keyList.count;
}
;
var Lcom_google_common_collect_LinkedListMultimap$1_2_classLit = createForClass('com.google.common.collect', 'LinkedListMultimap/1', 276);
function LinkedListMultimap$1EntriesImpl(this$0){
  this.this$01 = this$0;
}

defineClass(330, 647, $intern_22, LinkedListMultimap$1EntriesImpl);
_.listIterator_1 = function listIterator_7(index_0){
  return new LinkedListMultimap$NodeIterator(this.this$01, index_0);
}
;
_.size_1 = function size_22(){
  return this.this$01.size_0;
}
;
var Lcom_google_common_collect_LinkedListMultimap$1EntriesImpl_2_classLit = createForClass('com.google.common.collect', 'LinkedListMultimap/1EntriesImpl', 330);
function LinkedListMultimap$1KeySetImpl(this$0){
  this.this$01 = this$0;
}

defineClass(563, 648, $intern_21, LinkedListMultimap$1KeySetImpl);
_.contains = function contains_16(key){
  return $containsKey(this.this$01, key);
}
;
_.iterator_0 = function iterator_30(){
  return new LinkedListMultimap$DistinctKeyIterator(this.this$01);
}
;
_.remove_1 = function remove_27(o){
  return !$removeAll_1(this.this$01, o).list.isEmpty();
}
;
_.size_1 = function size_23(){
  return $size_0(this.this$01.keyToKeyList);
}
;
var Lcom_google_common_collect_LinkedListMultimap$1KeySetImpl_2_classLit = createForClass('com.google.common.collect', 'LinkedListMultimap/1KeySetImpl', 563);
function $checkForConcurrentModification(this$static){
  if (this$static.this$01.modCount != this$static.expectedModCount) {
    throw new ConcurrentModificationException;
  }
}

function LinkedListMultimap$DistinctKeyIterator(this$0){
  this.this$01 = this$0;
  this.seenKeys = new HashSet_0(capacity_0($keySet(this.this$01).size_1()));
  this.next_0 = this.this$01.head;
  this.expectedModCount = this.this$01.modCount;
}

defineClass(562, 1, $intern_18, LinkedListMultimap$DistinctKeyIterator);
_.hasNext_0 = function hasNext_14(){
  $checkForConcurrentModification(this);
  return !!this.next_0;
}
;
_.next_1 = function next_15(){
  $checkForConcurrentModification(this);
  checkElement(this.next_0);
  this.current = this.next_0;
  $add_18(this.seenKeys, this.current.key);
  do {
    this.next_0 = this.next_0.next_0;
  }
   while (!!this.next_0 && !$add_18(this.seenKeys, this.next_0.key));
  return this.current.key;
}
;
_.remove = function remove_28(){
  $checkForConcurrentModification(this);
  checkState_0(!!this.current);
  clear_14(new LinkedListMultimap$ValueForKeyIterator(this.this$01, this.current.key));
  this.current = null;
  this.expectedModCount = this.this$01.modCount;
}
;
_.expectedModCount = 0;
var Lcom_google_common_collect_LinkedListMultimap$DistinctKeyIterator_2_classLit = createForClass('com.google.common.collect', 'LinkedListMultimap/DistinctKeyIterator', 562);
function LinkedListMultimap$KeyList(firstNode){
  this.head = firstNode;
  this.tail = firstNode;
  firstNode.previousSibling = null;
  firstNode.nextSibling = null;
  this.count = 1;
}

defineClass(126, 1, {126:1}, LinkedListMultimap$KeyList);
_.count = 0;
var Lcom_google_common_collect_LinkedListMultimap$KeyList_2_classLit = createForClass('com.google.common.collect', 'LinkedListMultimap/KeyList', 126);
function LinkedListMultimap$Node(key, value_0){
  this.key = key;
  this.value_0 = value_0;
}

defineClass(560, 667, $intern_26, LinkedListMultimap$Node);
_.getKey = function getKey_0(){
  return this.key;
}
;
_.getValue = function getValue_0(){
  return this.value_0;
}
;
_.setValue = function setValue_1(newValue){
  var result;
  result = this.value_0;
  this.value_0 = newValue;
  return result;
}
;
var Lcom_google_common_collect_LinkedListMultimap$Node_2_classLit = createForClass('com.google.common.collect', 'LinkedListMultimap/Node', 560);
function $add_3(){
  throw new UnsupportedOperationException;
}

function $checkForConcurrentModification_0(this$static){
  if (this$static.this$01.modCount != this$static.expectedModCount) {
    throw new ConcurrentModificationException;
  }
}

function $next_3(this$static){
  $checkForConcurrentModification_0(this$static);
  checkElement(this$static.next_0);
  this$static.previous = this$static.current = this$static.next_0;
  this$static.next_0 = this$static.next_0.next_0;
  ++this$static.nextIndex;
  return this$static.current;
}

function $previous(this$static){
  $checkForConcurrentModification_0(this$static);
  checkElement(this$static.previous);
  this$static.next_0 = this$static.current = this$static.previous;
  this$static.previous = this$static.previous.previous;
  --this$static.nextIndex;
  return this$static.current;
}

function $set(){
  throw new UnsupportedOperationException;
}

function LinkedListMultimap$NodeIterator(this$0, index_0){
  var size_0;
  this.this$01 = this$0;
  this.expectedModCount = this.this$01.modCount;
  size_0 = this$0.size_0;
  checkPositionIndex(index_0, size_0);
  if (index_0 >= (size_0 / 2 | 0)) {
    this.previous = this$0.tail;
    this.nextIndex = size_0;
    while (index_0++ < size_0) {
      $previous(this);
    }
  }
   else {
    this.next_0 = this$0.head;
    while (index_0-- > 0) {
      $next_3(this);
    }
  }
  this.current = null;
}

defineClass(561, 1, $intern_24, LinkedListMultimap$NodeIterator);
_.add_0 = function add_13(e){
  castTo(e, 21);
  $add_3();
}
;
_.next_1 = function next_16(){
  return $next_3(this);
}
;
_.previous_0 = function previous_3(){
  return $previous(this);
}
;
_.set_1 = function set_7(e){
  castTo(e, 21);
  $set();
}
;
_.hasNext_0 = function hasNext_15(){
  $checkForConcurrentModification_0(this);
  return !!this.next_0;
}
;
_.hasPrevious = function hasPrevious_2(){
  $checkForConcurrentModification_0(this);
  return !!this.previous;
}
;
_.nextIndex_0 = function nextIndex_3(){
  return this.nextIndex;
}
;
_.previousIndex = function previousIndex_2(){
  return this.nextIndex - 1;
}
;
_.remove = function remove_29(){
  $checkForConcurrentModification_0(this);
  checkState_0(!!this.current);
  if (this.current != this.next_0) {
    this.previous = this.current.previous;
    --this.nextIndex;
  }
   else {
    this.next_0 = this.current.next_0;
  }
  $removeNode(this.this$01, this.current);
  this.current = null;
  this.expectedModCount = this.this$01.modCount;
}
;
_.expectedModCount = 0;
_.nextIndex = 0;
var Lcom_google_common_collect_LinkedListMultimap$NodeIterator_2_classLit = createForClass('com.google.common.collect', 'LinkedListMultimap/NodeIterator', 561);
function $next_4(this$static){
  checkElement(this$static.next_0);
  this$static.previous = this$static.current = this$static.next_0;
  this$static.next_0 = this$static.next_0.nextSibling;
  ++this$static.nextIndex;
  return this$static.current.value_0;
}

function $previous_0(this$static){
  checkElement(this$static.previous);
  this$static.next_0 = this$static.current = this$static.previous;
  this$static.previous = this$static.previous.previousSibling;
  --this$static.nextIndex;
  return this$static.current.value_0;
}

function LinkedListMultimap$ValueForKeyIterator(this$0, key){
  var keyList;
  this.this$01 = this$0;
  this.key = key;
  keyList = castTo($get_9(this$0.keyToKeyList, key), 126);
  this.next_0 = !keyList?null:keyList.head;
}

function LinkedListMultimap$ValueForKeyIterator_0(this$0, key, index_0){
  var keyList, size_0;
  this.this$01 = this$0;
  keyList = castTo($get_9(this$0.keyToKeyList, key), 126);
  size_0 = !keyList?0:keyList.count;
  checkPositionIndex(index_0, size_0);
  if (index_0 >= (size_0 / 2 | 0)) {
    this.previous = !keyList?null:keyList.tail;
    this.nextIndex = size_0;
    while (index_0++ < size_0) {
      $previous_0(this);
    }
  }
   else {
    this.next_0 = !keyList?null:keyList.head;
    while (index_0-- > 0) {
      $next_4(this);
    }
  }
  this.key = key;
  this.current = null;
}

defineClass(241, 1, $intern_24, LinkedListMultimap$ValueForKeyIterator, LinkedListMultimap$ValueForKeyIterator_0);
_.add_0 = function add_14(value_0){
  this.previous = $addNode(this.this$01, this.key, value_0, this.next_0);
  ++this.nextIndex;
  this.current = null;
}
;
_.hasNext_0 = function hasNext_16(){
  return !!this.next_0;
}
;
_.hasPrevious = function hasPrevious_3(){
  return !!this.previous;
}
;
_.next_1 = function next_17(){
  return $next_4(this);
}
;
_.nextIndex_0 = function nextIndex_4(){
  return this.nextIndex;
}
;
_.previous_0 = function previous_4(){
  return $previous_0(this);
}
;
_.previousIndex = function previousIndex_3(){
  return this.nextIndex - 1;
}
;
_.remove = function remove_30(){
  checkState_0(!!this.current);
  if (this.current != this.next_0) {
    this.previous = this.current.previousSibling;
    --this.nextIndex;
  }
   else {
    this.next_0 = this.current.nextSibling;
  }
  $removeNode(this.this$01, this.current);
  this.current = null;
}
;
_.set_1 = function set_8(value_0){
  checkState(!!this.current);
  this.current.value_0 = value_0;
}
;
_.nextIndex = 0;
var Lcom_google_common_collect_LinkedListMultimap$ValueForKeyIterator_2_classLit = createForClass('com.google.common.collect', 'LinkedListMultimap/ValueForKeyIterator', 241);
function computeArrayListCapacity(arraySize){
  checkNonnegative(arraySize, 'arraySize');
  return saturatedCast(add_20(add_20(5, arraySize), arraySize / 10 | 0));
}

function equalsImpl(thisList, other){
  var i, otherList, size_0;
  if (maskUndefined(other) === maskUndefined(checkNotNull(thisList))) {
    return true;
  }
  if (!instanceOf(other, 20)) {
    return false;
  }
  otherList = castTo(other, 20);
  size_0 = thisList.size_1();
  if (size_0 != otherList.size_1()) {
    return false;
  }
  if (instanceOf(otherList, 67)) {
    for (i = 0; i < size_0; i++) {
      if (!equal(thisList.get_2(i), otherList.get_2(i))) {
        return false;
      }
    }
    return true;
  }
   else {
    return elementsEqual(thisList.iterator_0(), otherList.iterator_0());
  }
}

function hashCodeImpl(list){
  var hashCode, o, o$iterator;
  hashCode = 1;
  for (o$iterator = list.iterator_0(); o$iterator.hasNext_0();) {
    o = o$iterator.next_1();
    hashCode = 31 * hashCode + (o == null?0:hashCode__I__devirtual$(o));
    hashCode = ~~hashCode;
  }
  return hashCode;
}

function newArrayList(elements){
  checkNotNull(elements);
  return instanceOf(elements, 19)?new ArrayList_1(($clinit_Collections2() , castTo(elements, 19))):newArrayList_0(elements.iterator_0());
}

function newArrayList_0(elements){
  var list;
  list = new ArrayList;
  addAll_5(list, elements);
  return list;
}

function newArrayList_1(elements){
  var capacity, list;
  checkNotNull(elements);
  capacity = computeArrayListCapacity(elements.length);
  list = new ArrayList_0(capacity);
  addAll_8(list, elements);
  return list;
}

function newArrayListWithCapacity(initialArraySize){
  checkNonnegative(initialArraySize, 'initialArraySize');
  return new ArrayList_0(initialArraySize);
}

function newLinkedList(elements){
  var list;
  list = new LinkedList;
  addAll_4(list, elements);
  return list;
}

function reverse_0(list){
  return instanceOf(list, 89)?$reverse(castTo(list, 89)):instanceOf(list, 87)?castTo(list, 87).forwardList:instanceOf(list, 67)?new Lists$RandomAccessReverseList(list):new Lists$ReverseList(list);
}

defineClass(419, 646, $intern_22);
_.add_2 = function add_15(index_0, element){
  this.backingList.add_2(index_0, element);
}
;
_.contains = function contains_17(o){
  return this.backingList.contains(o);
}
;
_.get_2 = function get_13(index_0){
  return this.backingList.get_2(index_0);
}
;
_.remove_2 = function remove_31(index_0){
  return this.backingList.remove_2(index_0);
}
;
_.set_2 = function set_9(index_0, element){
  return this.backingList.set_2(index_0, element);
}
;
_.size_1 = function size_24(){
  return this.backingList.size_1();
}
;
var Lcom_google_common_collect_Lists$AbstractListWrapper_2_classLit = createForClass('com.google.common.collect', 'Lists/AbstractListWrapper', 419);
defineClass(420, 419, $intern_23);
var Lcom_google_common_collect_Lists$RandomAccessListWrapper_2_classLit = createForClass('com.google.common.collect', 'Lists/RandomAccessListWrapper', 420);
function Lists$1($anonymous0){
  this.backingList = castTo(checkNotNull($anonymous0), 20);
}

defineClass(422, 420, $intern_23, Lists$1);
_.listIterator_1 = function listIterator_8(index_0){
  return this.backingList.listIterator_1(index_0);
}
;
var Lcom_google_common_collect_Lists$1_2_classLit = createForClass('com.google.common.collect', 'Lists/1', 422);
function $listIterator_1(this$static, index_0){
  var forwardIterator, start_0;
  start_0 = $reversePosition(this$static, index_0);
  forwardIterator = this$static.forwardList.listIterator_1(start_0);
  return new Lists$ReverseList$1(this$static, forwardIterator);
}

function $reverseIndex(this$static, index_0){
  var size_0;
  size_0 = this$static.forwardList.size_1();
  checkElementIndex(index_0, size_0);
  return size_0 - 1 - index_0;
}

function $reversePosition(this$static, index_0){
  var size_0;
  size_0 = this$static.forwardList.size_1();
  checkPositionIndex(index_0, size_0);
  return size_0 - index_0;
}

function Lists$ReverseList(forwardList){
  this.forwardList = castTo(checkNotNull(forwardList), 20);
}

defineClass(87, 646, {87:1, 22:1, 19:1, 20:1}, Lists$ReverseList);
_.add_2 = function add_16(index_0, element){
  this.forwardList.add_2($reversePosition(this, index_0), element);
}
;
_.clear_0 = function clear_17(){
  this.forwardList.clear_0();
}
;
_.get_2 = function get_14(index_0){
  return this.forwardList.get_2($reverseIndex(this, index_0));
}
;
_.iterator_0 = function iterator_31(){
  return $listIterator_1(this, 0);
}
;
_.listIterator_1 = function listIterator_9(index_0){
  return $listIterator_1(this, index_0);
}
;
_.remove_2 = function remove_32(index_0){
  return this.forwardList.remove_2($reverseIndex(this, index_0));
}
;
_.removeRange = function removeRange_0(fromIndex, toIndex){
  (checkPositionIndexes(fromIndex, toIndex, this.forwardList.size_1()) , reverse_0(this.forwardList.subList($reversePosition(this, toIndex), $reversePosition(this, fromIndex)))).clear_0();
}
;
_.set_2 = function set_10(index_0, element){
  return this.forwardList.set_2($reverseIndex(this, index_0), element);
}
;
_.size_1 = function size_25(){
  return this.forwardList.size_1();
}
;
_.subList = function subList_5(fromIndex, toIndex){
  return checkPositionIndexes(fromIndex, toIndex, this.forwardList.size_1()) , reverse_0(this.forwardList.subList($reversePosition(this, toIndex), $reversePosition(this, fromIndex)));
}
;
var Lcom_google_common_collect_Lists$ReverseList_2_classLit = createForClass('com.google.common.collect', 'Lists/ReverseList', 87);
function Lists$RandomAccessReverseList(forwardList){
  Lists$ReverseList.call(this, forwardList);
}

defineClass(220, 87, {87:1, 22:1, 19:1, 20:1, 67:1}, Lists$RandomAccessReverseList);
var Lcom_google_common_collect_Lists$RandomAccessReverseList_2_classLit = createForClass('com.google.common.collect', 'Lists/RandomAccessReverseList', 220);
function Lists$ReverseList$1(this$1, val$forwardIterator){
  this.this$11 = this$1;
  this.val$forwardIterator2 = val$forwardIterator;
}

defineClass(421, 1, $intern_24, Lists$ReverseList$1);
_.add_0 = function add_17(e){
  this.val$forwardIterator2.add_0(e);
  this.val$forwardIterator2.previous_0();
  this.canRemoveOrSet = false;
}
;
_.hasNext_0 = function hasNext_17(){
  return this.val$forwardIterator2.hasPrevious();
}
;
_.hasPrevious = function hasPrevious_4(){
  return this.val$forwardIterator2.hasNext_0();
}
;
_.next_1 = function next_18(){
  if (!this.val$forwardIterator2.hasPrevious()) {
    throw new NoSuchElementException;
  }
  this.canRemoveOrSet = true;
  return this.val$forwardIterator2.previous_0();
}
;
_.nextIndex_0 = function nextIndex_5(){
  return $reversePosition(this.this$11, this.val$forwardIterator2.nextIndex_0());
}
;
_.previous_0 = function previous_5(){
  if (!this.val$forwardIterator2.hasNext_0()) {
    throw new NoSuchElementException;
  }
  this.canRemoveOrSet = true;
  return this.val$forwardIterator2.next_1();
}
;
_.previousIndex = function previousIndex_4(){
  return $reversePosition(this.this$11, this.val$forwardIterator2.nextIndex_0()) - 1;
}
;
_.remove = function remove_33(){
  checkState_0(this.canRemoveOrSet);
  this.val$forwardIterator2.remove();
  this.canRemoveOrSet = false;
}
;
_.set_1 = function set_11(e){
  checkState(this.canRemoveOrSet);
  this.val$forwardIterator2.set_1(e);
}
;
_.canRemoveOrSet = false;
var Lcom_google_common_collect_Lists$ReverseList$1_2_classLit = createForClass('com.google.common.collect', 'Lists/ReverseList/1', 421);
function $clinit_Maps(){
  $clinit_Maps = emptyMethod;
  STANDARD_JOINER_0 = new Joiner$MapJoiner(($clinit_Collections2() , STANDARD_JOINER));
}

function asMapEntryIterator(set_0, function_0){
  $clinit_Maps();
  return new Maps$1(set_0.iterator_0(), function_0);
}

function capacity_0(expectedSize){
  $clinit_Maps();
  if (expectedSize < 3) {
    checkNonnegative(expectedSize, 'expectedSize');
    return expectedSize + 1;
  }
  if (expectedSize < $intern_29) {
    return round_int(expectedSize / 0.75 + 1);
  }
  return $intern_3;
}

function equalsImpl_0(map_0, object){
  $clinit_Maps();
  var o;
  if (map_0 === object) {
    return true;
  }
   else if (instanceOf(object, 57)) {
    o = castTo(object, 57);
    return equalsImpl_3($entrySet_1(map_0), o.entrySet_0());
  }
  return false;
}

function safeContainsKey(map_0, key){
  $clinit_Maps();
  checkNotNull(map_0);
  try {
    return map_0.containsKey(key);
  }
   catch ($e0) {
    $e0 = wrap($e0);
    if (instanceOf($e0, 119)) {
      return false;
    }
     else if (instanceOf($e0, 76)) {
      return false;
    }
     else 
      throw unwrap_5($e0);
  }
}

function safeGet(map_0, key){
  $clinit_Maps();
  checkNotNull(map_0);
  try {
    return map_0.get_1(key);
  }
   catch ($e0) {
    $e0 = wrap($e0);
    if (instanceOf($e0, 119)) {
      return null;
    }
     else if (instanceOf($e0, 76)) {
      return null;
    }
     else 
      throw unwrap_5($e0);
  }
}

function safeRemove(map_0, key){
  $clinit_Maps();
  checkNotNull(map_0);
  try {
    return instanceOfString(key)?$removeStringValue(map_0, key):$remove_18(map_0.hashCodeMap, key);
  }
   catch ($e0) {
    $e0 = wrap($e0);
    if (instanceOf($e0, 119)) {
      return null;
    }
     else if (instanceOf($e0, 76)) {
      return null;
    }
     else 
      throw unwrap_5($e0);
  }
}

var STANDARD_JOINER_0;
function Maps$1($anonymous0, val$function){
  this.val$function2 = val$function;
  TransformedIterator.call(this, $anonymous0);
}

defineClass(376, 261, $intern_18, Maps$1);
_.transform_0 = function transform_6(key){
  return $clinit_Maps() , new ImmutableEntry(key, $apply(this.val$function2, key));
}
;
var Lcom_google_common_collect_Maps$1_2_classLit = createForClass('com.google.common.collect', 'Maps/1', 376);
function $clinit_Maps$EntryFunction(){
  $clinit_Maps$EntryFunction = emptyMethod;
  KEY = new Maps$EntryFunction$1;
  VALUE = new Maps$EntryFunction$2;
}

function Maps$EntryFunction(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function values_9(){
  $clinit_Maps$EntryFunction();
  return stampJavaTypeInfo(getClassLiteralForArray(Lcom_google_common_collect_Maps$EntryFunction_2_classLit, 1), $intern_13, 188, 0, [KEY, VALUE]);
}

defineClass(188, 17, $intern_36);
var KEY, VALUE;
var Lcom_google_common_collect_Maps$EntryFunction_2_classLit = createForEnum('com.google.common.collect', 'Maps/EntryFunction', 188, Ljava_lang_Enum_2_classLit, values_9);
function Maps$EntryFunction$1(){
  Maps$EntryFunction.call(this, 'KEY', 0);
}

defineClass(374, 188, $intern_36, Maps$EntryFunction$1);
_.apply_0 = function apply_9(entry){
  return castTo(entry, 21).getKey();
}
;
var Lcom_google_common_collect_Maps$EntryFunction$1_2_classLit = createForEnum('com.google.common.collect', 'Maps/EntryFunction/1', 374, Lcom_google_common_collect_Maps$EntryFunction_2_classLit, null);
function Maps$EntryFunction$2(){
  Maps$EntryFunction.call(this, 'VALUE', 1);
}

defineClass(375, 188, $intern_36, Maps$EntryFunction$2);
_.apply_0 = function apply_10(entry){
  return castTo(entry, 21).getValue();
}
;
var Lcom_google_common_collect_Maps$EntryFunction$2_2_classLit = createForEnum('com.google.common.collect', 'Maps/EntryFunction/2', 375, Lcom_google_common_collect_Maps$EntryFunction_2_classLit, null);
function $iterator_2(this$static){
  return $clinit_Maps() , transform_2(this$static.map_0.entrySet_0().iterator_0(), ($clinit_Maps$EntryFunction() , VALUE));
}

function Maps$Values(map_0){
  this.map_0 = castTo(checkNotNull(map_0), 57);
}

defineClass(373, 639, $intern_20, Maps$Values);
_.clear_0 = function clear_18(){
  this.map_0.clear_0();
}
;
_.contains = function contains_18(o){
  return this.map_0.containsValue(o);
}
;
_.isEmpty = function isEmpty_14(){
  return this.map_0.isEmpty();
}
;
_.iterator_0 = function iterator_32(){
  return $iterator_2(this);
}
;
_.remove_1 = function remove_34(o){
  var entry, entry$iterator;
  try {
    return $advanceToFind(this, o, true);
  }
   catch ($e0) {
    $e0 = wrap($e0);
    if (instanceOf($e0, 45)) {
      for (entry$iterator = this.map_0.entrySet_0().iterator_0(); entry$iterator.hasNext_0();) {
        entry = castTo(entry$iterator.next_1(), 21);
        if (equal(o, entry.getValue())) {
          this.map_0.remove_0(entry.getKey());
          return true;
        }
      }
      return false;
    }
     else 
      throw unwrap_5($e0);
  }
}
;
_.size_1 = function size_26(){
  return this.map_0.size_1();
}
;
var Lcom_google_common_collect_Maps$Values_2_classLit = createForClass('com.google.common.collect', 'Maps/Values', 373);
function equalsImpl_1(multimap, object){
  var that;
  if (object === multimap) {
    return true;
  }
  if (instanceOf(object, 144)) {
    that = castTo(object, 144);
    return multimap.asMap_0().equals(that.asMap_0());
  }
  return false;
}

function invertFrom(source, dest){
  var entry, entry$iterator, result;
  checkNotNull(dest);
  for (entry$iterator = (result = source.entries_0 , castTo(!result?(source.entries_0 = new LinkedListMultimap$1EntriesImpl(source)):result, 20)).iterator_0(); entry$iterator.hasNext_0();) {
    entry = castTo(entry$iterator.next_1(), 21);
    $put(dest, entry.getValue(), entry.getKey());
  }
  return dest;
}

function $removeValuesForKey_0(this$static, key){
  this$static.multimap.keySet_0().remove_1(key);
}

function Multimaps$AsMap(multimap){
  this.multimap = castTo(checkNotNull(multimap), 144);
}

defineClass(301, 653, $intern_19, Multimaps$AsMap);
_.get_1 = function get_15(key){
  return this.multimap.containsKey(key)?this.multimap.get_0(key):null;
}
;
_.remove_0 = function remove_35(key){
  return this.multimap.containsKey(key)?this.multimap.removeAll(key):null;
}
;
_.clear_0 = function clear_19(){
  this.multimap.clear_0();
}
;
_.containsKey = function containsKey_5(key){
  return this.multimap.containsKey(key);
}
;
_.createEntrySet_0 = function createEntrySet_2(){
  return new Multimaps$AsMap$EntrySet(this);
}
;
_.createEntrySet = function(){
  return this.createEntrySet_0();
}
;
_.isEmpty = function isEmpty_15(){
  return this.multimap.isEmpty();
}
;
_.keySet_0 = function keySet_4(){
  return this.multimap.keySet_0();
}
;
_.size_1 = function size_27(){
  return this.multimap.keySet_0().size_1();
}
;
var Lcom_google_common_collect_Multimaps$AsMap_2_classLit = createForClass('com.google.common.collect', 'Multimaps/AsMap', 301);
function Multimaps$AsMap$EntrySet(this$1){
  this.this$11 = this$1;
}

defineClass(393, 654, $intern_21, Multimaps$AsMap$EntrySet);
_.iterator_0 = function iterator_33(){
  return asMapEntryIterator(this.this$11.multimap.keySet_0(), new Multimaps$AsMap$EntrySet$1(this));
}
;
_.map_1 = function map_2(){
  return this.this$11;
}
;
_.remove_1 = function remove_36(o){
  var entry;
  if (!$contains(this, o)) {
    return false;
  }
  entry = castTo(o, 21);
  $removeValuesForKey_0(this.this$11, entry.getKey());
  return true;
}
;
var Lcom_google_common_collect_Multimaps$AsMap$EntrySet_2_classLit = createForClass('com.google.common.collect', 'Multimaps/AsMap/EntrySet', 393);
function $apply(this$static, key){
  return this$static.this$21.this$11.multimap.get_0(key);
}

function Multimaps$AsMap$EntrySet$1(this$2){
  this.this$21 = this$2;
}

defineClass(395, 1, $intern_35, Multimaps$AsMap$EntrySet$1);
_.apply_0 = function apply_11(key){
  return $apply(this, key);
}
;
var Lcom_google_common_collect_Multimaps$AsMap$EntrySet$1_2_classLit = createForClass('com.google.common.collect', 'Multimaps/AsMap/EntrySet/1', 395);
function $iterator_3(this$static){
  return $clinit_Maps() , transform_2($entries(this$static.multimap).iterator_0(), ($clinit_Maps$EntryFunction() , KEY));
}

function Multimaps$Keys(multimap){
  this.multimap = multimap;
}

defineClass(391, 655, $intern_27, Multimaps$Keys);
_.clear_0 = function clear_20(){
  $clear_3(this.multimap);
}
;
_.contains = function contains_19(element){
  return $containsKey(this.multimap, element);
}
;
_.count_0 = function count_1(element){
  var values;
  return values = castTo(safeGet($asMap(this.multimap), element), 19) , !values?0:values.size_1();
}
;
_.createEntrySet = function createEntrySet_3(){
  return new Multimaps$Keys$KeysEntrySet(this);
}
;
_.distinctElements_0 = function distinctElements(){
  return $asMap(this.multimap).size_1();
}
;
_.entryIterator_0 = function entryIterator_0(){
  return new Multimaps$Keys$1($entrySet($asMap(this.multimap)).iterator_0());
}
;
_.iterator_0 = function iterator_34(){
  return $iterator_3(this);
}
;
_.remove_3 = function remove_37(element, occurrences){
  var i, iterator, oldCount, values, values0;
  checkNonnegative(occurrences, 'occurrences');
  if (occurrences == 0) {
    return values0 = castTo(safeGet($asMap(this.multimap), element), 19) , !values0?0:values0.size_1();
  }
  values = castTo(safeGet($asMap(this.multimap), element), 19);
  if (!values) {
    return 0;
  }
  oldCount = values.size_1();
  if (occurrences >= oldCount) {
    values.clear_0();
  }
   else {
    iterator = values.iterator_0();
    for (i = 0; i < occurrences; i++) {
      iterator.next_1();
      iterator.remove();
    }
  }
  return oldCount;
}
;
var Lcom_google_common_collect_Multimaps$Keys_2_classLit = createForClass('com.google.common.collect', 'Multimaps/Keys', 391);
function Multimaps$Keys$1($anonymous0){
  TransformedIterator.call(this, $anonymous0);
}

defineClass(302, 261, $intern_18, Multimaps$Keys$1);
_.transform_0 = function transform_7(backingEntry){
  return new Multimaps$Keys$1$1(castTo(backingEntry, 21));
}
;
var Lcom_google_common_collect_Multimaps$Keys$1_2_classLit = createForClass('com.google.common.collect', 'Multimaps/Keys/1', 302);
function $toString_6(this$static){
  var n, text_0;
  text_0 = valueOf_1(this$static.getElement());
  n = this$static.getCount();
  return n == 1?text_0:text_0 + ' x ' + n;
}

defineClass(657, 1, {83:1});
_.equals = function equals_24(object){
  var that;
  if (instanceOf(object, 83)) {
    that = castTo(object, 83);
    return this.getCount() == that.getCount() && equal(this.getElement(), that.getElement());
  }
  return false;
}
;
_.hashCode_0 = function hashCode_24(){
  var e;
  e = this.getElement();
  return (e == null?0:hashCode__I__devirtual$(e)) ^ this.getCount();
}
;
_.toString_0 = function toString_30(){
  return $toString_6(this);
}
;
var Lcom_google_common_collect_Multisets$AbstractEntry_2_classLit = createForClass('com.google.common.collect', 'Multisets/AbstractEntry', 657);
function Multimaps$Keys$1$1(val$backingEntry){
  this.val$backingEntry2 = val$backingEntry;
}

defineClass(394, 657, {83:1}, Multimaps$Keys$1$1);
_.getCount = function getCount(){
  return castTo(this.val$backingEntry2.getValue(), 19).size_1();
}
;
_.getElement = function getElement(){
  return this.val$backingEntry2.getKey();
}
;
var Lcom_google_common_collect_Multimaps$Keys$1$1_2_classLit = createForClass('com.google.common.collect', 'Multimaps/Keys/1/1', 394);
function Multimaps$Keys$KeysEntrySet(this$1){
  this.this$11 = this$1;
}

defineClass(392, 656, $intern_21, Multimaps$Keys$KeysEntrySet);
_.contains = function contains_20(o){
  var collection, entry;
  if (instanceOf(o, 83)) {
    entry = castTo(o, 83);
    collection = castTo($asMap(this.this$11.multimap).get_1(entry.getElement()), 19);
    return !!collection && collection.size_1() == entry.getCount();
  }
  return false;
}
;
_.isEmpty = function isEmpty_16(){
  return !this.this$11.multimap.head;
}
;
_.iterator_0 = function iterator_35(){
  return new Multimaps$Keys$1($entrySet($asMap(this.this$11.multimap)).iterator_0());
}
;
_.multiset_0 = function multiset_1(){
  return this.this$11;
}
;
_.remove_1 = function remove_38(o){
  var collection, entry;
  if (instanceOf(o, 83)) {
    entry = castTo(o, 83);
    collection = castTo($asMap(this.this$11.multimap).get_1(entry.getElement()), 19);
    if (!!collection && collection.size_1() == entry.getCount()) {
      collection.clear_0();
      return true;
    }
  }
  return false;
}
;
_.size_1 = function size_28(){
  return $asMap(this.this$11.multimap).size_1();
}
;
var Lcom_google_common_collect_Multimaps$Keys$KeysEntrySet_2_classLit = createForClass('com.google.common.collect', 'Multimaps/Keys/KeysEntrySet', 392);
function $clinit_Multisets(){
  $clinit_Multisets = emptyMethod;
  new Multisets$1;
}

function addAllImpl(self_0, elements){
  $clinit_Multisets();
  var entry, entry$iterator, that;
  if (elements.isEmpty()) {
    return false;
  }
  if (instanceOf(elements, 207)) {
    that = castTo(elements, 207);
    for (entry$iterator = that.entrySet_0().iterator_0(); entry$iterator.hasNext_0();) {
      entry = castTo(entry$iterator.next_1(), 83);
      self_0.add_3(entry.getElement(), entry.getCount());
    }
  }
   else {
    addAll_5(self_0, elements.iterator_0());
  }
  return true;
}

function equalsImpl_2(multiset, object){
  $clinit_Multisets();
  var entry, entry$iterator, that;
  if (object === multiset) {
    return true;
  }
  if (instanceOf(object, 207)) {
    that = castTo(object, 207);
    if (multiset.size_1() != that.size_1() || $entrySet_0(multiset).size_1() != that.entrySet_0().size_1()) {
      return false;
    }
    for (entry$iterator = that.entrySet_0().iterator_0(); entry$iterator.hasNext_0();) {
      entry = castTo(entry$iterator.next_1(), 83);
      if (multiset.count_0(entry.getElement()) != entry.getCount()) {
        return false;
      }
    }
    return true;
  }
  return false;
}

function setCountImpl(self_0, element, oldCount, newCount){
  $clinit_Multisets();
  checkNonnegative(oldCount, 'oldCount');
  checkNonnegative(newCount, 'newCount');
  if (self_0.count_0(element) == oldCount) {
    self_0.setCount(element, newCount);
    return true;
  }
   else {
    return false;
  }
}

function sizeImpl(multiset){
  $clinit_Multisets();
  var entry, entry$iterator, size_0;
  size_0 = 0;
  for (entry$iterator = $entrySet_0(multiset).iterator_0(); entry$iterator.hasNext_0();) {
    entry = castTo(entry$iterator.next_1(), 83);
    size_0 = add_20(size_0, entry.getCount());
  }
  return saturatedCast(size_0);
}

defineClass(658, 1, $intern_9);
var Lcom_google_common_collect_Ordering_2_classLit = createForClass('com.google.common.collect', 'Ordering', 658);
function $compare(entry1, entry2){
  return compare_3(entry2.getCount(), entry1.getCount());
}

function Multisets$1(){
}

defineClass(398, 658, $intern_9, Multisets$1);
_.compare_0 = function compare_0(entry1, entry2){
  return $compare(castTo(entry1, 83), castTo(entry2, 83));
}
;
var Lcom_google_common_collect_Multisets$1_2_classLit = createForClass('com.google.common.collect', 'Multisets/1', 398);
function Multisets$ImmutableEntry(element, count){
  this.element = element;
  this.count = count;
  checkNonnegative(count, 'count');
}

defineClass(397, 657, {83:1, 3:1}, Multisets$ImmutableEntry);
_.getCount = function getCount_0(){
  return this.count;
}
;
_.getElement = function getElement_0(){
  return this.element;
}
;
_.count = 0;
var Lcom_google_common_collect_Multisets$ImmutableEntry_2_classLit = createForClass('com.google.common.collect', 'Multisets/ImmutableEntry', 397);
function Multisets$MultisetIteratorImpl(multiset, entryIterator){
  this.multiset = multiset;
  this.entryIterator = entryIterator;
}

defineClass(303, 1, $intern_18, Multisets$MultisetIteratorImpl);
_.hasNext_0 = function hasNext_18(){
  return this.laterCount > 0 || this.entryIterator.hasNext_0();
}
;
_.next_1 = function next_19(){
  if (!(this.laterCount > 0 || this.entryIterator.hasNext_0())) {
    throw new NoSuchElementException;
  }
  if (this.laterCount == 0) {
    this.currentEntry = castTo(this.entryIterator.next_1(), 83);
    this.totalCount = this.laterCount = this.currentEntry.getCount();
  }
  --this.laterCount;
  this.canRemove = true;
  return this.currentEntry.getElement();
}
;
_.remove = function remove_39(){
  checkState_0(this.canRemove);
  this.totalCount == 1?this.entryIterator.remove():this.multiset.remove_3(this.currentEntry.getElement(), 1) > 0;
  --this.totalCount;
  this.canRemove = false;
}
;
_.canRemove = false;
_.laterCount = 0;
_.totalCount = 0;
var Lcom_google_common_collect_Multisets$MultisetIteratorImpl_2_classLit = createForClass('com.google.common.collect', 'Multisets/MultisetIteratorImpl', 303);
function $clinit_NaturalOrdering(){
  $clinit_NaturalOrdering = emptyMethod;
  INSTANCE_0 = new NaturalOrdering;
}

function $compare_0(left, right){
  checkNotNull(left);
  checkNotNull(right);
  return compareTo_Ljava_lang_Object__I__devirtual$(left, right);
}

function NaturalOrdering(){
}

defineClass(621, 658, {3:1, 56:1}, NaturalOrdering);
_.compare_0 = function compare_1(left, right){
  return $compare_0(castTo(left, 23), castTo(right, 23));
}
;
_.toString_0 = function toString_31(){
  return 'Ordering.natural()';
}
;
var INSTANCE_0;
var Lcom_google_common_collect_NaturalOrdering_2_classLit = createForClass('com.google.common.collect', 'NaturalOrdering', 621);
function RegularImmutableAsList(delegate, delegateList){
  this.delegate = delegate;
  this.delegateList = delegateList;
}

function RegularImmutableAsList_0(delegate, array){
  $clinit_ImmutableList();
  RegularImmutableAsList.call(this, delegate, unsafeDelegateList(new Arrays$ArrayList(array)));
}

defineClass(343, 660, $intern_32, RegularImmutableAsList_0);
_.listIterator_1 = function listIterator_11(index_0){
  return $listIterator(this.delegateList, index_0);
}
;
_.delegateCollection = function delegateCollection_0(){
  return this.delegate;
}
;
_.get_2 = function get_16(index_0){
  return $get_1(this.delegateList, index_0);
}
;
_.listIterator_2 = function listIterator_10(index_0){
  return $listIterator(this.delegateList, index_0);
}
;
var Lcom_google_common_collect_RegularImmutableAsList_2_classLit = createForClass('com.google.common.collect', 'RegularImmutableAsList', 343);
function $clinit_RegularImmutableBiMap(){
  $clinit_RegularImmutableBiMap = emptyMethod;
  EMPTY_0 = new RegularImmutableBiMap;
}

function RegularImmutableBiMap(){
  ImmutableBiMap.call(this, new RegularImmutableMap(new HashMap));
  this.inverse = this;
}

defineClass(559, 275, $intern_33, RegularImmutableBiMap);
_.inverse_0 = function inverse_0(){
  return this.inverse;
}
;
var EMPTY_0;
var Lcom_google_common_collect_RegularImmutableBiMap_2_classLit = createForClass('com.google.common.collect', 'RegularImmutableBiMap', 559);
function RegularImmutableList(delegate){
  $clinit_ImmutableList();
  this.delegate = ($clinit_Collections() , instanceOf(delegate, 67)?new Collections$UnmodifiableRandomAccessList(delegate):new Collections$UnmodifiableList(delegate));
}

defineClass(53, 666, $intern_32, RegularImmutableList);
_.delegateList_0 = function delegateList_0(){
  return this.delegate;
}
;
var Lcom_google_common_collect_RegularImmutableList_2_classLit = createForClass('com.google.common.collect', 'RegularImmutableList', 53);
function RegularImmutableMap(delegate){
  ForwardingImmutableMap.call(this, delegate);
}

defineClass(321, 320, $intern_33, RegularImmutableMap);
var Lcom_google_common_collect_RegularImmutableMap_2_classLit = createForClass('com.google.common.collect', 'RegularImmutableMap', 321);
function $clinit_RegularImmutableSet(){
  $clinit_RegularImmutableSet = emptyMethod;
  $clinit_ImmutableCollection();
  EMPTY_1 = new RegularImmutableSet(($clinit_Collections() , $clinit_Collections() , EMPTY_SET));
}

function RegularImmutableSet(delegate){
  $clinit_RegularImmutableSet();
  ForwardingImmutableSet.call(this, delegate);
}

defineClass(265, 315, $intern_34, RegularImmutableSet);
var EMPTY_1;
var Lcom_google_common_collect_RegularImmutableSet_2_classLit = createForClass('com.google.common.collect', 'RegularImmutableSet', 265);
function equalsImpl_3(s, object){
  var o;
  if (s === object) {
    return true;
  }
  if (instanceOf(object, 18)) {
    o = castTo(object, 18);
    try {
      return s.size_1() == o.size_1() && s.containsAll(o);
    }
     catch ($e0) {
      $e0 = wrap($e0);
      if (instanceOf($e0, 76)) {
        return false;
      }
       else if (instanceOf($e0, 119)) {
        return false;
      }
       else 
        throw unwrap_5($e0);
    }
  }
  return false;
}

function hashCodeImpl_0(s){
  var hashCode, o, o$iterator;
  hashCode = 0;
  for (o$iterator = s.iterator_0(); o$iterator.hasNext_0();) {
    o = o$iterator.next_1();
    hashCode += o != null?hashCode__I__devirtual$(o):0;
    hashCode = ~~hashCode;
  }
  return hashCode;
}

function intersection(set1, set2){
  var inSet2;
  checkNotNull_0(set1, 'set1');
  checkNotNull_0(set2, 'set2');
  inSet2 = ($clinit_Predicates() , new Predicates$InPredicate(set2));
  return new Sets$2(set1, inSet2, set2);
}

function newHashSet(elements){
  return elements?new HashSet_1(($clinit_Collections2() , elements)):newHashSet_0(null.iterator_0());
}

function newHashSet_0(elements){
  var set_0;
  set_0 = new HashSet;
  addAll_5(set_0, elements);
  return set_0;
}

function newHashSet_1(elements){
  var set_0;
  set_0 = new HashSet_0(capacity_0(elements.length));
  addAll_8(set_0, elements);
  return set_0;
}

defineClass(649, 640, $intern_21);
_.iterator_0 = function iterator_36(){
  var outerIter;
  return filter_1((outerIter = (new AbstractMap$1(this.val$set11.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter)), this.val$inSet22);
}
;
var Lcom_google_common_collect_Sets$SetView_2_classLit = createForClass('com.google.common.collect', 'Sets/SetView', 649);
function $isEmpty(this$static){
  var outerIter;
  return !$hasNext(filter_1((outerIter = (new AbstractMap$1(this$static.val$set11.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter)), this$static.val$inSet22));
}

function Sets$2(val$set1, val$inSet2, val$set2){
  this.val$set11 = val$set1;
  this.val$inSet22 = val$inSet2;
  this.val$set23 = val$set2;
}

defineClass(377, 649, $intern_21, Sets$2);
_.iterator_0 = function iterator_37(){
  var outerIter;
  return filter_1((outerIter = (new AbstractMap$1(this.val$set11.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter)), this.val$inSet22);
}
;
_.contains = function contains_21(object){
  return $contains_7(this.val$set11, object) && $contains_7(this.val$set23, object);
}
;
_.containsAll = function containsAll_6(collection){
  return $containsAll(this.val$set11, collection) && $containsAll(this.val$set23, collection);
}
;
_.isEmpty = function isEmpty_17(){
  return $isEmpty(this);
}
;
_.size_1 = function size_29(){
  var outerIter;
  return size_19(filter_1((outerIter = (new AbstractMap$1(this.val$set11.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter)), this.val$inSet22));
}
;
var Lcom_google_common_collect_Sets$2_2_classLit = createForClass('com.google.common.collect', 'Sets/2', 377);
function SingletonImmutableBiMap(key, value_0){
  ImmutableBiMap.call(this, singletonMap(checkNotNull(key), checkNotNull(value_0)));
  this.singleKey = key;
  this.singleValue = value_0;
}

function SingletonImmutableBiMap_0(key, value_0, inverse){
  ImmutableBiMap.call(this, singletonMap(checkNotNull(key), checkNotNull(value_0)));
  this.singleKey = key;
  this.singleValue = value_0;
  this.inverse = inverse;
}

defineClass(328, 275, $intern_33, SingletonImmutableBiMap, SingletonImmutableBiMap_0);
_.values_0 = function values_11(){
  return $clinit_ImmutableCollection() , new SingletonImmutableSet(this.singleValue);
}
;
_.inverse_0 = function inverse_1(){
  var result;
  result = this.inverse;
  return !result?(this.inverse = new SingletonImmutableBiMap_0(this.singleValue, this.singleKey, this)):result;
}
;
_.values_2 = function values_10(){
  return $clinit_ImmutableCollection() , new SingletonImmutableSet(this.singleValue);
}
;
var Lcom_google_common_collect_SingletonImmutableBiMap_2_classLit = createForClass('com.google.common.collect', 'SingletonImmutableBiMap', 328);
function SingletonImmutableList(element){
  $clinit_ImmutableList();
  this.delegate = ($clinit_Collections() , new Collections$SingletonList(checkNotNull(element)));
}

defineClass(127, 666, $intern_32, SingletonImmutableList);
_.delegateList_0 = function delegateList_1(){
  return this.delegate;
}
;
var Lcom_google_common_collect_SingletonImmutableList_2_classLit = createForClass('com.google.common.collect', 'SingletonImmutableList', 127);
function SingletonImmutableSet(element){
  $clinit_ImmutableCollection();
  this.element = checkNotNull(element);
}

defineClass(135, 662, $intern_34, SingletonImmutableSet);
_.iterator_0 = function iterator_39(){
  return $clinit_Iterators() , new Iterators$11(this.element);
}
;
_.contains = function contains_22(object){
  return equals_Ljava_lang_Object__Z__devirtual$(this.element, object);
}
;
_.iterator_1 = function iterator_38(){
  return $clinit_Iterators() , new Iterators$11(this.element);
}
;
_.size_1 = function size_30(){
  return 1;
}
;
var Lcom_google_common_collect_SingletonImmutableSet_2_classLit = createForClass('com.google.common.collect', 'SingletonImmutableSet', 135);
function $add_4(this$static, element, occurrences){
  var newRoot, newRoot0, result, root;
  checkNonnegative(occurrences, 'occurrences');
  if (occurrences == 0) {
    return $count(this$static, element);
  }
  checkArgument($contains_1(this$static.range, element));
  root = this$static.rootReference.value_0;
  if (!root) {
    this$static.comparator.compare_0(element, element);
    newRoot0 = new TreeMultiset$AvlNode(element, occurrences);
    successor_1(this$static.header, newRoot0, this$static.header);
    $checkAndSet(this$static.rootReference, null, newRoot0);
    return 0;
  }
  result = initUnidimensionalArray(I_classLit, $intern_37, 26, 1, 12, 1);
  newRoot = $add_5(root, this$static.comparator, element, occurrences, result);
  $checkAndSet(this$static.rootReference, root, newRoot);
  return result[0];
}

function $aggregateAboveRange(this$static, aggr, node){
  var cmp;
  if (!node) {
    return 0;
  }
  cmp = this$static.comparator.compare_0(this$static.range.upperEndpoint, node.elem);
  if (cmp > 0) {
    return $aggregateAboveRange(this$static, aggr, node.right);
  }
   else if (cmp == 0) {
    switch (this$static.range.upperBoundType.ordinal) {
      case 0:
        return add_20(aggr.nodeAggregate(node), aggr.treeAggregate(node.right));
      case 1:
        return aggr.treeAggregate(node.right);
      default:throw new AssertionError;
    }
  }
   else {
    return add_20(add_20(aggr.treeAggregate(node.right), aggr.nodeAggregate(node)), $aggregateAboveRange(this$static, aggr, node.left));
  }
}

function $aggregateBelowRange(this$static, aggr, node){
  var cmp;
  if (!node) {
    return 0;
  }
  cmp = this$static.comparator.compare_0(this$static.range.lowerEndpoint, node.elem);
  if (cmp < 0) {
    return $aggregateBelowRange(this$static, aggr, node.left);
  }
   else if (cmp == 0) {
    switch (this$static.range.lowerBoundType.ordinal) {
      case 0:
        return add_20(aggr.nodeAggregate(node), aggr.treeAggregate(node.left));
      case 1:
        return aggr.treeAggregate(node.left);
      default:throw new AssertionError;
    }
  }
   else {
    return add_20(add_20(aggr.treeAggregate(node.left), aggr.nodeAggregate(node)), $aggregateBelowRange(this$static, aggr, node.right));
  }
}

function $aggregateForEntries(this$static, aggr){
  var root, total;
  root = this$static.rootReference.value_0;
  total = aggr.treeAggregate(root);
  this$static.range.hasLowerBound && (total = sub_1(total, $aggregateBelowRange(this$static, aggr, root)));
  this$static.range.hasUpperBound && (total = sub_1(total, $aggregateAboveRange(this$static, aggr, root)));
  return total;
}

function $count(this$static, element){
  var root;
  try {
    root = this$static.rootReference.value_0;
    if (!$contains_1(this$static.range, element) || !root) {
      return 0;
    }
    return $count_0(root, this$static.comparator, element);
  }
   catch ($e0) {
    $e0 = wrap($e0);
    if (instanceOf($e0, 119)) {
      return 0;
    }
     else if (instanceOf($e0, 76)) {
      return 0;
    }
     else 
      throw unwrap_5($e0);
  }
}

function $firstNode(this$static){
  var endpoint, node, root;
  root = this$static.rootReference.value_0;
  if (!root) {
    return null;
  }
  if (this$static.range.hasLowerBound) {
    endpoint = this$static.range.lowerEndpoint;
    node = $ceiling(this$static.rootReference.value_0, this$static.comparator, endpoint);
    if (!node) {
      return null;
    }
    this$static.range.lowerBoundType == ($clinit_BoundType() , OPEN) && this$static.comparator.compare_0(endpoint, node.elem) == 0 && (node = node.succ);
  }
   else {
    node = this$static.header.succ;
  }
  return node == this$static.header || !$contains_1(this$static.range, node.elem)?null:node;
}

function $headMultiset(this$static, upperBound, boundType){
  return new TreeMultiset(this$static.rootReference, $intersect(this$static.range, upTo(this$static.comparator, upperBound, boundType)), this$static.header);
}

function $remove_4(this$static, element, occurrences){
  var newRoot, result, root;
  checkNonnegative(occurrences, 'occurrences');
  if (occurrences == 0) {
    return $count(this$static, element);
  }
  root = this$static.rootReference.value_0;
  result = initUnidimensionalArray(I_classLit, $intern_37, 26, 1, 12, 1);
  try {
    if (!$contains_1(this$static.range, element) || !root) {
      return 0;
    }
    newRoot = $remove_5(root, this$static.comparator, element, occurrences, result);
  }
   catch ($e0) {
    $e0 = wrap($e0);
    if (instanceOf($e0, 119)) {
      return 0;
    }
     else if (instanceOf($e0, 76)) {
      return 0;
    }
     else 
      throw unwrap_5($e0);
  }
  $checkAndSet(this$static.rootReference, root, newRoot);
  return result[0];
}

function $setCount(this$static, element, count){
  var newRoot, result, root;
  checkNonnegative(count, 'count');
  if (!$contains_1(this$static.range, element)) {
    checkArgument(count == 0);
    return 0;
  }
  root = this$static.rootReference.value_0;
  if (!root) {
    count > 0 && $add_4(this$static, element, count);
    return 0;
  }
  result = initUnidimensionalArray(I_classLit, $intern_37, 26, 1, 12, 1);
  newRoot = $setCount_1(root, this$static.comparator, element, count, result);
  $checkAndSet(this$static.rootReference, root, newRoot);
  return result[0];
}

function TreeMultiset(rootReference, range, endLink){
  AbstractSortedMultiset.call(this, range.comparator);
  this.rootReference = rootReference;
  this.range = range;
  this.header = endLink;
}

function TreeMultiset_0(comparator){
  AbstractSortedMultiset.call(this, comparator);
  this.range = new GeneralRange(comparator, false, null, ($clinit_BoundType() , OPEN), false, null, OPEN);
  this.header = new TreeMultiset$AvlNode(null, 1);
  successor_0(this.header, this.header);
  this.rootReference = new TreeMultiset$Reference;
}

function distinctElements_1(node){
  return !node?0:node.distinctElements;
}

function successor_0(a, b){
  a.succ = b;
  b.pred = a;
}

function successor_1(a, b, c){
  a.succ = b;
  b.pred = a;
  b.succ = c;
  c.pred = b;
}

defineClass(285, 342, {207:1, 3:1, 22:1, 19:1}, TreeMultiset, TreeMultiset_0);
_.add_3 = function add_18(element, occurrences){
  return $add_4(this, element, occurrences);
}
;
_.count_0 = function count_2(element){
  return $count(this, element);
}
;
_.distinctElements_0 = function distinctElements_0(){
  return saturatedCast($aggregateForEntries(this, ($clinit_TreeMultiset$Aggregate() , DISTINCT)));
}
;
_.entryIterator_0 = function entryIterator_1(){
  return new TreeMultiset$2(this);
}
;
_.remove_3 = function remove_40(element, occurrences){
  return $remove_4(this, element, occurrences);
}
;
_.setCount = function setCount_1(element, count){
  return $setCount(this, element, count);
}
;
_.setCount_0 = function setCount_2(element, oldCount, newCount){
  var newRoot, result, root;
  checkNonnegative(newCount, 'newCount');
  checkNonnegative(oldCount, 'oldCount');
  checkArgument($contains_1(this.range, element));
  root = this.rootReference.value_0;
  if (!root) {
    if (oldCount == 0) {
      newCount > 0 && $add_4(this, element, newCount);
      return true;
    }
     else {
      return false;
    }
  }
  result = initUnidimensionalArray(I_classLit, $intern_37, 26, 1, 12, 1);
  newRoot = $setCount_0(root, this.comparator, element, oldCount, newCount, result);
  $checkAndSet(this.rootReference, root, newRoot);
  return result[0] == oldCount;
}
;
_.size_1 = function size_31(){
  return saturatedCast($aggregateForEntries(this, ($clinit_TreeMultiset$Aggregate() , SIZE)));
}
;
var Lcom_google_common_collect_TreeMultiset_2_classLit = createForClass('com.google.common.collect', 'TreeMultiset', 285);
function TreeMultiset$1(this$0, val$baseEntry){
  this.this$01 = this$0;
  this.val$baseEntry2 = val$baseEntry;
}

defineClass(618, 657, {83:1}, TreeMultiset$1);
_.getCount = function getCount_1(){
  var result;
  result = this.val$baseEntry2.elemCount;
  return result == 0?$count(this.this$01, this.val$baseEntry2.elem):result;
}
;
_.getElement = function getElement_1(){
  return this.val$baseEntry2.elem;
}
;
var Lcom_google_common_collect_TreeMultiset$1_2_classLit = createForClass('com.google.common.collect', 'TreeMultiset/1', 618);
function $hasNext_1(this$static){
  if (!this$static.current) {
    return false;
  }
   else if ($tooHigh(this$static.this$01.range, this$static.current.elem)) {
    this$static.current = null;
    return false;
  }
   else {
    return true;
  }
}

function $next_5(this$static){
  var result;
  if (!$hasNext_1(this$static)) {
    throw new NoSuchElementException;
  }
  result = new TreeMultiset$1(this$static.this$01, this$static.current);
  this$static.prevEntry = result;
  this$static.current.succ == this$static.this$01.header?(this$static.current = null):(this$static.current = this$static.current.succ);
  return result;
}

function TreeMultiset$2(this$0){
  this.this$01 = this$0;
  this.current = $firstNode(this.this$01);
}

defineClass(619, 1, $intern_18, TreeMultiset$2);
_.next_1 = function next_20(){
  return $next_5(this);
}
;
_.hasNext_0 = function hasNext_19(){
  return $hasNext_1(this);
}
;
_.remove = function remove_41(){
  checkState_0(!!this.prevEntry);
  $setCount(this.this$01, this.prevEntry.val$baseEntry2.elem, 0);
  this.prevEntry = null;
}
;
var Lcom_google_common_collect_TreeMultiset$2_2_classLit = createForClass('com.google.common.collect', 'TreeMultiset/2', 619);
function $clinit_TreeMultiset$Aggregate(){
  $clinit_TreeMultiset$Aggregate = emptyMethod;
  SIZE = new TreeMultiset$Aggregate$1;
  DISTINCT = new TreeMultiset$Aggregate$2;
}

function TreeMultiset$Aggregate(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function values_12(){
  $clinit_TreeMultiset$Aggregate();
  return stampJavaTypeInfo(getClassLiteralForArray(Lcom_google_common_collect_TreeMultiset$Aggregate_2_classLit, 1), $intern_13, 205, 0, [SIZE, DISTINCT]);
}

defineClass(205, 17, $intern_38);
var DISTINCT, SIZE;
var Lcom_google_common_collect_TreeMultiset$Aggregate_2_classLit = createForEnum('com.google.common.collect', 'TreeMultiset/Aggregate', 205, Ljava_lang_Enum_2_classLit, values_12);
function TreeMultiset$Aggregate$1(){
  TreeMultiset$Aggregate.call(this, 'SIZE', 0);
}

defineClass(616, 205, $intern_38, TreeMultiset$Aggregate$1);
_.nodeAggregate = function nodeAggregate(node){
  return node.elemCount;
}
;
_.treeAggregate = function treeAggregate(root){
  return !root?0:root.totalCount;
}
;
var Lcom_google_common_collect_TreeMultiset$Aggregate$1_2_classLit = createForEnum('com.google.common.collect', 'TreeMultiset/Aggregate/1', 616, Lcom_google_common_collect_TreeMultiset$Aggregate_2_classLit, null);
function TreeMultiset$Aggregate$2(){
  TreeMultiset$Aggregate.call(this, 'DISTINCT', 1);
}

defineClass(617, 205, $intern_38, TreeMultiset$Aggregate$2);
_.nodeAggregate = function nodeAggregate_0(node){
  return 1;
}
;
_.treeAggregate = function treeAggregate_0(root){
  return !root?0:root.distinctElements;
}
;
var Lcom_google_common_collect_TreeMultiset$Aggregate$2_2_classLit = createForEnum('com.google.common.collect', 'TreeMultiset/Aggregate/2', 617, Lcom_google_common_collect_TreeMultiset$Aggregate_2_classLit, null);
function $add_5(this$static, comparator, e, count, result){
  var cmp, initHeight, initLeft, initRight, resultCount;
  cmp = comparator.compare_0(e, this$static.elem);
  if (cmp < 0) {
    initLeft = this$static.left;
    if (!initLeft) {
      result[0] = 0;
      return $addLeftChild(this$static, e, count);
    }
    initHeight = initLeft.height;
    this$static.left = $add_5(initLeft, comparator, e, count, result);
    result[0] == 0 && ++this$static.distinctElements;
    this$static.totalCount = add_20(this$static.totalCount, count);
    return this$static.left.height == initHeight?this$static:$rebalance(this$static);
  }
   else if (cmp > 0) {
    initRight = this$static.right;
    if (!initRight) {
      result[0] = 0;
      return $addRightChild(this$static, e, count);
    }
    initHeight = initRight.height;
    this$static.right = $add_5(initRight, comparator, e, count, result);
    result[0] == 0 && ++this$static.distinctElements;
    this$static.totalCount = add_20(this$static.totalCount, count);
    return this$static.right.height == initHeight?this$static:$rebalance(this$static);
  }
  result[0] = this$static.elemCount;
  resultCount = add_20(this$static.elemCount, count);
  checkArgument(compare_5(resultCount, $intern_3) <= 0);
  this$static.elemCount += count;
  this$static.totalCount = add_20(this$static.totalCount, count);
  return this$static;
}

function $addLeftChild(this$static, e, count){
  this$static.left = new TreeMultiset$AvlNode(e, count);
  successor_1(this$static.pred, this$static.left, this$static);
  this$static.height = max_3(2, this$static.height);
  ++this$static.distinctElements;
  this$static.totalCount = add_20(this$static.totalCount, count);
  return this$static;
}

function $addRightChild(this$static, e, count){
  this$static.right = new TreeMultiset$AvlNode(e, count);
  successor_1(this$static, this$static.right, this$static.succ);
  this$static.height = max_3(2, this$static.height);
  ++this$static.distinctElements;
  this$static.totalCount = add_20(this$static.totalCount, count);
  return this$static;
}

function $balanceFactor(this$static){
  return height_0(this$static.left) - height_0(this$static.right);
}

function $ceiling(this$static, comparator, e){
  var cmp;
  cmp = comparator.compare_0(e, this$static.elem);
  return cmp < 0?!this$static.left?this$static:castTo(firstNonNull($ceiling(this$static.left, comparator, e), this$static), 206):cmp == 0?this$static:!this$static.right?null:$ceiling(this$static.right, comparator, e);
}

function $count_0(this$static, comparator, e){
  var cmp;
  cmp = comparator.compare_0(e, this$static.elem);
  return cmp < 0?!this$static.left?0:$count_0(this$static.left, comparator, e):cmp > 0?!this$static.right?0:$count_0(this$static.right, comparator, e):this$static.elemCount;
}

function $deleteMe(this$static){
  var newTop, oldElemCount;
  oldElemCount = this$static.elemCount;
  this$static.elemCount = 0;
  successor_0(this$static.pred, this$static.succ);
  if (!this$static.left) {
    return this$static.right;
  }
   else if (!this$static.right) {
    return this$static.left;
  }
   else if (this$static.left.height >= this$static.right.height) {
    newTop = this$static.pred;
    newTop.left = $removeMax(this$static.left, newTop);
    newTop.right = this$static.right;
    newTop.distinctElements = this$static.distinctElements - 1;
    newTop.totalCount = sub_1(this$static.totalCount, oldElemCount);
    return $rebalance(newTop);
  }
   else {
    newTop = this$static.succ;
    newTop.right = $removeMin(this$static.right, newTop);
    newTop.left = this$static.left;
    newTop.distinctElements = this$static.distinctElements - 1;
    newTop.totalCount = sub_1(this$static.totalCount, oldElemCount);
    return $rebalance(newTop);
  }
}

function $rebalance(this$static){
  switch (height_0(this$static.left) - height_0(this$static.right)) {
    case -2:
      $balanceFactor(this$static.right) > 0 && (this$static.right = $rotateRight(this$static.right));
      return $rotateLeft(this$static);
    case 2:
      $balanceFactor(this$static.left) < 0 && (this$static.left = $rotateLeft(this$static.left));
      return $rotateRight(this$static);
    default:this$static.height = 1 + max_3(height_0(this$static.left), height_0(this$static.right));
      return this$static;
  }
}

function $remove_5(this$static, comparator, e, count, result){
  var cmp, initLeft, initRight;
  cmp = comparator.compare_0(e, this$static.elem);
  if (cmp < 0) {
    initLeft = this$static.left;
    if (!initLeft) {
      result[0] = 0;
      return this$static;
    }
    this$static.left = $remove_5(initLeft, comparator, e, count, result);
    if (result[0] > 0) {
      if (count >= result[0]) {
        --this$static.distinctElements;
        this$static.totalCount = sub_1(this$static.totalCount, result[0]);
      }
       else {
        this$static.totalCount = sub_1(this$static.totalCount, count);
      }
    }
    return result[0] == 0?this$static:$rebalance(this$static);
  }
   else if (cmp > 0) {
    initRight = this$static.right;
    if (!initRight) {
      result[0] = 0;
      return this$static;
    }
    this$static.right = $remove_5(initRight, comparator, e, count, result);
    if (result[0] > 0) {
      if (count >= result[0]) {
        --this$static.distinctElements;
        this$static.totalCount = sub_1(this$static.totalCount, result[0]);
      }
       else {
        this$static.totalCount = sub_1(this$static.totalCount, count);
      }
    }
    return $rebalance(this$static);
  }
  result[0] = this$static.elemCount;
  if (count >= this$static.elemCount) {
    return $deleteMe(this$static);
  }
   else {
    this$static.elemCount -= count;
    this$static.totalCount = sub_1(this$static.totalCount, count);
    return this$static;
  }
}

function $removeMax(this$static, node){
  if (!this$static.right) {
    return this$static.left;
  }
   else {
    this$static.right = $removeMax(this$static.right, node);
    --this$static.distinctElements;
    this$static.totalCount = sub_1(this$static.totalCount, node.elemCount);
    return $rebalance(this$static);
  }
}

function $removeMin(this$static, node){
  if (!this$static.left) {
    return this$static.right;
  }
   else {
    this$static.left = $removeMin(this$static.left, node);
    --this$static.distinctElements;
    this$static.totalCount = sub_1(this$static.totalCount, node.elemCount);
    return $rebalance(this$static);
  }
}

function $rotateLeft(this$static){
  var newTop;
  checkState(!!this$static.right);
  newTop = this$static.right;
  this$static.right = newTop.left;
  newTop.left = this$static;
  newTop.totalCount = this$static.totalCount;
  newTop.distinctElements = this$static.distinctElements;
  this$static.distinctElements = 1 + distinctElements_1(this$static.left) + distinctElements_1(this$static.right);
  this$static.totalCount = add_20(add_20(this$static.elemCount, totalCount(this$static.left)), totalCount(this$static.right));
  this$static.height = 1 + max_3(height_0(this$static.left), height_0(this$static.right));
  newTop.height = 1 + max_3(height_0(newTop.left), height_0(newTop.right));
  return newTop;
}

function $rotateRight(this$static){
  var newTop;
  checkState(!!this$static.left);
  newTop = this$static.left;
  this$static.left = newTop.right;
  newTop.right = this$static;
  newTop.totalCount = this$static.totalCount;
  newTop.distinctElements = this$static.distinctElements;
  this$static.distinctElements = 1 + distinctElements_1(this$static.left) + distinctElements_1(this$static.right);
  this$static.totalCount = add_20(add_20(this$static.elemCount, totalCount(this$static.left)), totalCount(this$static.right));
  this$static.height = 1 + max_3(height_0(this$static.left), height_0(this$static.right));
  newTop.height = 1 + max_3(height_0(newTop.left), height_0(newTop.right));
  return newTop;
}

function $setCount_0(this$static, comparator, e, expectedCount, newCount, result){
  var cmp, initLeft, initRight;
  cmp = comparator.compare_0(e, this$static.elem);
  if (cmp < 0) {
    initLeft = this$static.left;
    if (!initLeft) {
      result[0] = 0;
      if (expectedCount == 0 && newCount > 0) {
        return $addLeftChild(this$static, e, newCount);
      }
      return this$static;
    }
    this$static.left = $setCount_0(initLeft, comparator, e, expectedCount, newCount, result);
    if (result[0] == expectedCount) {
      newCount == 0 && result[0] != 0?--this$static.distinctElements:newCount > 0 && result[0] == 0 && ++this$static.distinctElements;
      this$static.totalCount = add_20(this$static.totalCount, newCount - result[0]);
    }
    return $rebalance(this$static);
  }
   else if (cmp > 0) {
    initRight = this$static.right;
    if (!initRight) {
      result[0] = 0;
      if (expectedCount == 0 && newCount > 0) {
        return $addRightChild(this$static, e, newCount);
      }
      return this$static;
    }
    this$static.right = $setCount_0(initRight, comparator, e, expectedCount, newCount, result);
    if (result[0] == expectedCount) {
      newCount == 0 && result[0] != 0?--this$static.distinctElements:newCount > 0 && result[0] == 0 && ++this$static.distinctElements;
      this$static.totalCount = add_20(this$static.totalCount, newCount - result[0]);
    }
    return $rebalance(this$static);
  }
  result[0] = this$static.elemCount;
  if (expectedCount == this$static.elemCount) {
    if (newCount == 0) {
      return $deleteMe(this$static);
    }
    this$static.totalCount = add_20(this$static.totalCount, newCount - this$static.elemCount);
    this$static.elemCount = newCount;
  }
  return this$static;
}

function $setCount_1(this$static, comparator, e, count, result){
  var cmp, initLeft, initRight;
  cmp = comparator.compare_0(e, this$static.elem);
  if (cmp < 0) {
    initLeft = this$static.left;
    if (!initLeft) {
      result[0] = 0;
      return count > 0?$addLeftChild(this$static, e, count):this$static;
    }
    this$static.left = $setCount_1(initLeft, comparator, e, count, result);
    count == 0 && result[0] != 0?--this$static.distinctElements:count > 0 && result[0] == 0 && ++this$static.distinctElements;
    this$static.totalCount = add_20(this$static.totalCount, count - result[0]);
    return $rebalance(this$static);
  }
   else if (cmp > 0) {
    initRight = this$static.right;
    if (!initRight) {
      result[0] = 0;
      return count > 0?$addRightChild(this$static, e, count):this$static;
    }
    this$static.right = $setCount_1(initRight, comparator, e, count, result);
    count == 0 && result[0] != 0?--this$static.distinctElements:count > 0 && result[0] == 0 && ++this$static.distinctElements;
    this$static.totalCount = add_20(this$static.totalCount, count - result[0]);
    return $rebalance(this$static);
  }
  result[0] = this$static.elemCount;
  if (count == 0) {
    return $deleteMe(this$static);
  }
  this$static.totalCount = add_20(this$static.totalCount, count - this$static.elemCount);
  this$static.elemCount = count;
  return this$static;
}

function TreeMultiset$AvlNode(elem, elemCount){
  checkArgument(elemCount > 0);
  this.elem = elem;
  this.elemCount = elemCount;
  this.totalCount = elemCount;
  this.distinctElements = 1;
  this.height = 1;
  this.left = null;
  this.right = null;
}

function height_0(node){
  return !node?0:node.height;
}

function totalCount(node){
  return !node?0:node.totalCount;
}

defineClass(206, 657, {83:1, 206:1}, TreeMultiset$AvlNode);
_.getCount = function getCount_2(){
  return this.elemCount;
}
;
_.getElement = function getElement_2(){
  return this.elem;
}
;
_.toString_0 = function toString_32(){
  return $clinit_Multisets() , $toString_6(new Multisets$ImmutableEntry(this.elem, this.elemCount));
}
;
_.distinctElements = 0;
_.elemCount = 0;
_.height = 0;
_.totalCount = 0;
var Lcom_google_common_collect_TreeMultiset$AvlNode_2_classLit = createForClass('com.google.common.collect', 'TreeMultiset/AvlNode', 206);
function $checkAndSet(this$static, expected, newValue){
  if (this$static.value_0 != expected) {
    throw new ConcurrentModificationException;
  }
  this$static.value_0 = newValue;
}

function TreeMultiset$Reference(){
}

defineClass(615, 1, {}, TreeMultiset$Reference);
var Lcom_google_common_collect_TreeMultiset$Reference_2_classLit = createForClass('com.google.common.collect', 'TreeMultiset/Reference', 615);
function $clinit_DoubleMath(){
  $clinit_DoubleMath = emptyMethod;
  Math.log(2);
}

function fuzzyEquals(a, b){
  $clinit_DoubleMath();
  return (a - b > 0?a - b:-(a - b)) <= $intern_39 || a == b || isNaN(a) && isNaN(b);
}

function compare_2(a, b){
  return a == b?0:a?1:-1;
}

function compare_3(a, b){
  return a < b?-1:a > b?1:0;
}

function saturatedCast(value_0){
  if (compare_5(value_0, $intern_3) > 0) {
    return $intern_3;
  }
  if (compare_5(value_0, $intern_8) < 0) {
    return $intern_8;
  }
  return toInt(value_0);
}

var Lcom_google_gwt_core_client_JavaScriptObject_2_classLit = createForClass('com.google.gwt.core.client', 'JavaScriptObject$', 0);
function now_1(){
  if (Date.now) {
    return Date.now();
  }
  return (new Date).getTime();
}

function escapeChar(c, escapeTable){
  var lookedUp = escapeTable_0[c.charCodeAt(0)];
  return lookedUp == null?c:lookedUp;
}

function escapeValue(toEscape){
  var escapeTable = (!escapeTable_0 && (escapeTable_0 = initEscapeTable()) , escapeTable_0);
  var s = toEscape.replace(/[\x00-\x1f\xad\u0600-\u0603\u06dd\u070f\u17b4\u17b5\u200b-\u200f\u2028-\u202e\u2060-\u2064\u206a-\u206f\ufeff\ufff9-\ufffb"\\]/g, function(x_0){
    return escapeChar(x_0, escapeTable);
  }
  );
  return '"' + s + '"';
}

function initEscapeTable(){
  var out = ['\\u0000', '\\u0001', '\\u0002', '\\u0003', '\\u0004', '\\u0005', '\\u0006', '\\u0007', '\\b', '\\t', '\\n', '\\u000B', '\\f', '\\r', '\\u000E', '\\u000F', '\\u0010', '\\u0011', '\\u0012', '\\u0013', '\\u0014', '\\u0015', '\\u0016', '\\u0017', '\\u0018', '\\u0019', '\\u001A', '\\u001B', '\\u001C', '\\u001D', '\\u001E', '\\u001F'];
  out[34] = '\\"';
  out[92] = '\\\\';
  out[173] = '\\u00ad';
  out[1536] = '\\u0600';
  out[1537] = '\\u0601';
  out[1538] = '\\u0602';
  out[1539] = '\\u0603';
  out[1757] = '\\u06dd';
  out[1807] = '\\u070f';
  out[6068] = '\\u17b4';
  out[6069] = '\\u17b5';
  out[8203] = '\\u200b';
  out[8204] = '\\u200c';
  out[8205] = '\\u200d';
  out[8206] = '\\u200e';
  out[8207] = '\\u200f';
  out[8232] = '\\u2028';
  out[8233] = '\\u2029';
  out[8234] = '\\u202a';
  out[8235] = '\\u202b';
  out[8236] = '\\u202c';
  out[8237] = '\\u202d';
  out[8238] = '\\u202e';
  out[8288] = '\\u2060';
  out[8289] = '\\u2061';
  out[8290] = '\\u2062';
  out[8291] = '\\u2063';
  out[8292] = '\\u2064';
  out[8298] = '\\u206a';
  out[8299] = '\\u206b';
  out[8300] = '\\u206c';
  out[8301] = '\\u206d';
  out[8302] = '\\u206e';
  out[8303] = '\\u206f';
  out[65279] = '\\ufeff';
  out[65529] = '\\ufff9';
  out[65530] = '\\ufffa';
  out[65531] = '\\ufffb';
  return out;
}

var escapeTable_0;
defineClass(627, 1, {});
var Lcom_google_gwt_core_client_Scheduler_2_classLit = createForClass('com.google.gwt.core.client', 'Scheduler', 627);
function apply_12(jsFunction, thisObj, args){
  return jsFunction.apply(thisObj, args);
  var __0;
}

function enter_0(){
  var now_0;
  if (entryDepth != 0) {
    now_0 = now_1();
    if (now_0 - watchdogEntryDepthLastScheduled > 2000) {
      watchdogEntryDepthLastScheduled = now_0;
      watchdogEntryDepthTimerId = $wnd.setTimeout(watchdogEntryDepthRun, 10);
    }
  }
  if (entryDepth++ == 0) {
    $flushEntryCommands(($clinit_SchedulerImpl() , INSTANCE_1));
    return true;
  }
  return false;
}

function entry_0(jsFunction){
  return function(){
    return entry0_0(jsFunction, this, arguments);
    var __0;
  }
  ;
}

function entry0_0(jsFunction, thisObj, args){
  var initialEntry;
  initialEntry = enter_0();
  try {
    return apply_12(jsFunction, thisObj, args);
  }
   finally {
    exit(initialEntry);
  }
}

function exit(initialEntry){
  initialEntry && $flushFinallyCommands(($clinit_SchedulerImpl() , INSTANCE_1));
  --entryDepth;
  if (initialEntry) {
    if (watchdogEntryDepthTimerId != -1) {
      watchdogEntryDepthCancel(watchdogEntryDepthTimerId);
      watchdogEntryDepthTimerId = -1;
    }
  }
}

function reportToBrowser(e){
  $wnd.setTimeout(function(){
    throw e;
  }
  , 0);
}

function watchdogEntryDepthCancel(timerId){
  $wnd.clearTimeout(timerId);
}

function watchdogEntryDepthRun(){
  entryDepth != 0 && (entryDepth = 0);
  watchdogEntryDepthTimerId = -1;
}

var entryDepth = 0, watchdogEntryDepthLastScheduled = 0, watchdogEntryDepthTimerId = -1;
function $clinit_SchedulerImpl(){
  $clinit_SchedulerImpl = emptyMethod;
  INSTANCE_1 = new SchedulerImpl;
}

function $flushEntryCommands(this$static){
  var oldQueue, rescheduled;
  if (this$static.entryCommands) {
    rescheduled = null;
    do {
      oldQueue = this$static.entryCommands;
      this$static.entryCommands = null;
      rescheduled = runScheduledTasks(oldQueue, rescheduled);
    }
     while (this$static.entryCommands);
    this$static.entryCommands = rescheduled;
  }
}

function $flushFinallyCommands(this$static){
  var oldQueue, rescheduled;
  if (this$static.finallyCommands) {
    rescheduled = null;
    do {
      oldQueue = this$static.finallyCommands;
      this$static.finallyCommands = null;
      rescheduled = runScheduledTasks(oldQueue, rescheduled);
    }
     while (this$static.finallyCommands);
    this$static.finallyCommands = rescheduled;
  }
}

function SchedulerImpl(){
}

function push_0(queue, task){
  !queue && (queue = []);
  queue[queue.length] = task;
  return queue;
}

function runScheduledTasks(tasks, rescheduled){
  var e, i, j, t;
  for (i = 0 , j = tasks.length; i < j; i++) {
    t = tasks[i];
    try {
      t[1]?t[0].$_nullMethod() && (rescheduled = push_0(rescheduled, t)):t[0].$_nullMethod();
    }
     catch ($e0) {
      $e0 = wrap($e0);
      if (instanceOf($e0, 46)) {
        e = $e0;
        reportToBrowser(instanceOf(e, 164)?castTo(e, 164).getThrown():e);
      }
       else 
        throw unwrap_5($e0);
    }
  }
  return rescheduled;
}

defineClass(360, 627, {}, SchedulerImpl);
var INSTANCE_1;
var Lcom_google_gwt_core_client_impl_SchedulerImpl_2_classLit = createForClass('com.google.gwt.core.client.impl', 'SchedulerImpl', 360);
defineClass(645, 1, {});
_.isArray_0 = function isArray(){
  return null;
}
;
_.isBoolean = function isBoolean(){
  return null;
}
;
_.isNumber = function isNumber(){
  return null;
}
;
_.isObject = function isObject(){
  return null;
}
;
_.isString = function isString(){
  return null;
}
;
var Lcom_google_gwt_json_client_JSONValue_2_classLit = createForClass('com.google.gwt.json.client', 'JSONValue', 645);
function $get_5(this$static, index_0){
  var v = this$static.jsArray[index_0];
  var func = ($clinit_JSONParser() , typeMap)[typeof v];
  return func?func(v):throwUnknownTypeException(typeof v);
}

function $set_0(this$static, index_0, value_0){
  var previous;
  previous = $get_5(this$static, index_0);
  $set0(this$static, index_0, value_0);
  return previous;
}

function $set0(this$static, index_0, value_0){
  if (value_0) {
    var func = value_0.getUnwrapper();
    value_0 = func(value_0);
  }
   else {
    value_0 = undefined;
  }
  this$static.jsArray[index_0] = value_0;
}

function JSONArray(){
  this.jsArray = [];
}

function JSONArray_0(arr){
  this.jsArray = arr;
}

function unwrap(value_0){
  return value_0.jsArray;
}

defineClass(214, 645, {214:1}, JSONArray, JSONArray_0);
_.equals = function equals_25(other){
  if (!instanceOf(other, 214)) {
    return false;
  }
  return this.jsArray == castTo(other, 214).jsArray;
}
;
_.getUnwrapper = function getUnwrapper(){
  return unwrap;
}
;
_.hashCode_0 = function hashCode_25(){
  return getObjectIdentityHashCode(this.jsArray);
}
;
_.isArray_0 = function isArray_0(){
  return this;
}
;
_.toString_0 = function toString_34(){
  var c, i, sb;
  sb = new StringBuilder_1('[');
  for (i = 0 , c = this.jsArray.length; i < c; i++) {
    i > 0 && (sb.string += ',' , sb);
    $append_2(sb, $get_5(this, i));
  }
  sb.string += ']';
  return sb.string;
}
;
var Lcom_google_gwt_json_client_JSONArray_2_classLit = createForClass('com.google.gwt.json.client', 'JSONArray', 214);
function $clinit_JSONBoolean(){
  $clinit_JSONBoolean = emptyMethod;
  FALSE = new JSONBoolean(false);
  TRUE = new JSONBoolean(true);
}

function JSONBoolean(value_0){
  this.value_0 = value_0;
}

function unwrap_0(value_0){
  return value_0.value_0;
}

defineClass(292, 645, {}, JSONBoolean);
_.getUnwrapper = function getUnwrapper_0(){
  return unwrap_0;
}
;
_.isBoolean = function isBoolean_0(){
  return this;
}
;
_.toString_0 = function toString_35(){
  return toString_72(this.value_0);
}
;
_.value_0 = false;
var FALSE, TRUE;
var Lcom_google_gwt_json_client_JSONBoolean_2_classLit = createForClass('com.google.gwt.json.client', 'JSONBoolean', 292);
function JSONException(message){
  RuntimeException_0.call(this, message);
}

defineClass(371, 72, $intern_2, JSONException);
var Lcom_google_gwt_json_client_JSONException_2_classLit = createForClass('com.google.gwt.json.client', 'JSONException', 371);
function $clinit_JSONNull(){
  $clinit_JSONNull = emptyMethod;
  instance = new JSONNull;
}

function JSONNull(){
}

function unwrap_1(){
  return null;
}

defineClass(435, 645, {}, JSONNull);
_.getUnwrapper = function getUnwrapper_1(){
  return unwrap_1;
}
;
_.toString_0 = function toString_36(){
  return 'null';
}
;
var instance;
var Lcom_google_gwt_json_client_JSONNull_2_classLit = createForClass('com.google.gwt.json.client', 'JSONNull', 435);
function JSONNumber(value_0){
  this.value_0 = value_0;
}

function unwrap_2(value_0){
  return value_0.value_0;
}

defineClass(104, 645, {104:1}, JSONNumber);
_.equals = function equals_26(other){
  if (!instanceOf(other, 104)) {
    return false;
  }
  return this.value_0 == castTo(other, 104).value_0;
}
;
_.getUnwrapper = function getUnwrapper_2(){
  return unwrap_2;
}
;
_.hashCode_0 = function hashCode_26(){
  return round_int(checkNotNull_1(this.value_0));
}
;
_.isNumber = function isNumber_0(){
  return this;
}
;
_.toString_0 = function toString_37(){
  return this.value_0 + '';
}
;
_.value_0 = 0;
var Lcom_google_gwt_json_client_JSONNumber_2_classLit = createForClass('com.google.gwt.json.client', 'JSONNumber', 104);
function $computeKeys0(this$static, result){
  var jsObject = this$static.jsObject;
  var i = 0;
  for (var key in jsObject) {
    jsObject.hasOwnProperty(key) && (result[i++] = key);
  }
  return result;
}

function $containsKey_0(this$static, key){
  return key in this$static.jsObject;
}

function $get_6(this$static, key){
  if (key == null) {
    throw new NullPointerException;
  }
  return $get0(this$static, key);
}

function $get0(this$static, key){
  var jsObject = this$static.jsObject;
  var v;
  key = String(key);
  jsObject.hasOwnProperty(key) && (v = jsObject[key]);
  var func = ($clinit_JSONParser() , typeMap)[typeof v];
  var ret = func?func(v):throwUnknownTypeException(typeof v);
  return ret;
}

function $put_1(this$static, key, jsonValue){
  var previous;
  if (key == null) {
    throw new NullPointerException;
  }
  previous = $get_6(this$static, key);
  $put0(this$static, key, jsonValue);
  return previous;
}

function $put0(this$static, key, value_0){
  if (value_0) {
    var func = value_0.getUnwrapper();
    this$static.jsObject[key] = func(value_0);
  }
   else {
    delete this$static.jsObject[key];
  }
}

function JSONObject(){
  JSONObject_0.call(this, {});
}

function JSONObject_0(jsValue){
  this.jsObject = jsValue;
}

function unwrap_3(value_0){
  return value_0.jsObject;
}

defineClass(69, 645, {69:1}, JSONObject, JSONObject_0);
_.equals = function equals_27(other){
  if (!instanceOf(other, 69)) {
    return false;
  }
  return this.jsObject == castTo(other, 69).jsObject;
}
;
_.getUnwrapper = function getUnwrapper_3(){
  return unwrap_3;
}
;
_.hashCode_0 = function hashCode_27(){
  return getObjectIdentityHashCode(this.jsObject);
}
;
_.isObject = function isObject_0(){
  return this;
}
;
_.toString_0 = function toString_38(){
  var first, key, key$index, key$max, keys_0, sb;
  sb = new StringBuilder_1('{');
  first = true;
  keys_0 = $computeKeys0(this, initUnidimensionalArray(Ljava_lang_String_2_classLit, $intern_0, 2, 0, 5, 1));
  for (key$index = 0 , key$max = keys_0.length; key$index < key$max; ++key$index) {
    key = keys_0[key$index];
    first?(first = false):(sb.string += ', ' , sb);
    $append_3(sb, escapeValue(key));
    sb.string += ':';
    $append_2(sb, $get_6(this, key));
  }
  sb.string += '}';
  return sb.string;
}
;
var Lcom_google_gwt_json_client_JSONObject_2_classLit = createForClass('com.google.gwt.json.client', 'JSONObject', 69);
function JSONObject$1(this$0, val$keys){
  this.this$01 = this$0;
  this.val$keys2 = val$keys;
}

defineClass(361, 640, $intern_21, JSONObject$1);
_.contains = function contains_23(o){
  return instanceOfString(o) && $containsKey_0(this.this$01, castToString(o));
}
;
_.iterator_0 = function iterator_40(){
  return new AbstractList$IteratorImpl(new Arrays$ArrayList(this.val$keys2));
}
;
_.size_1 = function size_32(){
  return this.val$keys2.length;
}
;
var Lcom_google_gwt_json_client_JSONObject$1_2_classLit = createForClass('com.google.gwt.json.client', 'JSONObject/1', 361);
function $clinit_JSONParser(){
  $clinit_JSONParser = emptyMethod;
  typeMap = {'boolean':createBoolean, 'number':createNumber, 'string':createString, 'object':createObject, 'function':createObject, 'undefined':createUndefined};
}

function createBoolean(v){
  return $clinit_JSONBoolean() , v?TRUE:FALSE;
}

function createNumber(v){
  return new JSONNumber(v);
}

function createObject(o){
  if (!o) {
    return $clinit_JSONNull() , instance;
  }
  var v = o.valueOf?o.valueOf():o;
  if (v !== o) {
    var func = typeMap[typeof v];
    return func?func(v):throwUnknownTypeException(typeof v);
  }
   else if (o instanceof Array || o instanceof $wnd.Array) {
    return new JSONArray_0(o);
  }
   else {
    return new JSONObject_0(o);
  }
}

function createString(v){
  return new JSONString(v);
}

function createUndefined(){
  return null;
}

function throwUnknownTypeException(typeString){
  $clinit_JSONParser();
  throw new JSONException("Unexpected typeof result '" + typeString + "'; please report this bug to the GWT team");
}

var typeMap;
function JSONString(value_0){
  if (value_0 == null) {
    throw new NullPointerException;
  }
  this.value_0 = value_0;
}

function unwrap_4(value_0){
  return value_0.value_0;
}

defineClass(97, 645, {97:1}, JSONString);
_.equals = function equals_28(other){
  if (!instanceOf(other, 97)) {
    return false;
  }
  return $equals_5(this.value_0, castTo(other, 97).value_0);
}
;
_.getUnwrapper = function getUnwrapper_4(){
  return unwrap_4;
}
;
_.hashCode_0 = function hashCode_28(){
  return getHashCode_0(this.value_0);
}
;
_.isString = function isString_0(){
  return this;
}
;
_.toString_0 = function toString_39(){
  return escapeValue(this.value_0);
}
;
var Lcom_google_gwt_json_client_JSONString_2_classLit = createForClass('com.google.gwt.json.client', 'JSONString', 97);
function create_0(value_0){
  var a0, a1, a2;
  a0 = value_0 & $intern_40;
  a1 = value_0 >> 22 & $intern_40;
  a2 = value_0 < 0?$intern_41:0;
  return create0(a0, a1, a2);
}

function create0(l, m, h){
  return {'l':l, 'm':m, 'h':h};
}

function toDoubleHelper(a){
  return a.l + a.m * $intern_42 + a.h * $intern_43;
}

function add_19(a, b){
  var sum0, sum1, sum2;
  sum0 = a.l + b.l;
  sum1 = a.m + b.m + (sum0 >> 22);
  sum2 = a.h + b.h + (sum1 >> 22);
  return create0(sum0 & $intern_40, sum1 & $intern_40, sum2 & $intern_41);
}

function and(a, b){
  return create0(a.l & b.l, a.m & b.m, a.h & b.h);
}

function compare_4(a, b){
  var a0, a1, a2, b0, b1, b2, signA, signB;
  signA = a.h >> 19;
  signB = b.h >> 19;
  if (signA != signB) {
    return signB - signA;
  }
  a2 = a.h;
  b2 = b.h;
  if (a2 != b2) {
    return a2 - b2;
  }
  a1 = a.m;
  b1 = b.m;
  if (a1 != b1) {
    return a1 - b1;
  }
  a0 = a.l;
  b0 = b.l;
  return a0 - b0;
}

function fromDouble(value_0){
  var a0, a1, a2, negative, result, neg0, neg1, neg2;
  if (isNaN(value_0)) {
    return $clinit_BigLongLib$Const() , ZERO;
  }
  if (value_0 < -9223372036854775808) {
    return $clinit_BigLongLib$Const() , MIN_VALUE;
  }
  if (value_0 >= 9223372036854775807) {
    return $clinit_BigLongLib$Const() , MAX_VALUE;
  }
  negative = false;
  if (value_0 < 0) {
    negative = true;
    value_0 = -value_0;
  }
  a2 = 0;
  if (value_0 >= $intern_43) {
    a2 = round_int(value_0 / $intern_43);
    value_0 -= a2 * $intern_43;
  }
  a1 = 0;
  if (value_0 >= $intern_42) {
    a1 = round_int(value_0 / $intern_42);
    value_0 -= a1 * $intern_42;
  }
  a0 = round_int(value_0);
  result = create0(a0, a1, a2);
  negative && (neg0 = ~result.l + 1 & $intern_40 , neg1 = ~result.m + (neg0 == 0?1:0) & $intern_40 , neg2 = ~result.h + (neg0 == 0 && neg1 == 0?1:0) & $intern_41 , result.l = neg0 , result.m = neg1 , result.h = neg2 , undefined);
  return result;
}

function mul(a, b){
  var a0, a1, a2, a3, a4, b0, b1, b2, b3, b4, c0, c00, c01, c1, c10, c11, c12, c13, c2, c22, c23, c24, p0, p1, p2, p3, p4;
  a0 = a.l & 8191;
  a1 = a.l >> 13 | (a.m & 15) << 9;
  a2 = a.m >> 4 & 8191;
  a3 = a.m >> 17 | (a.h & 255) << 5;
  a4 = (a.h & 1048320) >> 8;
  b0 = b.l & 8191;
  b1 = b.l >> 13 | (b.m & 15) << 9;
  b2 = b.m >> 4 & 8191;
  b3 = b.m >> 17 | (b.h & 255) << 5;
  b4 = (b.h & 1048320) >> 8;
  p0 = a0 * b0;
  p1 = a1 * b0;
  p2 = a2 * b0;
  p3 = a3 * b0;
  p4 = a4 * b0;
  if (b1 != 0) {
    p1 += a0 * b1;
    p2 += a1 * b1;
    p3 += a2 * b1;
    p4 += a3 * b1;
  }
  if (b2 != 0) {
    p2 += a0 * b2;
    p3 += a1 * b2;
    p4 += a2 * b2;
  }
  if (b3 != 0) {
    p3 += a0 * b3;
    p4 += a1 * b3;
  }
  b4 != 0 && (p4 += a0 * b4);
  c00 = p0 & $intern_40;
  c01 = (p1 & 511) << 13;
  c0 = c00 + c01;
  c10 = p0 >> 22;
  c11 = p1 >> 9;
  c12 = (p2 & 262143) << 4;
  c13 = (p3 & 31) << 17;
  c1 = c10 + c11 + c12 + c13;
  c22 = p2 >> 18;
  c23 = p3 >> 5;
  c24 = (p4 & 4095) << 8;
  c2 = c22 + c23 + c24;
  c1 += c0 >> 22;
  c0 &= $intern_40;
  c2 += c1 >> 22;
  c1 &= $intern_40;
  c2 &= $intern_41;
  return create0(c0, c1, c2);
}

function shr(a, n){
  var a2, negative, res0, res1, res2;
  n &= 63;
  a2 = a.h;
  negative = (a2 & 524288) != 0;
  negative && (a2 |= -1048576);
  if (n < 22) {
    res2 = a2 >> n;
    res1 = a.m >> n | a2 << 22 - n;
    res0 = a.l >> n | a.m << 22 - n;
  }
   else if (n < 44) {
    res2 = negative?$intern_41:0;
    res1 = a2 >> n - 22;
    res0 = a.m >> n - 22 | a2 << 44 - n;
  }
   else {
    res2 = negative?$intern_41:0;
    res1 = negative?$intern_40:0;
    res0 = a2 >> n - 44;
  }
  return create0(res0 & $intern_40, res1 & $intern_40, res2 & $intern_41);
}

function sub_0(a, b){
  var sum0, sum1, sum2;
  sum0 = a.l - b.l;
  sum1 = a.m - b.m + (sum0 >> 22);
  sum2 = a.h - b.h + (sum1 >> 22);
  return create0(sum0 & $intern_40, sum1 & $intern_40, sum2 & $intern_41);
}

function toDouble(a){
  var neg0, neg1, neg2;
  if (compare_4(a, ($clinit_BigLongLib$Const() , ZERO)) < 0) {
    return -toDoubleHelper((neg0 = ~a.l + 1 & $intern_40 , neg1 = ~a.m + (neg0 == 0?1:0) & $intern_40 , neg2 = ~a.h + (neg0 == 0 && neg1 == 0?1:0) & $intern_41 , create0(neg0, neg1, neg2)));
  }
  return a.l + a.m * $intern_42 + a.h * $intern_43;
}

function $clinit_BigLongLib$Const(){
  $clinit_BigLongLib$Const = emptyMethod;
  MAX_VALUE = create0($intern_40, $intern_40, 524287);
  MIN_VALUE = create0(0, 0, 524288);
  create_0(1);
  create_0(2);
  ZERO = create_0(0);
}

var MAX_VALUE, MIN_VALUE, ZERO;
function add_20(a, b){
  var result;
  if (isSmallLong0(a) && isSmallLong0(b)) {
    result = a + b;
    if ($intern_44 < result && result < $intern_43) {
      return result;
    }
  }
  return createLongEmul(add_19(isSmallLong0(a)?toBigLong(a):a, isSmallLong0(b)?toBigLong(b):b));
}

function and_0(a, b){
  return createLongEmul(and(isSmallLong0(a)?toBigLong(a):a, isSmallLong0(b)?toBigLong(b):b));
}

function compare_5(a, b){
  var result;
  if (isSmallLong0(a) && isSmallLong0(b)) {
    result = a - b;
    if (!isNaN(result)) {
      return result;
    }
  }
  return compare_4(isSmallLong0(a)?toBigLong(a):a, isSmallLong0(b)?toBigLong(b):b);
}

function createLongEmul(big_0){
  var a2;
  a2 = big_0.h;
  if (a2 == 0) {
    return big_0.l + big_0.m * $intern_42;
  }
  if (a2 == $intern_41) {
    return big_0.l + big_0.m * $intern_42 - $intern_43;
  }
  return big_0;
}

function fromDouble_0(value_0){
  if ($intern_44 < value_0 && value_0 < $intern_43) {
    return value_0 < 0?Math.ceil(value_0):Math.floor(value_0);
  }
  return createLongEmul(fromDouble(value_0));
}

function isSmallLong0(value_0){
  return typeof value_0 === 'number';
}

function lt(a, b){
  return compare_5(a, b) < 0;
}

function mul_0(a, b){
  var result;
  if (isSmallLong0(a) && isSmallLong0(b)) {
    result = a * b;
    if ($intern_44 < result && result < $intern_43) {
      return result;
    }
  }
  return createLongEmul(mul(isSmallLong0(a)?toBigLong(a):a, isSmallLong0(b)?toBigLong(b):b));
}

function sub_1(a, b){
  var result;
  if (isSmallLong0(a) && isSmallLong0(b)) {
    result = a - b;
    if ($intern_44 < result && result < $intern_43) {
      return result;
    }
  }
  return createLongEmul(sub_0(isSmallLong0(a)?toBigLong(a):a, isSmallLong0(b)?toBigLong(b):b));
}

function toBigLong(longValue){
  var a0, a1, a3, value_0;
  value_0 = longValue;
  a3 = 0;
  if (value_0 < 0) {
    value_0 += $intern_43;
    a3 = $intern_41;
  }
  a1 = round_int(value_0 / $intern_42);
  a0 = round_int(value_0 - a1 * $intern_42);
  return create0(a0, a1, a3);
}

function toDouble_0(a){
  var d;
  if (isSmallLong0(a)) {
    d = a;
    return d == -0.?0:d;
  }
  return toDouble(a);
}

function toInt(a){
  if (isSmallLong0(a)) {
    return a | 0;
  }
  return a.l | a.m << 22;
}

function init(){
  $exportLayout();
}

function $$init_0(this$static){
  this$static.children = new LinkedList;
}

function $begin(this$static, name_0, thetotalWork){
  if (this$static.closed_0) {
    throw new IllegalStateException_0('The task is already done.');
  }
   else if (this$static.taskName != null) {
    return false;
  }
   else {
    this$static.taskName = name_0;
    this$static.totalWork = thetotalWork;
    return true;
  }
}

function $doSubTask(maxHierarchyLevels, measureExecTime){
  return maxHierarchyLevels > 0?new BasicProgressMonitor_0(maxHierarchyLevels - 1, measureExecTime):new BasicProgressMonitor_0(maxHierarchyLevels, measureExecTime);
}

function $done(this$static){
  if (this$static.taskName == null) {
    throw new IllegalStateException_0('The task has not begun yet.');
  }
  if (!this$static.closed_0) {
    this$static.completedWork < this$static.totalWork && $internalWorked(this$static, this$static.totalWork - this$static.completedWork);
    this$static.closed_0 = true;
  }
}

function $internalWorked(this$static, work){
  if (this$static.totalWork > 0 && this$static.completedWork < this$static.totalWork) {
    this$static.completedWork += work;
    !!this$static.parentMonitor && this$static.parentMonitor.currentChildWork > 0 && this$static.maxLevels != 0 && $internalWorked(this$static.parentMonitor, work / this$static.totalWork * this$static.parentMonitor.currentChildWork);
  }
}

function $subTask(this$static, work){
  var subMonitor;
  if (this$static.closed_0) {
    return null;
  }
   else {
    subMonitor = $doSubTask(this$static.maxLevels, this$static.measureExecutionTime);
    $add_8(this$static.children, subMonitor);
    subMonitor.parentMonitor = this$static;
    this$static.currentChildWork = work;
    return subMonitor;
  }
}

function BasicProgressMonitor(){
  $$init_0(this);
  this.maxLevels = -1;
  this.measureExecutionTime = true;
}

function BasicProgressMonitor_0(maxLevels, measureExecutionTime){
  $$init_0(this);
  this.maxLevels = maxLevels;
  this.measureExecutionTime = measureExecutionTime;
}

defineClass(186, 1, {}, BasicProgressMonitor, BasicProgressMonitor_0);
_.closed_0 = false;
_.completedWork = 0;
_.currentChildWork = -1;
_.maxLevels = 0;
_.measureExecutionTime = false;
_.totalWork = 0;
var Lde_cau_cs_kieler_core_alg_BasicProgressMonitor_2_classLit = createForClass('de.cau.cs.kieler.core.alg', 'BasicProgressMonitor', 186);
function $add_6(this$static, dx, dy){
  this$static.x_0 += dx;
  this$static.y_0 += dy;
  return this$static;
}

function $add_7(this$static, v){
  this$static.x_0 += v.x_0;
  this$static.y_0 += v.y_0;
  return this$static;
}

function $bound(this$static, highx, highy){
  if (highx < 0 || highy < 0) {
    throw new IllegalArgumentException_0('The highx must be bigger then lowx and the highy must be bigger then lowy');
  }
  this$static.x_0 < 0?(this$static.x_0 = 0):this$static.x_0 > highx && (this$static.x_0 = highx);
  this$static.y_0 < 0?(this$static.y_0 = 0):this$static.y_0 > highy && (this$static.y_0 = highy);
  return this$static;
}

function $clone(this$static){
  return new KVector_1(this$static.x_0, this$static.y_0);
}

function $equals_3(this$static, obj){
  var other;
  if (instanceOf(obj, 10)) {
    other = castTo(obj, 10);
    return this$static.x_0 == other.x_0 && this$static.y_0 == other.y_0;
  }
   else {
    return false;
  }
}

function $negate(this$static){
  this$static.x_0 = -this$static.x_0;
  this$static.y_0 = -this$static.y_0;
  return this$static;
}

function $parse_0(this$static, string){
  var end, exception, start_0, tokens;
  start_0 = 0;
  while (start_0 < ($clinit_String() , string.length) && isdelim(string.charCodeAt(start_0), '([{"\' \t\r\n')) {
    ++start_0;
  }
  end = string.length;
  while (end > 0 && isdelim(string.charCodeAt(end - 1), ')]}"\' \t\r\n')) {
    --end;
  }
  if (start_0 >= end) {
    throw new IllegalArgumentException_0('The given string does not contain any numbers.');
  }
  tokens = $split_1(string.substr(start_0, end - start_0), ',|;|\r|\n');
  if (tokens.length != 2) {
    throw new IllegalArgumentException_0('Exactly two numbers are expected, ' + tokens.length + ' were found.');
  }
  try {
    this$static.x_0 = __parseAndValidateDouble($trim(tokens[0]));
    this$static.y_0 = __parseAndValidateDouble($trim(tokens[1]));
  }
   catch ($e0) {
    $e0 = wrap($e0);
    if (instanceOf($e0, 130)) {
      exception = $e0;
      throw new IllegalArgumentException_0('The given string contains parts that cannot be parsed as numbers.' + exception);
    }
     else 
      throw unwrap_5($e0);
  }
}

function $reset(this$static){
  this$static.x_0 = 0;
  this$static.y_0 = 0;
  return this$static;
}

function $scale(this$static, scale){
  this$static.x_0 *= scale;
  this$static.y_0 *= scale;
  return this$static;
}

function $sub(this$static, dx, dy){
  this$static.x_0 -= dx;
  this$static.y_0 -= dy;
  return this$static;
}

function $sub_0(this$static, v){
  this$static.x_0 -= v.x_0;
  this$static.y_0 -= v.y_0;
  return this$static;
}

function KVector(){
  this.x_0 = 0;
  this.y_0 = 0;
}

function KVector_0(angle){
  this.x_0 = Math.cos(angle);
  this.y_0 = Math.sin(angle);
}

function KVector_1(thex, they){
  this.x_0 = thex;
  this.y_0 = they;
}

function KVector_2(v){
  this.x_0 = v.x_0;
  this.y_0 = v.y_0;
}

function isdelim(c, delims){
  var i;
  for (i = 0; i < ($clinit_String() , delims.length); i++) {
    if (c == delims.charCodeAt(i)) {
      return true;
    }
  }
  return false;
}

function sum_0(vs){
  var sum, v, v$index, v$max;
  sum = new KVector;
  for (v$index = 0 , v$max = vs.length; v$index < v$max; ++v$index) {
    v = vs[v$index];
    sum.x_0 += v.x_0;
    sum.y_0 += v.y_0;
  }
  return sum;
}

defineClass(10, 1, {10:1, 286:1, 3:1, 5:1}, KVector, KVector_0, KVector_1, KVector_2);
_.equals = function equals_29(obj){
  return $equals_3(this, obj);
}
;
_.hashCode_0 = function hashCode_29(){
  return round_int(checkNotNull_1(this.x_0)) + reverse_2(round_int(checkNotNull_1(this.y_0)));
}
;
_.toString_0 = function toString_40(){
  return '(' + this.x_0 + ',' + this.y_0 + ')';
}
;
_.x_0 = 0;
_.y_0 = 0;
var Lde_cau_cs_kieler_core_math_KVector_2_classLit = createForClass('de.cau.cs.kieler.core.math', 'KVector', 10);
function $$init_1(this$static){
  this$static.header = new LinkedList$Node;
  this$static.tail = new LinkedList$Node;
}

function $add_8(this$static, o){
  $addNode_0(this$static, o, this$static.tail.prev, this$static.tail);
  return true;
}

function $addFirst(this$static, o){
  $addNode_0(this$static, o, this$static.header, this$static.header.next_0);
}

function $addLast(this$static, o){
  $addNode_0(this$static, o, this$static.tail.prev, this$static.tail);
}

function $addNode_0(this$static, o, prev, next){
  var node;
  node = new LinkedList$Node;
  node.value_0 = o;
  node.prev = prev;
  node.next_0 = next;
  next.prev = prev.next_0 = node;
  ++this$static.size_0;
}

function $getFirst(this$static){
  checkCriticalElement(this$static.size_0 != 0);
  return this$static.header.next_0.value_0;
}

function $getLast(this$static){
  checkCriticalElement(this$static.size_0 != 0);
  return this$static.tail.prev.value_0;
}

function $listIterator_2(this$static, index_0){
  var i, node;
  checkCriticalPositionIndex(index_0, this$static.size_0);
  if (index_0 >= this$static.size_0 >> 1) {
    node = this$static.tail;
    for (i = this$static.size_0; i > index_0; --i) {
      node = node.prev;
    }
  }
   else {
    node = this$static.header.next_0;
    for (i = 0; i < index_0; ++i) {
      node = node.next_0;
    }
  }
  return new LinkedList$ListIteratorImpl(this$static, index_0, node);
}

function $poll(this$static){
  return this$static.size_0 == 0?null:(checkCriticalElement(this$static.size_0 != 0) , $removeNode_0(this$static, this$static.header.next_0));
}

function $removeFirst(this$static){
  checkCriticalElement(this$static.size_0 != 0);
  return $removeNode_0(this$static, this$static.header.next_0);
}

function $removeLast(this$static){
  checkCriticalElement(this$static.size_0 != 0);
  return $removeNode_0(this$static, this$static.tail.prev);
}

function $removeNode_0(this$static, node){
  var oldValue;
  oldValue = node.value_0;
  node.next_0.prev = node.prev;
  node.prev.next_0 = node.next_0;
  node.next_0 = node.prev = null;
  node.value_0 = null;
  --this$static.size_0;
  return oldValue;
}

function $reset_0(this$static){
  this$static.header.next_0 = this$static.tail;
  this$static.tail.prev = this$static.header;
  this$static.header.prev = this$static.tail.next_0 = null;
  this$static.size_0 = 0;
}

function LinkedList(){
  $$init_1(this);
  $reset_0(this);
}

defineClass(58, 647, {3:1, 5:1, 22:1, 19:1, 58:1, 20:1}, LinkedList);
_.add_1 = function add_21(o){
  return $add_8(this, o);
}
;
_.clear_0 = function clear_21(){
  $reset_0(this);
}
;
_.listIterator_1 = function listIterator_12(index_0){
  return $listIterator_2(this, index_0);
}
;
_.size_1 = function size_33(){
  return this.size_0;
}
;
_.size_0 = 0;
var Ljava_util_LinkedList_2_classLit = createForClass('java.util', 'LinkedList', 58);
function $addAll_3(this$static, vectors){
  var vector, vector$index, vector$max;
  for (vector$index = 0 , vector$max = vectors.length; vector$index < vector$max; ++vector$index) {
    vector = vectors[vector$index];
    $addNode_0(this$static, vector, this$static.tail.prev, this$static.tail);
  }
}

function $addAllAsCopies(this$static, index_0, chain){
  var copies, v, v$iterator;
  copies = new LinkedList;
  for (v$iterator = $listIterator_2(chain, 0); v$iterator.currentNode != v$iterator.this$01.tail;) {
    v = castTo($next_11(v$iterator), 10);
    $add_8(copies, new KVector_2(v));
  }
  $addAll_2(this$static, index_0, copies);
}

function $offset(this$static, offset){
  var vector, vector$iterator;
  for (vector$iterator = $listIterator_2(this$static, 0); vector$iterator.currentNode != vector$iterator.this$01.tail;) {
    vector = castTo($next_11(vector$iterator), 10);
    vector.x_0 += offset.x_0;
    vector.y_0 += offset.y_0;
  }
  return this$static;
}

function $parse_1(this$static, string){
  var exception, i, tokens, x_0, xy, y_0;
  tokens = $split_1(string, ',|;|\\(|\\)|\\[|\\]|\\{|\\}| |\t|\n');
  $reset_0(this$static);
  try {
    i = 0;
    xy = 0;
    x_0 = 0;
    y_0 = 0;
    while (i < tokens.length) {
      if (tokens[i] != null && length_1($trim(tokens[i])) > 0) {
        xy % 2 == 0?(x_0 = __parseAndValidateDouble(tokens[i])):(y_0 = __parseAndValidateDouble(tokens[i]));
        xy > 0 && xy % 2 != 0 && $add_8(this$static, new KVector_1(x_0, y_0));
        ++xy;
      }
      ++i;
    }
  }
   catch ($e0) {
    $e0 = wrap($e0);
    if (instanceOf($e0, 130)) {
      exception = $e0;
      throw new IllegalArgumentException_0('The given string does not match the expected format for vectors.' + exception);
    }
     else 
      throw unwrap_5($e0);
  }
}

function KVectorChain(){
  LinkedList.call(this);
}

function KVectorChain_0(collection){
  $$init_1(this);
  $reset_0(this);
  $addAll(this, collection);
}

function reverse_1(chain){
  var result, vector, vector$iterator;
  result = new KVectorChain;
  for (vector$iterator = $listIterator_2(chain, 0); vector$iterator.currentNode != vector$iterator.this$01.tail;) {
    vector = castTo($next_11(vector$iterator), 10);
    $add_2(result, 0, new KVector_2(vector));
  }
  return result;
}

defineClass(44, 58, {44:1, 286:1, 3:1, 5:1, 22:1, 19:1, 58:1, 20:1}, KVectorChain, KVectorChain_0);
_.toString_0 = function toString_41(){
  var builder, iter, vector;
  builder = new StringBuilder_1('(');
  iter = $listIterator_2(this, 0);
  while (iter.currentNode != iter.this$01.tail) {
    vector = castTo($next_11(iter), 10);
    $append_3(builder, vector.x_0 + ',' + vector.y_0);
    iter.currentNode != iter.this$01.tail && (builder.string += '; ' , builder);
  }
  return builder.string += ')' , builder.string;
}
;
var Lde_cau_cs_kieler_core_math_KVectorChain_2_classLit = createForClass('de.cau.cs.kieler.core.math', 'KVectorChain', 44);
function $clinit_KielerMath(){
  $clinit_KielerMath = emptyMethod;
  Math.pow(2, -65);
}

function maxd(values){
  $clinit_KielerMath();
  var i, max_0;
  max_0 = $intern_45;
  for (i = 0; i < values.length; i++) {
    values[i] > max_0 && (max_0 = values[i]);
  }
  return max_0;
}

var Lde_cau_cs_kieler_core_properties_IProperty_2_classLit = createForInterface('de.cau.cs.kieler.core.properties', 'IProperty');
function $checkProperties(this$static, newProperties){
  var property, property$index, property$max, value_0;
  if (!this$static.propertyMap) {
    return;
  }
  for (property$index = 0 , property$max = newProperties.length; property$index < property$max; ++property$index) {
    property = newProperties[property$index];
    value_0 = $get_9(this$static.propertyMap, property);
    if (value_0 != null) {
      property.getLowerBound();
      property.getUpperBound();
    }
  }
}

function $copyProperties(this$static, other){
  var otherMap;
  if (!other) {
    return this$static;
  }
  otherMap = !other.propertyMap?($clinit_Collections() , $clinit_Collections() , EMPTY_MAP):other.propertyMap;
  otherMap.isEmpty() || (!this$static.propertyMap?(this$static.propertyMap = new HashMap_1(otherMap)):$putAll(this$static.propertyMap, otherMap));
  return this$static;
}

function $getProperty(this$static, property){
  var defaultValue, value_0;
  if (this$static.propertyMap) {
    value_0 = $get_9(this$static.propertyMap, property);
    if (value_0 != null) {
      return value_0;
    }
  }
  defaultValue = $getDefault(property);
  instanceOf(defaultValue, 5) && $setProperty(this$static, property, defaultValue);
  return defaultValue;
}

function $setProperty(this$static, property, value_0){
  !this$static.propertyMap && (this$static.propertyMap = new HashMap);
  value_0 == null?$remove_9(this$static.propertyMap, property):$put_2(this$static.propertyMap, property, value_0);
  return this$static;
}

function MapPropertyHolder(){
}

defineClass(131, 1, {179:1, 131:1, 3:1}, MapPropertyHolder);
var Lde_cau_cs_kieler_core_properties_MapPropertyHolder_2_classLit = createForClass('de.cau.cs.kieler.core.properties', 'MapPropertyHolder', 131);
function $clinit_Property(){
  $clinit_Property = emptyMethod;
  NEGATIVE_INFINITY = new Property$1;
  POSITIVE_INFINITY = new Property$2;
}

function $compareTo_0(this$static, other){
  return compareTo_15(this$static.id_0, other.getId());
}

function $equals_4(this$static, obj){
  return instanceOf(obj, 79) && $equals_5(this$static.id_0, castTo(obj, 79).getId());
}

function $getDefault(this$static){
  var clone, entry, entryIterator, it;
  if (instanceOf(this$static.defaultValue, 10)) {
    return $clone(castTo(this$static.defaultValue, 10));
  }
   else if (instanceOf(this$static.defaultValue, 65)) {
    return $clone_0(castTo(this$static.defaultValue, 86));
  }
   else if (instanceOf(this$static.defaultValue, 50)) {
    return castTo(this$static.defaultValue, 50).clone();
  }
   else if (instanceOf(this$static.defaultValue, 191)) {
    clone = new TreeSet;
    it = (entryIterator = new TreeMap$EntryIterator((new TreeMap$EntrySet((new AbstractNavigableMap$NavigableKeySet(castTo(this$static.defaultValue, 191).map_0)).map_0)).this$01_0) , new AbstractNavigableMap$NavigableKeySet$1(entryIterator));
    while ($hasNext_2(it.val$entryIterator2.iter)) {
      $add_20(clone, (entry = $next_12(it.val$entryIterator2) , entry.getKey()));
    }
    return clone;
  }
   else if (instanceOf(this$static.defaultValue, 13)) {
    return new ArrayList_1(castTo(this$static.defaultValue, 13));
  }
   else if (instanceOf(this$static.defaultValue, 44)) {
    clone = new KVectorChain;
    it = $listIterator_2(castTo(this$static.defaultValue, 44), 0);
    while (it.currentNode != it.this$01.tail) {
      $add_8(clone, castTo($next_11(it), 10));
    }
    return clone;
  }
   else if (instanceOf(this$static.defaultValue, 58)) {
    clone = new LinkedList;
    it = $listIterator_2(castTo(this$static.defaultValue, 58), 0);
    while (it.currentNode != it.this$01.tail) {
      $add_8(clone, $next_11(it));
    }
    return clone;
  }
   else {
    return this$static.defaultValue;
  }
}

function Property(other, thedefaultValue){
  $clinit_Property();
  Property_4.call(this, other.id_0, thedefaultValue, other.lowerBound, other.upperBound);
}

function Property_0(other, thedefaultValue, thelowerBound){
  $clinit_Property();
  Property_4.call(this, other.id_0, thedefaultValue, thelowerBound, other.upperBound);
}

function Property_1(theid){
  $clinit_Property();
  this.lowerBound = NEGATIVE_INFINITY;
  this.upperBound = POSITIVE_INFINITY;
  this.id_0 = theid;
}

function Property_2(theid, thedefaultValue){
  $clinit_Property();
  Property_1.call(this, theid);
  this.defaultValue = thedefaultValue;
}

function Property_3(theid, thedefaultValue, thelowerBound){
  $clinit_Property();
  Property_2.call(this, theid, thedefaultValue);
  thelowerBound != null && (this.lowerBound = thelowerBound);
}

function Property_4(theid, thedefaultValue, thelowerBound, theupperBound){
  $clinit_Property();
  Property_3.call(this, theid, thedefaultValue, thelowerBound);
  theupperBound != null && (this.upperBound = theupperBound);
}

defineClass(14, 1, $intern_46, Property, Property_0, Property_1, Property_2, Property_3, Property_4);
_.compareTo = function compareTo_0(other){
  return $compareTo_0(this, castTo(other, 79));
}
;
_.equals = function equals_30(obj){
  return $equals_4(this, obj);
}
;
_.getId = function getId(){
  return this.id_0;
}
;
_.getLowerBound = function getLowerBound(){
  return this.lowerBound;
}
;
_.getUpperBound = function getUpperBound(){
  return this.upperBound;
}
;
_.hashCode_0 = function hashCode_30(){
  return getHashCode_0(this.id_0);
}
;
_.toString_0 = function toString_42(){
  return this.id_0;
}
;
var NEGATIVE_INFINITY, POSITIVE_INFINITY;
var Lde_cau_cs_kieler_core_properties_Property_2_classLit = createForClass('de.cau.cs.kieler.core.properties', 'Property', 14);
function Property$1(){
}

defineClass(366, 1, {23:1}, Property$1);
_.compareTo = function compareTo_1(other){
  return -1;
}
;
var Lde_cau_cs_kieler_core_properties_Property$1_2_classLit = createForClass('de.cau.cs.kieler.core.properties', 'Property/1', 366);
function Property$2(){
}

defineClass(367, 1, {23:1}, Property$2);
_.compareTo = function compareTo_2(other){
  return 1;
}
;
var Lde_cau_cs_kieler_core_properties_Property$2_2_classLit = createForClass('de.cau.cs.kieler.core.properties', 'Property/2', 367);
function Pair(thefirst, thesecond){
  this.first = thefirst;
  this.second = thesecond;
}

defineClass(27, 1, {27:1, 22:1}, Pair);
_.equals = function equals_31(obj){
  var firstEqual, other, secondEqual;
  if (instanceOf(obj, 27)) {
    other = castTo(obj, 27);
    firstEqual = this.first == null?other.first == null:equals_Ljava_lang_Object__Z__devirtual$(this.first, other.first);
    secondEqual = this.second == null?other.second == null:equals_Ljava_lang_Object__Z__devirtual$(this.second, other.second);
    return firstEqual && secondEqual;
  }
   else {
    return false;
  }
}
;
_.hashCode_0 = function hashCode_31(){
  var first1, first2, firstCode, second1, second2, secondCode;
  firstCode = this.first == null?0:hashCode__I__devirtual$(this.first);
  first1 = firstCode & $intern_6;
  first2 = firstCode & -65536;
  secondCode = this.second == null?0:hashCode__I__devirtual$(this.second);
  second1 = secondCode & $intern_6;
  second2 = secondCode & -65536;
  return first1 ^ second2 >> 16 & $intern_6 | first2 ^ second1 << 16;
}
;
_.iterator_0 = function iterator_41(){
  return new Pair$1(this);
}
;
_.toString_0 = function toString_43(){
  return this.first == null && this.second == null?'pair(null,null)':this.first == null?'pair(null,' + toString__Ljava_lang_String___devirtual$(this.second) + ')':this.second == null?'pair(' + toString__Ljava_lang_String___devirtual$(this.first) + ',null)':'pair(' + toString__Ljava_lang_String___devirtual$(this.first) + ',' + toString__Ljava_lang_String___devirtual$(this.second) + ')';
}
;
var Lde_cau_cs_kieler_core_util_Pair_2_classLit = createForClass('de.cau.cs.kieler.core.util', 'Pair', 27);
function Pair$1(this$0){
  this.this$01 = this$0;
}

defineClass(431, 1, $intern_18, Pair$1);
_.hasNext_0 = function hasNext_20(){
  return !this.visitedSecond && (!this.visitedFirst && this.this$01.first != null || this.this$01.second != null);
}
;
_.next_1 = function next_21(){
  if (!this.visitedSecond && !this.visitedFirst && this.this$01.first != null) {
    this.visitedFirst = true;
    return this.this$01.first;
  }
   else if (!this.visitedSecond && this.this$01.second != null) {
    this.visitedSecond = true;
    return this.this$01.second;
  }
  throw new NoSuchElementException;
}
;
_.remove = function remove_42(){
  this.visitedSecond && this.this$01.second != null?(this.this$01.second = null):this.visitedFirst && this.this$01.first != null && (this.this$01.first = null);
  throw new IllegalStateException;
}
;
_.visitedFirst = false;
_.visitedSecond = false;
var Lde_cau_cs_kieler_core_util_Pair$1_2_classLit = createForClass('de.cau.cs.kieler.core.util', 'Pair/1', 431);
function UnsupportedConfigurationException(message){
  RuntimeException_0.call(this, message);
}

defineClass(228, 72, $intern_2, UnsupportedConfigurationException);
var Lde_cau_cs_kieler_kiml_UnsupportedConfigurationException_2_classLit = createForClass('de.cau.cs.kieler.kiml', 'UnsupportedConfigurationException', 228);
function UnsupportedGraphException(message){
  RuntimeException_0.call(this, message);
}

defineClass(98, 72, $intern_2, UnsupportedGraphException);
var Lde_cau_cs_kieler_kiml_UnsupportedGraphException_2_classLit = createForClass('de.cau.cs.kieler.kiml', 'UnsupportedGraphException', 98);
function $clinit_LabelManagementOptions(){
  $clinit_LabelManagementOptions = emptyMethod;
  LABEL_MANAGER = new Property_2('de.cau.cs.kieler.labels.labelManager', null);
}

var LABEL_MANAGER;
function $clinit_Alignment(){
  $clinit_Alignment = emptyMethod;
  AUTOMATIC = new Alignment('AUTOMATIC', 0);
  LEFT = new Alignment('LEFT', 1);
  RIGHT = new Alignment('RIGHT', 2);
  TOP = new Alignment('TOP', 3);
  BOTTOM = new Alignment('BOTTOM', 4);
  CENTER = new Alignment('CENTER', 5);
}

function Alignment(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function values_13(){
  $clinit_Alignment();
  return stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_Alignment_2_classLit, 1), $intern_13, 103, 0, [AUTOMATIC, LEFT, RIGHT, TOP, BOTTOM, CENTER]);
}

defineClass(103, 17, {103:1, 3:1, 23:1, 17:1}, Alignment);
var AUTOMATIC, BOTTOM, CENTER, LEFT, RIGHT, TOP;
var Lde_cau_cs_kieler_kiml_options_Alignment_2_classLit = createForEnum('de.cau.cs.kieler.kiml.options', 'Alignment', 103, Ljava_lang_Enum_2_classLit, values_13);
function $clinit_Alignment$Map(){
  $clinit_Alignment$Map = emptyMethod;
  $MAP = createValueOfMap(($clinit_Alignment() , stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_Alignment_2_classLit, 1), $intern_13, 103, 0, [AUTOMATIC, LEFT, RIGHT, TOP, BOTTOM, CENTER])));
}

var $MAP;
function $clinit_Direction(){
  $clinit_Direction = emptyMethod;
  UNDEFINED = new Direction('UNDEFINED', 0);
  RIGHT_0 = new Direction('RIGHT', 1);
  LEFT_0 = new Direction('LEFT', 2);
  DOWN = new Direction('DOWN', 3);
  UP = new Direction('UP', 4);
}

function $isHorizontal(this$static){
  return this$static == LEFT_0 || this$static == RIGHT_0;
}

function $isVertical(this$static){
  return this$static == UP || this$static == DOWN;
}

function $opposite(this$static){
  switch (this$static.ordinal) {
    case 2:
      return RIGHT_0;
    case 1:
      return LEFT_0;
    case 4:
      return DOWN;
    case 3:
      return UP;
    default:return UNDEFINED;
  }
}

function Direction(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function values_14(){
  $clinit_Direction();
  return stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_Direction_2_classLit, 1), $intern_13, 59, 0, [UNDEFINED, RIGHT_0, LEFT_0, DOWN, UP]);
}

defineClass(59, 17, {59:1, 3:1, 23:1, 17:1}, Direction);
var DOWN, LEFT_0, RIGHT_0, UNDEFINED, UP;
var Lde_cau_cs_kieler_kiml_options_Direction_2_classLit = createForEnum('de.cau.cs.kieler.kiml.options', 'Direction', 59, Ljava_lang_Enum_2_classLit, values_14);
function $clinit_Direction$Map(){
  $clinit_Direction$Map = emptyMethod;
  $MAP_0 = createValueOfMap(($clinit_Direction() , stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_Direction_2_classLit, 1), $intern_13, 59, 0, [UNDEFINED, RIGHT_0, LEFT_0, DOWN, UP])));
}

var $MAP_0;
function $clinit_EdgeLabelPlacement(){
  $clinit_EdgeLabelPlacement = emptyMethod;
  UNDEFINED_0 = new EdgeLabelPlacement('UNDEFINED', 0);
  CENTER_0 = new EdgeLabelPlacement('CENTER', 1);
  HEAD = new EdgeLabelPlacement('HEAD', 2);
  TAIL = new EdgeLabelPlacement('TAIL', 3);
}

function EdgeLabelPlacement(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function values_15(){
  $clinit_EdgeLabelPlacement();
  return stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_EdgeLabelPlacement_2_classLit, 1), $intern_13, 107, 0, [UNDEFINED_0, CENTER_0, HEAD, TAIL]);
}

defineClass(107, 17, {107:1, 3:1, 23:1, 17:1}, EdgeLabelPlacement);
var CENTER_0, HEAD, TAIL, UNDEFINED_0;
var Lde_cau_cs_kieler_kiml_options_EdgeLabelPlacement_2_classLit = createForEnum('de.cau.cs.kieler.kiml.options', 'EdgeLabelPlacement', 107, Ljava_lang_Enum_2_classLit, values_15);
function $clinit_EdgeLabelPlacement$Map(){
  $clinit_EdgeLabelPlacement$Map = emptyMethod;
  $MAP_1 = createValueOfMap(($clinit_EdgeLabelPlacement() , stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_EdgeLabelPlacement_2_classLit, 1), $intern_13, 107, 0, [UNDEFINED_0, CENTER_0, HEAD, TAIL])));
}

var $MAP_1;
function $clinit_EdgeRouting(){
  $clinit_EdgeRouting = emptyMethod;
  UNDEFINED_1 = new EdgeRouting('UNDEFINED', 0);
  POLYLINE = new EdgeRouting('POLYLINE', 1);
  ORTHOGONAL = new EdgeRouting('ORTHOGONAL', 2);
  SPLINES = new EdgeRouting('SPLINES', 3);
}

function EdgeRouting(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function values_16(){
  $clinit_EdgeRouting();
  return stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_EdgeRouting_2_classLit, 1), $intern_13, 122, 0, [UNDEFINED_1, POLYLINE, ORTHOGONAL, SPLINES]);
}

defineClass(122, 17, {122:1, 3:1, 23:1, 17:1}, EdgeRouting);
var ORTHOGONAL, POLYLINE, SPLINES, UNDEFINED_1;
var Lde_cau_cs_kieler_kiml_options_EdgeRouting_2_classLit = createForEnum('de.cau.cs.kieler.kiml.options', 'EdgeRouting', 122, Ljava_lang_Enum_2_classLit, values_16);
function $clinit_EdgeRouting$Map(){
  $clinit_EdgeRouting$Map = emptyMethod;
  $MAP_2 = createValueOfMap(($clinit_EdgeRouting() , stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_EdgeRouting_2_classLit, 1), $intern_13, 122, 0, [UNDEFINED_1, POLYLINE, ORTHOGONAL, SPLINES])));
}

var $MAP_2;
function $clinit_EdgeType(){
  $clinit_EdgeType = emptyMethod;
  NONE = new EdgeType('NONE', 0);
  DIRECTED = new EdgeType('DIRECTED', 1);
  UNDIRECTED = new EdgeType('UNDIRECTED', 2);
  ASSOCIATION = new EdgeType('ASSOCIATION', 3);
  GENERALIZATION = new EdgeType('GENERALIZATION', 4);
  DEPENDENCY = new EdgeType('DEPENDENCY', 5);
}

function EdgeType(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function values_17(){
  $clinit_EdgeType();
  return stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_EdgeType_2_classLit, 1), $intern_13, 133, 0, [NONE, DIRECTED, UNDIRECTED, ASSOCIATION, GENERALIZATION, DEPENDENCY]);
}

defineClass(133, 17, {133:1, 3:1, 23:1, 17:1}, EdgeType);
var ASSOCIATION, DEPENDENCY, DIRECTED, GENERALIZATION, NONE, UNDIRECTED;
var Lde_cau_cs_kieler_kiml_options_EdgeType_2_classLit = createForEnum('de.cau.cs.kieler.kiml.options', 'EdgeType', 133, Ljava_lang_Enum_2_classLit, values_17);
function $clinit_EdgeType$Map(){
  $clinit_EdgeType$Map = emptyMethod;
  $MAP_3 = createValueOfMap(($clinit_EdgeType() , stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_EdgeType_2_classLit, 1), $intern_13, 133, 0, [NONE, DIRECTED, UNDIRECTED, ASSOCIATION, GENERALIZATION, DEPENDENCY])));
}

var $MAP_3;
function $clinit_HierarchyHandling(){
  $clinit_HierarchyHandling = emptyMethod;
  INHERIT = new HierarchyHandling('INHERIT', 0);
  INCLUDE_CHILDREN = new HierarchyHandling('INCLUDE_CHILDREN', 1);
  SEPARATE_CHILDREN = new HierarchyHandling('SEPARATE_CHILDREN', 2);
}

function HierarchyHandling(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function values_18(){
  $clinit_HierarchyHandling();
  return stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_HierarchyHandling_2_classLit, 1), $intern_13, 166, 0, [INHERIT, INCLUDE_CHILDREN, SEPARATE_CHILDREN]);
}

defineClass(166, 17, {166:1, 3:1, 23:1, 17:1}, HierarchyHandling);
var INCLUDE_CHILDREN, INHERIT, SEPARATE_CHILDREN;
var Lde_cau_cs_kieler_kiml_options_HierarchyHandling_2_classLit = createForEnum('de.cau.cs.kieler.kiml.options', 'HierarchyHandling', 166, Ljava_lang_Enum_2_classLit, values_18);
function $clinit_HierarchyHandling$Map(){
  $clinit_HierarchyHandling$Map = emptyMethod;
  $MAP_4 = createValueOfMap(($clinit_HierarchyHandling() , stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_HierarchyHandling_2_classLit, 1), $intern_13, 166, 0, [INHERIT, INCLUDE_CHILDREN, SEPARATE_CHILDREN])));
}

var $MAP_4;
function $clinit_LayoutOptions(){
  $clinit_LayoutOptions = emptyMethod;
  var all, all0;
  ANIMATE = new Property_2('de.cau.cs.kieler.animate', ($clinit_Boolean() , $clinit_Boolean() , TRUE_0));
  new Property_2('de.cau.cs.kieler.minAnimTime', valueOf_0(400));
  new Property_2('de.cau.cs.kieler.maxAnimTime', valueOf_0(4000));
  new Property_2('de.cau.cs.kieler.animTimeFactor', valueOf_0(100));
  ADDITIONAL_PORT_SPACE = new Property_2('de.cau.cs.kieler.additionalPortSpace', null);
  COMMENT_BOX = new Property_2('de.cau.cs.kieler.commentBox', (null , FALSE_0));
  new Property_1('de.cau.cs.kieler.diagramType');
  EDGE_LABEL_PLACEMENT = new Property_2('de.cau.cs.kieler.edgeLabelPlacement', ($clinit_EdgeLabelPlacement() , UNDEFINED_0));
  EDGE_TYPE = new Property_2('de.cau.cs.kieler.edgeType', ($clinit_EdgeType() , NONE));
  FONT_NAME = new Property_1('de.cau.cs.kieler.fontName');
  FONT_SIZE = new Property_2('de.cau.cs.kieler.fontSize', valueOf_0(0));
  HYPERNODE = new Property_2('de.cau.cs.kieler.hypernode', (null , FALSE_0));
  JUNCTION_POINTS = new Property_2('de.cau.cs.kieler.junctionPoints', new KVectorChain);
  new Property_2('de.cau.cs.kieler.layoutAncestors', (null , FALSE_0));
  MARGINS = new Property_2('de.cau.cs.kieler.margins', new Spacing$Margins);
  MIN_HEIGHT = new Property_3('de.cau.cs.kieler.minHeight', new Float_0(0), new Float_0(0));
  MIN_WIDTH = new Property_3('de.cau.cs.kieler.minWidth', new Float_0(0), new Float_0(0));
  NO_LAYOUT = new Property_2('de.cau.cs.kieler.noLayout', (null , FALSE_0));
  OFFSET = new Property_1('de.cau.cs.kieler.offset');
  PORT_ANCHOR = new Property_1('de.cau.cs.kieler.klay.layered.portAnchor');
  PORT_INDEX = new Property_1('de.cau.cs.kieler.portIndex');
  PORT_SIDE = new Property_2('de.cau.cs.kieler.portSide', ($clinit_PortSide() , UNDEFINED_4));
  new Property_2('de.cau.cs.kieler.progressBar', (null , FALSE_0));
  new Property_2('de.cau.cs.kieler.resetConfig', (null , TRUE_0));
  new Property_2('de.cau.cs.kieler.scaleFactor', new Float_0(1));
  THICKNESS = new Property_2('de.cau.cs.kieler.thickness', new Float_0(1));
  new Property_2('de.cau.cs.kieler.zoomToFit', (null , FALSE_0));
  ALGORITHM = new Property_1('de.cau.cs.kieler.algorithm');
  ALIGNMENT = new Property_2('de.cau.cs.kieler.alignment', ($clinit_Alignment() , AUTOMATIC));
  ASPECT_RATIO = new Property_2('de.cau.cs.kieler.aspectRatio', new Float_0(0));
  BEND_POINTS = new Property_1('de.cau.cs.kieler.bendPoints');
  BORDER_SPACING = new Property_2('de.cau.cs.kieler.borderSpacing', new Float_0(-1));
  DEBUG_MODE = new Property_2('de.cau.cs.kieler.debugMode', (null , FALSE_0));
  DIRECTION = new Property_2('de.cau.cs.kieler.direction', ($clinit_Direction() , UNDEFINED));
  EDGE_ROUTING = new Property_2('de.cau.cs.kieler.edgeRouting', ($clinit_EdgeRouting() , UNDEFINED_1));
  EXPAND_NODES = new Property_2('de.cau.cs.kieler.expandNodes', (null , FALSE_0));
  HIERARCHY_HANDLING = new Property_2('de.cau.cs.kieler.hierarchyHandling', ($clinit_HierarchyHandling() , INHERIT));
  INTERACTIVE = new Property_2('de.cau.cs.kieler.interactive', (null , FALSE_0));
  LABEL_SPACING = new Property_3('de.cau.cs.kieler.labelSpacing', new Float_0(3), new Float_0(0));
  LAYOUT_HIERARCHY = new Property_2('de.cau.cs.kieler.layoutHierarchy', (null , FALSE_0));
  NODE_LABEL_PLACEMENT = new Property_2('de.cau.cs.kieler.nodeLabelPlacement', ($clinit_NodeLabelPlacement() , all0 = castTo($getEnumConstants(Lde_cau_cs_kieler_kiml_options_NodeLabelPlacement_2_classLit), 11) , new EnumSet$EnumSetImpl(all0, castTo(createFrom(all0, all0.length), 11), 0)));
  PORT_CONSTRAINTS = new Property_2('de.cau.cs.kieler.portConstraints', ($clinit_PortConstraints() , UNDEFINED_3));
  PORT_LABEL_PLACEMENT = new Property_2('de.cau.cs.kieler.portLabelPlacement', ($clinit_PortLabelPlacement() , OUTSIDE_0));
  PORT_SPACING = new Property_3('de.cau.cs.kieler.portSpacing', new Float_0(-1), new Float_0(0));
  PORT_ALIGNMENT = new Property_2('de.cau.cs.kieler.portAlignment', ($clinit_PortAlignment() , JUSTIFIED));
  PORT_ALIGNMENT_NORTH = new Property_2('de.cau.cs.kieler.portAlignment.north', UNDEFINED_2);
  PORT_ALIGNMENT_SOUTH = new Property_2('de.cau.cs.kieler.portAlignment.south', UNDEFINED_2);
  PORT_ALIGNMENT_WEST = new Property_2('de.cau.cs.kieler.portAlignment.west', UNDEFINED_2);
  PORT_ALIGNMENT_EAST = new Property_2('de.cau.cs.kieler.portAlignment.east', UNDEFINED_2);
  POSITION = new Property_1('de.cau.cs.kieler.position');
  PRIORITY = new Property_1('de.cau.cs.kieler.priority');
  new Property_1('de.cau.cs.kieler.randomSeed');
  SELF_LOOP_INSIDE = new Property_2('de.cau.cs.kieler.selfLoopInside', (null , FALSE_0));
  SEPARATE_CC = new Property_1('de.cau.cs.kieler.separateConnComp');
  SIZE_CONSTRAINT = new Property_2('de.cau.cs.kieler.sizeConstraint', ($clinit_SizeConstraint() , all = castTo($getEnumConstants(Lde_cau_cs_kieler_kiml_options_SizeConstraint_2_classLit), 11) , new EnumSet$EnumSetImpl(all, castTo(createFrom(all, all.length), 11), 0)));
  SIZE_OPTIONS = new Property_2('de.cau.cs.kieler.sizeOptions', of_4(($clinit_SizeOptions() , DEFAULT_MINIMUM_SIZE), stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_SizeOptions_2_classLit, 1), $intern_13, 139, 0, [APPLY_ADDITIONAL_INSETS])));
  SPACING = new Property_3('de.cau.cs.kieler.spacing', new Float_0(-1), new Float_0(0));
  LAYOUT_PARTITIONS = new Property_2('de.cau.cs.kieler.layoutPartitions', (null , FALSE_0));
  PARTITION = new Property_1('de.cau.cs.kieler.partition');
}

var ADDITIONAL_PORT_SPACE, ALGORITHM, ALIGNMENT, ANIMATE, ASPECT_RATIO, BEND_POINTS, BORDER_SPACING, COMMENT_BOX, DEBUG_MODE, DIRECTION, EDGE_LABEL_PLACEMENT, EDGE_ROUTING, EDGE_TYPE, EXPAND_NODES, FONT_NAME, FONT_SIZE, HIERARCHY_HANDLING, HYPERNODE, INTERACTIVE, JUNCTION_POINTS, LABEL_SPACING, LAYOUT_HIERARCHY, LAYOUT_PARTITIONS, MARGINS, MIN_HEIGHT, MIN_WIDTH, NODE_LABEL_PLACEMENT, NO_LAYOUT, OFFSET, PARTITION, PORT_ALIGNMENT, PORT_ALIGNMENT_EAST, PORT_ALIGNMENT_NORTH, PORT_ALIGNMENT_SOUTH, PORT_ALIGNMENT_WEST, PORT_ANCHOR, PORT_CONSTRAINTS, PORT_INDEX, PORT_LABEL_PLACEMENT, PORT_SIDE, PORT_SPACING, POSITION, PRIORITY, SELF_LOOP_INSIDE, SEPARATE_CC, SIZE_CONSTRAINT, SIZE_OPTIONS, SPACING, THICKNESS;
function $clinit_NodeLabelPlacement(){
  $clinit_NodeLabelPlacement = emptyMethod;
  H_LEFT = new NodeLabelPlacement('H_LEFT', 0);
  H_CENTER = new NodeLabelPlacement('H_CENTER', 1);
  H_RIGHT = new NodeLabelPlacement('H_RIGHT', 2);
  V_TOP = new NodeLabelPlacement('V_TOP', 3);
  V_CENTER = new NodeLabelPlacement('V_CENTER', 4);
  V_BOTTOM = new NodeLabelPlacement('V_BOTTOM', 5);
  INSIDE = new NodeLabelPlacement('INSIDE', 6);
  OUTSIDE = new NodeLabelPlacement('OUTSIDE', 7);
  H_PRIORITY = new NodeLabelPlacement('H_PRIORITY', 8);
}

function NodeLabelPlacement(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function values_19(){
  $clinit_NodeLabelPlacement();
  return stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_NodeLabelPlacement_2_classLit, 1), $intern_13, 41, 0, [H_LEFT, H_CENTER, H_RIGHT, V_TOP, V_CENTER, V_BOTTOM, INSIDE, OUTSIDE, H_PRIORITY]);
}

defineClass(41, 17, {41:1, 3:1, 23:1, 17:1}, NodeLabelPlacement);
var H_CENTER, H_LEFT, H_PRIORITY, H_RIGHT, INSIDE, OUTSIDE, V_BOTTOM, V_CENTER, V_TOP;
var Lde_cau_cs_kieler_kiml_options_NodeLabelPlacement_2_classLit = createForEnum('de.cau.cs.kieler.kiml.options', 'NodeLabelPlacement', 41, Ljava_lang_Enum_2_classLit, values_19);
function $clinit_NodeLabelPlacement$Map(){
  $clinit_NodeLabelPlacement$Map = emptyMethod;
  $MAP_5 = createValueOfMap(($clinit_NodeLabelPlacement() , stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_NodeLabelPlacement_2_classLit, 1), $intern_13, 41, 0, [H_LEFT, H_CENTER, H_RIGHT, V_TOP, V_CENTER, V_BOTTOM, INSIDE, OUTSIDE, H_PRIORITY])));
}

var $MAP_5;
function $clinit_PortAlignment(){
  $clinit_PortAlignment = emptyMethod;
  UNDEFINED_2 = new PortAlignment('UNDEFINED', 0);
  JUSTIFIED = new PortAlignment('JUSTIFIED', 1);
  BEGIN = new PortAlignment('BEGIN', 2);
  CENTER_1 = new PortAlignment('CENTER', 3);
  END = new PortAlignment('END', 4);
}

function PortAlignment(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function values_20(){
  $clinit_PortAlignment();
  return stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_PortAlignment_2_classLit, 1), $intern_13, 99, 0, [UNDEFINED_2, JUSTIFIED, BEGIN, CENTER_1, END]);
}

defineClass(99, 17, {99:1, 3:1, 23:1, 17:1}, PortAlignment);
var BEGIN, CENTER_1, END, JUSTIFIED, UNDEFINED_2;
var Lde_cau_cs_kieler_kiml_options_PortAlignment_2_classLit = createForEnum('de.cau.cs.kieler.kiml.options', 'PortAlignment', 99, Ljava_lang_Enum_2_classLit, values_20);
function $clinit_PortAlignment$Map(){
  $clinit_PortAlignment$Map = emptyMethod;
  $MAP_6 = createValueOfMap(($clinit_PortAlignment() , stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_PortAlignment_2_classLit, 1), $intern_13, 99, 0, [UNDEFINED_2, JUSTIFIED, BEGIN, CENTER_1, END])));
}

var $MAP_6;
function $clinit_PortConstraints(){
  $clinit_PortConstraints = emptyMethod;
  UNDEFINED_3 = new PortConstraints('UNDEFINED', 0);
  FREE = new PortConstraints('FREE', 1);
  FIXED_SIDE = new PortConstraints('FIXED_SIDE', 2);
  FIXED_ORDER = new PortConstraints('FIXED_ORDER', 3);
  FIXED_RATIO = new PortConstraints('FIXED_RATIO', 4);
  FIXED_POS = new PortConstraints('FIXED_POS', 5);
}

function $isOrderFixed(this$static){
  return this$static == FIXED_ORDER || this$static == FIXED_RATIO || this$static == FIXED_POS;
}

function $isSideFixed(this$static){
  return this$static != FREE && this$static != UNDEFINED_3;
}

function PortConstraints(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function values_21(){
  $clinit_PortConstraints();
  return stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_PortConstraints_2_classLit, 1), $intern_13, 28, 0, [UNDEFINED_3, FREE, FIXED_SIDE, FIXED_ORDER, FIXED_RATIO, FIXED_POS]);
}

defineClass(28, 17, {28:1, 3:1, 23:1, 17:1}, PortConstraints);
var FIXED_ORDER, FIXED_POS, FIXED_RATIO, FIXED_SIDE, FREE, UNDEFINED_3;
var Lde_cau_cs_kieler_kiml_options_PortConstraints_2_classLit = createForEnum('de.cau.cs.kieler.kiml.options', 'PortConstraints', 28, Ljava_lang_Enum_2_classLit, values_21);
function $clinit_PortConstraints$Map(){
  $clinit_PortConstraints$Map = emptyMethod;
  $MAP_7 = createValueOfMap(($clinit_PortConstraints() , stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_PortConstraints_2_classLit, 1), $intern_13, 28, 0, [UNDEFINED_3, FREE, FIXED_SIDE, FIXED_ORDER, FIXED_RATIO, FIXED_POS])));
}

var $MAP_7;
function $clinit_PortLabelPlacement(){
  $clinit_PortLabelPlacement = emptyMethod;
  OUTSIDE_0 = new PortLabelPlacement('OUTSIDE', 0);
  INSIDE_0 = new PortLabelPlacement('INSIDE', 1);
  FIXED = new PortLabelPlacement('FIXED', 2);
}

function PortLabelPlacement(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function values_22(){
  $clinit_PortLabelPlacement();
  return stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_PortLabelPlacement_2_classLit, 1), $intern_13, 149, 0, [OUTSIDE_0, INSIDE_0, FIXED]);
}

defineClass(149, 17, {149:1, 3:1, 23:1, 17:1}, PortLabelPlacement);
var FIXED, INSIDE_0, OUTSIDE_0;
var Lde_cau_cs_kieler_kiml_options_PortLabelPlacement_2_classLit = createForEnum('de.cau.cs.kieler.kiml.options', 'PortLabelPlacement', 149, Ljava_lang_Enum_2_classLit, values_22);
function $clinit_PortLabelPlacement$Map(){
  $clinit_PortLabelPlacement$Map = emptyMethod;
  $MAP_8 = createValueOfMap(($clinit_PortLabelPlacement() , stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_PortLabelPlacement_2_classLit, 1), $intern_13, 149, 0, [OUTSIDE_0, INSIDE_0, FIXED])));
}

var $MAP_8;
function $clinit_PortSide(){
  $clinit_PortSide = emptyMethod;
  var all;
  UNDEFINED_4 = new PortSide('UNDEFINED', 0);
  NORTH = new PortSide('NORTH', 1);
  EAST = new PortSide('EAST', 2);
  SOUTH = new PortSide('SOUTH', 3);
  WEST = new PortSide('WEST', 4);
  SIDES_NONE = ($clinit_Collections() , new Collections$UnmodifiableSet((all = castTo($getEnumConstants(Lde_cau_cs_kieler_kiml_options_PortSide_2_classLit), 11) , new EnumSet$EnumSetImpl(all, castTo(createFrom(all, all.length), 11), 0))));
  SIDES_NORTH = asImmutable(of_4(NORTH, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_PortSide_2_classLit, 1), $intern_13, 32, 0, [])));
  SIDES_EAST = asImmutable(of_4(EAST, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_PortSide_2_classLit, 1), $intern_13, 32, 0, [])));
  SIDES_SOUTH = asImmutable(of_4(SOUTH, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_PortSide_2_classLit, 1), $intern_13, 32, 0, [])));
  SIDES_WEST = asImmutable(of_4(WEST, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_PortSide_2_classLit, 1), $intern_13, 32, 0, [])));
  SIDES_NORTH_SOUTH = asImmutable(of_4(NORTH, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_PortSide_2_classLit, 1), $intern_13, 32, 0, [SOUTH])));
  SIDES_EAST_WEST = asImmutable(of_4(EAST, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_PortSide_2_classLit, 1), $intern_13, 32, 0, [WEST])));
  SIDES_NORTH_WEST = asImmutable(of_4(NORTH, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_PortSide_2_classLit, 1), $intern_13, 32, 0, [WEST])));
  SIDES_NORTH_EAST = asImmutable(of_4(NORTH, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_PortSide_2_classLit, 1), $intern_13, 32, 0, [EAST])));
  SIDES_SOUTH_WEST = asImmutable(of_4(SOUTH, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_PortSide_2_classLit, 1), $intern_13, 32, 0, [WEST])));
  SIDES_EAST_SOUTH = asImmutable(of_4(EAST, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_PortSide_2_classLit, 1), $intern_13, 32, 0, [SOUTH])));
  SIDES_NORTH_EAST_WEST = asImmutable(of_4(NORTH, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_PortSide_2_classLit, 1), $intern_13, 32, 0, [EAST, WEST])));
  SIDES_EAST_SOUTH_WEST = asImmutable(of_4(EAST, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_PortSide_2_classLit, 1), $intern_13, 32, 0, [SOUTH, WEST])));
  SIDES_NORTH_SOUTH_WEST = asImmutable(of_4(NORTH, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_PortSide_2_classLit, 1), $intern_13, 32, 0, [SOUTH, WEST])));
  SIDES_NORTH_EAST_SOUTH = asImmutable(of_4(NORTH, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_PortSide_2_classLit, 1), $intern_13, 32, 0, [EAST, SOUTH])));
  SIDES_NORTH_EAST_SOUTH_WEST = asImmutable(of_4(NORTH, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_PortSide_2_classLit, 1), $intern_13, 32, 0, [EAST, SOUTH, WEST])));
}

function $opposed(this$static){
  switch (this$static.ordinal) {
    case 1:
      return SOUTH;
    case 2:
      return WEST;
    case 3:
      return NORTH;
    case 4:
      return EAST;
    default:return UNDEFINED_4;
  }
}

function PortSide(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function fromDirection(direction){
  $clinit_PortSide();
  switch (direction.ordinal) {
    case 4:
      return NORTH;
    case 1:
      return EAST;
    case 3:
      return SOUTH;
    case 2:
      return WEST;
    default:return UNDEFINED_4;
  }
}

function values_23(){
  $clinit_PortSide();
  return stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_PortSide_2_classLit, 1), $intern_13, 32, 0, [UNDEFINED_4, NORTH, EAST, SOUTH, WEST]);
}

defineClass(32, 17, {32:1, 3:1, 23:1, 17:1}, PortSide);
var EAST, NORTH, SIDES_EAST, SIDES_EAST_SOUTH, SIDES_EAST_SOUTH_WEST, SIDES_EAST_WEST, SIDES_NONE, SIDES_NORTH, SIDES_NORTH_EAST, SIDES_NORTH_EAST_SOUTH, SIDES_NORTH_EAST_SOUTH_WEST, SIDES_NORTH_EAST_WEST, SIDES_NORTH_SOUTH, SIDES_NORTH_SOUTH_WEST, SIDES_NORTH_WEST, SIDES_SOUTH, SIDES_SOUTH_WEST, SIDES_WEST, SOUTH, UNDEFINED_4, WEST;
var Lde_cau_cs_kieler_kiml_options_PortSide_2_classLit = createForEnum('de.cau.cs.kieler.kiml.options', 'PortSide', 32, Ljava_lang_Enum_2_classLit, values_23);
function $clinit_PortSide$Map(){
  $clinit_PortSide$Map = emptyMethod;
  $MAP_9 = createValueOfMap(($clinit_PortSide() , stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_PortSide_2_classLit, 1), $intern_13, 32, 0, [UNDEFINED_4, NORTH, EAST, SOUTH, WEST])));
}

var $MAP_9;
function $clinit_SizeConstraint(){
  $clinit_SizeConstraint = emptyMethod;
  PORTS = new SizeConstraint('PORTS', 0);
  PORT_LABELS = new SizeConstraint('PORT_LABELS', 1);
  NODE_LABELS = new SizeConstraint('NODE_LABELS', 2);
  MINIMUM_SIZE = new SizeConstraint('MINIMUM_SIZE', 3);
}

function SizeConstraint(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function values_24(){
  $clinit_SizeConstraint();
  return stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_SizeConstraint_2_classLit, 1), $intern_13, 150, 0, [PORTS, PORT_LABELS, NODE_LABELS, MINIMUM_SIZE]);
}

defineClass(150, 17, {150:1, 3:1, 23:1, 17:1}, SizeConstraint);
var MINIMUM_SIZE, NODE_LABELS, PORTS, PORT_LABELS;
var Lde_cau_cs_kieler_kiml_options_SizeConstraint_2_classLit = createForEnum('de.cau.cs.kieler.kiml.options', 'SizeConstraint', 150, Ljava_lang_Enum_2_classLit, values_24);
function $clinit_SizeConstraint$Map(){
  $clinit_SizeConstraint$Map = emptyMethod;
  $MAP_10 = createValueOfMap(($clinit_SizeConstraint() , stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_SizeConstraint_2_classLit, 1), $intern_13, 150, 0, [PORTS, PORT_LABELS, NODE_LABELS, MINIMUM_SIZE])));
}

var $MAP_10;
function $clinit_SizeOptions(){
  $clinit_SizeOptions = emptyMethod;
  DEFAULT_MINIMUM_SIZE = new SizeOptions('DEFAULT_MINIMUM_SIZE', 0);
  MINIMUM_SIZE_ACCOUNTS_FOR_INSETS = new SizeOptions('MINIMUM_SIZE_ACCOUNTS_FOR_INSETS', 1);
  COMPUTE_INSETS = new SizeOptions('COMPUTE_INSETS', 2);
  APPLY_ADDITIONAL_INSETS = new SizeOptions('APPLY_ADDITIONAL_INSETS', 3);
}

function SizeOptions(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function values_25(){
  $clinit_SizeOptions();
  return stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_SizeOptions_2_classLit, 1), $intern_13, 139, 0, [DEFAULT_MINIMUM_SIZE, MINIMUM_SIZE_ACCOUNTS_FOR_INSETS, COMPUTE_INSETS, APPLY_ADDITIONAL_INSETS]);
}

defineClass(139, 17, {139:1, 3:1, 23:1, 17:1}, SizeOptions);
var APPLY_ADDITIONAL_INSETS, COMPUTE_INSETS, DEFAULT_MINIMUM_SIZE, MINIMUM_SIZE_ACCOUNTS_FOR_INSETS;
var Lde_cau_cs_kieler_kiml_options_SizeOptions_2_classLit = createForEnum('de.cau.cs.kieler.kiml.options', 'SizeOptions', 139, Ljava_lang_Enum_2_classLit, values_25);
function $clinit_SizeOptions$Map(){
  $clinit_SizeOptions$Map = emptyMethod;
  $MAP_11 = createValueOfMap(($clinit_SizeOptions() , stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_SizeOptions_2_classLit, 1), $intern_13, 139, 0, [DEFAULT_MINIMUM_SIZE, MINIMUM_SIZE_ACCOUNTS_FOR_INSETS, COMPUTE_INSETS, APPLY_ADDITIONAL_INSETS])));
}

var $MAP_11;
function $getPosition(this$static){
  return new KVector_1(this$static.x_0, this$static.y_0);
}

function $setRect(this$static, nx, ny, nw, nh){
  this$static.x_0 = nx;
  this$static.y_0 = ny;
  this$static.width_0 = nw;
  this$static.height = nh;
}

function $union(this$static, other){
  var t, x1, x2, y1, y2;
  x1 = min_1(this$static.x_0, other.x_0);
  y1 = min_1(this$static.y_0, other.y_0);
  x2 = max_1(this$static.x_0 + this$static.width_0, other.x_0 + other.width_0);
  y2 = max_1(this$static.y_0 + this$static.height, other.y_0 + other.height);
  if (x2 < x1) {
    t = x1;
    x1 = x2;
    x2 = t;
  }
  if (y2 < y1) {
    t = y1;
    y1 = y2;
    y2 = t;
  }
  $setRect(this$static, x1, y1, x2 - x1, y2 - y1);
}

function Rectangle(){
  Rectangle_0.call(this, 0, 0, 0, 0);
}

function Rectangle_0(x_0, y_0, w, h){
  this.x_0 = x_0;
  this.y_0 = y_0;
  this.width_0 = w;
  this.height = h;
}

defineClass(62, 1, {62:1}, Rectangle, Rectangle_0);
_.equals = function equals_32(obj){
  var other;
  if (obj == null || !instanceOf(obj, 62)) {
    return false;
  }
  other = castTo(obj, 62);
  return equals_50(this.x_0, other.x_0) && equals_50(this.y_0, other.y_0) && equals_50(this.width_0, other.width_0) && equals_50(this.height, other.height);
}
;
_.hashCode_0 = function hashCode_32(){
  return hashCode_44(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [this.x_0, this.y_0, this.width_0, this.height]));
}
;
_.toString_0 = function toString_44(){
  return 'Rect[x=' + this.x_0 + ',y=' + this.y_0 + ',w=' + this.width_0 + ',h=' + this.height + ']';
}
;
_.height = 0;
_.width_0 = 0;
_.x_0 = 0;
_.y_0 = 0;
var Lde_cau_cs_kieler_kiml_util_nodespacing_Rectangle_2_classLit = createForClass('de.cau.cs.kieler.kiml.util.nodespacing', 'Rectangle', 62);
function LabelGroup(){
  Rectangle.call(this);
}

defineClass(283, 62, {283:1, 62:1}, LabelGroup);
_.nextLabelYPos = 0;
var Lde_cau_cs_kieler_kiml_util_labelspacing_LabelGroup_2_classLit = createForClass('de.cau.cs.kieler.kiml.util.labelspacing', 'LabelGroup', 283);
function $clinit_LabelLocation(){
  $clinit_LabelLocation = emptyMethod;
  OUT_T_L = new LabelLocation('OUT_T_L', 0, ($clinit_ImmutableList() , new SingletonImmutableList(of_4(($clinit_NodeLabelPlacement() , OUTSIDE), stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_NodeLabelPlacement_2_classLit, 1), $intern_13, 41, 0, [V_TOP, H_LEFT])))), ($clinit_TextAlignment() , LEFT_1));
  OUT_T_C = new LabelLocation('OUT_T_C', 1, new RegularImmutableList(nullCheckedList(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [of_4(OUTSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_NodeLabelPlacement_2_classLit, 1), $intern_13, 41, 0, [V_TOP, H_CENTER])), of_4(OUTSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_NodeLabelPlacement_2_classLit, 1), $intern_13, 41, 0, [V_TOP, H_CENTER, H_PRIORITY]))]))), CENTER_2);
  OUT_T_R = new LabelLocation('OUT_T_R', 2, new SingletonImmutableList(of_4(OUTSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_NodeLabelPlacement_2_classLit, 1), $intern_13, 41, 0, [V_TOP, H_RIGHT]))), RIGHT_1);
  OUT_B_L = new LabelLocation('OUT_B_L', 3, new SingletonImmutableList(of_4(OUTSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_NodeLabelPlacement_2_classLit, 1), $intern_13, 41, 0, [V_BOTTOM, H_LEFT]))), LEFT_1);
  OUT_B_C = new LabelLocation('OUT_B_C', 4, new RegularImmutableList(nullCheckedList(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [of_4(OUTSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_NodeLabelPlacement_2_classLit, 1), $intern_13, 41, 0, [V_BOTTOM, H_CENTER])), of_4(OUTSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_NodeLabelPlacement_2_classLit, 1), $intern_13, 41, 0, [V_BOTTOM, H_CENTER, H_PRIORITY]))]))), CENTER_2);
  OUT_B_R = new LabelLocation('OUT_B_R', 5, new SingletonImmutableList(of_4(OUTSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_NodeLabelPlacement_2_classLit, 1), $intern_13, 41, 0, [V_BOTTOM, H_RIGHT]))), RIGHT_1);
  OUT_L_T = new LabelLocation('OUT_L_T', 6, new SingletonImmutableList(of_4(OUTSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_NodeLabelPlacement_2_classLit, 1), $intern_13, 41, 0, [H_LEFT, V_TOP, H_PRIORITY]))), RIGHT_1);
  OUT_L_C = new LabelLocation('OUT_L_C', 7, new RegularImmutableList(nullCheckedList(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [of_4(OUTSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_NodeLabelPlacement_2_classLit, 1), $intern_13, 41, 0, [H_LEFT, V_CENTER])), of_4(OUTSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_NodeLabelPlacement_2_classLit, 1), $intern_13, 41, 0, [H_LEFT, V_CENTER, H_PRIORITY]))]))), RIGHT_1);
  OUT_L_B = new LabelLocation('OUT_L_B', 8, new SingletonImmutableList(of_4(OUTSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_NodeLabelPlacement_2_classLit, 1), $intern_13, 41, 0, [H_LEFT, V_BOTTOM, H_PRIORITY]))), RIGHT_1);
  OUT_R_T = new LabelLocation('OUT_R_T', 9, new SingletonImmutableList(of_4(OUTSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_NodeLabelPlacement_2_classLit, 1), $intern_13, 41, 0, [H_RIGHT, V_TOP, H_PRIORITY]))), LEFT_1);
  OUT_R_C = new LabelLocation('OUT_R_C', 10, new RegularImmutableList(nullCheckedList(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [of_4(OUTSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_NodeLabelPlacement_2_classLit, 1), $intern_13, 41, 0, [H_RIGHT, V_CENTER])), of_4(OUTSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_NodeLabelPlacement_2_classLit, 1), $intern_13, 41, 0, [H_RIGHT, V_CENTER, H_PRIORITY]))]))), LEFT_1);
  OUT_R_B = new LabelLocation('OUT_R_B', 11, new SingletonImmutableList(of_4(OUTSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_NodeLabelPlacement_2_classLit, 1), $intern_13, 41, 0, [H_RIGHT, V_BOTTOM, H_PRIORITY]))), LEFT_1);
  IN_T_L = new LabelLocation('IN_T_L', 12, new RegularImmutableList(nullCheckedList(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [of_4(INSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_NodeLabelPlacement_2_classLit, 1), $intern_13, 41, 0, [V_TOP, H_LEFT])), of_4(INSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_NodeLabelPlacement_2_classLit, 1), $intern_13, 41, 0, [V_TOP, H_LEFT, H_PRIORITY]))]))), LEFT_1);
  IN_T_C = new LabelLocation('IN_T_C', 13, new RegularImmutableList(nullCheckedList(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [of_4(INSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_NodeLabelPlacement_2_classLit, 1), $intern_13, 41, 0, [V_TOP, H_CENTER])), of_4(INSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_NodeLabelPlacement_2_classLit, 1), $intern_13, 41, 0, [V_TOP, H_CENTER, H_PRIORITY]))]))), CENTER_2);
  IN_T_R = new LabelLocation('IN_T_R', 14, new RegularImmutableList(nullCheckedList(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [of_4(INSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_NodeLabelPlacement_2_classLit, 1), $intern_13, 41, 0, [V_TOP, H_RIGHT])), of_4(INSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_NodeLabelPlacement_2_classLit, 1), $intern_13, 41, 0, [V_TOP, H_RIGHT, H_PRIORITY]))]))), RIGHT_1);
  IN_C_L = new LabelLocation('IN_C_L', 15, new RegularImmutableList(nullCheckedList(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [of_4(INSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_NodeLabelPlacement_2_classLit, 1), $intern_13, 41, 0, [V_CENTER, H_LEFT])), of_4(INSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_NodeLabelPlacement_2_classLit, 1), $intern_13, 41, 0, [V_CENTER, H_LEFT, H_PRIORITY]))]))), LEFT_1);
  IN_C_C = new LabelLocation('IN_C_C', 16, new RegularImmutableList(nullCheckedList(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [of_4(INSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_NodeLabelPlacement_2_classLit, 1), $intern_13, 41, 0, [V_CENTER, H_CENTER])), of_4(INSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_NodeLabelPlacement_2_classLit, 1), $intern_13, 41, 0, [V_CENTER, H_CENTER, H_PRIORITY]))]))), CENTER_2);
  IN_C_R = new LabelLocation('IN_C_R', 17, new RegularImmutableList(nullCheckedList(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [of_4(INSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_NodeLabelPlacement_2_classLit, 1), $intern_13, 41, 0, [V_CENTER, H_RIGHT])), of_4(INSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_NodeLabelPlacement_2_classLit, 1), $intern_13, 41, 0, [V_CENTER, H_RIGHT, H_PRIORITY]))]))), RIGHT_1);
  IN_B_L = new LabelLocation('IN_B_L', 18, new RegularImmutableList(nullCheckedList(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [of_4(INSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_NodeLabelPlacement_2_classLit, 1), $intern_13, 41, 0, [V_BOTTOM, H_LEFT])), of_4(INSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_NodeLabelPlacement_2_classLit, 1), $intern_13, 41, 0, [V_BOTTOM, H_LEFT, H_PRIORITY]))]))), LEFT_1);
  IN_B_C = new LabelLocation('IN_B_C', 19, new RegularImmutableList(nullCheckedList(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [of_4(INSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_NodeLabelPlacement_2_classLit, 1), $intern_13, 41, 0, [V_BOTTOM, H_CENTER])), of_4(INSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_NodeLabelPlacement_2_classLit, 1), $intern_13, 41, 0, [V_BOTTOM, H_CENTER, H_PRIORITY]))]))), CENTER_2);
  IN_B_R = new LabelLocation('IN_B_R', 20, new RegularImmutableList(nullCheckedList(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [of_4(INSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_NodeLabelPlacement_2_classLit, 1), $intern_13, 41, 0, [V_BOTTOM, H_RIGHT])), of_4(INSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_NodeLabelPlacement_2_classLit, 1), $intern_13, 41, 0, [V_BOTTOM, H_RIGHT, H_PRIORITY]))]))), RIGHT_1);
  UNDEFINED_5 = new LabelLocation('UNDEFINED', 21, (null , EMPTY), null);
}

function LabelLocation(enum$name, enum$ordinal, assignedPlacements, horizontalAlignment){
  Enum.call(this, enum$name, enum$ordinal);
  this.assignedPlacements = assignedPlacements;
  this.horizontalAlignment = horizontalAlignment;
}

function fromNodeLabelPlacement(labelPlacement){
  $clinit_LabelLocation();
  var location_0, location$array, location$index, location$max;
  for (location$array = values_26() , location$index = 0 , location$max = location$array.length; location$index < location$max; ++location$index) {
    location_0 = location$array[location$index];
    if ($contains_0(location_0.assignedPlacements, labelPlacement)) {
      return location_0;
    }
  }
  return UNDEFINED_5;
}

function values_26(){
  $clinit_LabelLocation();
  return stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_util_labelspacing_LabelLocation_2_classLit, 1), $intern_13, 66, 0, [OUT_T_L, OUT_T_C, OUT_T_R, OUT_B_L, OUT_B_C, OUT_B_R, OUT_L_T, OUT_L_C, OUT_L_B, OUT_R_T, OUT_R_C, OUT_R_B, IN_T_L, IN_T_C, IN_T_R, IN_C_L, IN_C_C, IN_C_R, IN_B_L, IN_B_C, IN_B_R, UNDEFINED_5]);
}

defineClass(66, 17, {66:1, 3:1, 23:1, 17:1}, LabelLocation);
var IN_B_C, IN_B_L, IN_B_R, IN_C_C, IN_C_L, IN_C_R, IN_T_C, IN_T_L, IN_T_R, OUT_B_C, OUT_B_L, OUT_B_R, OUT_L_B, OUT_L_C, OUT_L_T, OUT_R_B, OUT_R_C, OUT_R_T, OUT_T_C, OUT_T_L, OUT_T_R, UNDEFINED_5;
var Lde_cau_cs_kieler_kiml_util_labelspacing_LabelLocation_2_classLit = createForEnum('de.cau.cs.kieler.kiml.util.labelspacing', 'LabelLocation', 66, Ljava_lang_Enum_2_classLit, values_26);
function calculateRequiredNodeLabelSpace(node, labelSpacing, labelGroupsBoundingBoxes, insets){
  var boundingBox, entry, entry$iterator, label_0, label$iterator, labelPlacement, nodeLabelPlacement;
  if (!$hasNext_3(new ArrayList$1($getLabels_0(node)))) {
    return insets;
  }
  nodeLabelPlacement = fromNodeLabelPlacement(castTo($getProperty_0(node, ($clinit_LayoutOptions() , NODE_LABEL_PLACEMENT)), 86));
  for (label$iterator = new ArrayList$1($getLabels_0(node)); label$iterator.i < label$iterator.this$01.array.length;) {
    label_0 = castTo($next_8(label$iterator), 129);
    labelPlacement = fromNodeLabelPlacement(castTo($getProperty_0(label_0, NODE_LABEL_PLACEMENT), 86));
    labelPlacement == ($clinit_LabelLocation() , UNDEFINED_5) && (labelPlacement = nodeLabelPlacement);
    $setVolatileId(label_0, labelPlacement.ordinal);
    boundingBox = retrieveLabelGroupsBoundingBox(labelGroupsBoundingBoxes, labelPlacement);
    boundingBox.width_0 = max_1(boundingBox.width_0, label_0.element.size_0.x_0);
    boundingBox.height += label_0.element.size_0.y_0 + labelSpacing;
  }
  for (entry$iterator = new EnumMap$EntrySetIterator((new EnumMap$EntrySet(labelGroupsBoundingBoxes)).this$01); $hasNext_4(entry$iterator.it);) {
    entry = (entry$iterator.key = $next_9(entry$iterator.it) , new EnumMap$MapEntry(entry$iterator.this$01, entry$iterator.key));
    boundingBox = castTo(entry.this$01.values[entry.key.ordinal], 62);
    boundingBox.height -= labelSpacing;
    switch (castTo(entry.key, 66).ordinal) {
      case 12:
      case 13:
      case 14:
        insets.top_0 = max_1(insets.top_0, boundingBox.height + labelSpacing);
        break;
      case 15:
        insets.left = max_1(insets.left, boundingBox.width_0 + labelSpacing);
        break;
      case 17:
        insets.right = max_1(insets.right, boundingBox.width_0 + labelSpacing);
        break;
      case 18:
      case 19:
      case 20:
        insets.bottom = max_1(insets.bottom, boundingBox.height + labelSpacing);
    }
  }
  return insets;
}

function retrieveLabelGroupsBoundingBox(labelGroupsBoundingBoxes, location_0){
  var boundingBox;
  if ($containsEnum(labelGroupsBoundingBoxes.keySet, location_0)) {
    return castTo($containsEnum(labelGroupsBoundingBoxes.keySet, location_0)?labelGroupsBoundingBoxes.values[location_0.ordinal]:null, 62);
  }
   else {
    boundingBox = new LabelGroup;
    $add_17(labelGroupsBoundingBoxes.keySet, location_0);
    $set_5(labelGroupsBoundingBoxes, location_0.ordinal, boundingBox);
    return boundingBox;
  }
}

function $clinit_TextAlignment(){
  $clinit_TextAlignment = emptyMethod;
  LEFT_1 = new TextAlignment('LEFT', 0);
  CENTER_2 = new TextAlignment('CENTER', 1);
  RIGHT_1 = new TextAlignment('RIGHT', 2);
}

function TextAlignment(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function values_27(){
  $clinit_TextAlignment();
  return stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_util_labelspacing_TextAlignment_2_classLit, 1), $intern_13, 225, 0, [LEFT_1, CENTER_2, RIGHT_1]);
}

defineClass(225, 17, {225:1, 3:1, 23:1, 17:1}, TextAlignment);
var CENTER_2, LEFT_1, RIGHT_1;
var Lde_cau_cs_kieler_kiml_util_labelspacing_TextAlignment_2_classLit = createForEnum('de.cau.cs.kieler.kiml.util.labelspacing', 'TextAlignment', 225, Ljava_lang_Enum_2_classLit, values_27);
function calculateLabelAndNodeSizes(adapter){
  $clinit_LabelAndNodeSizeProcessor();
  $process(adapter);
}

function $clinit_LabelAndNodeSizeProcessor(){
  $clinit_LabelAndNodeSizeProcessor = emptyMethod;
  PORT_RATIO_OR_POSITION = new Property_2('portRatioOrPosition', 0);
}

function $calculateAndSetPortMargins(port){
  var label_0, label$iterator, labelBox, labels, lmargins, margin, portBox;
  labels = $getLabels_1(port);
  if ($hasNext_3(new ArrayList$1(labels))) {
    portBox = new Rectangle_0(0, 0, port.element.size_0.x_0, port.element.size_0.y_0);
    for (label$iterator = new ArrayList$1(labels); label$iterator.i < label$iterator.this$01.array.length;) {
      label_0 = castTo($next_8(label$iterator), 129);
      labelBox = new Rectangle_0(label_0.element.pos.x_0, label_0.element.pos.y_0, label_0.element.size_0.x_0, label_0.element.size_0.y_0);
      $union(portBox, labelBox);
    }
    margin = new Spacing$Margins_1((lmargins = castTo(port.element, 7).margin , new Spacing$Margins_0(lmargins.top_0, lmargins.left, lmargins.bottom, lmargins.right)));
    margin.top_0 = -portBox.y_0;
    margin.bottom = portBox.y_0 + portBox.height - port.element.size_0.y_0;
    margin.left = -portBox.x_0;
    margin.right = portBox.x_0 + portBox.width_0 - port.element.size_0.x_0;
    castTo(port.element, 7).margin.left = margin.left;
    castTo(port.element, 7).margin.top_0 = margin.top_0;
    castTo(port.element, 7).margin.right = margin.right;
    castTo(port.element, 7).margin.bottom = margin.bottom;
  }
}

function $calculateMinNodeSizeForFixedPorts(node, accountForLabels){
  var lmargins, lmargins0, port, port$iterator, result;
  result = new KVector;
  for (port$iterator = new ArrayList$1($getPorts(node)); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_8(port$iterator), 161);
    switch (castTo(port.element, 7).side.ordinal) {
      case 4:
      case 2:
        result.y_0 = max_1(result.y_0, port.element.pos.y_0 + port.element.size_0.y_0 + (accountForLabels?(lmargins0 = castTo(port.element, 7).margin , new Spacing$Margins_0(lmargins0.top_0, lmargins0.left, lmargins0.bottom, lmargins0.right)).bottom:0));
        break;
      case 1:
      case 3:
        result.x_0 = max_1(result.x_0, port.element.pos.x_0 + port.element.size_0.x_0 + (accountForLabels?(lmargins = castTo(port.element, 7).margin , new Spacing$Margins_0(lmargins.top_0, lmargins.left, lmargins.bottom, lmargins.right)).right:0));
    }
  }
  return result;
}

function $calculatePortInformation(data_0, accountForLabels){
  var lmargins, lmargins0, lmargins1, lmargins2, port, port$iterator, portAlignment, side, side$array, side$array0, side$index, side$index0, side$max, side$max0;
  if (!$hasNext_3(new ArrayList$1($getPorts(data_0.node)))) {
    return;
  }
  for (port$iterator = new ArrayList$1($getPorts(data_0.node)); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_8(port$iterator), 161);
    side = castTo(port.element, 7).side.ordinal;
    ++data_0.portsCount[side];
    switch (castTo(port.element, 7).side.ordinal) {
      case 4:
      case 2:
        data_0.portUsedSpace[side] += port.element.size_0.y_0 + (accountForLabels?(lmargins0 = castTo(port.element, 7).margin , new Spacing$Margins_0(lmargins0.top_0, lmargins0.left, lmargins0.bottom, lmargins0.right)).bottom + (lmargins1 = castTo(port.element, 7).margin , new Spacing$Margins_0(lmargins1.top_0, lmargins1.left, lmargins1.bottom, lmargins1.right)).top_0:0);
        break;
      case 1:
      case 3:
        data_0.portUsedSpace[side] += port.element.size_0.x_0 + (accountForLabels?(lmargins2 = castTo(port.element, 7).margin , new Spacing$Margins_0(lmargins2.top_0, lmargins2.left, lmargins2.bottom, lmargins2.right)).left + (lmargins = castTo(port.element, 7).margin , new Spacing$Margins_0(lmargins.top_0, lmargins.left, lmargins.bottom, lmargins.right)).right:0);
    }
  }
  portAlignment = castTo($getProperty_0(data_0.node, ($clinit_LayoutOptions() , PORT_ALIGNMENT)), 99);
  portAlignment = portAlignment == ($clinit_PortAlignment() , UNDEFINED_2)?JUSTIFIED:portAlignment;
  data_0.portAlignment[1] = castTo($getProperty_0(data_0.node, PORT_ALIGNMENT_NORTH), 99);
  data_0.portAlignment[3] = castTo($getProperty_0(data_0.node, PORT_ALIGNMENT_SOUTH), 99);
  data_0.portAlignment[4] = castTo($getProperty_0(data_0.node, PORT_ALIGNMENT_WEST), 99);
  data_0.portAlignment[2] = castTo($getProperty_0(data_0.node, PORT_ALIGNMENT_EAST), 99);
  for (side$array0 = ($clinit_PortSide() , stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_PortSide_2_classLit, 1), $intern_13, 32, 0, [UNDEFINED_4, NORTH, EAST, SOUTH, WEST])) , side$index0 = 0 , side$max0 = side$array0.length; side$index0 < side$max0; ++side$index0) {
    side = side$array0[side$index0];
    data_0.portAlignment[side.ordinal] = data_0.portAlignment[side.ordinal] == UNDEFINED_2?portAlignment:data_0.portAlignment[side.ordinal];
  }
  data_0.hasAdditionalPortSpace = $getProperty_0(data_0.node, ADDITIONAL_PORT_SPACE) != null;
  for (side$array = stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_PortSide_2_classLit, 1), $intern_13, 32, 0, [UNDEFINED_4, NORTH, EAST, SOUTH, WEST]) , side$index = 0 , side$max = side$array.length; side$index < side$max; ++side$index) {
    side = side$array[side$index];
    data_0.portsCount[side.ordinal] == 1?(data_0.portGapsCount[side.ordinal] = 2):!data_0.hasAdditionalPortSpace && data_0.portAlignment[side.ordinal] == JUSTIFIED?(data_0.portGapsCount[side.ordinal] = data_0.portsCount[side.ordinal] + 1):(data_0.portGapsCount[side.ordinal] = data_0.portsCount[side.ordinal] - 1);
  }
}

function $calculatePortSpaceRequirements(data_0, portSpacing){
  var additionalHeight, additionalPortSpace, additionalWidth, requiredHeight, requiredWidth;
  if (data_0.hasAdditionalPortSpace) {
    additionalPortSpace = castTo($getProperty_0(data_0.node, ($clinit_LayoutOptions() , ADDITIONAL_PORT_SPACE)), 64);
    additionalWidth = additionalPortSpace.left + additionalPortSpace.right;
    additionalHeight = additionalPortSpace.top_0 + additionalPortSpace.bottom;
  }
   else {
    additionalWidth = portSpacing * 2;
    additionalHeight = portSpacing * 2;
  }
  requiredWidth = max_1(data_0.portsCount[1] > 0?additionalWidth + data_0.portGapsCount[1] * portSpacing + data_0.portUsedSpace[1]:0, data_0.portsCount[3] > 0?additionalWidth + data_0.portGapsCount[3] * portSpacing + data_0.portUsedSpace[3]:0);
  requiredHeight = max_1(data_0.portsCount[4] > 0?additionalHeight + data_0.portGapsCount[4] * portSpacing + data_0.portUsedSpace[4]:0, data_0.portsCount[2] > 0?additionalHeight + data_0.portGapsCount[2] * portSpacing + data_0.portUsedSpace[2]:0);
  return new KVector_1(requiredWidth, requiredHeight);
}

function $calculateRequiredPortLabelSpace(data_0){
  var lmargins, lmargins0, lmargins1, lmargins2, port, port$iterator;
  for (port$iterator = new ArrayList$1($getPorts(data_0.node)); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_8(port$iterator), 161);
    switch (castTo(port.element, 7).side.ordinal) {
      case 4:
        data_0.requiredPortLabelSpace.left = max_1(data_0.requiredPortLabelSpace.left, (lmargins0 = castTo(port.element, 7).margin , new Spacing$Margins_0(lmargins0.top_0, lmargins0.left, lmargins0.bottom, lmargins0.right)).right);
        break;
      case 2:
        data_0.requiredPortLabelSpace.right = max_1(data_0.requiredPortLabelSpace.right, (lmargins1 = castTo(port.element, 7).margin , new Spacing$Margins_0(lmargins1.top_0, lmargins1.left, lmargins1.bottom, lmargins1.right)).left);
        break;
      case 1:
        data_0.requiredPortLabelSpace.top_0 = max_1(data_0.requiredPortLabelSpace.top_0, (lmargins2 = castTo(port.element, 7).margin , new Spacing$Margins_0(lmargins2.top_0, lmargins2.left, lmargins2.bottom, lmargins2.right)).bottom);
        break;
      case 3:
        data_0.requiredPortLabelSpace.bottom = max_1(data_0.requiredPortLabelSpace.bottom, (lmargins = castTo(port.element, 7).margin , new Spacing$Margins_0(lmargins.top_0, lmargins.left, lmargins.bottom, lmargins.right)).top_0);
    }
  }
}

function $computeLabelGroupPositions(data_0){
  var boundingBox, entry, entry$iterator;
  for (entry$iterator = new EnumMap$EntrySetIterator((new EnumMap$EntrySet(data_0.labelGroupsBoundingBoxes)).this$01); $hasNext_4(entry$iterator.it);) {
    entry = (entry$iterator.key = $next_9(entry$iterator.it) , new EnumMap$MapEntry(entry$iterator.this$01, entry$iterator.key));
    boundingBox = castTo(entry.this$01.values[entry.key.ordinal], 62);
    switch (castTo(entry.key, 66).ordinal) {
      case 0:
        boundingBox.x_0 = 0;
        boundingBox.y_0 = -(boundingBox.height + data_0.labelSpacing);
        break;
      case 1:
        boundingBox.x_0 = (data_0.node.element.size_0.x_0 - boundingBox.width_0) / 2;
        boundingBox.y_0 = -(boundingBox.height + data_0.labelSpacing);
        break;
      case 2:
        boundingBox.x_0 = data_0.node.element.size_0.x_0 - boundingBox.width_0;
        boundingBox.y_0 = -(boundingBox.height + data_0.labelSpacing);
        break;
      case 3:
        boundingBox.x_0 = 0;
        boundingBox.y_0 = data_0.node.element.size_0.y_0 + data_0.labelSpacing;
        break;
      case 4:
        boundingBox.x_0 = (data_0.node.element.size_0.x_0 - boundingBox.width_0) / 2;
        boundingBox.y_0 = data_0.node.element.size_0.y_0 + data_0.labelSpacing;
        break;
      case 5:
        boundingBox.x_0 = data_0.node.element.size_0.x_0 - boundingBox.width_0;
        boundingBox.y_0 = data_0.node.element.size_0.y_0 + data_0.labelSpacing;
        break;
      case 6:
        boundingBox.x_0 = -(boundingBox.width_0 + data_0.labelSpacing);
        boundingBox.y_0 = 0;
        break;
      case 7:
        boundingBox.x_0 = -(boundingBox.width_0 + data_0.labelSpacing);
        boundingBox.y_0 = (data_0.node.element.size_0.y_0 - boundingBox.height) / 2;
        break;
      case 8:
        boundingBox.x_0 = -(boundingBox.width_0 + data_0.labelSpacing);
        boundingBox.y_0 = data_0.node.element.size_0.y_0 - boundingBox.height;
        break;
      case 9:
        boundingBox.x_0 = data_0.node.element.size_0.x_0 + data_0.labelSpacing;
        boundingBox.y_0 = 0;
        break;
      case 10:
        boundingBox.x_0 = data_0.node.element.size_0.x_0 + data_0.labelSpacing;
        boundingBox.y_0 = (data_0.node.element.size_0.y_0 - boundingBox.height) / 2;
        break;
      case 11:
        boundingBox.x_0 = data_0.node.element.size_0.x_0 + data_0.labelSpacing;
        boundingBox.y_0 = data_0.node.element.size_0.y_0 - boundingBox.height;
        break;
      case 12:
        boundingBox.x_0 = data_0.requiredPortLabelSpace.left + data_0.labelSpacing;
        boundingBox.y_0 = data_0.requiredPortLabelSpace.top_0 + data_0.labelSpacing;
        break;
      case 13:
        boundingBox.x_0 = (data_0.node.element.size_0.x_0 - boundingBox.width_0) / 2;
        boundingBox.y_0 = data_0.requiredPortLabelSpace.top_0 + data_0.labelSpacing;
        break;
      case 14:
        boundingBox.x_0 = data_0.node.element.size_0.x_0 - data_0.requiredPortLabelSpace.right - boundingBox.width_0 - data_0.labelSpacing;
        boundingBox.y_0 = data_0.requiredPortLabelSpace.top_0 + data_0.labelSpacing;
        break;
      case 15:
        boundingBox.x_0 = data_0.requiredPortLabelSpace.left + data_0.labelSpacing;
        boundingBox.y_0 = (data_0.node.element.size_0.y_0 - boundingBox.height) / 2;
        break;
      case 16:
        boundingBox.x_0 = (data_0.node.element.size_0.x_0 - boundingBox.width_0) / 2;
        boundingBox.y_0 = (data_0.node.element.size_0.y_0 - boundingBox.height) / 2;
        break;
      case 17:
        boundingBox.x_0 = data_0.node.element.size_0.x_0 - data_0.requiredPortLabelSpace.right - boundingBox.width_0 - data_0.labelSpacing;
        boundingBox.y_0 = (data_0.node.element.size_0.y_0 - boundingBox.height) / 2;
        break;
      case 18:
        boundingBox.x_0 = data_0.requiredPortLabelSpace.left + data_0.labelSpacing;
        boundingBox.y_0 = data_0.node.element.size_0.y_0 - data_0.requiredPortLabelSpace.bottom - boundingBox.height - data_0.labelSpacing;
        break;
      case 19:
        boundingBox.x_0 = (data_0.node.element.size_0.x_0 - boundingBox.width_0) / 2;
        boundingBox.y_0 = data_0.node.element.size_0.y_0 - data_0.requiredPortLabelSpace.bottom - boundingBox.height - data_0.labelSpacing;
        break;
      case 20:
        boundingBox.x_0 = data_0.node.element.size_0.x_0 - data_0.requiredPortLabelSpace.right - boundingBox.width_0 - data_0.labelSpacing;
        boundingBox.y_0 = data_0.node.element.size_0.y_0 - data_0.requiredPortLabelSpace.bottom - boundingBox.height - data_0.labelSpacing;
    }
  }
}

function $computePortPlacementData(data_0){
  var additionalPortSpace, nodeSize, usableSpaceEast, usableSpaceNorth, usableSpaceSouth, usableSpaceWest, usedPortSpace;
  nodeSize = data_0.node.element.size_0;
  data_0.hasAdditionalPortSpace?(additionalPortSpace = castTo($getProperty_0(data_0.node, ($clinit_LayoutOptions() , ADDITIONAL_PORT_SPACE)), 64)):(additionalPortSpace = new Spacing$Margins_0(data_0.portSpacing, data_0.portSpacing, data_0.portSpacing, data_0.portSpacing));
  usableSpaceNorth = nodeSize.x_0;
  (data_0.hasAdditionalPortSpace || data_0.portAlignment[1] != ($clinit_PortAlignment() , JUSTIFIED)) && (usableSpaceNorth -= additionalPortSpace.left + additionalPortSpace.right);
  usableSpaceSouth = nodeSize.x_0;
  (data_0.hasAdditionalPortSpace || data_0.portAlignment[3] != ($clinit_PortAlignment() , JUSTIFIED)) && (usableSpaceSouth -= additionalPortSpace.left + additionalPortSpace.right);
  usableSpaceWest = nodeSize.y_0;
  (data_0.hasAdditionalPortSpace || data_0.portAlignment[4] != ($clinit_PortAlignment() , JUSTIFIED)) && (usableSpaceWest -= additionalPortSpace.top_0 + additionalPortSpace.bottom);
  usableSpaceEast = nodeSize.y_0;
  (data_0.hasAdditionalPortSpace || data_0.portAlignment[2] != ($clinit_PortAlignment() , JUSTIFIED)) && (usableSpaceEast -= additionalPortSpace.top_0 + additionalPortSpace.bottom);
  if ($getPortAlignment(data_0, ($clinit_PortSide() , NORTH)) == ($clinit_PortAlignment() , JUSTIFIED)) {
    data_0.portGapsSize[1] = (usableSpaceNorth - $getPortUsedSpace(data_0, NORTH)) / $getPortGapsCount(data_0, NORTH);
    data_0.northX = data_0.hasAdditionalPortSpace?additionalPortSpace.left + ($getPortsCount(data_0, NORTH) == 1?data_0.portGapsSize[1]:0):data_0.portGapsSize[1];
  }
   else {
    data_0.portGapsSize[1] = data_0.portSpacing;
    usedPortSpace = $getPortUsedSpace(data_0, NORTH) + data_0.portGapsSize[1] * ($getPortsCount(data_0, NORTH) - 1);
    switch ($getPortAlignment(data_0, NORTH).ordinal) {
      case 2:
        data_0.northX = additionalPortSpace.left;
        break;
      case 3:
        data_0.northX = additionalPortSpace.left + (usableSpaceNorth - usedPortSpace) / 2;
        break;
      case 4:
        data_0.northX = nodeSize.x_0 - usedPortSpace - additionalPortSpace.right;
    }
  }
  if ($getPortAlignment(data_0, SOUTH) == JUSTIFIED) {
    data_0.portGapsSize[3] = (usableSpaceSouth - $getPortUsedSpace(data_0, SOUTH)) / $getPortGapsCount(data_0, SOUTH);
    data_0.southX = nodeSize.x_0 - (data_0.hasAdditionalPortSpace?additionalPortSpace.right + ($getPortsCount(data_0, SOUTH) == 1?data_0.portGapsSize[3]:0):data_0.portGapsSize[3]);
  }
   else {
    data_0.portGapsSize[3] = data_0.portSpacing;
    usedPortSpace = $getPortUsedSpace(data_0, SOUTH) + data_0.portGapsSize[3] * ($getPortsCount(data_0, SOUTH) - 1);
    switch ($getPortAlignment(data_0, SOUTH).ordinal) {
      case 2:
        data_0.southX = usedPortSpace + additionalPortSpace.left;
        break;
      case 3:
        data_0.southX = nodeSize.x_0 - (usableSpaceSouth - usedPortSpace) / 2 - additionalPortSpace.right;
        break;
      case 4:
        data_0.southX = nodeSize.x_0 - additionalPortSpace.right;
    }
  }
  if ($getPortAlignment(data_0, WEST) == JUSTIFIED) {
    data_0.portGapsSize[4] = (usableSpaceWest - $getPortUsedSpace(data_0, WEST)) / $getPortGapsCount(data_0, WEST);
    data_0.westY = nodeSize.y_0 - (data_0.hasAdditionalPortSpace?additionalPortSpace.bottom + ($getPortsCount(data_0, WEST) == 1?data_0.portGapsSize[4]:0):data_0.portGapsSize[4]);
  }
   else {
    data_0.portGapsSize[4] = data_0.portSpacing;
    usedPortSpace = $getPortUsedSpace(data_0, WEST) + data_0.portGapsSize[4] * ($getPortsCount(data_0, WEST) - 1);
    switch ($getPortAlignment(data_0, WEST).ordinal) {
      case 2:
        data_0.westY = usedPortSpace + additionalPortSpace.top_0;
        break;
      case 3:
        data_0.westY = nodeSize.y_0 - (usableSpaceWest - usedPortSpace) / 2 - additionalPortSpace.bottom;
        break;
      case 4:
        data_0.westY = nodeSize.y_0 - additionalPortSpace.bottom;
    }
  }
  if ($getPortAlignment(data_0, EAST) == JUSTIFIED) {
    data_0.portGapsSize[2] = (usableSpaceEast - $getPortUsedSpace(data_0, EAST)) / $getPortGapsCount(data_0, EAST);
    data_0.eastY = data_0.hasAdditionalPortSpace?additionalPortSpace.top_0 + ($getPortsCount(data_0, EAST) == 1?data_0.portGapsSize[2]:0):data_0.portGapsSize[2];
  }
   else {
    data_0.portGapsSize[2] = data_0.portSpacing;
    usedPortSpace = $getPortUsedSpace(data_0, EAST) + data_0.portGapsSize[2] * ($getPortsCount(data_0, EAST) - 1);
    switch ($getPortAlignment(data_0, EAST).ordinal) {
      case 2:
        data_0.eastY = additionalPortSpace.top_0;
        break;
      case 3:
        data_0.eastY = additionalPortSpace.top_0 + (usableSpaceEast - usedPortSpace) / 2;
        break;
      case 4:
        data_0.eastY = nodeSize.y_0 - usedPortSpace - additionalPortSpace.bottom;
    }
  }
}

function $doPlaceNodeLabels(data_0){
  var boundingBox, label_0, label$iterator, location_0, position;
  for (label$iterator = new ArrayList$1($getLabels_0(data_0.node)); label$iterator.i < label$iterator.this$01.array.length;) {
    label_0 = castTo($next_8(label$iterator), 129);
    position = new KVector_2(label_0.element.pos);
    location_0 = values_26()[label_0.element.id_0];
    boundingBox = castTo($get_11(data_0.labelGroupsBoundingBoxes, location_0), 283);
    position.y_0 = boundingBox.y_0 + boundingBox.nextLabelYPos;
    location_0.horizontalAlignment == ($clinit_TextAlignment() , LEFT_1)?(position.x_0 = boundingBox.x_0):location_0.horizontalAlignment == CENTER_2?(position.x_0 = boundingBox.x_0 + (boundingBox.width_0 - label_0.element.size_0.x_0) / 2):location_0.horizontalAlignment == RIGHT_1 && (position.x_0 = boundingBox.x_0 + boundingBox.width_0 - label_0.element.size_0.x_0);
    label_0.element.pos.x_0 = position.x_0;
    label_0.element.pos.y_0 = position.y_0;
    boundingBox.nextLabelYPos += label_0.element.size_0.y_0 + data_0.labelSpacing;
  }
}

function $enlargeNodeSizeForLabels(data_0, labelSpacing, nodeSize){
  var boundingBox, entry, entry$iterator, maxHeightInsideCenter, minHeightInside, sumHeightOusideLeft, sumHeightOusideRight, sumWidthInsideBottom, sumWidthInsideCenter, sumWidthInsideTop, sumWidthOutsideBottom, sumWidthOutsideTop;
  sumHeightOusideLeft = 0;
  sumHeightOusideRight = 0;
  sumWidthOutsideTop = 0;
  sumWidthOutsideBottom = 0;
  maxHeightInsideCenter = 0;
  sumWidthInsideTop = 0;
  sumWidthInsideCenter = 0;
  sumWidthInsideBottom = 0;
  for (entry$iterator = new EnumMap$EntrySetIterator((new EnumMap$EntrySet(data_0.labelGroupsBoundingBoxes)).this$01); $hasNext_4(entry$iterator.it);) {
    entry = (entry$iterator.key = $next_9(entry$iterator.it) , new EnumMap$MapEntry(entry$iterator.this$01, entry$iterator.key));
    boundingBox = castTo(entry.this$01.values[entry.key.ordinal], 62);
    switch (castTo(entry.key, 66).ordinal) {
      case 12:
      case 13:
      case 14:
        sumWidthInsideTop += boundingBox.width_0 + labelSpacing;
        break;
      case 15:
      case 16:
      case 17:
        sumWidthInsideCenter += boundingBox.width_0 + labelSpacing;
        maxHeightInsideCenter = max_1(maxHeightInsideCenter, boundingBox.height + labelSpacing);
        break;
      case 18:
      case 19:
      case 20:
        sumWidthInsideBottom += boundingBox.width_0 + labelSpacing;
        break;
      case 0:
      case 1:
      case 2:
        sumWidthOutsideTop += boundingBox.width_0 + labelSpacing;
        break;
      case 3:
      case 4:
      case 5:
        sumWidthOutsideBottom += boundingBox.width_0 + labelSpacing;
        break;
      case 6:
      case 7:
      case 8:
        sumHeightOusideLeft += boundingBox.height + labelSpacing;
        break;
      case 9:
      case 10:
      case 11:
        sumHeightOusideRight += boundingBox.height + labelSpacing;
    }
  }
  sumHeightOusideLeft -= labelSpacing;
  sumHeightOusideRight -= labelSpacing;
  sumWidthOutsideTop -= labelSpacing;
  sumWidthOutsideBottom -= labelSpacing;
  sumWidthInsideTop += sumWidthInsideTop != 0?labelSpacing:0;
  sumWidthInsideCenter += sumWidthInsideCenter != 0?labelSpacing:0;
  sumWidthInsideBottom += sumWidthInsideBottom != 0?labelSpacing:0;
  minHeightInside = data_0.requiredNodeLabelSpace.top_0 + maxHeightInsideCenter + data_0.requiredNodeLabelSpace.bottom;
  minHeightInside += minHeightInside != 0?labelSpacing:0;
  nodeSize.x_0 = max_1(nodeSize.x_0, sumWidthOutsideTop);
  nodeSize.x_0 = max_1(nodeSize.x_0, sumWidthInsideTop);
  nodeSize.x_0 = max_1(nodeSize.x_0, sumWidthInsideCenter);
  nodeSize.x_0 = max_1(nodeSize.x_0, sumWidthInsideBottom);
  nodeSize.x_0 = max_1(nodeSize.x_0, sumWidthOutsideBottom);
  nodeSize.y_0 = max_1(nodeSize.y_0, sumHeightOusideLeft);
  nodeSize.y_0 = max_1(nodeSize.y_0, minHeightInside);
  nodeSize.y_0 = max_1(nodeSize.y_0, sumHeightOusideRight);
}

function $placeFixedPosNodePorts(node){
  var nodeSize, port, port$iterator, portOffset, position;
  nodeSize = node.element.size_0;
  for (port$iterator = new ArrayList$1($getPorts(node)); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_8(port$iterator), 161);
    portOffset = castTo($getProperty_0(port, ($clinit_LayoutOptions() , OFFSET)), 15);
    !portOffset && (portOffset = new Float_0(0));
    position = new KVector_2(port.element.pos);
    switch (castTo(port.element, 7).side.ordinal) {
      case 4:
        position.x_0 = -port.element.size_0.x_0 - portOffset.value_0;
        break;
      case 2:
        position.x_0 = nodeSize.x_0 + portOffset.value_0;
        break;
      case 1:
        position.y_0 = -port.element.size_0.y_0 - portOffset.value_0;
        break;
      case 3:
        position.y_0 = nodeSize.y_0 + portOffset.value_0;
    }
    port.element.pos.x_0 = position.x_0;
    port.element.pos.y_0 = position.y_0;
  }
}

function $placeFixedRatioNodePorts(node){
  var nodeSize, port, port$iterator, portOffset;
  nodeSize = node.element.size_0;
  for (port$iterator = new ArrayList$1($getPorts(node)); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_8(port$iterator), 161);
    portOffset = castTo($getProperty_0(port, ($clinit_LayoutOptions() , OFFSET)), 15);
    !portOffset && (portOffset = new Float_0(0));
    switch (castTo(port.element, 7).side.ordinal) {
      case 4:
        port.element.pos.y_0 = nodeSize.y_0 * checkNotNull_1(castToDouble($getProperty_0(port, PORT_RATIO_OR_POSITION)));
        port.element.pos.x_0 = -port.element.size_0.x_0 - portOffset.value_0;
        break;
      case 2:
        port.element.pos.y_0 = nodeSize.y_0 * checkNotNull_1(castToDouble($getProperty_0(port, PORT_RATIO_OR_POSITION)));
        port.element.pos.x_0 = nodeSize.x_0 + portOffset.value_0;
        break;
      case 1:
        port.element.pos.x_0 = nodeSize.x_0 * checkNotNull_1(castToDouble($getProperty_0(port, PORT_RATIO_OR_POSITION)));
        port.element.pos.y_0 = -port.element.size_0.y_0 - portOffset.value_0;
        break;
      case 3:
        port.element.pos.x_0 = nodeSize.x_0 * checkNotNull_1(castToDouble($getProperty_0(port, PORT_RATIO_OR_POSITION)));
        port.element.pos.y_0 = nodeSize.y_0 + portOffset.value_0;
    }
    switch (castTo(port.element, 7).side.ordinal) {
      case 4:
        port.element.pos.y_0 = nodeSize.y_0 * checkNotNull_1(castToDouble($getProperty_0(port, PORT_RATIO_OR_POSITION)));
        port.element.pos.x_0 = -port.element.size_0.x_0 - portOffset.value_0;
        break;
      case 2:
        port.element.pos.y_0 = nodeSize.y_0 * checkNotNull_1(castToDouble($getProperty_0(port, PORT_RATIO_OR_POSITION)));
        port.element.pos.x_0 = nodeSize.x_0 + portOffset.value_0;
        break;
      case 1:
        port.element.pos.x_0 = nodeSize.x_0 * checkNotNull_1(castToDouble($getProperty_0(port, PORT_RATIO_OR_POSITION)));
        port.element.pos.y_0 = -port.element.size_0.y_0 - portOffset.value_0;
        break;
      case 3:
        port.element.pos.x_0 = nodeSize.x_0 * checkNotNull_1(castToDouble($getProperty_0(port, PORT_RATIO_OR_POSITION)));
        port.element.pos.y_0 = nodeSize.y_0 + portOffset.value_0;
    }
  }
}

function $placeHypernodePorts(node){
  var port, port$iterator, position;
  for (port$iterator = new ArrayList$1($getPorts(node)); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_8(port$iterator), 161);
    position = new KVector_2(port.element.pos);
    switch (castTo(port.element, 7).side.ordinal) {
      case 4:
        position.x_0 = 0;
        position.y_0 = node.element.size_0.y_0 / 2;
        break;
      case 2:
        position.x_0 = node.element.size_0.x_0;
        position.y_0 = node.element.size_0.y_0 / 2;
        break;
      case 1:
        position.x_0 = node.element.size_0.x_0 / 2;
        position.y_0 = 0;
        break;
      case 3:
        position.x_0 = node.element.size_0.x_0 / 2;
        position.y_0 = node.element.size_0.y_0;
    }
    port.element.pos.x_0 = position.x_0;
    port.element.pos.y_0 = position.y_0;
  }
}

function $placeNodeLabels(data_0){
  if (!$hasNext_3(new ArrayList$1($getLabels_0(data_0.node)))) {
    return;
  }
  $computeLabelGroupPositions(data_0);
  $doPlaceNodeLabels(data_0);
}

function $placeNodePorts(data_0){
  var accountForLabels, lmargins, nodeSize, port, port$iterator, portMargins, portOffset, portSize, position;
  nodeSize = data_0.node.element.size_0;
  accountForLabels = castTo($getProperty_0(data_0.node, ($clinit_LayoutOptions() , SIZE_CONSTRAINT)), 86).contains(($clinit_SizeConstraint() , PORT_LABELS));
  $computePortPlacementData(data_0);
  for (port$iterator = new ArrayList$1($getPorts(data_0.node)); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_8(port$iterator), 161);
    portOffset = castTo($getProperty_0(port, OFFSET), 15);
    !portOffset && (portOffset = new Float_0(0));
    portSize = port.element.size_0;
    portMargins = (lmargins = castTo(port.element, 7).margin , new Spacing$Margins_0(lmargins.top_0, lmargins.left, lmargins.bottom, lmargins.right));
    position = new KVector_2(port.element.pos);
    switch (castTo(port.element, 7).side.ordinal) {
      case 4:
        position.x_0 = -portSize.x_0 - portOffset.value_0;
        position.y_0 = data_0.westY - portSize.y_0 - (accountForLabels?portMargins.bottom:0);
        data_0.westY -= $getPortGapsSize(data_0, ($clinit_PortSide() , WEST)) + portSize.y_0 + (accountForLabels?portMargins.top_0 + portMargins.bottom:0);
        break;
      case 2:
        position.x_0 = nodeSize.x_0 + portOffset.value_0;
        position.y_0 = data_0.eastY + (accountForLabels?portMargins.top_0:0);
        data_0.eastY += $getPortGapsSize(data_0, ($clinit_PortSide() , EAST)) + portSize.y_0 + (accountForLabels?portMargins.top_0 + portMargins.bottom:0);
        break;
      case 1:
        position.x_0 = data_0.northX + (accountForLabels?portMargins.left:0);
        position.y_0 = -port.element.size_0.y_0 - portOffset.value_0;
        data_0.northX += $getPortGapsSize(data_0, ($clinit_PortSide() , NORTH)) + portSize.x_0 + (accountForLabels?portMargins.left + portMargins.right:0);
        break;
      case 3:
        position.x_0 = data_0.southX - portSize.x_0 - (accountForLabels?portMargins.right:0);
        position.y_0 = nodeSize.y_0 + portOffset.value_0;
        data_0.southX -= $getPortGapsSize(data_0, ($clinit_PortSide() , SOUTH)) + portSize.x_0 + (accountForLabels?portMargins.left + portMargins.right:0);
    }
    port.element.pos.x_0 = position.x_0;
    port.element.pos.y_0 = position.y_0;
  }
}

function $placePortLabelsInside(port, compoundNodeMode, labelSpacing){
  var label_0, label$iterator, labels, position, y_0;
  labels = copyOf($getLabels_1(port));
  if (labels.delegateList_0().isEmpty()) {
    return;
  }
  y_0 = 0;
  switch (castTo(port.element, 7).side.ordinal) {
    case 4:
    case 2:
      y_0 = compoundNodeMode && unsafeCast(checkNotNull_1(castToBoolean($getProperty(castTo(port.element, 7), ($clinit_InternalProperties() , INSIDE_CONNECTIONS)))))?port.element.size_0.y_0:(port.element.size_0.y_0 - castTo(labels.delegateList_0().get_2(0), 129).getSize().y_0) / 2 - labelSpacing;
      break;
    case 1:
      y_0 = port.element.size_0.y_0;
      break;
    case 3:
      y_0 = 0;
  }
  castTo(port.element, 7).side == ($clinit_PortSide() , SOUTH) && $reverse(labels);
  for (label$iterator = new ArrayList$1($getLabels_1(port)); label$iterator.i < label$iterator.this$01.array.length;) {
    label_0 = castTo($next_8(label$iterator), 129);
    position = new KVector_2(port.element.pos);
    switch (castTo(port.element, 7).side.ordinal) {
      case 4:
        position.x_0 = port.element.size_0.x_0 + labelSpacing;
        position.y_0 = y_0 + labelSpacing;
        y_0 += labelSpacing + label_0.element.size_0.y_0;
        break;
      case 2:
        position.x_0 = -label_0.element.size_0.x_0 - labelSpacing;
        position.y_0 = y_0 + labelSpacing;
        y_0 += labelSpacing + label_0.element.size_0.y_0;
        break;
      case 1:
        position.x_0 = (port.element.size_0.x_0 - label_0.element.size_0.x_0) / 2;
        position.y_0 = y_0 + labelSpacing;
        y_0 += labelSpacing + label_0.element.size_0.y_0;
        break;
      case 3:
        position.x_0 = (port.element.size_0.x_0 - label_0.element.size_0.x_0) / 2;
        position.y_0 = y_0 - labelSpacing - label_0.element.size_0.y_0;
        y_0 -= labelSpacing + label_0.element.size_0.y_0;
    }
    label_0.element.pos.x_0 = position.x_0;
    label_0.element.pos.y_0 = position.y_0;
  }
}

function $placePortLabelsOutside(port, labelSpacing){
  var label_0, label$iterator, labelSide, labels, position, y_0;
  labels = copyOf($getLabels_1(port));
  if (labels.delegateList_0().isEmpty()) {
    return;
  }
  labelSide = castTo($getProperty(castTo(castTo(castTo(labels.delegateList_0().get_2(0), 129), 224).element, 33), ($clinit_LabelSide() , LABEL_SIDE)), 171);
  labelSide = labelSide == UNKNOWN?BELOW:labelSide;
  y_0 = 0;
  switch (castTo(port.element, 7).side.ordinal) {
    case 4:
    case 2:
      labelSide == BELOW && (y_0 = port.element.size_0.y_0);
      break;
    case 3:
      y_0 = port.element.size_0.y_0;
  }
  (castTo(port.element, 7).side == ($clinit_PortSide() , NORTH) || labelSide == ABOVE) && (labels = $reverse(labels));
  for (label$iterator = unmodifiableIterator(labels.delegateList_0().iterator_0()); label$iterator.hasNext_0();) {
    label_0 = castTo(label$iterator.next_1(), 129);
    position = new KVector_2(label_0.element.pos);
    if (labelSide == ABOVE) {
      switch (castTo(port.element, 7).side.ordinal) {
        case 1:
        case 4:
          position.x_0 = -label_0.element.size_0.x_0 - labelSpacing;
          position.y_0 = y_0 - labelSpacing - label_0.element.size_0.y_0;
          y_0 -= labelSpacing + label_0.element.size_0.y_0;
          break;
        case 2:
          position.x_0 = port.element.size_0.x_0 + labelSpacing;
          position.y_0 = y_0 - labelSpacing - label_0.element.size_0.y_0;
          y_0 -= labelSpacing + label_0.element.size_0.y_0;
          break;
        case 3:
          position.x_0 = -label_0.element.size_0.x_0 - labelSpacing;
          position.y_0 = y_0 + labelSpacing;
          y_0 += labelSpacing + label_0.element.size_0.y_0;
      }
    }
     else {
      switch (castTo(port.element, 7).side.ordinal) {
        case 4:
          position.x_0 = -label_0.element.size_0.x_0 - labelSpacing;
          position.y_0 = y_0 + labelSpacing;
          y_0 += labelSpacing + label_0.element.size_0.y_0;
          break;
        case 2:
          position.x_0 = port.element.size_0.x_0 + labelSpacing;
          position.y_0 = y_0 + labelSpacing;
          y_0 += labelSpacing + label_0.element.size_0.y_0;
          break;
        case 1:
          position.x_0 = port.element.size_0.x_0 + labelSpacing;
          position.y_0 = y_0 - labelSpacing - label_0.element.size_0.y_0;
          y_0 -= labelSpacing + label_0.element.size_0.y_0;
          break;
        case 3:
          position.x_0 = port.element.size_0.x_0 + labelSpacing;
          position.y_0 = y_0 + labelSpacing;
          y_0 += labelSpacing + label_0.element.size_0.y_0;
      }
    }
    label_0.element.pos.x_0 = position.x_0;
    label_0.element.pos.y_0 = position.y_0;
  }
}

function $placePorts(data_0){
  var portConstraints;
  if (!$hasNext_3(new ArrayList$1($getPorts(data_0.node)))) {
    return;
  }
  portConstraints = castTo($getProperty_0(data_0.node, ($clinit_LayoutOptions() , PORT_CONSTRAINTS)), 28);
  portConstraints == ($clinit_PortConstraints() , FIXED_POS)?$placeFixedPosNodePorts(data_0.node):portConstraints == FIXED_RATIO?$placeFixedRatioNodePorts(data_0.node):unsafeCast(checkNotNull_1(castToBoolean($getProperty_0(data_0.node, HYPERNODE)))) || data_0.node.element.size_0.x_0 == 0 && data_0.node.element.size_0.y_0 == 0?$placeHypernodePorts(data_0.node):$placeNodePorts(data_0);
}

function $process(layeredGraph){
  var compoundNodeMode, data_0, labelPlacement, labelSpacing, linsets, node, node$iterator, nodeInsets, port, port$iterator;
  labelSpacing = castTo($getProperty_1(layeredGraph, ($clinit_LayoutOptions() , LABEL_SPACING)), 15).value_0;
  for (node$iterator = new ArrayList$1($getNodes(layeredGraph)); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 625);
    data_0 = new LabelAndNodeSizeProcessor$NodeData(node);
    data_0.labelSpacing = labelSpacing;
    data_0.portSpacing = castTo($getProperty_0(node, PORT_SPACING), 15).value_0;
    labelPlacement = castTo($getProperty_0(node, PORT_LABEL_PLACEMENT), 149);
    compoundNodeMode = unsafeCast(checkNotNull_1(castToBoolean($getProperty(castTo(node.element, 9), ($clinit_InternalProperties() , COMPOUND_NODE)))));
    for (port$iterator = new ArrayList$1($getPorts(node)); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_8(port$iterator), 161);
      labelPlacement == ($clinit_PortLabelPlacement() , INSIDE_0)?$placePortLabelsInside(port, compoundNodeMode, labelSpacing):labelPlacement == OUTSIDE_0 && $placePortLabelsOutside(port, labelSpacing);
      $calculateAndSetPortMargins(port);
    }
    $calculatePortInformation(data_0, castTo($getProperty_0(node, SIZE_CONSTRAINT), 86).contains(($clinit_SizeConstraint() , PORT_LABELS)));
    $calculateRequiredPortLabelSpace(data_0);
    calculateRequiredNodeLabelSpace(data_0.node, data_0.labelSpacing, data_0.labelGroupsBoundingBoxes, data_0.requiredNodeLabelSpace);
    $resizeNode(data_0);
    $placePorts(data_0);
    $placeNodeLabels(data_0);
    nodeInsets = new Spacing$Insets_1((linsets = castTo(node.element, 9).insets , new Spacing$Insets_0(linsets.top_0, linsets.left, linsets.bottom, linsets.right)));
    nodeInsets.left = data_0.requiredNodeLabelSpace.left + data_0.requiredPortLabelSpace.left;
    nodeInsets.right = data_0.requiredNodeLabelSpace.right + data_0.requiredPortLabelSpace.right;
    nodeInsets.top_0 = data_0.requiredNodeLabelSpace.top_0 + data_0.requiredPortLabelSpace.top_0;
    nodeInsets.bottom = data_0.requiredNodeLabelSpace.bottom + data_0.requiredPortLabelSpace.bottom;
    castTo(node.element, 9).insets.left = nodeInsets.left;
    castTo(node.element, 9).insets.top_0 = nodeInsets.top_0;
    castTo(node.element, 9).insets.right = nodeInsets.right;
    castTo(node.element, 9).insets.bottom = nodeInsets.bottom;
  }
}

function $resizeNode(data_0){
  var accountForLabels, minHeight, minSizeForPorts, minWidth, nodeSize, originalNodeSize, portConstraints, sizeConstraint, sizeOptions;
  nodeSize = data_0.node.element.size_0;
  originalNodeSize = new KVector_2(nodeSize);
  sizeConstraint = castTo($getProperty_0(data_0.node, ($clinit_LayoutOptions() , SIZE_CONSTRAINT)), 86);
  sizeOptions = castTo($getProperty_0(data_0.node, SIZE_OPTIONS), 86);
  portConstraints = castTo($getProperty_0(data_0.node, PORT_CONSTRAINTS), 28);
  accountForLabels = $containsEnum(sizeConstraint, ($clinit_SizeConstraint() , PORT_LABELS));
  if (sizeConstraint.size_0 == 0) {
    return;
  }
  nodeSize.x_0 = 0;
  nodeSize.y_0 = 0;
  minSizeForPorts = null;
  switch (portConstraints.ordinal) {
    case 1:
    case 2:
    case 3:
      minSizeForPorts = $calculatePortSpaceRequirements(data_0, data_0.portSpacing);
      break;
    case 4:
      minSizeForPorts = new KVector_2(originalNodeSize);
      break;
    case 5:
      minSizeForPorts = $calculateMinNodeSizeForFixedPorts(data_0.node, accountForLabels);
  }
  if ($containsEnum(sizeConstraint, PORTS)) {
    if (minSizeForPorts) {
      nodeSize.x_0 = max_1(nodeSize.x_0, minSizeForPorts.x_0);
      nodeSize.y_0 = max_1(nodeSize.y_0, minSizeForPorts.y_0);
    }
    if (accountForLabels) {
      nodeSize.x_0 = max_1(nodeSize.x_0, data_0.requiredPortLabelSpace.left + data_0.requiredPortLabelSpace.right + data_0.portSpacing);
      nodeSize.y_0 = max_1(nodeSize.y_0, data_0.requiredPortLabelSpace.top_0 + data_0.requiredPortLabelSpace.bottom + data_0.portSpacing);
    }
  }
  $containsEnum(sizeConstraint, NODE_LABELS) && $hasNext_3(new ArrayList$1($getLabels_0(data_0.node))) && $enlargeNodeSizeForLabels(data_0, data_0.labelSpacing, nodeSize);
  if ($containsEnum(sizeConstraint, MINIMUM_SIZE)) {
    minWidth = castTo($getProperty_0(data_0.node, MIN_WIDTH), 15).value_0;
    minHeight = castTo($getProperty_0(data_0.node, MIN_HEIGHT), 15).value_0;
    if ($containsEnum(sizeOptions, ($clinit_SizeOptions() , DEFAULT_MINIMUM_SIZE))) {
      minWidth <= 0 && (minWidth = 20);
      minHeight <= 0 && (minHeight = 20);
    }
    if ($containsEnum(sizeOptions, MINIMUM_SIZE_ACCOUNTS_FOR_INSETS)) {
      minWidth > 0 && (nodeSize.x_0 = max_1(nodeSize.x_0, minWidth + data_0.requiredPortLabelSpace.left + data_0.requiredPortLabelSpace.right));
      minHeight > 0 && (nodeSize.y_0 = max_1(nodeSize.y_0, minHeight + data_0.requiredPortLabelSpace.top_0 + data_0.requiredPortLabelSpace.bottom));
    }
     else {
      minWidth > 0 && (nodeSize.x_0 = max_1(nodeSize.x_0, minWidth));
      minHeight > 0 && (nodeSize.y_0 = max_1(nodeSize.y_0, minHeight));
    }
  }
  $setSize(data_0.node, nodeSize);
}

var PORT_RATIO_OR_POSITION;
function $getPortAlignment(this$static, side){
  return this$static.portAlignment[side.ordinal];
}

function $getPortGapsCount(this$static, side){
  return this$static.portGapsCount[side.ordinal];
}

function $getPortGapsSize(this$static, side){
  return this$static.portGapsSize[side.ordinal];
}

function $getPortUsedSpace(this$static, side){
  return this$static.portUsedSpace[side.ordinal];
}

function $getPortsCount(this$static, side){
  return this$static.portsCount[side.ordinal];
}

function LabelAndNodeSizeProcessor$NodeData(node){
  this.requiredPortLabelSpace = new Spacing$Insets;
  this.requiredNodeLabelSpace = new Spacing$Insets;
  this.portsCount = initUnidimensionalArray(I_classLit, $intern_37, 26, ($clinit_PortSide() , stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_PortSide_2_classLit, 1), $intern_13, 32, 0, [UNDEFINED_4, NORTH, EAST, SOUTH, WEST])).length, 12, 1);
  this.portGapsCount = initUnidimensionalArray(I_classLit, $intern_37, 26, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_PortSide_2_classLit, 1), $intern_13, 32, 0, [UNDEFINED_4, NORTH, EAST, SOUTH, WEST]).length, 12, 1);
  this.portGapsSize = initUnidimensionalArray(D_classLit, $intern_11, 26, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_PortSide_2_classLit, 1), $intern_13, 32, 0, [UNDEFINED_4, NORTH, EAST, SOUTH, WEST]).length, 12, 1);
  this.portUsedSpace = initUnidimensionalArray(D_classLit, $intern_11, 26, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_PortSide_2_classLit, 1), $intern_13, 32, 0, [UNDEFINED_4, NORTH, EAST, SOUTH, WEST]).length, 12, 1);
  this.portAlignment = initUnidimensionalArray(Lde_cau_cs_kieler_kiml_options_PortAlignment_2_classLit, $intern_13, 99, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_PortSide_2_classLit, 1), $intern_13, 32, 0, [UNDEFINED_4, NORTH, EAST, SOUTH, WEST]).length, 0, 1);
  this.labelGroupsBoundingBoxes = new EnumMap(Lde_cau_cs_kieler_kiml_util_labelspacing_LabelLocation_2_classLit);
  this.node = node;
  fill_1(this.portsCount);
  fill_1(this.portGapsCount);
  fill(this.portUsedSpace, 0);
}

defineClass(589, 1, {}, LabelAndNodeSizeProcessor$NodeData);
_.eastY = 0;
_.hasAdditionalPortSpace = false;
_.labelSpacing = 0;
_.northX = 0;
_.portSpacing = 0;
_.southX = 0;
_.westY = 0;
var Lde_cau_cs_kieler_kiml_util_nodespacing_LabelAndNodeSizeProcessor$NodeData_2_classLit = createForClass('de.cau.cs.kieler.kiml.util.nodespacing', 'LabelAndNodeSizeProcessor/NodeData', 589);
function $clinit_LabelSide(){
  $clinit_LabelSide = emptyMethod;
  UNKNOWN = new LabelSide('UNKNOWN', 0);
  ABOVE = new LabelSide('ABOVE', 1);
  BELOW = new LabelSide('BELOW', 2);
  LABEL_SIDE = new Property_2('de.cau.cs.kieler.labelSide', UNKNOWN);
}

function LabelSide(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function values_28(){
  $clinit_LabelSide();
  return stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_util_nodespacing_LabelSide_2_classLit, 1), $intern_13, 171, 0, [UNKNOWN, ABOVE, BELOW]);
}

defineClass(171, 17, {171:1, 3:1, 23:1, 17:1}, LabelSide);
var ABOVE, BELOW, LABEL_SIDE, UNKNOWN;
var Lde_cau_cs_kieler_kiml_util_nodespacing_LabelSide_2_classLit = createForEnum('de.cau.cs.kieler.kiml.util.nodespacing', 'LabelSide', 171, Ljava_lang_Enum_2_classLit, values_28);
function $computeLabelBox(labelBox, label_0, incomingEdge, node, port, portLabelSpace, labelSpacing){
  labelBox.x_0 = node.element.pos.x_0;
  labelBox.y_0 = node.element.pos.y_0;
  if (port) {
    labelBox.x_0 += port.element.pos.x_0;
    labelBox.y_0 += port.element.pos.y_0;
  }
  labelBox.width_0 = label_0.element.size_0.x_0;
  labelBox.height = label_0.element.size_0.y_0;
  if (!port) {
    incomingEdge?(labelBox.x_0 -= labelSpacing + label_0.element.size_0.x_0):(labelBox.x_0 += node.element.size_0.x_0 + labelSpacing);
  }
   else {
    switch (castTo(port.element, 7).side.ordinal) {
      case 0:
      case 2:
        labelBox.x_0 += port.element.size_0.x_0 + labelSpacing + portLabelSpace.x_0 + labelSpacing;
        break;
      case 4:
        labelBox.x_0 -= labelSpacing + portLabelSpace.x_0 + labelSpacing + label_0.element.size_0.x_0;
        break;
      case 1:
        labelBox.x_0 += port.element.size_0.x_0 + labelSpacing;
        labelBox.y_0 -= labelSpacing + portLabelSpace.y_0 + labelSpacing + label_0.element.size_0.y_0;
        break;
      case 3:
        labelBox.x_0 += port.element.size_0.x_0 + labelSpacing;
        labelBox.y_0 += port.element.size_0.y_0 + labelSpacing + portLabelSpace.y_0 + labelSpacing;
    }
  }
}

function $process_0(this$static){
  var node, node$iterator, spacing;
  spacing = castTo($getProperty_1(this$static.adapter, ($clinit_LayoutOptions() , LABEL_SPACING)), 15).value_0;
  for (node$iterator = new ArrayList$1($getNodes(this$static.adapter)); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 625);
    $processNode(this$static, node, spacing);
  }
}

function $processEdgeHeadTailLabels(boundingBox, outgoingEdges, incomingEdges, node, port, portLabelSpace, labelSpacing){
  var edge, edge$iterator, edge$iterator0, label_0, label$iterator, labelBox;
  labelBox = new Rectangle;
  for (edge$iterator0 = outgoingEdges.iterator_0(); edge$iterator0.hasNext_0();) {
    edge = castTo(edge$iterator0.next_1(), 626);
    for (label$iterator = new ArrayList$1($getLabels(edge)); label$iterator.i < label$iterator.this$01.array.length;) {
      label_0 = castTo($next_8(label$iterator), 129);
      if (maskUndefined($getProperty_0(label_0, ($clinit_LayoutOptions() , EDGE_LABEL_PLACEMENT))) === maskUndefined(($clinit_EdgeLabelPlacement() , TAIL))) {
        $computeLabelBox(labelBox, label_0, false, node, port, portLabelSpace, labelSpacing);
        $union(boundingBox, labelBox);
      }
    }
  }
  for (edge$iterator = incomingEdges.iterator_0(); edge$iterator.hasNext_0();) {
    edge = castTo(edge$iterator.next_1(), 626);
    for (label$iterator = new ArrayList$1($getLabels(edge)); label$iterator.i < label$iterator.this$01.array.length;) {
      label_0 = castTo($next_8(label$iterator), 129);
      if (maskUndefined($getProperty_0(label_0, ($clinit_LayoutOptions() , EDGE_LABEL_PLACEMENT))) === maskUndefined(($clinit_EdgeLabelPlacement() , HEAD))) {
        $computeLabelBox(labelBox, label_0, true, node, port, portLabelSpace, labelSpacing);
        $union(boundingBox, labelBox);
      }
    }
  }
}

function $processNode(this$static, node, labelSpacing){
  var boundingBox, elementBox, label_0, label$iterator, lmargins, margin, port, port$iterator, portX, portY, requiredPortLabelSpace;
  boundingBox = new Rectangle_0(node.element.pos.x_0, node.element.pos.y_0, node.element.size_0.x_0, node.element.size_0.y_0);
  elementBox = new Rectangle;
  if (this$static.includeLabels) {
    for (label$iterator = new ArrayList$1($getLabels_0(node)); label$iterator.i < label$iterator.this$01.array.length;) {
      label_0 = castTo($next_8(label$iterator), 129);
      elementBox.x_0 = label_0.element.pos.x_0 + node.element.pos.x_0;
      elementBox.y_0 = label_0.element.pos.y_0 + node.element.pos.y_0;
      elementBox.width_0 = label_0.element.size_0.x_0;
      elementBox.height = label_0.element.size_0.y_0;
      $union(boundingBox, elementBox);
    }
  }
  for (port$iterator = new ArrayList$1($getPorts(node)); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_8(port$iterator), 161);
    portX = port.element.pos.x_0 + node.element.pos.x_0;
    portY = port.element.pos.y_0 + node.element.pos.y_0;
    if (this$static.includePorts) {
      elementBox.x_0 = portX;
      elementBox.y_0 = portY;
      elementBox.width_0 = port.element.size_0.x_0;
      elementBox.height = port.element.size_0.y_0;
      $union(boundingBox, elementBox);
    }
    if (this$static.includePortLabels) {
      for (label$iterator = new ArrayList$1($getLabels_1(port)); label$iterator.i < label$iterator.this$01.array.length;) {
        label_0 = castTo($next_8(label$iterator), 129);
        elementBox.x_0 = label_0.element.pos.x_0 + portX;
        elementBox.y_0 = label_0.element.pos.y_0 + portY;
        elementBox.width_0 = label_0.element.size_0.x_0;
        elementBox.height = label_0.element.size_0.y_0;
        $union(boundingBox, elementBox);
      }
    }
    if (this$static.includeEdgeHeadTailLabels) {
      requiredPortLabelSpace = new KVector_1(-labelSpacing, -labelSpacing);
      if (maskUndefined($getProperty_0(node, ($clinit_LayoutOptions() , PORT_LABEL_PLACEMENT))) === maskUndefined(($clinit_PortLabelPlacement() , OUTSIDE_0))) {
        for (label$iterator = new ArrayList$1($getLabels_1(port)); label$iterator.i < label$iterator.this$01.array.length;) {
          label_0 = castTo($next_8(label$iterator), 129);
          requiredPortLabelSpace.x_0 += label_0.element.size_0.x_0 + labelSpacing;
          requiredPortLabelSpace.y_0 += label_0.element.size_0.y_0 + labelSpacing;
        }
      }
      requiredPortLabelSpace.x_0 = max_1(requiredPortLabelSpace.x_0, 0);
      requiredPortLabelSpace.y_0 = max_1(requiredPortLabelSpace.y_0, 0);
      $processEdgeHeadTailLabels(boundingBox, $getOutgoingEdges(port), $getIncomingEdges(port), node, port, requiredPortLabelSpace, labelSpacing);
    }
  }
  this$static.includeEdgeHeadTailLabels && $processEdgeHeadTailLabels(boundingBox, ($clinit_Collections() , $clinit_Collections() , EMPTY_LIST), (null , EMPTY_LIST), node, null, null, labelSpacing);
  margin = new Spacing$Margins_1((lmargins = castTo(node.element, 9).margin , new Spacing$Margins_0(lmargins.top_0, lmargins.left, lmargins.bottom, lmargins.right)));
  margin.top_0 = node.element.pos.y_0 - boundingBox.y_0;
  margin.bottom = boundingBox.y_0 + boundingBox.height - (node.element.pos.y_0 + node.element.size_0.y_0);
  margin.left = node.element.pos.x_0 - boundingBox.x_0;
  margin.right = boundingBox.x_0 + boundingBox.width_0 - (node.element.pos.x_0 + node.element.size_0.x_0);
  castTo(node.element, 9).margin.left = margin.left;
  castTo(node.element, 9).margin.top_0 = margin.top_0;
  castTo(node.element, 9).margin.right = margin.right;
  castTo(node.element, 9).margin.bottom = margin.bottom;
}

function NodeMarginCalculator(adapter){
  this.adapter = adapter;
}

defineClass(590, 1, {}, NodeMarginCalculator);
_.includeEdgeHeadTailLabels = true;
_.includeLabels = true;
_.includePortLabels = true;
_.includePorts = true;
var Lde_cau_cs_kieler_kiml_util_nodespacing_NodeMarginCalculator_2_classLit = createForClass('de.cau.cs.kieler.kiml.util.nodespacing', 'NodeMarginCalculator', 590);
function $$init_2(this$static){
}

function $parse_2(this$static, string){
  var end, exception, key, keyandvalue, start_0, token, token$index, token$max, tokens, value_0;
  start_0 = 0;
  while (start_0 < ($clinit_String() , string.length) && isdelim_0(string.charCodeAt(start_0), '([{"\' \t\r\n')) {
    ++start_0;
  }
  end = string.length;
  while (end > 0 && isdelim_0(string.charCodeAt(end - 1), ')]}"\' \t\r\n')) {
    --end;
  }
  if (start_0 < end) {
    tokens = $split_1(string.substr(start_0, end - start_0), ',|;');
    try {
      for (token$index = 0 , token$max = tokens.length; token$index < token$max; ++token$index) {
        token = tokens[token$index];
        keyandvalue = $split_1(token, '=');
        if (keyandvalue.length != 2) {
          throw new IllegalArgumentException_0('Expecting a list of key-value pairs.');
        }
        key = $trim(keyandvalue[0]);
        value_0 = __parseAndValidateDouble($trim(keyandvalue[1]));
        $equals_5(key, 'top')?(this$static.top_0 = value_0):$equals_5(key, 'left')?(this$static.left = value_0):$equals_5(key, 'bottom')?(this$static.bottom = value_0):$equals_5(key, 'right') && (this$static.right = value_0);
      }
    }
     catch ($e0) {
      $e0 = wrap($e0);
      if (instanceOf($e0, 130)) {
        exception = $e0;
        throw new IllegalArgumentException_0('The given string contains parts that cannot be parsed as numbers.' + exception);
      }
       else 
        throw unwrap_5($e0);
    }
  }
}

function Spacing(){
  $$init_2(this);
}

function Spacing_0(top_0, left, bottom, right){
  $$init_2(this);
  this.top_0 = top_0;
  this.left = left;
  this.bottom = bottom;
  this.right = right;
}

function isdelim_0(c, delims){
  var i;
  for (i = 0; i < ($clinit_String() , delims.length); i++) {
    if (c == delims.charCodeAt(i)) {
      return true;
    }
  }
  return false;
}

defineClass(121, 1, $intern_47);
_.equals = function equals_33(obj){
  var other;
  if (instanceOf(obj, 121)) {
    other = castTo(obj, 121);
    return this.top_0 == other.top_0 && this.bottom == other.bottom && this.left == other.left && this.right == other.right;
  }
   else {
    return false;
  }
}
;
_.hashCode_0 = function hashCode_33(){
  var code1, code2;
  code1 = round_int(checkNotNull_1(this.left)) << 16;
  code1 |= round_int(checkNotNull_1(this.bottom)) & $intern_6;
  code2 = round_int(checkNotNull_1(this.right)) << 16;
  code2 |= round_int(checkNotNull_1(this.top_0)) & $intern_6;
  return code1 ^ code2;
}
;
_.toString_0 = function toString_45(){
  return '[top=' + this.top_0 + ',left=' + this.left + ',bottom=' + this.bottom + ',right=' + this.right + ']';
}
;
_.bottom = 0;
_.left = 0;
_.right = 0;
_.top_0 = 0;
var Lde_cau_cs_kieler_kiml_util_nodespacing_Spacing_2_classLit = createForClass('de.cau.cs.kieler.kiml.util.nodespacing', 'Spacing', 121);
function Spacing$Insets(){
  Spacing.call(this);
}

function Spacing$Insets_0(top_0, left, bottom, right){
  Spacing_0.call(this, top_0, left, bottom, right);
}

function Spacing$Insets_1(other){
  Spacing_0.call(this, other.top_0, other.left, other.bottom, other.right);
}

defineClass(232, 121, $intern_47, Spacing$Insets, Spacing$Insets_0, Spacing$Insets_1);
var Lde_cau_cs_kieler_kiml_util_nodespacing_Spacing$Insets_2_classLit = createForClass('de.cau.cs.kieler.kiml.util.nodespacing', 'Spacing/Insets', 232);
function Spacing$Margins(){
  Spacing.call(this);
}

function Spacing$Margins_0(top_0, left, bottom, right){
  Spacing_0.call(this, top_0, left, bottom, right);
}

function Spacing$Margins_1(other){
  Spacing_0.call(this, other.top_0, other.left, other.bottom, other.right);
}

defineClass(64, 121, {286:1, 121:1, 64:1, 3:1, 5:1}, Spacing$Margins, Spacing$Margins_0, Spacing$Margins_1);
var Lde_cau_cs_kieler_kiml_util_nodespacing_Spacing$Margins_2_classLit = createForClass('de.cau.cs.kieler.kiml.util.nodespacing', 'Spacing/Margins', 64);
function $exportLayout(){
  var klay = {'layout':function(d){
    $entry(layout(d));
  }
  };
  if (typeof klayregister === 'function') {
    klayregister(klay);
  }
   else {
    typeof document !== 'undefined' && ($wnd.$klay = klay);
    typeof module === 'object' && module.exports && (module.exports = klay);
    typeof document === 'undefined' && typeof self !== 'undefined' && self.addEventListener('message', function(e){
      klay.layout(e.data);
    }
    , false);
  }
}

function execCallback(callback, json){
  if (typeof klaycallback === 'function') {
    klaycallback(json);
  }
   else {
    typeof document !== 'undefined'?$entry(callback(json)):typeof module === 'object' && module.exports && $entry(callback(json));
    typeof document === 'undefined' && typeof self !== 'undefined' && self.postMessage(json);
  }
}

function layout(params){
  var e, errObj, error, graph, obj, opts, result, success, ujge;
  obj = new JSONObject_0(params);
  graph = $get_6(obj, 'graph');
  success = $get_6(obj, 'success');
  error = $get_6(obj, 'error');
  opts = $get_6(obj, 'options');
  try {
    if (!graph || !graph.isObject()) {
      throw new UnsupportedConfigurationException("Mandatory parameter missing, 'graph' must be specified");
    }
    $layout(new RecursiveLGraphLayout, graph.isObject(), opts?opts.isObject():null);
    result = graph.isObject().jsObject;
    !!success && !!success.isObject()?execCallback(success.isObject().jsObject, result):execCallback(null, result);
  }
   catch ($e0) {
    $e0 = wrap($e0);
    if (instanceOf($e0, 73)) {
      ujge = $e0;
      !!error && !!error.isObject()?execCallback(error.isObject().jsObject, $toJson(ujge).jsObject):execCallback(null, $toJson(ujge).jsObject);
    }
     else if (instanceOf($e0, 54)) {
      e = $e0;
      errObj = new JSONObject;
      $put_1(errObj, 'type', new JSONString($getName_1(e.___clazz)));
      e.getMessage() != null?$put_1(errObj, 'text', new JSONString(e.getMessage())):$put_1(errObj, 'text', new JSONString('null (sic)'));
      $put_1(errObj, 'stacktrace', new JSONString($join(new Joiner('\n'), new AbstractList$IteratorImpl(new Arrays$ArrayList((e.stackTrace == null && (e.stackTrace = constructJavaStackTrace(e)) , e.stackTrace))))));
      !!error && !!error.isObject()?execCallback(error.isObject().jsObject, errObj.jsObject):execCallback(null, errObj.jsObject);
      $printStackTraceImpl(e, ($clinit_System() , err), '');
    }
     else 
      throw unwrap_5($e0);
  }
}

function $doLayout(lGraph, progressMonitor){
  var all, all0, compoundNode, edge, edge$iterator, edge$iterator0, edgeRouting, height, junctionPoints, label_0, label$iterator, label$iterator0, maxv, maxx, maxy, node, node$iterator, node$iterator0, port, port$iterator, portx, porty, pos, width_0;
  $begin(progressMonitor, 'Fixed Layout', 1);
  edgeRouting = castTo($getProperty(lGraph, ($clinit_LayoutOptions() , EDGE_ROUTING)), 122);
  maxx = 0;
  maxy = 0;
  for (node$iterator0 = new ArrayList$1(lGraph.layerlessNodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
    node = castTo($next_8(node$iterator0), 9);
    pos = castTo($getProperty(node, POSITION), 10);
    if (pos) {
      node.pos.x_0 = pos.x_0;
      node.pos.y_0 = pos.y_0;
      if (castTo($getProperty(node, SIZE_CONSTRAINT), 86).contains(($clinit_SizeConstraint() , MINIMUM_SIZE))) {
        width_0 = castTo($getProperty(node, MIN_WIDTH), 15).value_0;
        height = castTo($getProperty(node, MIN_HEIGHT), 15).value_0;
        width_0 > 0 && height > 0 && resizeNode(node, new KVector_1(width_0, height), true);
      }
    }
    maxx = max_1(maxx, node.pos.x_0 + node.size_0.x_0);
    maxy = max_1(maxy, node.pos.y_0 + node.size_0.y_0);
    for (label$iterator0 = new ArrayList$1(node.labels); label$iterator0.i < label$iterator0.this$01.array.length;) {
      label_0 = castTo($next_8(label$iterator0), 33);
      pos = castTo($getProperty(label_0, POSITION), 10);
      if (pos) {
        label_0.pos.x_0 = pos.x_0;
        label_0.pos.y_0 = pos.y_0;
      }
      maxx = max_1(maxx, node.pos.x_0 + label_0.pos.x_0 + label_0.size_0.x_0);
      maxy = max_1(maxy, node.pos.y_0 + label_0.pos.y_0 + label_0.size_0.y_0);
    }
    for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_8(port$iterator), 7);
      pos = castTo($getProperty(port, POSITION), 10);
      if (pos) {
        port.pos.x_0 = pos.x_0;
        port.pos.y_0 = pos.y_0;
      }
      portx = node.pos.x_0 + port.pos.x_0;
      porty = node.pos.y_0 + port.pos.y_0;
      maxx = max_1(maxx, portx + port.size_0.x_0);
      maxy = max_1(maxy, porty + port.size_0.y_0);
      for (label$iterator = new ArrayList$1(port.labels); label$iterator.i < label$iterator.this$01.array.length;) {
        label_0 = castTo($next_8(label$iterator), 33);
        pos = castTo($getProperty(label_0, POSITION), 10);
        if (pos) {
          label_0.pos.x_0 = pos.x_0;
          label_0.pos.y_0 = pos.y_0;
        }
        maxx = max_1(maxx, portx + label_0.pos.x_0 + label_0.size_0.x_0);
        maxy = max_1(maxy, porty + label_0.pos.y_0 + label_0.size_0.y_0);
      }
    }
    for (edge$iterator0 = $iterator($getOutgoingEdges_0(node)); $hasNext_0(edge$iterator0);) {
      edge = castTo($next_2(edge$iterator0), 12);
      maxv = $processEdge(edge);
      maxx = max_1(maxx, maxv.x_0);
      maxy = max_1(maxy, maxv.y_0);
    }
    for (edge$iterator = $iterator($getIncomingEdges_0(node)); $hasNext_0(edge$iterator);) {
      edge = castTo($next_2(edge$iterator), 12);
      if (maskUndefined($getProperty(edge.source.owner, ($clinit_InternalProperties() , NESTED_LGRAPH))) !== maskUndefined(lGraph)) {
        maxv = $processEdge(edge);
        maxx = max_1(maxx, maxv.x_0);
        maxy = max_1(maxy, maxv.y_0);
      }
    }
  }
  if (edgeRouting == ($clinit_EdgeRouting() , ORTHOGONAL)) {
    for (node$iterator = new ArrayList$1(lGraph.layerlessNodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      for (edge$iterator = $iterator($getOutgoingEdges_0(node)); $hasNext_0(edge$iterator);) {
        edge = castTo($next_2(edge$iterator), 12);
        junctionPoints = determineJunctionPoints(edge);
        junctionPoints.size_0 == 0?$setProperty(edge, JUNCTION_POINTS, null):$setProperty(edge, JUNCTION_POINTS, junctionPoints);
      }
    }
  }
  lGraph.size_0.x_0 = maxx;
  lGraph.size_0.y_0 = maxy;
  $setProperty(lGraph, SIZE_CONSTRAINT, ($clinit_SizeConstraint() , all0 = castTo($getEnumConstants(Lde_cau_cs_kieler_kiml_options_SizeConstraint_2_classLit), 11) , new EnumSet$EnumSetImpl(all0, castTo(createFrom(all0, all0.length), 11), 0)));
  compoundNode = castTo($getProperty(lGraph, ($clinit_InternalProperties() , PARENT_LNODE)), 9);
  !!compoundNode && $setProperty(compoundNode, SIZE_CONSTRAINT, (all = castTo($getEnumConstants(Lde_cau_cs_kieler_kiml_options_SizeConstraint_2_classLit), 11) , new EnumSet$EnumSetImpl(all, castTo(createFrom(all, all.length), 11), 0)));
  $done(progressMonitor);
}

function $processEdge(edge){
  var actual, bendPoints, i, label_0, label$iterator, maxv, point, point$iterator, pos, sameHierarchy, v, v$iterator;
  sameHierarchy = maskUndefined($getProperty(edge.source.owner, ($clinit_InternalProperties() , NESTED_LGRAPH))) === maskUndefined($getProperty(edge.target.owner, NESTED_LGRAPH));
  maxv = new KVector;
  bendPoints = castTo($getProperty(edge, ($clinit_LayoutOptions() , BEND_POINTS)), 44);
  if (!!bendPoints && bendPoints.size_0 >= 2) {
    $reset_0(edge.bendPoints);
    i = 0;
    for (v$iterator = $listIterator_2(bendPoints, 0); v$iterator.currentNode != v$iterator.this$01.tail;) {
      v = castTo($next_11(v$iterator), 10);
      if (i == 0) {
        actual = $sub_0($sub_0(new KVector_1(v.x_0, v.y_0), edge.source.pos), edge.source.owner.pos);
        edge.source.anchor.x_0 = actual.x_0;
        edge.source.anchor.y_0 = actual.y_0;
      }
       else if (i == bendPoints.size_0 - 1) {
        actual = $sub_0($sub_0(new KVector_1(v.x_0, v.y_0), edge.target.pos), edge.target.owner.pos);
        edge.target.anchor.x_0 = actual.x_0;
        edge.target.anchor.y_0 = actual.y_0;
      }
       else {
        $add_8(edge.bendPoints, v);
      }
      ++i;
    }
  }
  if (sameHierarchy) {
    for (point$iterator = $listIterator_2(edge.bendPoints, 0); point$iterator.currentNode != point$iterator.this$01.tail;) {
      point = castTo($next_11(point$iterator), 10);
      maxv.x_0 = max_1(maxv.x_0, point.x_0);
      maxv.y_0 = max_1(maxv.y_0, point.y_0);
    }
  }
  for (label$iterator = new ArrayList$1(edge.labels); label$iterator.i < label$iterator.this$01.array.length;) {
    label_0 = castTo($next_8(label$iterator), 33);
    pos = castTo($getProperty(label_0, POSITION), 10);
    if (pos) {
      label_0.pos.x_0 = pos.x_0;
      label_0.pos.y_0 = pos.y_0;
    }
    if (sameHierarchy) {
      maxv.x_0 = max_1(maxv.x_0, label_0.pos.x_0 + label_0.size_0.x_0);
      maxv.y_0 = max_1(maxv.y_0, label_0.pos.y_0 + label_0.size_0.y_0);
    }
  }
  return maxv;
}

function determineJunctionPoints(edge){
  var allConnectedEdges, allEdgeIter, connectedPorts, dx2, dx3, dy2, dy3, i, junctionPoints, otherEdge, otherPoints, p, p$iterator, p1, p2, p3, pointsMap, reverse, thisPoints;
  junctionPoints = new KVectorChain;
  pointsMap = ($clinit_Maps() , new HashMap);
  $put_2(pointsMap, edge, getPoints(edge));
  connectedPorts = (checkNonnegative(2, 'initialArraySize') , new ArrayList_0(2));
  !!edge.source && $add_11(connectedPorts, edge.source);
  !!edge.target && $add_11(connectedPorts, edge.target);
  for (p$iterator = new ArrayList$1(connectedPorts); p$iterator.i < p$iterator.this$01.array.length;) {
    p = castTo($next_8(p$iterator), 7);
    allConnectedEdges = new LinkedList;
    $addAll(allConnectedEdges, newArrayList(concat(($clinit_ImmutableList() , new RegularImmutableList(nullCheckedList(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [p.incomingEdges, p.outgoingEdges])))))));
    $advanceToFind(allConnectedEdges, edge, true);
    if (allConnectedEdges.size_0 != 0) {
      thisPoints = castTo(getEntryValueOrNull($getEntry(pointsMap.hashCodeMap, edge)), 34);
      if (p == edge.target) {
        p1 = thisPoints[thisPoints.length - 1];
        reverse = true;
      }
       else {
        p1 = thisPoints[0];
        reverse = false;
      }
      for (i = 1; i < thisPoints.length; i++) {
        reverse?(p2 = thisPoints[thisPoints.length - 1 - i]):(p2 = thisPoints[i]);
        allEdgeIter = $listIterator_2(allConnectedEdges, 0);
        while (allEdgeIter.currentNode != allEdgeIter.this$01.tail) {
          otherEdge = castTo($next_11(allEdgeIter), 12);
          otherPoints = castTo(getEntryValueOrNull($getEntry(pointsMap.hashCodeMap, otherEdge)), 34);
          if (otherPoints == null) {
            otherPoints = getPoints(otherEdge);
            $put_5(pointsMap.hashCodeMap, otherEdge, otherPoints);
          }
          if (otherPoints.length <= i) {
            $remove_22(allEdgeIter);
          }
           else {
            reverse?(p3 = otherPoints[otherPoints.length - 1 - i]):(p3 = otherPoints[i]);
            if (p2.x_0 != p3.x_0 || p2.y_0 != p3.y_0) {
              dx2 = p2.x_0 - p1.x_0;
              dy2 = p2.y_0 - p1.y_0;
              dx3 = p3.x_0 - p1.x_0;
              dy3 = p3.y_0 - p1.y_0;
              dx3 * dy2 == dy3 * dx2 && signum(dx2) == signum(dx3) && signum(dy2) == signum(dy3)?((dx2 <= 0?0 - dx2:dx2) < (dx3 <= 0?0 - dx3:dx3) || (dy2 <= 0?0 - dy2:dy2) < (dy3 <= 0?0 - dy3:dy3)) && ($addNode_0(junctionPoints, p2, junctionPoints.tail.prev, junctionPoints.tail) , true):i > 1 && ($addNode_0(junctionPoints, p1, junctionPoints.tail.prev, junctionPoints.tail) , true);
              $remove_22(allEdgeIter);
            }
          }
        }
        p1 = p2;
      }
    }
  }
  return junctionPoints;
}

function getPoints(edge){
  var bendPoint, n, pointIter, points;
  n = edge.bendPoints.size_0 + 2;
  points = initUnidimensionalArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, $intern_48, 10, n, 0, 1);
  points[0] = $clone($getAbsoluteAnchor(edge.source));
  pointIter = $listIterator_2(edge.bendPoints, 0);
  while (pointIter.currentNode != pointIter.this$01.tail) {
    bendPoint = castTo($next_11(pointIter), 10);
    points[pointIter.currentIndex] = new KVector_1(bendPoint.x_0, bendPoint.y_0);
  }
  points[n - 1] = $clone($getAbsoluteAnchor(edge.target));
  return points;
}

function signum(x_0){
  if (x_0 < 0) {
    return -1;
  }
  if (x_0 > 0) {
    return 1;
  }
  return 0;
}

function $clinit_JsonGraphImporter(){
  $clinit_JsonGraphImporter = emptyMethod;
  INT_COORDINATES = new Property_2('intCoordinates', ($clinit_Boolean() , $clinit_Boolean() , FALSE_0));
  JSON_OBJECT = new Property_1('jsonObject');
  ZERO_VECTOR = new KVector_1(0, 0);
}

function $checkForId(obj){
  if (!('id' in obj.jsObject)) {
    throw new UnsupportedJsonGraphException_0("Every graph element must specify an 'id' property.", obj);
  }
  if (!$get_6(obj, 'id').isString()) {
    throw new UnsupportedJsonGraphException_0("Invalid format for 'id'. Must be a string, was " + $get_6(obj, 'id').___clazz, obj);
  }
}

function $checkForNonNull(obj){
  if (!obj) {
    throw new UnsupportedJsonGraphException('An element is null. The origin of an edge could not be determined, this might be due to an inconsistency within the internal element mappings.');
  }
}

function $importGraph(this$static, json){
  var rootGraph, val;
  $reset_3(this$static.nodeIdMap);
  $reset_3(this$static.edgeIdMap);
  $reset_3(this$static.portIdMap);
  $reset_3(this$static.nodeJsonMap);
  $reset_3(this$static.edgeJsonMap);
  $reset_3(this$static.portJsonMap);
  $reset_3(this$static.labelJsonMap);
  $reset_3(this$static.jsonLGraphMap);
  if (this$static.globalOptions) {
    val = $get_6(this$static.globalOptions, INT_COORDINATES.id_0);
    !!val && !!val.isBoolean() && (this$static.exportIntegerCoordinates = val.isBoolean().value_0);
  }
  rootGraph = $transformNodes(this$static, json, null);
  $transformEdges(this$static, json);
  return rootGraph;
}

function $setJsNumber(this$static, obj, key, value_0){
  var n;
  this$static.exportIntegerCoordinates?(n = new JSONNumber(round_int(value_0))):(n = new JSONNumber(value_0));
  $put_1(obj, key, n);
}

function $setJsProperty(obj, prop, value_0){
  $setJsProperty_0(obj, prop.id_0, value_0);
}

function $setJsProperty_0(obj, name_0, value_0){
  var props;
  props = $get_6(obj, 'properties');
  if (!props) {
    props = new JSONObject;
    $put_1(obj, 'properties', props);
  }
  $put_1(props.isObject(), name_0, value_0);
}

function $transferLayout(this$static, edge, json, offset){
  var bends, index_0, junctionPoints, junctions, jv, sourceInsets, sourcePort, src_0, srcPnt, tgt, tgtPnt, v, v$iterator, v$iterator0, vc;
  $checkForNonNull(json);
  if (isDescendant(edge.target.owner, edge.source.owner)) {
    sourcePort = edge.source;
    src_0 = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [sourcePort.pos, sourcePort.anchor]));
    sourceInsets = sourcePort.owner.insets;
    $add_6(src_0, -sourceInsets.left, -sourceInsets.top_0);
    src_0.x_0 -= offset.x_0;
    src_0.y_0 -= offset.y_0;
  }
   else {
    src_0 = $getAbsoluteAnchor(edge.source);
  }
  src_0.x_0 += offset.x_0;
  src_0.y_0 += offset.y_0;
  srcPnt = new JSONObject;
  $setJsNumber(this$static, srcPnt, 'x', src_0.x_0);
  $setJsNumber(this$static, srcPnt, 'y', src_0.y_0);
  $put_1(json, 'sourcePoint', srcPnt);
  tgt = $getAbsoluteAnchor(edge.target);
  $getProperty(edge, ($clinit_InternalProperties() , TARGET_OFFSET)) != null && $add_7(tgt, castTo($getProperty(edge, TARGET_OFFSET), 10));
  $add_7(tgt, offset);
  tgtPnt = new JSONObject;
  $setJsNumber(this$static, tgtPnt, 'x', tgt.x_0);
  $setJsNumber(this$static, tgtPnt, 'y', tgt.y_0);
  $put_1(json, 'targetPoint', tgtPnt);
  bends = new JSONArray;
  vc = $offset(edge.bendPoints, offset);
  index_0 = 0;
  for (v$iterator0 = $listIterator_2(vc, 0); v$iterator0.currentNode != v$iterator0.this$01.tail;) {
    v = castTo($next_11(v$iterator0), 10);
    jv = new JSONObject;
    $setJsNumber(this$static, jv, 'x', v.x_0);
    $setJsNumber(this$static, jv, 'y', v.y_0);
    $set_0(bends, index_0++, jv);
  }
  vc.size_0 == 0?$put_1(json, 'bendPoints', null):$put_1(json, 'bendPoints', bends);
  junctionPoints = castTo($getProperty(edge, ($clinit_LayoutOptions() , JUNCTION_POINTS)), 44);
  index_0 = 0;
  if (junctionPoints) {
    $offset(junctionPoints, offset);
    junctions = new JSONArray;
    for (v$iterator = $listIterator_2(junctionPoints, 0); v$iterator.currentNode != v$iterator.this$01.tail;) {
      v = castTo($next_11(v$iterator), 10);
      jv = new JSONObject;
      $setJsNumber(this$static, jv, 'x', v.x_0);
      $setJsNumber(this$static, jv, 'y', v.y_0);
      $set_0(junctions, index_0++, jv);
    }
    $put_1(json, 'junctionPoints', junctions);
  }
   else {
    $put_1(json, 'junctionPoints', null);
  }
}

function $transferLayout_0(this$static, parentGraph){
  var actualGraphSize, borderSpacing, childGraph, e, e$iterator, e$iterator0, edges, graphJson, graphNode, jEdge, jLabel, jNode, jPort, l, l$iterator, n, n$iterator, n$iterator0, offset, p, p$iterator, parentLNode;
  offset = new KVector_2(parentGraph.offset);
  edges = new ArrayList;
  for (n$iterator0 = new ArrayList$1(parentGraph.layerlessNodes); n$iterator0.i < n$iterator0.this$01.array.length;) {
    n = castTo($next_8(n$iterator0), 9);
    jNode = castTo($get_9(this$static.nodeJsonMap, n), 69);
    if (jNode) {
      $transferLayout_1(this$static, n, jNode, offset);
      for (p$iterator = new ArrayList$1(n.ports); p$iterator.i < p$iterator.this$01.array.length;) {
        p = castTo($next_8(p$iterator), 7);
        jPort = castTo($get_9(this$static.portJsonMap, p), 69);
        if (jPort) {
          $transferLayout_1(this$static, p, jPort, ZERO_VECTOR);
          $setJsProperty(jPort, ($clinit_LayoutOptions() , PORT_SIDE), new JSONString($name(p.side)));
        }
        if (maskUndefined($getProperty(n, ($clinit_LayoutOptions() , PORT_LABEL_PLACEMENT))) !== maskUndefined(($clinit_PortLabelPlacement() , FIXED))) {
          for (l$iterator = new ArrayList$1(p.labels); l$iterator.i < l$iterator.this$01.array.length;) {
            l = castTo($next_8(l$iterator), 33);
            jLabel = castTo($get_9(this$static.labelJsonMap, l), 69);
            $transferLayout_1(this$static, l, jLabel, ZERO_VECTOR);
          }
        }
      }
      if (castTo($getProperty(n, ($clinit_LayoutOptions() , NODE_LABEL_PLACEMENT)), 86).size_1() != 0) {
        for (l$iterator = new ArrayList$1(n.labels); l$iterator.i < l$iterator.this$01.array.length;) {
          l = castTo($next_8(l$iterator), 33);
          jLabel = castTo($get_9(this$static.labelJsonMap, l), 69);
          $transferLayout_1(this$static, l, jLabel, ZERO_VECTOR);
        }
      }
      for (e$iterator0 = $iterator($getOutgoingEdges_0(n)); $hasNext_0(e$iterator0);) {
        e = castTo($next_2(e$iterator0), 12);
        isDescendant(e.target.owner, n) || (edges.array[edges.array.length] = e , true);
      }
    }
  }
  parentLNode = castTo($getProperty(parentGraph, ($clinit_InternalProperties() , PARENT_LNODE)), 9);
  if (parentLNode) {
    for (e$iterator0 = $iterator($getOutgoingEdges_0(parentLNode)); $hasNext_0(e$iterator0);) {
      e = castTo($next_2(e$iterator0), 12);
      isDescendant(e.target.owner, parentLNode) && (edges.array[edges.array.length] = e , true);
    }
  }
  for (e$iterator = new ArrayList$1(edges); e$iterator.i < e$iterator.this$01.array.length;) {
    e = castTo($next_8(e$iterator), 12);
    jEdge = castTo($get_9(this$static.edgeJsonMap, e), 69);
    $transferLayout(this$static, e, jEdge, offset);
    for (l$iterator = new ArrayList$1(e.labels); l$iterator.i < l$iterator.this$01.array.length;) {
      l = castTo($next_8(l$iterator), 33);
      jLabel = castTo($get_9(this$static.labelJsonMap, l), 69);
      $transferLayout_1(this$static, l, jLabel, offset);
    }
  }
  actualGraphSize = (borderSpacing = castTo($getProperty(parentGraph, BORDER_SPACING_0), 15).value_0 , new KVector_1(parentGraph.size_0.x_0 + parentGraph.insets.left + parentGraph.insets.right + 2 * borderSpacing, parentGraph.size_0.y_0 + parentGraph.insets.top_0 + parentGraph.insets.bottom + 2 * borderSpacing));
  graphNode = castTo($getProperty(parentGraph, PARENT_LNODE), 9);
  if (graphNode) {
    graphNode.size_0.x_0 = actualGraphSize.x_0;
    graphNode.size_0.y_0 = actualGraphSize.y_0;
  }
  graphJson = castTo($getProperty(parentGraph, JSON_OBJECT), 69);
  $setJsNumber(this$static, graphJson, 'width', actualGraphSize.x_0);
  $setJsNumber(this$static, graphJson, 'height', actualGraphSize.y_0);
  for (n$iterator = new ArrayList$1(parentGraph.layerlessNodes); n$iterator.i < n$iterator.this$01.array.length;) {
    n = castTo($next_8(n$iterator), 9);
    childGraph = castTo($getProperty(n, NESTED_LGRAPH), 55);
    !!childGraph && $transferLayout_0(this$static, childGraph);
  }
}

function $transferLayout_1(this$static, shape_0, json, offset){
  var insets, padding, paddingVal;
  $setJsNumber(this$static, json, 'x', shape_0.pos.x_0 + offset.x_0);
  $setJsNumber(this$static, json, 'y', shape_0.pos.y_0 + offset.y_0);
  $setJsNumber(this$static, json, 'width', shape_0.size_0.x_0);
  $setJsNumber(this$static, json, 'height', shape_0.size_0.y_0);
  if (instanceOf(shape_0, 9)) {
    if (castTo($getProperty(shape_0, ($clinit_LayoutOptions() , SIZE_OPTIONS)), 86).contains(($clinit_SizeOptions() , COMPUTE_INSETS))) {
      insets = castTo(shape_0, 9).insets;
      paddingVal = $get_6(json, 'padding');
      if (!paddingVal) {
        paddingVal = new JSONObject;
        $put_1(json, 'padding', paddingVal);
      }
      padding = paddingVal.isObject();
      $setJsNumber(this$static, padding, 'left', insets.left);
      $setJsNumber(this$static, padding, 'top', insets.top_0);
      $setJsNumber(this$static, padding, 'right', insets.right);
      $setJsNumber(this$static, padding, 'bottom', insets.bottom);
    }
  }
}

function $transformDimensions(jsonEle, ele){
  var height, width_0, x_0, y_0;
  if ('x' in jsonEle.jsObject) {
    x_0 = castTo($get_6(jsonEle, 'x'), 104);
    ele.pos.x_0 = x_0.value_0;
  }
  if ('y' in jsonEle.jsObject) {
    y_0 = castTo($get_6(jsonEle, 'y'), 104);
    ele.pos.y_0 = y_0.value_0;
  }
  if ('width' in jsonEle.jsObject) {
    width_0 = castTo($get_6(jsonEle, 'width'), 104);
    ele.size_0.x_0 = width_0.value_0;
  }
  if ('height' in jsonEle.jsObject) {
    height = castTo($get_6(jsonEle, 'height'), 104);
    ele.size_0.y_0 = height.value_0;
  }
}

function $transformEdge(this$static, jEdge){
  var bendpoints, edge, graphProperties, i, id_0, jBends, jSourceNode, jSourcePort, jTargetNode, jTargetPort, jVector, noLayoutId, parentLGraph, sourceNode, sourcePort, targetNode, targetPort, v;
  $checkForId(jEdge);
  noLayoutId = ($clinit_LayoutOptions() , NO_LAYOUT).id_0;
  if (noLayoutId in jEdge.jsObject && $get_6(jEdge, noLayoutId).isBoolean().value_0) {
    return;
  }
  jSourceNode = $get_6(jEdge, 'source');
  jSourcePort = $get_6(jEdge, 'sourcePort');
  jTargetNode = $get_6(jEdge, 'target');
  jTargetPort = $get_6(jEdge, 'targetPort');
  if (!jSourceNode) {
    throw new UnsupportedJsonGraphException_1("Edges must contain a 'source' property.", null, jEdge);
  }
   else if (!jSourceNode.isString()) {
    throw new UnsupportedJsonGraphException_1("Invalid format of an edge's 'source' property. It must be a string.", jSourceNode, jEdge);
  }
  if (!jTargetNode) {
    throw new UnsupportedJsonGraphException_1("Edges must contain a 'target' property.", null, jEdge);
  }
   else if (!jTargetNode.isString()) {
    throw new UnsupportedJsonGraphException_1("Invalid format of an edge's 'target' property. It must be a string.", jTargetNode, jEdge);
  }
  sourcePort = null;
  targetPort = null;
  try {
    sourceNode = castTo($getStringValue(this$static.nodeIdMap, jSourceNode.isString().value_0), 9);
    !!jSourcePort && !!jSourcePort.isString() && (sourcePort = castTo($getStringValue(this$static.portIdMap, jSourcePort.isString().value_0), 7));
    targetNode = castTo($getStringValue(this$static.nodeIdMap, jTargetNode.isString().value_0), 9);
    !!jTargetPort && !!jTargetPort.isString() && (targetPort = castTo($getStringValue(this$static.portIdMap, jTargetPort.isString().value_0), 7));
  }
   catch ($e0) {
    $e0 = wrap($e0);
    if (instanceOf($e0, 76)) {
      throw new UnsupportedJsonGraphException_0("An edge's 'source', 'target', 'sourcePort', and 'targetPort' properties have to be strings.", jEdge);
    }
     else 
      throw unwrap_5($e0);
  }
  if (!unsafeCast(checkNotNull_1(this$static.layoutHierarchy))) {
    if (!sourceNode || !targetNode) {
      return;
    }
     else if ($getGraph(sourceNode) != $getGraph(targetNode)) {
      return;
    }
  }
  if (!sourceNode || !targetNode) {
    throw new UnsupportedJsonGraphException_0("An edge's source or target node could not be resolved.", jEdge);
  }
  parentLGraph = $getGraph(sourceNode);
  edge = new LEdge;
  $setProperty(edge, ($clinit_InternalProperties() , ORIGIN), jEdge);
  id_0 = castTo($get_6(jEdge, 'id'), 97);
  $putStringValue(this$static.edgeIdMap, id_0.value_0, edge);
  $put_2(this$static.edgeJsonMap, edge, jEdge);
  $transformProperties(jEdge, edge);
  $transformLabels(this$static, jEdge, edge, parentLGraph);
  graphProperties = castTo($getProperty(parentLGraph, GRAPH_PROPERTIES), 18);
  sourceNode == targetNode && graphProperties.add_1(($clinit_GraphProperties() , SELF_LOOPS));
  if (!sourcePort) {
    sourcePort = createPort(sourceNode, new KVector, ($clinit_PortType() , OUTPUT), parentLGraph);
  }
   else if (sourcePort.owner != sourceNode) {
    throw new UnsupportedJsonGraphException('Inconsistent source port reference found.');
  }
  if (!targetPort) {
    targetPort = createPort(targetNode, new KVector, ($clinit_PortType() , INPUT), parentLGraph);
  }
   else if (targetPort.owner != targetNode) {
    throw new UnsupportedJsonGraphException('Inconsistent target port reference found.');
  }
  $setSource(edge, sourcePort);
  $setTarget(edge, targetPort);
  (size_18(concat(($clinit_ImmutableList() , new RegularImmutableList(nullCheckedList(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [sourcePort.incomingEdges, sourcePort.outgoingEdges])))))) > 1 || size_18(concat(new RegularImmutableList(nullCheckedList(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [targetPort.incomingEdges, targetPort.outgoingEdges]))))) > 1) && graphProperties.add_1(($clinit_GraphProperties() , HYPEREDGES));
  if (maskUndefined($getProperty(parentLGraph, ($clinit_Properties() , CROSS_MIN))) === maskUndefined(($clinit_CrossingMinimizationStrategy() , INTERACTIVE_2)) && !('bendPoints' in jEdge.jsObject)) {
    bendpoints = new KVectorChain;
    try {
      jBends = $get_6(jEdge, 'bendPoints').isArray_0();
      for (i = 0; i < jBends.jsArray.length; ++i) {
        jVector = $get_5(jBends, i).isObject();
        v = new KVector_1($get_6(jVector, 'x').isNumber().value_0, $get_6(jVector, 'y').isNumber().value_0);
        $addNode_0(bendpoints, v, bendpoints.tail.prev, bendpoints.tail);
      }
      $setProperty(edge, ORIGINAL_BENDPOINTS, bendpoints);
    }
     catch ($e1) {
      $e1 = wrap($e1);
      if (instanceOf($e1, 54)) {
        throw new UnsupportedJsonGraphException_0("Invalid format of an edges 'bendPoints' property.", jEdge);
      }
       else 
        throw unwrap_5($e1);
    }
  }
  $setProperty(edge, JUNCTION_POINTS, null);
}

function $transformEdges(this$static, parent_0){
  var child, children, edgeVal, edges, i, val;
  if ('edges' in parent_0.jsObject) {
    val = $get_6(parent_0, 'edges');
    if (!val.isArray_0()) {
      throw new UnsupportedJsonGraphException_1("The 'edges' property of a node has to be an array.", val, parent_0);
    }
    edges = val.isArray_0();
    for (i = 0; i < edges.jsArray.length; ++i) {
      edgeVal = $get_5(edges, i);
      if (!edgeVal.isObject()) {
        throw new UnsupportedJsonGraphException_1("All elements of the 'edges' property must be objects.", edgeVal, parent_0);
      }
      $transformEdge(this$static, edgeVal.isObject());
    }
  }
  if ('children' in parent_0.jsObject) {
    children = $get_6(parent_0, 'children').isArray_0();
    for (i = 0; i < children.jsArray.length; ++i) {
      child = $get_5(children, i).isObject();
      $transformEdges(this$static, child);
    }
  }
}

function $transformLabel(this$static, jLabel, ele, graph){
  var graphProperties, label_0, labelPlacement, noLayoutId, text_0, val;
  noLayoutId = ($clinit_LayoutOptions() , NO_LAYOUT).id_0;
  if (noLayoutId in jLabel.jsObject && $get_6(jLabel, noLayoutId).isBoolean().value_0) {
    return;
  }
  val = $get_6(jLabel, 'text');
  if (!val) {
    throw new UnsupportedJsonGraphException_1("Labels must have a property 'text'.", null, jLabel);
  }
   else if (!val.isString()) {
    throw new UnsupportedJsonGraphException_1("A label's 'text' property must be a string.", val, jLabel);
  }
  text_0 = val.isString().value_0;
  label_0 = new LLabel(text_0);
  $setProperty(label_0, ($clinit_InternalProperties() , ORIGIN), jLabel);
  $put_2(this$static.labelJsonMap, label_0, jLabel);
  $transformDimensions(jLabel, label_0);
  $transformProperties(jLabel, label_0);
  instanceOf(ele, 9)?$add_11(castTo(ele, 9).labels, label_0):instanceOf(ele, 12)?$add_11(castTo(ele, 12).labels, label_0):instanceOf(ele, 7) && $add_11(castTo(ele, 7).labels, label_0);
  if (instanceOf(ele, 12)) {
    labelPlacement = castTo($getProperty(label_0, EDGE_LABEL_PLACEMENT), 107);
    $transformDimensions(jLabel, label_0);
    $setProperty(label_0, EDGE_LABEL_PLACEMENT, labelPlacement);
    graphProperties = castTo($getProperty(graph, GRAPH_PROPERTIES), 18);
    switch (labelPlacement.ordinal) {
      case 2:
      case 3:
        graphProperties.add_1(($clinit_GraphProperties() , END_LABELS));
      case 1:
      case 0:
        graphProperties.add_1(($clinit_GraphProperties() , CENTER_LABELS));
        $setProperty(label_0, EDGE_LABEL_PLACEMENT, ($clinit_EdgeLabelPlacement() , CENTER_0));
    }
  }
}

function $transformLabels(this$static, jElement, element, graph){
  var i, labels, val;
  if ('labels' in jElement.jsObject) {
    val = $get_6(jElement, 'labels');
    if (!val.isArray_0()) {
      throw new UnsupportedJsonGraphException_1("The 'labels' property of a node must be an array.", val, jElement);
    }
    labels = val.isArray_0();
    for (i = 0; i < labels.jsArray.length; ++i) {
      instanceOf($get_5(labels, i), 69) && $transformLabel(this$static, castTo($get_5(labels, i), 69), element, graph);
    }
  }
}

function $transformNode(this$static, jNode, graph){
  var graphProperties, i, id_0, node, portConstraints, ports, val;
  $checkForId(jNode);
  graphProperties = castTo($getProperty(graph, ($clinit_InternalProperties() , GRAPH_PROPERTIES)), 18);
  node = new LNode(graph);
  $setProperty(node, ORIGIN, jNode);
  $add_11(graph.layerlessNodes, node);
  id_0 = castTo($get_6(jNode, 'id'), 97);
  $putStringValue(this$static.nodeIdMap, id_0.value_0, node);
  $put_2(this$static.nodeJsonMap, node, jNode);
  $transformDimensions(jNode, node);
  $transformProperties(jNode, node);
  if ('ports' in jNode.jsObject) {
    val = $get_6(jNode, 'ports');
    if (!val.isArray_0()) {
      throw new UnsupportedJsonGraphException_1("The 'ports' property of the node must be an array.", val, jNode);
    }
    ports = val.isArray_0();
    for (i = 0; i < ports.jsArray.length; ++i) {
      instanceOf($get_5(ports, i), 69) && $transformPort(this$static, castTo($get_5(ports, i), 69), node, graph);
    }
  }
  $transformLabels(this$static, jNode, node, graph);
  'children' in jNode.jsObject && $get_6(jNode, 'children').isArray_0().jsArray.length > 0 && $setProperty(node, COMPOUND_NODE, ($clinit_Boolean() , $clinit_Boolean() , TRUE_0));
  portConstraints = castTo($getProperty(node, ($clinit_LayoutOptions() , PORT_CONSTRAINTS)), 28);
  portConstraints == ($clinit_PortConstraints() , UNDEFINED_3)?FREE:portConstraints != FREE && graphProperties.add_1(($clinit_GraphProperties() , NON_FREE_PORTS));
  unsafeCast(checkNotNull_1(castToBoolean($getProperty(node, COMMENT_BOX)))) && graphProperties.add_1(($clinit_GraphProperties() , COMMENTS));
  if (unsafeCast(checkNotNull_1(castToBoolean($getProperty(node, HYPERNODE))))) {
    graphProperties.add_1(($clinit_GraphProperties() , HYPERNODES));
    graphProperties.add_1(HYPEREDGES);
    $setProperty(node, PORT_CONSTRAINTS, FREE);
  }
  return node;
}

function $transformNodes(this$static, jparent, parentNode){
  var all, bottom, child, childNode, childNodes, childVal, children, graph, graphProperties, i, i0, jChild, left, linsets, padding, right, top_0, val;
  graph = new LGraph;
  $setProperty(graph, JSON_OBJECT, jparent);
  $put_2(this$static.jsonLGraphMap, jparent, graph);
  $setProperty(graph, ($clinit_InternalProperties() , PARENT_LNODE), parentNode);
  !!this$static.globalOptions && $transformPropertiesObj(this$static.globalOptions, graph, false);
  $transformProperties(jparent, graph);
  if ('padding' in jparent.jsObject) {
    linsets = graph.insets;
    padding = castTo($get_6(jparent, 'padding'), 69);
    left = castTo($get_6(padding, 'left'), 104);
    !!left && (linsets.left = left.value_0);
    top_0 = castTo($get_6(padding, 'top'), 104);
    !!top_0 && (linsets.top_0 = top_0.value_0);
    right = castTo($get_6(padding, 'right'), 104);
    !!right && (linsets.right = right.value_0);
    bottom = castTo($get_6(padding, 'bottom'), 104);
    !!bottom && (linsets.bottom = bottom.value_0);
  }
  graphProperties = (all = castTo($getEnumConstants(Lde_cau_cs_kieler_klay_layered_properties_GraphProperties_2_classLit), 11) , new EnumSet$EnumSetImpl(all, castTo(createFrom(all, all.length), 11), 0));
  $setProperty(graph, GRAPH_PROPERTIES, graphProperties);
  this$static.layoutHierarchy == null && (this$static.layoutHierarchy = castToBoolean($getProperty(graph, ($clinit_RecursiveLGraphLayout() , LAYOUT_HIERARCHY_0))));
  if ('children' in jparent.jsObject) {
    val = $get_6(jparent, 'children');
    if (!val.isArray_0()) {
      throw new UnsupportedJsonGraphException_1("The 'children' property of nodes must be an array.", val, jparent);
    }
    children = val.isArray_0();
    if (children.jsArray.length > 0) {
      !!parentNode && $setProperty(parentNode, NESTED_LGRAPH, graph);
      childNodes = initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LNode_2_classLit, $intern_49, 9, children.jsArray.length, 0, 1);
      for (i0 = 0; i0 < children.jsArray.length; ++i0) {
        childVal = $get_5(children, i0);
        if (!childVal.isObject()) {
          throw new UnsupportedJsonGraphException_1("A 'children' array contains a non-object node element.", childVal, jparent);
        }
        child = $transformNode(this$static, childVal.isObject(), graph);
        childNodes[i0] = child;
      }
      for (i = 0; i < children.jsArray.length; ++i) {
        jChild = $get_5(children, i).isObject();
        childNode = childNodes[i];
        'children' in jChild.jsObject && !unsafeCast(checkNotNull_1(castToBoolean($getProperty(childNode, ($clinit_LayoutOptions() , NO_LAYOUT))))) && $transformNodes(this$static, jChild, childNode);
      }
    }
  }
  return graph;
}

function $transformPort(this$static, jPort, node, graph){
  var direction, graphProperties, id_0, noLayoutId, port, portConstraints;
  $checkForId(jPort);
  graphProperties = castTo($getProperty(graph, ($clinit_InternalProperties() , GRAPH_PROPERTIES)), 18);
  noLayoutId = ($clinit_LayoutOptions() , NO_LAYOUT).id_0;
  if (noLayoutId in jPort.jsObject && $get_6(jPort, noLayoutId).isBoolean().value_0) {
    return;
  }
  port = new LPort;
  $setProperty(port, ORIGIN, jPort);
  $setNode(port, node);
  id_0 = castTo($get_6(jPort, 'id'), 97);
  $putStringValue(this$static.portIdMap, id_0.value_0, port);
  $put_2(this$static.portJsonMap, port, jPort);
  $transformDimensions(jPort, port);
  $transformProperties(jPort, port);
  $transformLabels(this$static, jPort, port, graph);
  $setSide(port, castTo($getProperty(port, PORT_SIDE), 32));
  portConstraints = castTo($getProperty(node, PORT_CONSTRAINTS), 28);
  portConstraints == ($clinit_PortConstraints() , UNDEFINED_3) && (portConstraints = FREE);
  direction = castTo($getProperty(graph, DIRECTION), 59);
  direction == ($clinit_Direction() , UNDEFINED) && (direction = RIGHT_0);
  initializePort(port, portConstraints, direction, castTo($getProperty(port, PORT_ANCHOR), 10));
  switch (direction.ordinal) {
    case 2:
    case 1:
      (port.side == ($clinit_PortSide() , NORTH) || port.side == SOUTH) && graphProperties.add_1(($clinit_GraphProperties() , NORTH_SOUTH_PORTS));
      break;
    case 4:
    case 3:
      (port.side == ($clinit_PortSide() , EAST) || port.side == WEST) && graphProperties.add_1(($clinit_GraphProperties() , NORTH_SOUTH_PORTS));
  }
}

function $transformProperties(jsonEle, ele){
  var val;
  if ('properties' in jsonEle.jsObject) {
    val = $get_6(jsonEle, 'properties');
    if (!val.isObject()) {
      throw new UnsupportedJsonGraphException_1("The 'properties' property of a graph element must be an object.", val, jsonEle);
    }
    $transformPropertiesObj(val.isObject(), ele, true);
  }
}

function $transformPropertiesObj(properties, ele, override){
  var key, key$iterator, keys_0, theVal;
  if (properties) {
    for (key$iterator = (keys_0 = $computeKeys0(properties, initUnidimensionalArray(Ljava_lang_String_2_classLit, $intern_0, 2, 0, 5, 1)) , new AbstractList$IteratorImpl(new Arrays$ArrayList((new JSONObject$1(properties, keys_0)).val$keys2))); key$iterator.i < key$iterator.this$01_0.size_1();) {
      key = (checkCriticalElement(key$iterator.i < key$iterator.this$01_0.size_1()) , castToString(key$iterator.this$01_0.get_2(key$iterator.last = key$iterator.i++)));
      theVal = $get_6(properties, key);
      setOption(ele, key, theVal, override);
    }
  }
}

function JsonGraphImporter(){
  $clinit_JsonGraphImporter();
  this.nodeIdMap = ($clinit_Maps() , new HashMap);
  this.edgeIdMap = new HashMap;
  this.portIdMap = new HashMap;
  this.nodeJsonMap = new HashMap;
  this.edgeJsonMap = new HashMap;
  this.portJsonMap = new HashMap;
  this.labelJsonMap = new HashMap;
  this.jsonLGraphMap = new HashMap;
}

defineClass(364, 1, {}, JsonGraphImporter);
_.exportIntegerCoordinates = false;
_.globalOptions = null;
_.layoutHierarchy = null;
var INT_COORDINATES, JSON_OBJECT, ZERO_VECTOR;
var Lde_cau_cs_kieler_klay_gwt_client_layout_JsonGraphImporter_2_classLit = createForClass('de.cau.cs.kieler.klay.gwt.client.layout', 'JsonGraphImporter', 364);
function $clinit_LayoutOptionResolver(){
  $clinit_LayoutOptionResolver = emptyMethod;
  SUFFIX_SET = new HashSet;
  STRING_TYPES = createTypesSet(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_properties_IProperty_2_classLit, 1), $intern_12, 79, 0, [($clinit_LayoutOptions() , ALGORITHM), FONT_NAME]));
  INT_TYPES = createTypesSet(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_properties_IProperty_2_classLit, 1), $intern_12, 79, 0, [PARTITION, PORT_INDEX, ($clinit_Properties() , RANDOM_SEED), FONT_SIZE, ($clinit_InternalProperties() , PRIORITY_0), THOROUGHNESS, NODE_PROMOTION_BOUNDARY]));
  BOOLEAN_TYPES = createTypesSet(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_properties_IProperty_2_classLit, 1), $intern_12, 79, 0, [ANIMATE, COMMENT_BOX, NO_LAYOUT, EXPAND_NODES, INTERACTIVE, LAYOUT_HIERARCHY, LAYOUT_PARTITIONS, SELF_LOOP_INSIDE, SEPARATE_CC, HYPERNODE, ADD_UNNECESSARY_BENDPOINTS, DEBUG_MODE_0, DISTRIBUTE_NODES, MERGE_EDGES, FEEDBACK_EDGES, MERGE_HIERARCHICAL_EDGES, SAUSAGE_FOLDING, NORTH_OR_SOUTH_PORT, COMPACT_COMPONENTS]));
  FLOAT_TYPES = createTypesSet(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_properties_IProperty_2_classLit, 1), $intern_12, 79, 0, [MIN_WIDTH, MIN_HEIGHT, LABEL_SPACING, THICKNESS, OFFSET, PORT_SPACING_0, BORDER_SPACING_0, ASPECT_RATIO_0, SPACING_0, OBJ_SPACING_IN_LAYER_FACTOR, EDGE_SPACING_FACTOR, LINEAR_SEGMENTS_DEFLECTION_DAMPENING]));
  ENUM_TYPES = createTypesSet(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_properties_IProperty_2_classLit, 1), $intern_12, 79, 0, [PORT_SIDE, ALIGNMENT, DIRECTION, EDGE_ROUTING, EDGE_LABEL_PLACEMENT, EDGE_TYPE, HIERARCHY_HANDLING, PORT_ALIGNMENT, PORT_ALIGNMENT_EAST, PORT_ALIGNMENT_NORTH, PORT_ALIGNMENT_SOUTH, PORT_ALIGNMENT_WEST, PORT_CONSTRAINTS, PORT_LABEL_PLACEMENT, COMPACTION_STRATEGY, CYCLE_BREAKING, NODE_LAYERING, EDGE_LABEL_SIDE_SELECTION, CROSS_MIN, NODE_PLACER, NODE_PROMOTION_0, FIXED_ALIGNMENT, GREEDY_SWITCH_TYPE, LAYER_CONSTRAINT, POST_COMPACTION, POST_COMPACTION_COSTRAINTS, SPLINE_SELF_LOOP_PLACEMENT, WIDE_NODES_ON_MULTIPLE_LAYERS, INTERACTIVE_REFERENCE_POINT]));
  ENUMSET_TYPES = createTypesSet(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_properties_IProperty_2_classLit, 1), $intern_12, 79, 0, [NODE_LABEL_PLACEMENT, SIZE_CONSTRAINT, SIZE_OPTIONS, CONTENT_ALIGNMENT]));
  OTHER_TYPES = createTypesSet(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_properties_IProperty_2_classLit, 1), $intern_12, 79, 0, [ADDITIONAL_PORT_SPACE, BEND_POINTS, JUNCTION_POINTS, MARGINS, PORT_ANCHOR, POSITION]));
  KLAY_JS = createTypesSet(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_properties_IProperty_2_classLit, 1), $intern_12, 79, 0, [($clinit_JsonGraphImporter() , INT_COORDINATES)]));
}

function createTypesSet(props){
  var id_0, imap, iset, map_0, outerIter, p, p$index, p$max, set_0, suffix;
  set_0 = new HashSet;
  map_0 = ($clinit_Maps() , new HashMap);
  for (p$index = 0 , p$max = props.length; p$index < p$max; ++p$index) {
    p = props[p$index];
    id_0 = p.getId();
    set_0.map_0.put(id_0, set_0);
    id_0 == null?$put_5(map_0.hashCodeMap, null, p):$put_6(map_0.stringMap, id_0, p);
    suffix = $substring_0(id_0, ($clinit_String() , id_0.lastIndexOf('.')) + 1, id_0.length);
    if (!$contains_7(SUFFIX_SET, suffix)) {
      set_0.map_0.put(suffix, set_0);
      suffix == null?$put_5(map_0.hashCodeMap, null, p):$put_6(map_0.stringMap, suffix, p);
      $add_18(SUFFIX_SET, suffix);
    }
  }
  iset = ($clinit_ImmutableCollection() , copyOf_1((outerIter = (new AbstractMap$1(set_0.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter))));
  imap = copyOf_0(map_0);
  return new Pair(iset, imap);
}

function equalsIdOrSuffix(prop, idOrSuffix){
  return $equals_5(prop.id_0, idOrSuffix) || $endsWith(prop.id_0, idOrSuffix) && (($clinit_String() , idOrSuffix.length) == length_1(prop.id_0) || charAt(prop.id_0, length_1(prop.id_0) - idOrSuffix.length - 1) == 46);
}

function setOption(element, id_0, value_0, override){
  $clinit_LayoutOptionResolver();
  var all, component, component$index, component$max, components, enumSetValue, enumValue, enumeration, margins, p, s, set_0, v, val, vc;
  if (!override) {
    if ((!element.propertyMap?($clinit_Collections() , $clinit_Collections() , EMPTY_MAP):element.propertyMap).containsKey(new LayoutOptionResolver$DummyProperty(id_0))) {
      return;
    }
  }
  if (castTo(STRING_TYPES.first, 18).contains(id_0)) {
    if (!value_0.isString()) {
      throw new UnsupportedGraphException("Invalid boolean format for property '" + id_0 + "' (" + value_0 + ').');
    }
    p = castTo(castTo(STRING_TYPES.second, 57).get_1(id_0), 79);
    s = value_0.isString().value_0;
    $setProperty(element, p, s);
    return;
  }
   else if (castTo(INT_TYPES.first, 18).contains(id_0)) {
    try {
      if (!value_0.isNumber()) {
        throw new NumberFormatException;
      }
      p = castTo(castTo(INT_TYPES.second, 57).get_1(id_0), 79);
      val = valueOf_0(__parseAndValidateInt(($clinit_String() , '' + value_0.isNumber().value_0)));
      $setProperty(element, p, val);
      return;
    }
     catch ($e0) {
      $e0 = wrap($e0);
      if (instanceOf($e0, 130)) {
        throw new UnsupportedGraphException("Invalid integer format for property '" + id_0 + "' (" + value_0 + ').');
      }
       else 
        throw unwrap_5($e0);
    }
  }
   else if (castTo(BOOLEAN_TYPES.first, 18).contains(id_0)) {
    if (!value_0.isBoolean()) {
      throw new UnsupportedGraphException("Invalid boolean format for property '" + id_0 + "' (" + value_0 + ').');
    }
    p = castTo(castTo(BOOLEAN_TYPES.second, 57).get_1(id_0), 79);
    val = ($clinit_Boolean() , value_0.isBoolean().value_0?TRUE_0:FALSE_0);
    $setProperty(element, p, val);
    return;
  }
   else if (castTo(FLOAT_TYPES.first, 18).contains(id_0)) {
    if (!value_0.isNumber()) {
      throw new UnsupportedGraphException("Invalid float format for property '" + id_0 + "' (" + value_0 + ').');
    }
    p = castTo(castTo(FLOAT_TYPES.second, 57).get_1(id_0), 79);
    val = new Float(value_0.isNumber().value_0);
    $setProperty(element, p, val);
    return;
  }
   else if (castTo(ENUM_TYPES.first, 18).contains(id_0)) {
    if (!value_0.isString()) {
      throw new UnsupportedGraphException("Invalid enum format for property '" + id_0 + "' (" + value_0 + ').');
    }
    enumValue = value_0.isString().value_0;
    enumeration = null;
    try {
      equalsIdOrSuffix(($clinit_LayoutOptions() , PORT_SIDE), id_0)?(enumeration = ($clinit_PortSide() , castTo(valueOf(($clinit_PortSide$Map() , $MAP_9), enumValue), 32))):equalsIdOrSuffix(ALIGNMENT, id_0)?(enumeration = ($clinit_Alignment() , castTo(valueOf(($clinit_Alignment$Map() , $MAP), enumValue), 103))):equalsIdOrSuffix(DIRECTION, id_0)?(enumeration = ($clinit_Direction() , castTo(valueOf(($clinit_Direction$Map() , $MAP_0), enumValue), 59))):equalsIdOrSuffix(EDGE_ROUTING, id_0)?(enumeration = ($clinit_EdgeRouting() , castTo(valueOf(($clinit_EdgeRouting$Map() , $MAP_2), enumValue), 122))):equalsIdOrSuffix(HIERARCHY_HANDLING, id_0)?(enumeration = ($clinit_HierarchyHandling() , castTo(valueOf(($clinit_HierarchyHandling$Map() , $MAP_4), enumValue), 166))):equalsIdOrSuffix(PORT_ALIGNMENT, id_0) || equalsIdOrSuffix(PORT_ALIGNMENT_EAST, id_0) || equalsIdOrSuffix(PORT_ALIGNMENT_NORTH, id_0) || equalsIdOrSuffix(PORT_ALIGNMENT_SOUTH, id_0) || equalsIdOrSuffix(PORT_ALIGNMENT_WEST, id_0)?(enumeration = ($clinit_PortAlignment() , castTo(valueOf(($clinit_PortAlignment$Map() , $MAP_6), enumValue), 99))):equalsIdOrSuffix(PORT_CONSTRAINTS, id_0)?(enumeration = ($clinit_PortConstraints() , castTo(valueOf(($clinit_PortConstraints$Map() , $MAP_7), enumValue), 28))):equalsIdOrSuffix(PORT_LABEL_PLACEMENT, id_0)?(enumeration = ($clinit_PortLabelPlacement() , castTo(valueOf(($clinit_PortLabelPlacement$Map() , $MAP_8), enumValue), 149))):equalsIdOrSuffix(EDGE_TYPE, id_0)?(enumeration = ($clinit_EdgeType() , castTo(valueOf(($clinit_EdgeType$Map() , $MAP_3), enumValue), 133))):equalsIdOrSuffix(EDGE_LABEL_PLACEMENT, id_0)?(enumeration = ($clinit_EdgeLabelPlacement() , castTo(valueOf(($clinit_EdgeLabelPlacement$Map() , $MAP_1), enumValue), 107))):equalsIdOrSuffix(($clinit_Properties() , CYCLE_BREAKING), id_0)?(enumeration = ($clinit_CycleBreakingStrategy() , castTo(valueOf(($clinit_CycleBreakingStrategy$Map() , $MAP_15), enumValue), 193))):equalsIdOrSuffix(NODE_LAYERING, id_0)?(enumeration = ($clinit_LayeringStrategy() , castTo(valueOf(($clinit_LayeringStrategy$Map() , $MAP_16), enumValue), 173))):equalsIdOrSuffix(EDGE_LABEL_SIDE_SELECTION, id_0)?(enumeration = ($clinit_EdgeLabelSideSelection() , castTo(valueOf(($clinit_EdgeLabelSideSelection$Map() , $MAP_21), enumValue), 115))):equalsIdOrSuffix(COMPACTION_STRATEGY, id_0)?(enumeration = ($clinit_CompactionStrategy() , castTo(valueOf(($clinit_CompactionStrategy$Map() , $MAP_19), enumValue), 194))):equalsIdOrSuffix(CROSS_MIN, id_0)?(enumeration = ($clinit_CrossingMinimizationStrategy() , castTo(valueOf(($clinit_CrossingMinimizationStrategy$Map() , $MAP_17), enumValue), 192))):equalsIdOrSuffix(NODE_PROMOTION_0, id_0)?(enumeration = ($clinit_NodePromotionStrategy() , castTo(valueOf(($clinit_NodePromotionStrategy$Map() , $MAP_12), enumValue), 109))):equalsIdOrSuffix(NODE_PLACER, id_0)?(enumeration = ($clinit_NodePlacementStrategy() , castTo(valueOf(($clinit_NodePlacementStrategy$Map() , $MAP_18), enumValue), 141))):equalsIdOrSuffix(POST_COMPACTION, id_0)?(enumeration = ($clinit_GraphCompactionStrategy() , castTo(valueOf(($clinit_GraphCompactionStrategy$Map() , $MAP_14), enumValue), 125))):equalsIdOrSuffix(POST_COMPACTION_COSTRAINTS, id_0)?(enumeration = ($clinit_ConstraintCalculationStrategy() , castTo(valueOf(($clinit_ConstraintCalculationStrategy$Map() , $MAP_13), enumValue), 175))):equalsIdOrSuffix(FIXED_ALIGNMENT, id_0)?(enumeration = ($clinit_FixedAlignment() , castTo(valueOf(($clinit_FixedAlignment$Map() , $MAP_22), enumValue), 124))):equalsIdOrSuffix(GREEDY_SWITCH_TYPE, id_0)?(enumeration = ($clinit_GreedySwitchType() , castTo(valueOf(($clinit_GreedySwitchType$Map() , $MAP_23), enumValue), 110))):equalsIdOrSuffix(LAYER_CONSTRAINT, id_0)?(enumeration = ($clinit_LayerConstraint() , castTo(valueOf(($clinit_LayerConstraint$Map() , $MAP_25), enumValue), 85))):equalsIdOrSuffix(SPLINE_SELF_LOOP_PLACEMENT, id_0)?(enumeration = ($clinit_SelfLoopPlacement() , castTo(valueOf(($clinit_SelfLoopPlacement$Map() , $MAP_26), enumValue), 153))):equalsIdOrSuffix(WIDE_NODES_ON_MULTIPLE_LAYERS, id_0)?(enumeration = ($clinit_WideNodesStrategy() , castTo(valueOf(($clinit_WideNodesStrategy$Map() , $MAP_27), enumValue), 172))):equalsIdOrSuffix(INTERACTIVE_REFERENCE_POINT, id_0) && (enumeration = ($clinit_InteractiveReferencePoint() , castTo(valueOf(($clinit_InteractiveReferencePoint$Map() , $MAP_24), enumValue), 174)));
    }
     catch ($e1) {
      $e1 = wrap($e1);
      if (instanceOf($e1, 54)) {
        throw new UnsupportedGraphException("Invalid enum format for property '" + id_0 + "' (" + value_0 + ').');
      }
       else 
        throw unwrap_5($e1);
    }
    p = castTo(castTo(ENUM_TYPES.second, 57).get_1(id_0), 79);
    $setProperty(element, p, enumeration);
    return;
  }
   else if (castTo(ENUMSET_TYPES.first, 18).contains(id_0)) {
    if (!value_0.isString()) {
      throw new UnsupportedGraphException("Invalid enum format for property '" + id_0 + "' (" + value_0 + ').');
    }
    enumSetValue = value_0.isString().value_0;
    set_0 = null;
    components = $split_1(enumSetValue, '[\\[\\]\\s,]+');
    for (component$index = 0 , component$max = components.length; component$index < component$max; ++component$index) {
      component = components[component$index];
      if (length_1($trim(component)) == 0) {
        continue;
      }
      if (equalsIdOrSuffix(($clinit_LayoutOptions() , NODE_LABEL_PLACEMENT), id_0)) {
        !set_0 && (set_0 = (all = castTo($getEnumConstants(Lde_cau_cs_kieler_kiml_options_NodeLabelPlacement_2_classLit), 11) , new EnumSet$EnumSetImpl(all, castTo(createFrom(all, all.length), 11), 0)));
        $add_17(set_0, ($clinit_NodeLabelPlacement() , castTo(valueOf(($clinit_NodeLabelPlacement$Map() , $MAP_5), component), 41)));
      }
       else if (equalsIdOrSuffix(SIZE_CONSTRAINT, id_0)) {
        !set_0 && (set_0 = (all = castTo($getEnumConstants(Lde_cau_cs_kieler_kiml_options_SizeConstraint_2_classLit), 11) , new EnumSet$EnumSetImpl(all, castTo(createFrom(all, all.length), 11), 0)));
        $add_17(set_0, ($clinit_SizeConstraint() , castTo(valueOf(($clinit_SizeConstraint$Map() , $MAP_10), component), 150)));
      }
       else if (equalsIdOrSuffix(SIZE_OPTIONS, id_0)) {
        !set_0 && (set_0 = (all = castTo($getEnumConstants(Lde_cau_cs_kieler_kiml_options_SizeOptions_2_classLit), 11) , new EnumSet$EnumSetImpl(all, castTo(createFrom(all, all.length), 11), 0)));
        $add_17(set_0, ($clinit_SizeOptions() , castTo(valueOf(($clinit_SizeOptions$Map() , $MAP_11), component), 139)));
      }
       else if (equalsIdOrSuffix(($clinit_Properties() , CONTENT_ALIGNMENT), id_0)) {
        !set_0 && (set_0 = (all = castTo($getEnumConstants(Lde_cau_cs_kieler_klay_layered_properties_ContentAlignment_2_classLit), 11) , new EnumSet$EnumSetImpl(all, castTo(createFrom(all, all.length), 11), 0)));
        $add_17(set_0, ($clinit_ContentAlignment() , castTo(valueOf(($clinit_ContentAlignment$Map() , $MAP_20), component), 123)));
      }
    }
    p = castTo(castTo(ENUMSET_TYPES.second, 57).get_1(id_0), 79);
    $setProperty(element, p, set_0);
    return;
  }
   else if (castTo(OTHER_TYPES.first, 18).contains(id_0)) {
    if (!value_0.isString()) {
      throw new UnsupportedGraphException("Invalid _other_ format for property '" + id_0 + "' (" + value_0 + ').');
    }
    if (equalsIdOrSuffix(($clinit_LayoutOptions() , POSITION), id_0) || equalsIdOrSuffix(PORT_ANCHOR, id_0)) {
      try {
        v = new KVector;
        $parse_0(v, value_0.isString().value_0);
        p = castTo(castTo(OTHER_TYPES.second, 57).get_1(id_0), 79);
        $setProperty(element, p, v);
        return;
      }
       catch ($e2) {
        $e2 = wrap($e2);
        if (instanceOf($e2, 29)) {
          throw new UnsupportedGraphException("Invalid KVector format for property '" + id_0 + "' " + value_0 + '.');
        }
         else 
          throw unwrap_5($e2);
      }
    }
     else if (equalsIdOrSuffix(BEND_POINTS, id_0) || equalsIdOrSuffix(JUNCTION_POINTS, id_0)) {
      try {
        vc = new KVectorChain;
        $parse_1(vc, value_0.isString().value_0);
        p = castTo(castTo(OTHER_TYPES.second, 57).get_1(id_0), 79);
        $setProperty(element, p, vc);
        return;
      }
       catch ($e3) {
        $e3 = wrap($e3);
        if (instanceOf($e3, 29)) {
          throw new UnsupportedGraphException("Invalid KVectorChain format for property '" + id_0 + "' " + value_0 + '.');
        }
         else 
          throw unwrap_5($e3);
      }
    }
     else if (equalsIdOrSuffix(MARGINS, id_0) || equalsIdOrSuffix(ADDITIONAL_PORT_SPACE, id_0)) {
      try {
        margins = new Spacing$Margins;
        $parse_2(margins, value_0.isString().value_0);
        p = castTo(castTo(OTHER_TYPES.second, 57).get_1(id_0), 79);
        $setProperty(element, p, margins);
        return;
      }
       catch ($e4) {
        $e4 = wrap($e4);
        if (instanceOf($e4, 29)) {
          throw new UnsupportedGraphException("Invalid Margins format for property '" + id_0 + "' " + value_0 + '.');
        }
         else 
          throw unwrap_5($e4);
      }
    }
  }
   else if (castTo(KLAY_JS.first, 18).contains(id_0)) {
    return;
  }
  throw new UnsupportedGraphException("Unsupported layout option '" + id_0 + "' (" + value_0 + ').');
}

var BOOLEAN_TYPES, ENUMSET_TYPES, ENUM_TYPES, FLOAT_TYPES, INT_TYPES, KLAY_JS, OTHER_TYPES, STRING_TYPES, SUFFIX_SET;
function LayoutOptionResolver$DummyProperty(theid){
  $clinit_Property();
  Property_1.call(this, theid);
}

defineClass(417, 14, $intern_46, LayoutOptionResolver$DummyProperty);
var Lde_cau_cs_kieler_klay_gwt_client_layout_LayoutOptionResolver$DummyProperty_2_classLit = createForClass('de.cau.cs.kieler.klay.gwt.client.layout', 'LayoutOptionResolver/DummyProperty', 417);
function $clinit_RecursiveLGraphLayout(){
  $clinit_RecursiveLGraphLayout = emptyMethod;
  LAYOUT_HIERARCHY_0 = new Property(($clinit_LayoutOptions() , LAYOUT_HIERARCHY), ($clinit_Boolean() , $clinit_Boolean() , TRUE_0));
}

function $layout(this$static, json, options){
  var graph, importer, klayLayered;
  importer = new JsonGraphImporter;
  importer.globalOptions = options;
  graph = $importGraph(importer, json);
  klayLayered = new KlayLayered;
  unsafeCast(checkNotNull_1(castToBoolean($getProperty(graph, LAYOUT_HIERARCHY_0))))?$doCompoundLayout(klayLayered, graph, new BasicProgressMonitor):$recLayout(this$static, klayLayered, graph);
  $transferLayout_0(importer, graph);
}

function $recLayout(this$static, layered, graph){
  var alg, borderSpacing, borderSpacing0, childGraph, n, n$iterator, pm, res;
  for (n$iterator = new ArrayList$1(graph.layerlessNodes); n$iterator.i < n$iterator.this$01.array.length;) {
    n = castTo($next_8(n$iterator), 9);
    childGraph = castTo($getProperty(n, ($clinit_InternalProperties() , NESTED_LGRAPH)), 55);
    if (childGraph) {
      res = $recLayout(this$static, layered, childGraph);
      n.size_0.x_0 = (borderSpacing0 = castTo($getProperty(res, BORDER_SPACING_0), 15).value_0 , new KVector_1(res.size_0.x_0 + res.insets.left + res.insets.right + 2 * borderSpacing0, res.size_0.y_0 + res.insets.top_0 + res.insets.bottom + 2 * borderSpacing0)).x_0;
      n.size_0.y_0 = (borderSpacing = castTo($getProperty(res, BORDER_SPACING_0), 15).value_0 , new KVector_1(res.size_0.x_0 + res.insets.left + res.insets.right + 2 * borderSpacing, res.size_0.y_0 + res.insets.top_0 + res.insets.bottom + 2 * borderSpacing)).y_0;
    }
  }
  pm = new BasicProgressMonitor;
  alg = castToString($getProperty(graph, ($clinit_LayoutOptions() , ALGORITHM)));
  alg != null && $equals_5(alg, 'de.cau.cs.kieler.fixed')?$doLayout(graph, pm):$doLayout_0(layered, graph, pm);
  return graph;
}

function RecursiveLGraphLayout(){
  $clinit_RecursiveLGraphLayout();
}

defineClass(348, 1, {}, RecursiveLGraphLayout);
var LAYOUT_HIERARCHY_0;
var Lde_cau_cs_kieler_klay_gwt_client_layout_RecursiveLGraphLayout_2_classLit = createForClass('de.cau.cs.kieler.klay.gwt.client.layout', 'RecursiveLGraphLayout', 348);
function $toJson(this$static){
  var obj;
  obj = new JSONObject;
  $put_1(obj, 'type', new JSONString(($ensureNamesAreInitialized(Lde_cau_cs_kieler_klay_gwt_client_layout_UnsupportedJsonGraphException_2_classLit) , Lde_cau_cs_kieler_klay_gwt_client_layout_UnsupportedJsonGraphException_2_classLit.typeName)));
  $put_1(obj, 'text', new JSONString(this$static.detailMessage));
  !!this$static.value_0 && $put_1(obj, 'value', this$static.value_0);
  !!this$static.context && $put_1(obj, 'context', this$static.context);
  $put_1(obj, 'stacktrace', new JSONString($join(new Joiner('\n'), new AbstractList$IteratorImpl(new Arrays$ArrayList((this$static.stackTrace == null && (this$static.stackTrace = constructJavaStackTrace(this$static)) , this$static.stackTrace))))));
  return obj;
}

function UnsupportedJsonGraphException(msg){
  UnsupportedGraphException.call(this, msg);
}

function UnsupportedJsonGraphException_0(msg, value_0){
  UnsupportedGraphException.call(this, msg);
  this.value_0 = value_0;
}

function UnsupportedJsonGraphException_1(msg, value_0, context){
  UnsupportedGraphException.call(this, msg);
  this.value_0 = value_0;
  this.context = context;
}

defineClass(73, 98, {73:1, 3:1, 54:1, 46:1}, UnsupportedJsonGraphException, UnsupportedJsonGraphException_0, UnsupportedJsonGraphException_1);
var Lde_cau_cs_kieler_klay_gwt_client_layout_UnsupportedJsonGraphException_2_classLit = createForClass('de.cau.cs.kieler.klay.gwt.client.layout', 'UnsupportedJsonGraphException', 73);
function $clinit_GraphConfigurator(){
  $clinit_GraphConfigurator = emptyMethod;
  BASELINE_PROCESSING_CONFIGURATION = $addBeforePhase5($addBeforePhase4($addBeforePhase4(new IntermediateProcessingConfiguration, ($clinit_IntermediateProcessorStrategy() , NODE_MARGIN_CALCULATOR)), LABEL_AND_NODE_SIZE_PROCESSOR), LAYER_SIZE_AND_GRAPH_HEIGHT_CALCULATOR);
  LABEL_MANAGEMENT_ADDITIONS = $addBeforePhase3(new IntermediateProcessingConfiguration, LABEL_MANAGEMENT_PROCESSOR);
}

function $cachedLayoutPhase(this$static, factory){
  var layoutPhase;
  layoutPhase = castTo($get_9(this$static.phaseCache, factory), 106);
  if (!layoutPhase) {
    layoutPhase = factory.create_0();
    $put_2(this$static.phaseCache, factory, layoutPhase);
  }
  return layoutPhase;
}

function $getIntermediateProcessorList(this$static, configuration, slot){
  var processor, processor$iterator, processorImpl, processors, result;
  processors = ($clinit_Collections() , new Collections$UnmodifiableSet(castTo($get_8(configuration.strategy, slot), 18)));
  result = new ArrayList_0(processors.coll.size_1());
  for (processor$iterator = new Collections$UnmodifiableCollectionIterator(processors.coll.iterator_0()); processor$iterator.it.hasNext_0();) {
    processor = castTo(processor$iterator.it.next_1(), 37);
    processorImpl = castTo($get_9(this$static.intermediateProcessorCache, processor), 31);
    if (!processorImpl) {
      processorImpl = $create(processor);
      $put_2(this$static.intermediateProcessorCache, processor, processorImpl);
    }
    result.array[result.array.length] = processorImpl;
  }
  return result;
}

function $getPhaseIndependentIntermediateProcessingConfiguration(lgraph){
  var configuration, graphProperties;
  graphProperties = castTo($getProperty(lgraph, ($clinit_InternalProperties() , GRAPH_PROPERTIES)), 18);
  configuration = fromExisting(BASELINE_PROCESSING_CONFIGURATION);
  unsafeCast(checkNotNull_1(castToBoolean($getProperty(lgraph, ($clinit_Properties() , FEEDBACK_EDGES)))))?$addBeforePhase1(configuration, ($clinit_IntermediateProcessorStrategy() , PORT_SIDE_PROCESSOR)):$addBeforePhase3(configuration, ($clinit_IntermediateProcessorStrategy() , PORT_SIDE_PROCESSOR));
  $getProperty(lgraph, ($clinit_LabelManagementOptions() , LABEL_MANAGER)) != null && $addAll_4(configuration, LABEL_MANAGEMENT_ADDITIONS);
  switch (castTo($getProperty(lgraph, ($clinit_LayoutOptions() , DIRECTION)), 59).ordinal) {
    case 2:
      $addAfterPhase5($addBeforePhase1(configuration, ($clinit_IntermediateProcessorStrategy() , LEFT_DIR_PREPROCESSOR)), LEFT_DIR_POSTPROCESSOR);
      break;
    case 3:
      $addAfterPhase5($addBeforePhase1(configuration, ($clinit_IntermediateProcessorStrategy() , DOWN_DIR_PREPROCESSOR)), DOWN_DIR_POSTPROCESSOR);
      break;
    case 4:
      $addAfterPhase5($addBeforePhase1(configuration, ($clinit_IntermediateProcessorStrategy() , UP_DIR_PREPROCESSOR)), UP_DIR_POSTPROCESSOR);
  }
  graphProperties.contains(($clinit_GraphProperties() , COMMENTS)) && $addAfterPhase5($addBeforePhase1(configuration, ($clinit_IntermediateProcessorStrategy() , COMMENT_PREPROCESSOR)), COMMENT_POSTPROCESSOR);
  maskUndefined($getProperty(lgraph, NODE_PROMOTION_0)) !== maskUndefined(($clinit_NodePromotionStrategy() , NONE_0)) && $addBeforePhase3(configuration, ($clinit_IntermediateProcessorStrategy() , NODE_PROMOTION));
  maskUndefined($getProperty(lgraph, POST_COMPACTION)) !== maskUndefined(($clinit_GraphCompactionStrategy() , NONE_1)) && maskUndefined($getProperty(lgraph, EDGE_ROUTING_0)) === maskUndefined(($clinit_EdgeRouting() , ORTHOGONAL)) && $addAfterPhase5(configuration, ($clinit_IntermediateProcessorStrategy() , HORIZONTAL_COMPACTOR));
  if (graphProperties.contains(PARTITIONS)) {
    $addBeforePhase1(configuration, ($clinit_IntermediateProcessorStrategy() , PARTITION_PREPROCESSOR));
    $addBeforePhase3(configuration, PARTITION_POSTPROCESSOR);
  }
  return configuration;
}

function $prepareGraphForLayout(this$static, lgraph){
  var algorithm, crossingMinimizer, cycleBreaker, edgeRouter, intermediateProcessingConfiguration, layerer, nodePlacer, spacing, direction, randomSeed, spacings;
  $checkProperties(lgraph, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_properties_IProperty_2_classLit, 1), $intern_12, 79, 0, [($clinit_InternalProperties() , SPACING_0), BORDER_SPACING_0, ($clinit_Properties() , THOROUGHNESS), ASPECT_RATIO_0]));
  spacing = castTo($getProperty(lgraph, SPACING_0), 15).value_0;
  castTo($getProperty(lgraph, EDGE_SPACING_FACTOR), 15).value_0 * spacing < 2 && $setProperty(lgraph, EDGE_SPACING_FACTOR, new Float_0(2 / spacing));
  direction = castTo($getProperty(lgraph, ($clinit_LayoutOptions() , DIRECTION)), 59);
  direction == ($clinit_Direction() , UNDEFINED) && $setProperty(lgraph, DIRECTION, getDirection_1(lgraph));
  randomSeed = castTo($getProperty(lgraph, RANDOM_SEED), 24);
  randomSeed.value_0 == 0?$setProperty(lgraph, RANDOM, new Random):$setProperty(lgraph, RANDOM, new Random_0(randomSeed.value_0));
  spacings = new Spacings(lgraph);
  $setProperty(lgraph, SPACINGS, spacings);
  cycleBreaker = $cachedLayoutPhase(this$static, castTo($getProperty(lgraph, CYCLE_BREAKING), 180));
  layerer = $cachedLayoutPhase(this$static, castTo($getProperty(lgraph, NODE_LAYERING), 180));
  crossingMinimizer = $cachedLayoutPhase(this$static, castTo($getProperty(lgraph, CROSS_MIN), 180));
  nodePlacer = $cachedLayoutPhase(this$static, castTo($getProperty(lgraph, NODE_PLACER), 180));
  edgeRouter = $cachedLayoutPhase(this$static, factoryFor(castTo($getProperty(lgraph, EDGE_ROUTING_0), 122)));
  intermediateProcessingConfiguration = new IntermediateProcessingConfiguration;
  $setProperty(lgraph, CONFIGURATION, intermediateProcessingConfiguration);
  $addAll_4($addAll_4($addAll_4($addAll_4($addAll_4($addAll_4(intermediateProcessingConfiguration, cycleBreaker.getIntermediateProcessingConfiguration(lgraph)), layerer.getIntermediateProcessingConfiguration(lgraph)), crossingMinimizer.getIntermediateProcessingConfiguration(lgraph)), nodePlacer.getIntermediateProcessingConfiguration(lgraph)), edgeRouter.getIntermediateProcessingConfiguration(lgraph)), $getPhaseIndependentIntermediateProcessingConfiguration(lgraph));
  algorithm = (checkNonnegative(30, 'initialArraySize') , new ArrayList_0(30));
  $setProperty(lgraph, PROCESSORS, algorithm);
  $addAll_6(algorithm, $getIntermediateProcessorList(this$static, intermediateProcessingConfiguration, 0));
  algorithm.array[algorithm.array.length] = cycleBreaker;
  $addAll_6(algorithm, $getIntermediateProcessorList(this$static, intermediateProcessingConfiguration, 1));
  algorithm.array[algorithm.array.length] = layerer;
  $addAll_6(algorithm, $getIntermediateProcessorList(this$static, intermediateProcessingConfiguration, 2));
  algorithm.array[algorithm.array.length] = crossingMinimizer;
  $addAll_6(algorithm, $getIntermediateProcessorList(this$static, intermediateProcessingConfiguration, 3));
  algorithm.array[algorithm.array.length] = nodePlacer;
  $addAll_6(algorithm, $getIntermediateProcessorList(this$static, intermediateProcessingConfiguration, 4));
  algorithm.array[algorithm.array.length] = edgeRouter;
  $addAll_6(algorithm, $getIntermediateProcessorList(this$static, intermediateProcessingConfiguration, 5));
}

function GraphConfigurator(){
  $clinit_GraphConfigurator();
  this.phaseCache = ($clinit_Maps() , new HashMap);
  this.intermediateProcessorCache = new HashMap;
}

defineClass(380, 1, {}, GraphConfigurator);
var BASELINE_PROCESSING_CONFIGURATION, LABEL_MANAGEMENT_ADDITIONS;
var Lde_cau_cs_kieler_klay_layered_GraphConfigurator_2_classLit = createForClass('de.cau.cs.kieler.klay.layered', 'GraphConfigurator', 380);
function $addAfterPhase5(this$static, processor){
  castTo($get_8(this$static.strategy, 5), 18).add_1(processor);
  return this$static;
}

function $addAll_4(this$static, operand){
  var i;
  if (operand) {
    for (i = 0; i < 6; i++) {
      castTo($get_8(this$static.strategy, i), 18).addAll(castTo($get_8(operand.strategy, i), 19));
    }
  }
  return this$static;
}

function $addBeforePhase1(this$static, processor){
  castTo($get_8(this$static.strategy, 0), 18).add_1(processor);
  return this$static;
}

function $addBeforePhase2(this$static, processor){
  castTo($get_8(this$static.strategy, 1), 18).add_1(processor);
  return this$static;
}

function $addBeforePhase3(this$static, processor){
  castTo($get_8(this$static.strategy, 2), 18).add_1(processor);
  return this$static;
}

function $addBeforePhase4(this$static, processor){
  castTo($get_8(this$static.strategy, 3), 18).add_1(processor);
  return this$static;
}

function $addBeforePhase5(this$static, processor){
  castTo($get_8(this$static.strategy, 4), 18).add_1(processor);
  return this$static;
}

function IntermediateProcessingConfiguration(){
  var all, i;
  this.strategy = new ArrayList_0(6);
  for (i = 0; i < 6; i++) {
    $add_11(this.strategy, (all = castTo($getEnumConstants(Lde_cau_cs_kieler_klay_layered_intermediate_IntermediateProcessorStrategy_2_classLit), 11) , new EnumSet$EnumSetImpl(all, castTo(createFrom(all, all.length), 11), 0)));
  }
}

function fromExisting(existing){
  var configuration;
  configuration = new IntermediateProcessingConfiguration;
  $addAll_4(configuration, existing);
  return configuration;
}

defineClass(49, 1, {}, IntermediateProcessingConfiguration);
var Lde_cau_cs_kieler_klay_layered_IntermediateProcessingConfiguration_2_classLit = createForClass('de.cau.cs.kieler.klay.layered', 'IntermediateProcessingConfiguration', 49);
function $doCompoundLayout(this$static, lgraph, monitor){
  $begin(monitor, 'Layered layout', 3);
  $process_2(this$static.compoundGraphPreprocessor, lgraph, $subTask(monitor, 1));
  $recursiveLayout(this$static, lgraph, $subTask(monitor, 1));
  $process_1(lgraph, $subTask(monitor, 1));
  $done(monitor);
}

function $doLayout_0(this$static, lgraph, monitor){
  var comp, comp$iterator, compWork, components;
  $begin(monitor, 'Layered layout', 1);
  $prepareGraphForLayout(this$static.graphConfigurator, lgraph);
  components = $split(this$static.componentsProcessor, lgraph);
  if (components.size_1() == 1) {
    $layout_0(castTo(components.get_2(0), 55), monitor);
  }
   else {
    compWork = 1 / components.size_1();
    for (comp$iterator = components.iterator_0(); comp$iterator.hasNext_0();) {
      comp = castTo(comp$iterator.next_1(), 55);
      $layout_0(comp, $subTask(monitor, compWork));
    }
  }
  $combine(this$static.componentsProcessor, components, lgraph);
  $resizeGraph(lgraph);
  $done(monitor);
}

function $graphLayoutToNode(node, lgraph){
  var actualGraphSize, borderSpacing, childNode, childNode$iterator, origin, port, portPosition;
  for (childNode$iterator = new ArrayList$1(lgraph.layerlessNodes); childNode$iterator.i < childNode$iterator.this$01.array.length;) {
    childNode = castTo($next_8(childNode$iterator), 9);
    origin = $getProperty(childNode, ($clinit_InternalProperties() , ORIGIN));
    if (instanceOf(origin, 7)) {
      port = castTo(origin, 7);
      portPosition = getExternalPortPosition(lgraph, childNode, port.size_0.x_0, port.size_0.y_0);
      port.pos.x_0 = portPosition.x_0;
      port.pos.y_0 = portPosition.y_0;
      $setSide(port, castTo($getProperty(childNode, EXT_PORT_SIDE), 32));
    }
  }
  actualGraphSize = (borderSpacing = castTo($getProperty(lgraph, ($clinit_InternalProperties() , BORDER_SPACING_0)), 15).value_0 , new KVector_1(lgraph.size_0.x_0 + lgraph.insets.left + lgraph.insets.right + 2 * borderSpacing, lgraph.size_0.y_0 + lgraph.insets.top_0 + lgraph.insets.bottom + 2 * borderSpacing));
  if (castTo($getProperty(lgraph, GRAPH_PROPERTIES), 18).contains(($clinit_GraphProperties() , EXTERNAL_PORTS))) {
    $setProperty(node, ($clinit_LayoutOptions() , PORT_CONSTRAINTS), ($clinit_PortConstraints() , FIXED_POS));
    castTo($getProperty($getGraph(node), GRAPH_PROPERTIES), 18).add_1(NON_FREE_PORTS);
    resizeNode(node, actualGraphSize, false);
  }
   else {
    resizeNode(node, actualGraphSize, true);
  }
}

function $layout_0(lgraph, monitor){
  var algorithm, layer, layer$iterator, monitorProgress, monitorStarted, node, node$iterator, processor, processor$iterator, slotIndex;
  monitorStarted = monitor.taskName != null && !monitor.closed_0;
  monitorStarted || $begin(monitor, 'Component Layout', 1);
  algorithm = castTo($getProperty(lgraph, ($clinit_InternalProperties() , PROCESSORS)), 20);
  monitorProgress = 1 / algorithm.size_1();
  if (unsafeCast(checkNotNull_1(castToBoolean($getProperty(lgraph, ($clinit_LayoutOptions() , DEBUG_MODE)))))) {
    slotIndex = 0;
    for (processor$iterator = algorithm.iterator_0(); processor$iterator.hasNext_0();) {
      processor = castTo(processor$iterator.next_1(), 31);
      ++slotIndex;
      $getSimpleName(getClass__Ljava_lang_Class___devirtual$(processor));
      processor.process(lgraph, $subTask(monitor, monitorProgress));
    }
  }
   else {
    for (processor$iterator = algorithm.iterator_0(); processor$iterator.hasNext_0();) {
      processor = castTo(processor$iterator.next_1(), 31);
      processor.process(lgraph, $subTask(monitor, monitorProgress));
    }
  }
  for (layer$iterator = new ArrayList$1(lgraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator), 16);
    $addAll_6(lgraph.layerlessNodes, layer.nodes);
    layer.nodes.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
  }
  for (node$iterator = new ArrayList$1(lgraph.layerlessNodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 9);
    $setLayer_0(node, null);
  }
  lgraph.layers.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
  monitorStarted || $done(monitor);
}

function $recursiveLayout(this$static, lgraph, monitor){
  var nestedGraph, node, node$iterator, workPerSubgraph;
  $begin(monitor, 'Recursive layout', 2);
  if (lgraph.layerlessNodes.array.length != 0) {
    workPerSubgraph = 1 / lgraph.layerlessNodes.array.length;
    for (node$iterator = new ArrayList$1(lgraph.layerlessNodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      nestedGraph = castTo($getProperty(node, ($clinit_InternalProperties() , NESTED_LGRAPH)), 55);
      if (nestedGraph) {
        $recursiveLayout(this$static, nestedGraph, $subTask(monitor, workPerSubgraph));
        $graphLayoutToNode(node, nestedGraph);
      }
    }
    $prepareGraphForLayout(this$static.graphConfigurator, lgraph);
    $layout_0(lgraph, monitor);
  }
  $resizeGraph(lgraph);
  $done(monitor);
}

function $resizeGraph(lgraph){
  var adjustedSize, borderSpacing, borderSpacing0, calculatedSize, minHeight, minWidth, sizeConstraint, sizeOptions;
  sizeConstraint = castTo($getProperty(lgraph, ($clinit_LayoutOptions() , SIZE_CONSTRAINT)), 18);
  sizeOptions = castTo($getProperty(lgraph, SIZE_OPTIONS), 18);
  borderSpacing0 = castTo($getProperty(lgraph, ($clinit_InternalProperties() , BORDER_SPACING_0)), 15).value_0;
  lgraph.offset.x_0 += borderSpacing0;
  lgraph.offset.y_0 += borderSpacing0;
  lgraph.size_0.x_0 += 2 * borderSpacing0;
  lgraph.size_0.y_0 += 2 * borderSpacing0;
  $setProperty(lgraph, BORDER_SPACING_0, new Float_0(0));
  calculatedSize = (borderSpacing = castTo($getProperty(lgraph, BORDER_SPACING_0), 15).value_0 , new KVector_1(lgraph.size_0.x_0 + lgraph.insets.left + lgraph.insets.right + 2 * borderSpacing, lgraph.size_0.y_0 + lgraph.insets.top_0 + lgraph.insets.bottom + 2 * borderSpacing));
  adjustedSize = new KVector_2(calculatedSize);
  if (sizeConstraint.contains(($clinit_SizeConstraint() , MINIMUM_SIZE))) {
    minWidth = castTo($getProperty(lgraph, MIN_WIDTH), 15).value_0;
    minHeight = castTo($getProperty(lgraph, MIN_HEIGHT), 15).value_0;
    if (sizeOptions.contains(($clinit_SizeOptions() , DEFAULT_MINIMUM_SIZE))) {
      minWidth <= 0 && (minWidth = 20);
      minHeight <= 0 && (minHeight = 20);
    }
    adjustedSize.x_0 = max_1(calculatedSize.x_0, minWidth);
    adjustedSize.y_0 = max_1(calculatedSize.y_0, minHeight);
  }
  $resizeGraphNoReallyIMeanIt(lgraph, calculatedSize, adjustedSize);
}

function $resizeGraphNoReallyIMeanIt(lgraph, oldSize, newSize){
  var contentAlignment, extPortSide, insets, node, node$iterator;
  contentAlignment = castTo($getProperty(lgraph, ($clinit_Properties() , CONTENT_ALIGNMENT)), 18);
  newSize.x_0 > oldSize.x_0 && (contentAlignment.contains(($clinit_ContentAlignment() , H_CENTER_0))?(lgraph.offset.x_0 += (newSize.x_0 - oldSize.x_0) / 2):contentAlignment.contains(H_RIGHT_0) && (lgraph.offset.x_0 += newSize.x_0 - oldSize.x_0));
  newSize.y_0 > oldSize.y_0 && (contentAlignment.contains(($clinit_ContentAlignment() , V_CENTER_0))?(lgraph.offset.y_0 += (newSize.y_0 - oldSize.y_0) / 2):contentAlignment.contains(V_BOTTOM_0) && (lgraph.offset.y_0 += newSize.y_0 - oldSize.y_0));
  if (castTo($getProperty(lgraph, ($clinit_InternalProperties() , GRAPH_PROPERTIES)), 18).contains(($clinit_GraphProperties() , EXTERNAL_PORTS)) && (newSize.x_0 > oldSize.x_0 || newSize.y_0 > oldSize.y_0)) {
    for (node$iterator = new ArrayList$1(lgraph.layerlessNodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      if (node.type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
        extPortSide = castTo($getProperty(node, EXT_PORT_SIDE), 32);
        extPortSide == ($clinit_PortSide() , EAST)?(node.pos.x_0 += newSize.x_0 - oldSize.x_0):extPortSide == SOUTH && (node.pos.y_0 += newSize.y_0 - oldSize.y_0);
      }
    }
  }
  insets = lgraph.insets;
  lgraph.size_0.x_0 = newSize.x_0 - insets.left - insets.right;
  lgraph.size_0.y_0 = newSize.y_0 - insets.top_0 - insets.bottom;
}

function KlayLayered(){
  this.graphConfigurator = new GraphConfigurator;
  this.componentsProcessor = new ComponentsProcessor;
  this.compoundGraphPreprocessor = new CompoundGraphPreprocessor;
  this.compoundGraphPostprocessor = new CompoundGraphPostprocessor;
}

defineClass(365, 1, {}, KlayLayered);
var Lde_cau_cs_kieler_klay_layered_KlayLayered_2_classLit = createForClass('de.cau.cs.kieler.klay.layered', 'KlayLayered', 365);
function $clinit_ComponentsToCGraphTransformer(){
  $clinit_ComponentsToCGraphTransformer = emptyMethod;
  SPACING_HANDLER = new ComponentsToCGraphTransformer$1;
}

function $applyLayout(this$static){
  var bottomRight, cNode, cNode$iterator, n, n$iterator, placeholder, placeholder$iterator, topLeft;
  for (n$iterator = new ArrayList$1(this$static.cGraph.cNodes); n$iterator.i < n$iterator.this$01.array.length;) {
    n = castTo($next_8(n$iterator), 25);
    n.applyElementPosition();
  }
  topLeft = new KVector_1($intern_50, $intern_50);
  bottomRight = new KVector_1($intern_51, $intern_51);
  for (cNode$iterator = new ArrayList$1(this$static.cGraph.cNodes); cNode$iterator.i < cNode$iterator.this$01.array.length;) {
    cNode = castTo($next_8(cNode$iterator), 25);
    topLeft.x_0 = min_1(topLeft.x_0, cNode.hitbox.x_0);
    topLeft.y_0 = min_1(topLeft.y_0, cNode.hitbox.y_0);
    bottomRight.x_0 = max_1(bottomRight.x_0, cNode.hitbox.x_0 + cNode.hitbox.width_0);
    bottomRight.y_0 = max_1(bottomRight.y_0, cNode.hitbox.y_0 + cNode.hitbox.height);
  }
  for (placeholder$iterator = $values(this$static.externalPlaceholder).iterator_0(); placeholder$iterator.hasNext_0();) {
    placeholder = castTo(placeholder$iterator.next_1(), 27);
    cNode = castTo(placeholder.second, 25);
    topLeft.x_0 = min_1(topLeft.x_0, cNode.hitbox.x_0);
    topLeft.y_0 = min_1(topLeft.y_0, cNode.hitbox.y_0);
    bottomRight.x_0 = max_1(bottomRight.x_0, cNode.hitbox.x_0 + cNode.hitbox.width_0);
    bottomRight.y_0 = max_1(bottomRight.y_0, cNode.hitbox.y_0 + cNode.hitbox.height);
  }
  this$static.globalOffset = $negate(new KVector_1(topLeft.x_0, topLeft.y_0));
  this$static.graphSize = $sub_0(new KVector_1(bottomRight.x_0, bottomRight.y_0), topLeft);
  this$static.cGraph.cGroups.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
  this$static.cGraph.cNodes.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
}

function $getOffset(this$static, c){
  var cOffset;
  cOffset = $sub_0($clone(castTo($get_9(this$static.oldPosition, c), 10)), $getPosition(castTo($get_9(this$static.offsets, c), 198).rect));
  return cOffset;
}

function $setLock(cNode, portSides){
  portSides.isEmpty() && $set_2(cNode.lock, true, true, true, true);
  portSides.equals(($clinit_PortSide() , SIDES_NORTH)) && $set_2(cNode.lock, true, true, true, false);
  portSides.equals(SIDES_EAST) && $set_2(cNode.lock, false, true, true, true);
  portSides.equals(SIDES_SOUTH) && $set_2(cNode.lock, true, true, false, true);
  portSides.equals(SIDES_WEST) && $set_2(cNode.lock, true, false, true, true);
  portSides.equals(SIDES_NORTH_EAST) && $set_2(cNode.lock, false, true, true, false);
  portSides.equals(SIDES_EAST_SOUTH) && $set_2(cNode.lock, false, true, false, true);
  portSides.equals(SIDES_SOUTH_WEST) && $set_2(cNode.lock, true, false, false, true);
  portSides.equals(SIDES_NORTH_WEST) && $set_2(cNode.lock, true, false, true, false);
  portSides.equals(SIDES_NORTH_SOUTH) && $set_2(cNode.lock, true, true, true, true);
  portSides.equals(SIDES_EAST_WEST) && $set_2(cNode.lock, true, true, true, true);
  portSides.equals(SIDES_NORTH_SOUTH) && $set_2(cNode.lock, true, true, true, true);
  portSides.equals(SIDES_EAST_SOUTH_WEST) && $set_2(cNode.lock, true, true, true, true);
  portSides.equals(SIDES_NORTH_SOUTH_WEST) && $set_2(cNode.lock, true, true, true, true);
  portSides.equals(SIDES_NORTH_EAST_WEST) && $set_2(cNode.lock, true, true, true, true);
  portSides.equals(SIDES_NORTH_EAST_SOUTH_WEST) && $set_2(cNode.lock, true, true, true, true);
}

function $transform_1(this$static, ccs){
  var comp, comp$iterator, dummyGroup, ee, ee$iterator, group, rect, rect$iterator, rectNode, rectPlaceholder;
  this$static.cGraph = new CGraph(allOf(Lde_cau_cs_kieler_kiml_options_Direction_2_classLit));
  for (comp$iterator = new ArrayList$1(ccs.components); comp$iterator.i < comp$iterator.this$01.array.length;) {
    comp = castTo($next_8(comp$iterator), 347);
    group = new CGroup(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_compaction_oned_CNode_2_classLit, 1), $intern_12, 25, 0, []));
    $add_11(this$static.cGraph.cGroups, group);
    for (rect$iterator = new ArrayList$1(comp.rectilinearConvexHull); rect$iterator.i < rect$iterator.this$01.array.length;) {
      rect = castTo($next_8(rect$iterator), 62);
      rectNode = new ComponentsToCGraphTransformer$CRectNode(this$static, rect);
      $setLock(rectNode, castTo($getProperty(comp.graph, ($clinit_InternalProperties() , EXT_PORT_CONNECTIONS)), 18));
      if (!$containsKey_1(this$static.oldPosition, comp)) {
        $put_2(this$static.oldPosition, comp, new KVector_1(rect.x_0, rect.y_0));
        $put_2(this$static.offsets, comp, rectNode);
      }
      $add_11(this$static.cGraph.cNodes, rectNode);
      $addCNode(group, rectNode);
    }
    for (ee$iterator = new ArrayList$1(comp.externalExtensions); ee$iterator.i < ee$iterator.this$01.array.length;) {
      ee = castTo($next_8(ee$iterator), 251);
      rectNode = new ComponentsToCGraphTransformer$CRectNode(this$static, ee.getRepresentor());
      $put_2(this$static.externalExtensions, ee, new Pair(group, rectNode));
      $setLock(rectNode, castTo($getProperty(comp.graph, ($clinit_InternalProperties() , EXT_PORT_CONNECTIONS)), 18));
      if (ee.getPlaceholder()) {
        rectPlaceholder = new ComponentsToCGraphTransformer$CRectNode_0(this$static, ee.getPlaceholder(), 1);
        $setLock(rectPlaceholder, castTo($getProperty(comp.graph, EXT_PORT_CONNECTIONS), 18));
        dummyGroup = new CGroup(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_compaction_oned_CNode_2_classLit, 1), $intern_12, 25, 0, []));
        $addCNode(dummyGroup, rectPlaceholder);
        $put(this$static.externalPlaceholder, ee.getDirection(), new Pair(group, rectPlaceholder));
      }
    }
  }
  return this$static.cGraph;
}

function ComponentsToCGraphTransformer(spacing){
  $clinit_ComponentsToCGraphTransformer();
  this.oldPosition = ($clinit_Maps() , new HashMap);
  this.offsets = new HashMap;
  this.externalExtensions = new HashMap;
  this.externalPlaceholder = new HashMultimap;
  this.spacing = spacing;
}

defineClass(577, 1, {}, ComponentsToCGraphTransformer);
_.spacing = 0;
var SPACING_HANDLER;
var Lde_cau_cs_kieler_klay_layered_compaction_components_ComponentsToCGraphTransformer_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.compaction.components', 'ComponentsToCGraphTransformer', 577);
function $clinit_ISpacingsHandler(){
  $clinit_ISpacingsHandler = emptyMethod;
  DEFAULT_SPACING_HANDLER = new ISpacingsHandler$1;
}

var DEFAULT_SPACING_HANDLER;
function ComponentsToCGraphTransformer$1(){
}

defineClass(578, 1, {}, ComponentsToCGraphTransformer$1);
_.getHorizontalSpacing = function getHorizontalSpacing(cNode1, cNode2){
  return min_1(cNode1.getHorizontalSpacing_0(), cNode2.getHorizontalSpacing_0());
}
;
_.getVerticalSpacing = function getVerticalSpacing(cNode1, cNode2){
  return min_1(cNode1.getVerticalSpacing_0(), cNode2.getVerticalSpacing_0());
}
;
var Lde_cau_cs_kieler_klay_layered_compaction_components_ComponentsToCGraphTransformer$1_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.compaction.components', 'ComponentsToCGraphTransformer/1', 578);
function CNode(){
  this.constraints = new ArrayList;
  this.cGroupOffset = new KVector;
  this.lock = new Quadruplet;
  this.spacingIgnore = new Quadruplet;
}

defineClass(25, 1, {25:1});
_.id_0 = 0;
_.parentNode = null;
_.reposition = true;
_.startPos = $intern_51;
var Lde_cau_cs_kieler_klay_layered_compaction_oned_CNode_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.compaction.oned', 'CNode', 25);
function ComponentsToCGraphTransformer$CRectNode(this$0, rect){
  ComponentsToCGraphTransformer$CRectNode_0.call(this, this$0, rect, null);
}

function ComponentsToCGraphTransformer$CRectNode_0(this$0, rect, spacing){
  this.this$01 = this$0;
  CNode.call(this);
  this.rect = rect;
  this.hitbox = new Rectangle_0(rect.x_0, rect.y_0, rect.width_0, rect.height);
  this.individualSpacing = spacing;
}

defineClass(198, 25, {198:1, 25:1}, ComponentsToCGraphTransformer$CRectNode, ComponentsToCGraphTransformer$CRectNode_0);
_.applyElementPosition = function applyElementPosition(){
  this.rect.x_0 = this.hitbox.x_0;
  this.rect.y_0 = this.hitbox.y_0;
}
;
_.getHorizontalSpacing_0 = function getHorizontalSpacing_0(){
  return this.individualSpacing != null?checkNotNull_1(this.individualSpacing):this.this$01.spacing;
}
;
_.getVerticalSpacing_0 = function getVerticalSpacing_0(){
  return this.individualSpacing != null?checkNotNull_1(this.individualSpacing):this.this$01.spacing;
}
;
_.toString_0 = function toString_46(){
  return '';
}
;
var Lde_cau_cs_kieler_klay_layered_compaction_components_ComponentsToCGraphTransformer$CRectNode_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.compaction.components', 'ComponentsToCGraphTransformer/CRectNode', 198);
function $clinit_OneDimensionalComponentsCompaction(){
  $clinit_OneDimensionalComponentsCompaction = emptyMethod;
  LEFT_RIGHT = newHashSet_1(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_Direction_2_classLit, 1), $intern_13, 59, 0, [($clinit_Direction() , LEFT_0), RIGHT_0]));
  UP_DOWN = newHashSet_1(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_Direction_2_classLit, 1), $intern_13, 59, 0, [UP, DOWN]));
}

function $addExternalEdgeRepresentations(this$static, ees){
  var p, p$iterator;
  for (p$iterator = new ArrayList$1(ees); p$iterator.i < p$iterator.this$01.array.length;) {
    p = castTo($next_8(p$iterator), 27);
    $add_11(this$static.compactionGraph.cNodes, castTo(p.second, 25));
    $addCNode(castTo(p.first, 78), castTo(p.second, 25));
  }
}

function $addPlaceholders(this$static, dir_0){
  var d, d$iterator, dirs, entry, outerIter, pair, pair$iterator;
  dirs = dir_0 == 1?UP_DOWN:LEFT_RIGHT;
  for (d$iterator = (outerIter = (new AbstractMap$1(dirs.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter)); d$iterator.val$outerIter2.hasNext_0();) {
    d = (entry = castTo(d$iterator.val$outerIter2.next_1(), 21) , castTo(entry.getKey(), 59));
    for (pair$iterator = castTo($get(this$static.transformer.externalPlaceholder, d), 18).iterator_0(); pair$iterator.hasNext_0();) {
      pair = castTo(pair$iterator.next_1(), 27);
      $add_11(this$static.compactionGraph.cNodes, castTo(pair.second, 25));
      $add_11(this$static.compactionGraph.cGroups, castTo(pair.second, 25).cGroup);
    }
  }
}

function $compact(this$static){
  var delta, direction, g, g$iterator, g$iterator0, g$iterator1, g$iterator2;
  delta = 0;
  for (g$iterator0 = new ArrayList$1(this$static.compactionGraph.cGroups); g$iterator0.i < g$iterator0.this$01.array.length;) {
    g = castTo($next_8(g$iterator0), 78);
    g.delta = 0;
    g.deltaNormalized = 0;
  }
  $addPlaceholders(this$static, 0);
  $addExternalEdgeRepresentations(this$static, this$static.verticalExternalExtensions);
  $calculateGroupOffsets(this$static.compactor);
  $forceConstraintsRecalculation(this$static.compactor);
  direction = ($clinit_Direction() , LEFT_0);
  $compact_1($applyLockingStrategy($changeDirection($compact_1($applyLockingStrategy($changeDirection($compact_1($changeDirection(this$static.compactor, direction)), $opposite(direction)))), direction)));
  $changeDirection(this$static.compactor, LEFT_0);
  $removeExternalEdgeRepresentations(this$static, this$static.verticalExternalExtensions);
  $removePlaceholders(this$static, 0);
  $updateExternalExtensionDimensions(this$static, 0);
  $updatePlaceholders(this$static, 1);
  $addPlaceholders(this$static, 1);
  $addExternalEdgeRepresentations(this$static, this$static.horizontalExternalExtensions);
  $calculateGroupOffsets(this$static.compactor);
  for (g$iterator1 = new ArrayList$1(this$static.compactionGraph.cGroups); g$iterator1.i < g$iterator1.this$01.array.length;) {
    g = castTo($next_8(g$iterator1), 78);
    delta += abs_0(g.deltaNormalized);
  }
  for (g$iterator2 = new ArrayList$1(this$static.compactionGraph.cGroups); g$iterator2.i < g$iterator2.this$01.array.length;) {
    g = castTo($next_8(g$iterator2), 78);
    g.delta = 0;
    g.deltaNormalized = 0;
  }
  direction = UP;
  $compact_1($applyLockingStrategy($changeDirection($compact_1($applyLockingStrategy($changeDirection($compact_1($forceConstraintsRecalculation($changeDirection(this$static.compactor, direction))), $opposite(direction)))), direction)));
  $changeDirection(this$static.compactor, LEFT_0);
  $removeExternalEdgeRepresentations(this$static, this$static.horizontalExternalExtensions);
  $removePlaceholders(this$static, 1);
  $updateExternalExtensionDimensions(this$static, 1);
  $updatePlaceholders(this$static, 0);
  $forceConstraintsRecalculation(this$static.compactor);
  for (g$iterator = new ArrayList$1(this$static.compactionGraph.cGroups); g$iterator.i < g$iterator.this$01.array.length;) {
    g = castTo($next_8(g$iterator), 78);
    delta += abs_0(g.deltaNormalized);
  }
  return delta;
}

function $compact_0(this$static){
  var allNodes, cNode, cNode$iterator, delta, entry, entry$iterator, run;
  allNodes = new ArrayList;
  this$static.verticalExternalExtensions = new ArrayList;
  this$static.horizontalExternalExtensions = new ArrayList;
  for (entry$iterator = new AbstractHashMap$EntrySetIterator((new AbstractHashMap$EntrySet(this$static.transformer.externalExtensions)).this$01); entry$iterator.hasNext;) {
    entry = $next_6(entry$iterator);
    $add_11(allNodes, castTo(castTo(entry.getValue(), 27).second, 25));
    $isHorizontal(castTo(entry.getKey(), 251).getDirection())?$add_11(this$static.horizontalExternalExtensions, castTo(entry.getValue(), 27)):$add_11(this$static.verticalExternalExtensions, castTo(entry.getValue(), 27));
  }
  $addExternalEdgeRepresentations(this$static, this$static.horizontalExternalExtensions);
  $addExternalEdgeRepresentations(this$static, this$static.verticalExternalExtensions);
  this$static.compactor = new OneDimensionalCompactor(this$static.compactionGraph);
  $setSpacingsHandler(this$static.compactor, ($clinit_ComponentsToCGraphTransformer() , SPACING_HANDLER));
  $removeExternalEdgeRepresentations(this$static, this$static.horizontalExternalExtensions);
  $removeExternalEdgeRepresentations(this$static, this$static.verticalExternalExtensions);
  $addAll_6(allNodes, this$static.compactor.cGraph.cNodes);
  this$static.topLeft = new KVector_1($intern_50, $intern_50);
  this$static.bottomRight = new KVector_1($intern_51, $intern_51);
  for (cNode$iterator = new ArrayList$1(allNodes); cNode$iterator.i < cNode$iterator.this$01.array.length;) {
    cNode = castTo($next_8(cNode$iterator), 25);
    this$static.topLeft.x_0 = min_1(this$static.topLeft.x_0, cNode.hitbox.x_0);
    this$static.topLeft.y_0 = min_1(this$static.topLeft.y_0, cNode.hitbox.y_0);
    this$static.bottomRight.x_0 = max_1(this$static.bottomRight.x_0, cNode.hitbox.x_0 + cNode.hitbox.width_0);
    this$static.bottomRight.y_0 = max_1(this$static.bottomRight.y_0, cNode.hitbox.y_0 + cNode.hitbox.height);
  }
  $setLockingStrategy(this$static.compactor, new OneDimensionalComponentsCompaction$lambda$0$Type);
  run = 0;
  do {
    delta = $compact(this$static);
    ++run;
  }
   while ((run < 2 || delta > $intern_39) && run < 10);
  $setLockingStrategy(this$static.compactor, new OneDimensionalComponentsCompaction$lambda$1$Type);
  $compact(this$static);
  $finish(this$static.compactor);
  $applyLayout(this$static.transformer);
}

function $getOffset_0(this$static, c){
  var individual;
  individual = $getOffset(this$static.transformer, c);
  return $add_7($negate(individual), this$static.transformer.globalOffset);
}

function $removeExternalEdgeRepresentations(this$static, ees){
  var p, p$iterator;
  for (p$iterator = new ArrayList$1(ees); p$iterator.i < p$iterator.this$01.array.length;) {
    p = castTo($next_8(p$iterator), 27);
    $remove_7(this$static.compactionGraph.cNodes, p.second);
    $removeCNode(castTo(p.first, 78), castTo(p.second, 25));
  }
}

function $removePlaceholders(this$static, dir_0){
  var d, d$iterator, dirs, entry, outerIter, pair, pair$iterator;
  dirs = dir_0 == 1?UP_DOWN:LEFT_RIGHT;
  for (d$iterator = (outerIter = (new AbstractMap$1(dirs.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter)); d$iterator.val$outerIter2.hasNext_0();) {
    d = (entry = castTo(d$iterator.val$outerIter2.next_1(), 21) , castTo(entry.getKey(), 59));
    for (pair$iterator = castTo($get(this$static.transformer.externalPlaceholder, d), 18).iterator_0(); pair$iterator.hasNext_0();) {
      pair = castTo(pair$iterator.next_1(), 27);
      $remove_7(this$static.compactionGraph.cNodes, pair.second);
      $remove_7(this$static.compactionGraph.cGroups, castTo(pair.second, 25).cGroup);
    }
  }
}

function $updateExternalExtensionDimensions(this$static, dir_0){
  var adelta, cNode, ee, entry, entry$iterator, group;
  for (entry$iterator = new AbstractHashMap$EntrySetIterator((new AbstractHashMap$EntrySet(this$static.transformer.externalExtensions)).this$01); entry$iterator.hasNext;) {
    entry = $next_6(entry$iterator);
    ee = castTo(entry.getKey(), 251);
    if (dir_0 == 1) {
      if (ee.getDirection() != ($clinit_Direction() , UP) && ee.getDirection() != DOWN) {
        continue;
      }
    }
     else {
      if (ee.getDirection() != ($clinit_Direction() , LEFT_0) && ee.getDirection() != RIGHT_0) {
        continue;
      }
    }
    cNode = castTo(castTo(entry.getValue(), 27).second, 25);
    group = castTo(castTo(entry.getValue(), 27).first, 78);
    adelta = group.deltaNormalized;
    switch (ee.getDirection().ordinal) {
      case 2:
        cNode.hitbox.x_0 = this$static.topLeft.x_0;
        cNode.hitbox.width_0 = max_1(1, cNode.hitbox.width_0 + adelta);
        break;
      case 1:
        cNode.hitbox.x_0 = cNode.hitbox.x_0 + adelta;
        cNode.hitbox.width_0 = max_1(1, cNode.hitbox.width_0 - adelta);
        break;
      case 4:
        cNode.hitbox.y_0 = this$static.topLeft.y_0;
        cNode.hitbox.height = max_1(1, cNode.hitbox.height + adelta);
        break;
      case 3:
        cNode.hitbox.y_0 = cNode.hitbox.y_0 + adelta;
        cNode.hitbox.height = max_1(1, cNode.hitbox.height - adelta);
    }
  }
}

function $updatePlaceholders(this$static, dir_0){
  var adelta, cNode, d, d$iterator, dirs, entry, outerIter, pair, pair$iterator, parentComponentGroup;
  dirs = dir_0 == 1?UP_DOWN:LEFT_RIGHT;
  for (d$iterator = (outerIter = (new AbstractMap$1(dirs.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter)); d$iterator.val$outerIter2.hasNext_0();) {
    d = (entry = castTo(d$iterator.val$outerIter2.next_1(), 21) , castTo(entry.getKey(), 59));
    for (pair$iterator = castTo($get(this$static.transformer.externalPlaceholder, d), 18).iterator_0(); pair$iterator.hasNext_0();) {
      pair = castTo(pair$iterator.next_1(), 27);
      cNode = castTo(pair.second, 25);
      parentComponentGroup = castTo(pair.first, 78);
      adelta = parentComponentGroup.deltaNormalized;
      switch (d.ordinal) {
        case 2:
        case 1:
          cNode.hitbox.y_0 += adelta;
          break;
        case 4:
        case 3:
          cNode.hitbox.x_0 += adelta;
      }
    }
  }
}

function OneDimensionalComponentsCompaction(){
}

defineClass(549, 1, {}, OneDimensionalComponentsCompaction);
var LEFT_RIGHT, UP_DOWN;
var Lde_cau_cs_kieler_klay_layered_compaction_components_OneDimensionalComponentsCompaction_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.compaction.components', 'OneDimensionalComponentsCompaction', 549);
function OneDimensionalComponentsCompaction$lambda$0$Type(){
}

defineClass(550, 1, $intern_35, OneDimensionalComponentsCompaction$lambda$0$Type);
_.apply_0 = function apply_13(arg0){
  return $clinit_OneDimensionalComponentsCompaction() , $clinit_Boolean() , castTo(castTo(arg0, 27).first, 25).cGroup.outDegree != 0?TRUE_0:FALSE_0;
}
;
var Lde_cau_cs_kieler_klay_layered_compaction_components_OneDimensionalComponentsCompaction$lambda$0$Type_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.compaction.components', 'OneDimensionalComponentsCompaction/lambda$0$Type', 550);
function OneDimensionalComponentsCompaction$lambda$1$Type(){
}

defineClass(551, 1, $intern_35, OneDimensionalComponentsCompaction$lambda$1$Type);
_.apply_0 = function apply_14(arg0){
  return $clinit_OneDimensionalComponentsCompaction() , $clinit_Boolean() , $get_7(castTo(castTo(arg0, 27).first, 25).lock, castTo(castTo(arg0, 27).second, 59)) || castTo(castTo(arg0, 27).first, 25).cGroup.outDegree != 0 && $get_7(castTo(castTo(arg0, 27).first, 25).lock, castTo(castTo(arg0, 27).second, 59))?TRUE_0:FALSE_0;
}
;
var Lde_cau_cs_kieler_klay_layered_compaction_components_OneDimensionalComponentsCompaction$lambda$1$Type_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.compaction.components', 'OneDimensionalComponentsCompaction/lambda$1$Type', 551);
function $supports(this$static, direction){
  return $containsEnum(this$static.supportedDirections, direction);
}

function CGraph(supportedDirections){
  this.cNodes = new ArrayList;
  this.cGroups = new ArrayList;
  this.supportedDirections = supportedDirections;
}

defineClass(324, 1, {}, CGraph);
var Lde_cau_cs_kieler_klay_layered_compaction_oned_CGraph_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.compaction.oned', 'CGraph', 324);
function $addCNode(this$static, cNode){
  $add_18(this$static.cNodes, cNode);
  if (cNode.cGroup) {
    throw new RuntimeException_0('CNode belongs to another CGroup.');
  }
  cNode.cGroup = this$static;
}

function $removeCNode(this$static, cNode){
  var removed;
  removed = $remove_17(this$static.cNodes, cNode);
  removed && (cNode.cGroup = null);
  return removed;
}

function CGroup(inputCNodes){
  var cNode, cNode$index, cNode$max;
  this.cNodes = new LinkedHashSet;
  this.incomingConstraints = new HashSet;
  this.outDegree = 0;
  for (cNode$index = 0 , cNode$max = inputCNodes.length; cNode$index < cNode$max; ++cNode$index) {
    cNode = inputCNodes[cNode$index];
    !this.reference && (this.reference = cNode);
    $addCNode(this, cNode);
  }
}

defineClass(78, 1, {78:1}, CGroup);
_.delta = 0;
_.deltaNormalized = 0;
_.id_0 = 0;
_.outDegree = 0;
_.reposition = true;
_.startPos = $intern_51;
var Lde_cau_cs_kieler_klay_layered_compaction_oned_CGroup_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.compaction.oned', 'CGroup', 78);
function eq(d1, d2){
  return $clinit_DoubleMath() , (d1 - d2 > 0?d1 - d2:-(d1 - d2)) <= $intern_39 || d1 == d2 || isNaN(d1) && isNaN(d2);
}

function gt(d1, d2){
  return $clinit_DoubleMath() , $clinit_DoubleMath() , ((d1 - d2 > 0?d1 - d2:-(d1 - d2)) <= $intern_39 || d1 == d2 || isNaN(d1) && isNaN(d2)?0:d1 < d2?-1:d1 > d2?1:compare_2(isNaN(d1), isNaN(d2))) > 0;
}

function lt_0(d1, d2){
  return $clinit_DoubleMath() , $clinit_DoubleMath() , ((d1 - d2 > 0?d1 - d2:-(d1 - d2)) <= $intern_39 || d1 == d2 || isNaN(d1) && isNaN(d2)?0:d1 < d2?-1:d1 > d2?1:compare_2(isNaN(d1), isNaN(d2))) < 0;
}

function ISpacingsHandler$1(){
}

defineClass(470, 1, {}, ISpacingsHandler$1);
_.getHorizontalSpacing = function getHorizontalSpacing_1(cNode1, cNode2){
  return max_1(cNode1.getHorizontalSpacing_0(), cNode2.getHorizontalSpacing_0());
}
;
_.getVerticalSpacing = function getVerticalSpacing_1(cNode1, cNode2){
  return max_1(cNode1.getVerticalSpacing_0(), cNode2.getVerticalSpacing_0());
}
;
var Lde_cau_cs_kieler_klay_layered_compaction_oned_ISpacingsHandler$1_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.compaction.oned', 'ISpacingsHandler/1', 470);
function $clinit_OneDimensionalCompactor(){
  $clinit_OneDimensionalCompactor = emptyMethod;
  LONGEST_PATH_COMPACTION = new LongestPathCompaction;
  SCANLINE_CONSTRAINTS = new ScanlineConstraintCalculator;
  QUADRATIC_CONSTRAINTS = new QuadraticConstraintCalculation;
}

function $applyLockingStrategy(this$static){
  $applyLockingStrategy_0(this$static, this$static.direction);
  return this$static;
}

function $applyLockingStrategy_0(this$static, dir_0){
  var cGroup, cGroup$iterator, cNode, cNode$iterator;
  for (cGroup$iterator = new ArrayList$1(this$static.cGraph.cGroups); cGroup$iterator.i < cGroup$iterator.this$01.array.length;) {
    cGroup = castTo($next_8(cGroup$iterator), 78);
    cGroup.reposition = true;
  }
  for (cNode$iterator = new ArrayList$1(this$static.cGraph.cNodes); cNode$iterator.i < cNode$iterator.this$01.array.length;) {
    cNode = castTo($next_8(cNode$iterator), 25);
    cNode.reposition = unsafeCast(checkNotNull_1(castToBoolean(this$static.lockingStrategy.apply_0(new Pair(cNode, dir_0)))));
    cNode.cGroup.reposition = cNode.cGroup.reposition & unsafeCast(checkNotNull_1(castToBoolean(this$static.lockingStrategy.apply_0(new Pair(cNode, dir_0)))));
  }
  return this$static;
}

function $calculateConstraints(this$static){
  var cNode, cNode$iterator;
  for (cNode$iterator = new ArrayList$1(this$static.cGraph.cNodes); cNode$iterator.i < cNode$iterator.this$01.array.length;) {
    cNode = castTo($next_8(cNode$iterator), 25);
    cNode.constraints.clear_0();
  }
  this$static.constraintAlgorithm.calculateConstraints(this$static);
  $calculateConstraintsForCGroups(this$static);
}

function $calculateConstraintsForCGroups(this$static){
  var cNode, cNode$iterator, entry, group, group$iterator, group$iterator0, inc, inc$iterator, outerIter;
  for (group$iterator0 = new ArrayList$1(this$static.cGraph.cGroups); group$iterator0.i < group$iterator0.this$01.array.length;) {
    group = castTo($next_8(group$iterator0), 78);
    group.outDegree = 0;
    group.incomingConstraints.map_0.clear_0();
  }
  for (group$iterator = new ArrayList$1(this$static.cGraph.cGroups); group$iterator.i < group$iterator.this$01.array.length;) {
    group = castTo($next_8(group$iterator), 78);
    for (cNode$iterator = (outerIter = (new AbstractMap$1(group.cNodes.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter)); cNode$iterator.val$outerIter2.hasNext_0();) {
      cNode = (entry = castTo(cNode$iterator.val$outerIter2.next_1(), 21) , castTo(entry.getKey(), 25));
      for (inc$iterator = cNode.constraints.iterator_0(); inc$iterator.hasNext_0();) {
        inc = castTo(inc$iterator.next_1(), 25);
        if (inc.cGroup != group) {
          $add_18(group.incomingConstraints, inc);
          ++inc.cGroup.outDegree;
        }
      }
    }
  }
}

function $calculateGroupOffsets(this$static){
  var entry, group, group$iterator, n, n$iterator, n$iterator0, outerIter, outerIter0;
  for (group$iterator = new ArrayList$1(this$static.cGraph.cGroups); group$iterator.i < group$iterator.this$01.array.length;) {
    group = castTo($next_8(group$iterator), 78);
    group.reference = null;
    for (n$iterator0 = (outerIter0 = (new AbstractMap$1(group.cNodes.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter0)); n$iterator0.val$outerIter2.hasNext_0();) {
      n = (entry = castTo(n$iterator0.val$outerIter2.next_1(), 21) , castTo(entry.getKey(), 25));
      $reset(n.cGroupOffset);
      (!group.reference || n.hitbox.x_0 < group.reference.hitbox.x_0) && (group.reference = n);
    }
    for (n$iterator = (outerIter = (new AbstractMap$1(group.cNodes.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter)); n$iterator.val$outerIter2.hasNext_0();) {
      n = (entry = castTo(n$iterator.val$outerIter2.next_1(), 21) , castTo(entry.getKey(), 25));
      n.cGroupOffset.x_0 = n.hitbox.x_0 - group.reference.hitbox.x_0;
      n.cGroupOffset.y_0 = n.hitbox.y_0 - group.reference.hitbox.y_0;
    }
  }
  return this$static;
}

function $changeDirection(this$static, dir_0){
  var oldDirection;
  if (this$static.finished) {
    throw new IllegalStateException_0(($ensureNamesAreInitialized(Lde_cau_cs_kieler_klay_layered_compaction_oned_OneDimensionalCompactor_2_classLit) , 'The ' + Lde_cau_cs_kieler_klay_layered_compaction_oned_OneDimensionalCompactor_2_classLit.simpleName + ' instance has been finished already.'));
  }
  if (!$supports(this$static.cGraph, dir_0)) {
    throw new RuntimeException_0('The direction ' + dir_0 + ' is not supported by the CGraph instance.');
  }
  if (dir_0 == this$static.direction) {
    return this$static;
  }
  oldDirection = this$static.direction;
  this$static.direction = dir_0;
  switch (oldDirection.ordinal) {
    case 0:
      switch (dir_0.ordinal) {
        case 2:
          $calculateConstraints(this$static);
          break;
        case 1:
          $mirrorHitboxes(this$static);
          $calculateConstraints(this$static);
          break;
        case 4:
          $transposeHitboxes(this$static);
          $calculateConstraints(this$static);
          break;
        case 3:
          $transposeHitboxes(this$static);
          $mirrorHitboxes(this$static);
          $calculateConstraints(this$static);
      }

      break;
    case 2:
      switch (dir_0.ordinal) {
        case 1:
          $mirrorHitboxes(this$static);
          $reverseConstraints(this$static);
          break;
        case 4:
          $transposeHitboxes(this$static);
          $calculateConstraints(this$static);
          break;
        case 3:
          $transposeHitboxes(this$static);
          $mirrorHitboxes(this$static);
          $calculateConstraints(this$static);
      }

      break;
    case 1:
      switch (dir_0.ordinal) {
        case 2:
          $mirrorHitboxes(this$static);
          $reverseConstraints(this$static);
          break;
        case 4:
          $mirrorHitboxes(this$static);
          $transposeHitboxes(this$static);
          $calculateConstraints(this$static);
          break;
        case 3:
          $mirrorHitboxes(this$static);
          $transposeHitboxes(this$static);
          $mirrorHitboxes(this$static);
          $calculateConstraints(this$static);
      }

      break;
    case 4:
      switch (dir_0.ordinal) {
        case 2:
          $transposeHitboxes(this$static);
          $calculateConstraints(this$static);
          break;
        case 1:
          $transposeHitboxes(this$static);
          $mirrorHitboxes(this$static);
          $calculateConstraints(this$static);
          break;
        case 3:
          $mirrorHitboxes(this$static);
          $reverseConstraints(this$static);
      }

      break;
    case 3:
      switch (dir_0.ordinal) {
        case 2:
          $mirrorHitboxes(this$static);
          $transposeHitboxes(this$static);
          $calculateConstraints(this$static);
          break;
        case 1:
          $mirrorHitboxes(this$static);
          $transposeHitboxes(this$static);
          $mirrorHitboxes(this$static);
          $calculateConstraints(this$static);
          break;
        case 4:
          $mirrorHitboxes(this$static);
          $reverseConstraints(this$static);
      }

  }
  return this$static;
}

function $compact_1(this$static){
  var g, g$iterator, incN, incN$iterator, n, n$iterator, node, node$iterator;
  if (this$static.finished) {
    throw new IllegalStateException_0(($ensureNamesAreInitialized(Lde_cau_cs_kieler_klay_layered_compaction_oned_OneDimensionalCompactor_2_classLit) , 'The ' + Lde_cau_cs_kieler_klay_layered_compaction_oned_OneDimensionalCompactor_2_classLit.simpleName + ' instance has been finished already.'));
  }
  this$static.direction == ($clinit_Direction() , UNDEFINED) && $changeDirection(this$static, LEFT_0);
  for (g$iterator = new ArrayList$1(this$static.cGraph.cGroups); g$iterator.i < g$iterator.this$01.array.length;) {
    g = castTo($next_8(g$iterator), 78);
    g.outDegree = 0;
  }
  for (n$iterator = new ArrayList$1(this$static.cGraph.cNodes); n$iterator.i < n$iterator.this$01.array.length;) {
    n = castTo($next_8(n$iterator), 25);
    n.startPos = $intern_51;
    for (incN$iterator = n.constraints.iterator_0(); incN$iterator.hasNext_0();) {
      incN = castTo(incN$iterator.next_1(), 25);
      ++incN.cGroup.outDegree;
    }
  }
  this$static.compactionAlgorithm.compact(this$static);
  for (node$iterator = new ArrayList$1(this$static.cGraph.cNodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 25);
    node.reposition = true;
  }
  return this$static;
}

function $finish(this$static){
  $changeDirection(this$static, ($clinit_Direction() , LEFT_0));
  this$static.finished = true;
  return this$static;
}

function $forceConstraintsRecalculation(this$static){
  $calculateConstraints(this$static);
  return this$static;
}

function $mirrorHitboxes(this$static){
  var cNode, cNode$iterator;
  for (cNode$iterator = new ArrayList$1(this$static.cGraph.cNodes); cNode$iterator.i < cNode$iterator.this$01.array.length;) {
    cNode = castTo($next_8(cNode$iterator), 25);
    cNode.hitbox.x_0 = -cNode.hitbox.x_0 - cNode.hitbox.width_0;
    !!cNode.parentNode && (cNode.cGroupOffset.x_0 = -cNode.cGroupOffset.x_0 + cNode.parentNode.hitbox.width_0);
  }
  $calculateGroupOffsets(this$static);
}

function $reverseConstraints(this$static){
  var cNode, cNode$iterator, cNode$iterator0, cNode$iterator1, inc, inc$iterator, incMap;
  incMap = ($clinit_Maps() , new HashMap);
  for (cNode$iterator0 = new ArrayList$1(this$static.cGraph.cNodes); cNode$iterator0.i < cNode$iterator0.this$01.array.length;) {
    cNode = castTo($next_8(cNode$iterator0), 25);
    $put_2(incMap, cNode, new ArrayList);
  }
  for (cNode$iterator1 = new ArrayList$1(this$static.cGraph.cNodes); cNode$iterator1.i < cNode$iterator1.this$01.array.length;) {
    cNode = castTo($next_8(cNode$iterator1), 25);
    cNode.startPos = $intern_51;
    for (inc$iterator = cNode.constraints.iterator_0(); inc$iterator.hasNext_0();) {
      inc = castTo(inc$iterator.next_1(), 25);
      castTo(getEntryValueOrNull($getEntry(incMap.hashCodeMap, inc)), 20).add_1(cNode);
    }
  }
  for (cNode$iterator = new ArrayList$1(this$static.cGraph.cNodes); cNode$iterator.i < cNode$iterator.this$01.array.length;) {
    cNode = castTo($next_8(cNode$iterator), 25);
    cNode.constraints.clear_0();
    cNode.constraints = castTo(getEntryValueOrNull($getEntry(incMap.hashCodeMap, cNode)), 20);
  }
  $calculateConstraintsForCGroups(this$static);
}

function $setCompactionAlgorithm(this$static, compactor){
  this$static.compactionAlgorithm = compactor;
  return this$static;
}

function $setConstraintAlgorithm(this$static, theConstraintAlgorithm){
  this$static.constraintAlgorithm = theConstraintAlgorithm;
  return this$static;
}

function $setLockingStrategy(this$static, strategy){
  this$static.lockingStrategy = strategy;
  return this$static;
}

function $setSpacingsHandler(this$static, handler){
  this$static.spacingsHandler = handler;
  return this$static;
}

function $transposeHitboxes(this$static){
  var cNode, cNode$iterator, tmp;
  for (cNode$iterator = new ArrayList$1(this$static.cGraph.cNodes); cNode$iterator.i < cNode$iterator.this$01.array.length;) {
    cNode = castTo($next_8(cNode$iterator), 25);
    tmp = cNode.hitbox.x_0;
    cNode.hitbox.x_0 = cNode.hitbox.y_0;
    cNode.hitbox.y_0 = tmp;
    tmp = cNode.hitbox.width_0;
    cNode.hitbox.width_0 = cNode.hitbox.height;
    cNode.hitbox.height = tmp;
    tmp = cNode.cGroupOffset.x_0;
    cNode.cGroupOffset.x_0 = cNode.cGroupOffset.y_0;
    cNode.cGroupOffset.y_0 = tmp;
  }
  $calculateGroupOffsets(this$static);
}

function OneDimensionalCompactor(cGraph){
  $clinit_OneDimensionalCompactor();
  var group, n, n$iterator;
  this.compactionAlgorithm = LONGEST_PATH_COMPACTION;
  this.constraintAlgorithm = SCANLINE_CONSTRAINTS;
  this.direction = ($clinit_Direction() , UNDEFINED);
  this.spacingsHandler = ($clinit_ISpacingsHandler() , DEFAULT_SPACING_HANDLER);
  this.cGraph = cGraph;
  $setLockingStrategy(this, new OneDimensionalCompactor$lambda$0$Type);
  $calculateGroupOffsets(this);
  for (n$iterator = new ArrayList$1(cGraph.cNodes); n$iterator.i < n$iterator.this$01.array.length;) {
    n = castTo($next_8(n$iterator), 25);
    if (!n.cGroup) {
      group = new CGroup(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_compaction_oned_CNode_2_classLit, 1), $intern_12, 25, 0, [n]));
      $add_11(cGraph.cGroups, group);
    }
  }
}

defineClass(323, 1, {}, OneDimensionalCompactor);
_.finished = false;
var LONGEST_PATH_COMPACTION, QUADRATIC_CONSTRAINTS, SCANLINE_CONSTRAINTS;
var Lde_cau_cs_kieler_klay_layered_compaction_oned_OneDimensionalCompactor_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.compaction.oned', 'OneDimensionalCompactor', 323);
function OneDimensionalCompactor$lambda$0$Type(){
}

defineClass(554, 1, $intern_35, OneDimensionalCompactor$lambda$0$Type);
_.apply_0 = function apply_15(arg0){
  return $clinit_OneDimensionalCompactor() , $clinit_Boolean() , castTo(castTo(arg0, 27).first, 25).cGroup.outDegree != 0?TRUE_0:FALSE_0;
}
;
var Lde_cau_cs_kieler_klay_layered_compaction_oned_OneDimensionalCompactor$lambda$0$Type_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.compaction.oned', 'OneDimensionalCompactor/lambda$0$Type', 554);
function $get_7(this$static, direction){
  switch (direction.ordinal) {
    case 2:
      return this$static.left;
    case 1:
      return this$static.right;
    case 4:
      return this$static.up;
    case 3:
      return this$static.down;
    default:return false;
  }
}

function $set_1(this$static, value_0, direction){
  switch (direction.ordinal) {
    case 2:
      this$static.left = value_0;
      break;
    case 1:
      this$static.right = value_0;
      break;
    case 4:
      this$static.up = value_0;
      break;
    case 3:
      this$static.down = value_0;
  }
}

function $set_2(this$static, l, r, u, d){
  this$static.left = l;
  this$static.right = r;
  this$static.up = u;
  this$static.down = d;
}

function Quadruplet(){
  $set_2(this, false, false, false, false);
}

defineClass(335, 1, {}, Quadruplet);
_.down = false;
_.left = false;
_.right = false;
_.up = false;
var Lde_cau_cs_kieler_klay_layered_compaction_oned_Quadruplet_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.compaction.oned', 'Quadruplet', 335);
function LongestPathCompaction(){
}

defineClass(587, 1, {}, LongestPathCompaction);
_.compact = function compact(compactor){
  var cNode, cNode$iterator, cNode$iterator0, diff, entry, group, group$iterator, incNode, incNode$iterator, minStartPos, node, node$iterator, node$iterator0, outerIter, outerIter0, sinks, spacing, suggestedX;
  minStartPos = $intern_50;
  for (cNode$iterator0 = new ArrayList$1(compactor.cGraph.cNodes); cNode$iterator0.i < cNode$iterator0.this$01.array.length;) {
    cNode = castTo($next_8(cNode$iterator0), 25);
    minStartPos = min_1(minStartPos, cNode.cGroup.reference.hitbox.x_0 + cNode.cGroupOffset.x_0);
  }
  sinks = new LinkedList;
  for (group$iterator = new ArrayList$1(compactor.cGraph.cGroups); group$iterator.i < group$iterator.this$01.array.length;) {
    group = castTo($next_8(group$iterator), 78);
    group.startPos = minStartPos;
    group.outDegree == 0 && ($addNode_0(sinks, group, sinks.tail.prev, sinks.tail) , true);
  }
  while (sinks.size_0 != 0) {
    group = castTo(sinks.size_0 == 0?null:(checkCriticalElement(sinks.size_0 != 0) , $removeNode_0(sinks, sinks.header.next_0)), 78);
    diff = group.reference.hitbox.x_0;
    for (node$iterator0 = (outerIter0 = (new AbstractMap$1(group.cNodes.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter0)); node$iterator0.val$outerIter2.hasNext_0();) {
      node = (entry = castTo(node$iterator0.val$outerIter2.next_1(), 21) , castTo(entry.getKey(), 25));
      suggestedX = group.startPos + node.cGroupOffset.x_0;
      node.cGroup.reposition || node.hitbox.x_0 < suggestedX?(node.startPos = suggestedX):(node.startPos = node.hitbox.x_0);
    }
    diff -= group.reference.startPos;
    group.delta += diff;
    compactor.direction == ($clinit_Direction() , RIGHT_0) || compactor.direction == DOWN?(group.deltaNormalized += diff):(group.deltaNormalized -= diff);
    for (node$iterator = (outerIter = (new AbstractMap$1(group.cNodes.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter)); node$iterator.val$outerIter2.hasNext_0();) {
      node = (entry = castTo(node$iterator.val$outerIter2.next_1(), 21) , castTo(entry.getKey(), 25));
      for (incNode$iterator = node.constraints.iterator_0(); incNode$iterator.hasNext_0();) {
        incNode = castTo(incNode$iterator.next_1(), 25);
        $isHorizontal(compactor.direction)?(spacing = compactor.spacingsHandler.getHorizontalSpacing(node, incNode)):(spacing = compactor.spacingsHandler.getVerticalSpacing(node, incNode));
        incNode.cGroup.startPos = max_1(incNode.cGroup.startPos, node.startPos + node.hitbox.width_0 + spacing - incNode.cGroupOffset.x_0);
        incNode.reposition || (incNode.cGroup.startPos = max_1(incNode.cGroup.startPos, incNode.hitbox.x_0 - incNode.cGroupOffset.x_0));
        --incNode.cGroup.outDegree;
        incNode.cGroup.outDegree == 0 && $add_8(sinks, incNode.cGroup);
      }
    }
  }
  for (cNode$iterator = new ArrayList$1(compactor.cGraph.cNodes); cNode$iterator.i < cNode$iterator.this$01.array.length;) {
    cNode = castTo($next_8(cNode$iterator), 25);
    cNode.hitbox.x_0 = cNode.startPos;
  }
}
;
var Lde_cau_cs_kieler_klay_layered_compaction_oned_algs_LongestPathCompaction_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.compaction.oned.algs', 'LongestPathCompaction', 587);
function QuadraticConstraintCalculation(){
}

defineClass(588, 1, {}, QuadraticConstraintCalculation);
_.calculateConstraints = function calculateConstraints(compactor){
  var cNode, cNode$iterator, cNode1, cNode1$iterator, cNode2, cNode2$iterator, spacing;
  for (cNode$iterator = new ArrayList$1(compactor.cGraph.cNodes); cNode$iterator.i < cNode$iterator.this$01.array.length;) {
    cNode = castTo($next_8(cNode$iterator), 25);
    cNode.constraints.clear_0();
  }
  for (cNode1$iterator = new ArrayList$1(compactor.cGraph.cNodes); cNode1$iterator.i < cNode1$iterator.this$01.array.length;) {
    cNode1 = castTo($next_8(cNode1$iterator), 25);
    for (cNode2$iterator = new ArrayList$1(compactor.cGraph.cNodes); cNode2$iterator.i < cNode2$iterator.this$01.array.length;) {
      cNode2 = castTo($next_8(cNode2$iterator), 25);
      if (cNode1 == cNode2) {
        continue;
      }
      if (!!cNode1.cGroup && cNode1.cGroup == cNode2.cGroup) {
        continue;
      }
      $isHorizontal(compactor.direction)?(spacing = compactor.spacingsHandler.getVerticalSpacing(cNode1, cNode2)):(spacing = compactor.spacingsHandler.getHorizontalSpacing(cNode1, cNode2));
      cNode1 != cNode2.parentNode && (cNode2.hitbox.x_0 > cNode1.hitbox.x_0 || cNode1.hitbox.x_0 == cNode2.hitbox.x_0 && cNode1.hitbox.width_0 < cNode2.hitbox.width_0) && gt(cNode2.hitbox.y_0 + cNode2.hitbox.height + spacing, cNode1.hitbox.y_0) && lt_0(cNode2.hitbox.y_0, cNode1.hitbox.y_0 + cNode1.hitbox.height + spacing) && cNode1.constraints.add_1(cNode2);
    }
  }
}
;
var Lde_cau_cs_kieler_klay_layered_compaction_oned_algs_QuadraticConstraintCalculation_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.compaction.oned.algs', 'QuadraticConstraintCalculation', 588);
function $blowUpHitboxes(this$static, filter, spacingFun){
  var n, n$iterator, spacing;
  for (n$iterator = new ArrayList$1(this$static.compactor.cGraph.cNodes); n$iterator.i < n$iterator.this$01.array.length;) {
    n = castTo($next_8(n$iterator), 25);
    if (!filter.apply_1(n)) {
      continue;
    }
    spacing = checkNotNull_1(castToDouble(spacingFun.apply_0(n)));
    if (spacing > 0) {
      !($isHorizontal(this$static.compactor.direction) && n.spacingIgnore.up) && !($isVertical(this$static.compactor.direction) && n.spacingIgnore.left) && (n.hitbox.y_0 -= 0 > spacing / 2 - 0.5?0:spacing / 2 - 0.5);
      !($isHorizontal(this$static.compactor.direction) && n.spacingIgnore.down) && !($isVertical(this$static.compactor.direction) && n.spacingIgnore.right) && (n.hitbox.height += 0 > spacing - 1?0:spacing - 1);
    }
  }
}

function $normalizeHitboxes(this$static, filter, spacingFun){
  var n, n$iterator, spacing;
  for (n$iterator = new ArrayList$1(this$static.compactor.cGraph.cNodes); n$iterator.i < n$iterator.this$01.array.length;) {
    n = castTo($next_8(n$iterator), 25);
    if (!filter.apply_1(n)) {
      continue;
    }
    spacing = checkNotNull_1(castToDouble(spacingFun.apply_0(n)));
    if (spacing > 0) {
      !($isHorizontal(this$static.compactor.direction) && n.spacingIgnore.up) && !($isVertical(this$static.compactor.direction) && n.spacingIgnore.left) && (n.hitbox.y_0 += 0 > spacing / 2 - 0.5?0:spacing / 2 - 0.5);
      !($isHorizontal(this$static.compactor.direction) && n.spacingIgnore.down) && !($isVertical(this$static.compactor.direction) && n.spacingIgnore.right) && (n.hitbox.height -= spacing - 1);
    }
  }
}

function $sweep(this$static, filterFun, spacingFun){
  var n, n$iterator, points;
  $blowUpHitboxes(this$static, filterFun, spacingFun);
  points = new ArrayList;
  for (n$iterator = new ArrayList$1(this$static.compactor.cGraph.cNodes); n$iterator.i < n$iterator.this$01.array.length;) {
    n = castTo($next_8(n$iterator), 25);
    if (filterFun.apply_1(n)) {
      $add_11(points, new ScanlineConstraintCalculator$Timestamp(n, true));
      $add_11(points, new ScanlineConstraintCalculator$Timestamp(n, false));
    }
  }
  $reset_1(this$static.constraintsScanlineHandler);
  execute(points, this$static.constraintsScanlineComparator, new Arrays$ArrayList(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_compaction_recthull_Scanline$EventHandler_2_classLit, 1), $intern_12, 160, 0, [this$static.constraintsScanlineHandler])));
  $normalizeHitboxes(this$static, filterFun, spacingFun);
}

function ScanlineConstraintCalculator(){
  this.constraintsScanlineComparator = new ScanlineConstraintCalculator$lambda$0$Type;
  this.constraintsScanlineHandler = new ScanlineConstraintCalculator$ConstraintsScanlineHandler(this);
}

function lambda$0(p1_0, p2_1){
  var cmp, y1, y2;
  y1 = p1_0.node.hitbox.y_0;
  p1_0.low || (y1 += p1_0.node.hitbox.height);
  y2 = p2_1.node.hitbox.y_0;
  p2_1.low || (y2 += p2_1.node.hitbox.height);
  cmp = compare_31(y1, y2);
  if (cmp == 0) {
    if (!p1_0.low && p2_1.low) {
      return -1;
    }
     else if (!p2_1.low && p1_0.low) {
      return 1;
    }
  }
  return cmp;
}

defineClass(317, 1, {}, ScanlineConstraintCalculator);
_.calculateConstraints = function calculateConstraints_0(theCompactor){
  this.compactor = theCompactor;
  $sweep(this, new ScanlineConstraintCalculator$lambda$1$Type, new ScanlineConstraintCalculator$lambda$2$Type);
}
;
var Lde_cau_cs_kieler_klay_layered_compaction_oned_algs_ScanlineConstraintCalculator_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.compaction.oned.algs', 'ScanlineConstraintCalculator', 317);
var Lde_cau_cs_kieler_klay_layered_compaction_recthull_Scanline$EventHandler_2_classLit = createForInterface('de.cau.cs.kieler.klay.layered.compaction.recthull', 'Scanline/EventHandler');
function $handle(this$static, p){
  var right, left, right_0;
  p.low?($add_20(this$static.intervals, p.node) , this$static.cand[p.node.id_0] = castTo($lower(this$static.intervals, p.node), 25) , right = castTo($higher(this$static.intervals, p.node), 25) , !!right && (this$static.cand[right.id_0] = p.node) , undefined):(left = castTo($lower(this$static.intervals, p.node), 25) , !!left && left == this$static.cand[p.node.id_0] && !!left.cGroup && left.cGroup != p.node.cGroup && left.constraints.add_1(p.node) , right_0 = castTo($higher(this$static.intervals, p.node), 25) , !!right_0 && this$static.cand[right_0.id_0] == p.node && !!right_0.cGroup && right_0.cGroup != p.node.cGroup && p.node.constraints.add_1(right_0) , $remove_25(this$static.intervals, p.node) , undefined);
}

function $reset_1(this$static){
  var index_0, n, n$iterator;
  $clear_7(this$static.intervals.map_0);
  this$static.cand = initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_compaction_oned_CNode_2_classLit, $intern_12, 25, this$static.this$01.compactor.cGraph.cNodes.array.length, 0, 1);
  index_0 = 0;
  for (n$iterator = new ArrayList$1(this$static.this$01.compactor.cGraph.cNodes); n$iterator.i < n$iterator.this$01.array.length;) {
    n = castTo($next_8(n$iterator), 25);
    n.id_0 = index_0++;
  }
}

function ScanlineConstraintCalculator$ConstraintsScanlineHandler(this$0){
  this.this$01 = this$0;
  this.intervals = new TreeSet_0(castTo(checkNotNull(new ScanlineConstraintCalculator$ConstraintsScanlineHandler$lambda$0$Type), 56));
}

defineClass(464, 1, {160:1}, ScanlineConstraintCalculator$ConstraintsScanlineHandler);
_.handle = function handle(p){
  $handle(this, castTo(p, 235));
}
;
var Lde_cau_cs_kieler_klay_layered_compaction_oned_algs_ScanlineConstraintCalculator$ConstraintsScanlineHandler_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.compaction.oned.algs', 'ScanlineConstraintCalculator/ConstraintsScanlineHandler', 464);
function ScanlineConstraintCalculator$ConstraintsScanlineHandler$lambda$0$Type(){
}

defineClass(465, 1, $intern_9, ScanlineConstraintCalculator$ConstraintsScanlineHandler$lambda$0$Type);
_.compare_0 = function compare_6(arg0, arg1){
  return compare_31((castTo(arg0, 25).hitbox.x_0 + castTo(arg0, 25).hitbox.width_0) / 2, (castTo(arg1, 25).hitbox.x_0 + castTo(arg1, 25).hitbox.width_0) / 2);
}
;
var Lde_cau_cs_kieler_klay_layered_compaction_oned_algs_ScanlineConstraintCalculator$ConstraintsScanlineHandler$lambda$0$Type_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.compaction.oned.algs', 'ScanlineConstraintCalculator/ConstraintsScanlineHandler/lambda$0$Type', 465);
function ScanlineConstraintCalculator$Timestamp(node, low){
  this.node = node;
  this.low = low;
}

defineClass(235, 1, {235:1}, ScanlineConstraintCalculator$Timestamp);
_.low = false;
var Lde_cau_cs_kieler_klay_layered_compaction_oned_algs_ScanlineConstraintCalculator$Timestamp_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.compaction.oned.algs', 'ScanlineConstraintCalculator/Timestamp', 235);
function ScanlineConstraintCalculator$lambda$0$Type(){
}

defineClass(466, 1, $intern_9, ScanlineConstraintCalculator$lambda$0$Type);
_.compare_0 = function compare_7(arg0, arg1){
  return lambda$0(arg0, arg1);
}
;
var Lde_cau_cs_kieler_klay_layered_compaction_oned_algs_ScanlineConstraintCalculator$lambda$0$Type_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.compaction.oned.algs', 'ScanlineConstraintCalculator/lambda$0$Type', 466);
function ScanlineConstraintCalculator$lambda$1$Type(){
}

defineClass(467, 1, $intern_52, ScanlineConstraintCalculator$lambda$1$Type);
_.apply_1 = function apply_16(arg0){
  return true;
}
;
var Lde_cau_cs_kieler_klay_layered_compaction_oned_algs_ScanlineConstraintCalculator$lambda$1$Type_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.compaction.oned.algs', 'ScanlineConstraintCalculator/lambda$1$Type', 467);
function ScanlineConstraintCalculator$lambda$2$Type(){
}

defineClass(468, 1, $intern_35, ScanlineConstraintCalculator$lambda$2$Type);
_.apply_0 = function apply_17(arg0){
  return 0;
}
;
var Lde_cau_cs_kieler_klay_layered_compaction_oned_algs_ScanlineConstraintCalculator$lambda$2$Type_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.compaction.oned.algs', 'ScanlineConstraintCalculator/lambda$2$Type', 468);
function Point(x_0, y_0){
  this.x_0 = x_0;
  this.y_0 = y_0;
}

function Point_0(x_0, y_0, quadrant){
  Point.call(this, x_0, y_0);
  this.quadrant = quadrant;
}

defineClass(48, 1, {48:1}, Point, Point_0);
_.equals = function equals_34(obj){
  var p2;
  if (obj == null) {
    return false;
  }
  if (Lde_cau_cs_kieler_klay_layered_compaction_recthull_Point_2_classLit != getClass__Ljava_lang_Class___devirtual$(obj)) {
    return false;
  }
  p2 = castTo(obj, 48);
  return equals_50(this.x_0, p2.x_0) && equals_50(this.y_0, p2.y_0);
}
;
_.hashCode_0 = function hashCode_34(){
  return hashCode_44(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [this.x_0, this.y_0]));
}
;
_.toString_0 = function toString_47(){
  return '(' + this.x_0 + ', ' + this.y_0 + (this.convex?'cx':'') + this.quadrant + ')';
}
;
_.convex = true;
_.x_0 = 0;
_.y_0 = 0;
var Lde_cau_cs_kieler_klay_layered_compaction_recthull_Point_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.compaction.recthull', 'Point', 48);
function $clinit_Point$Quadrant(){
  $clinit_Point$Quadrant = emptyMethod;
  Q1 = new Point$Quadrant('Q1', 0);
  Q4 = new Point$Quadrant('Q4', 1);
  Q2 = new Point$Quadrant('Q2', 2);
  Q3 = new Point$Quadrant('Q3', 3);
}

function $isLeft(this$static){
  return this$static == Q1 || this$static == Q4;
}

function $isUpper(this$static){
  return this$static == Q1 || this$static == Q2;
}

function Point$Quadrant(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function isBothLeftOrBothRight(q1, q2){
  $clinit_Point$Quadrant();
  return q1 == Q1 && q2 == Q4 || q1 == Q4 && q2 == Q1 || q1 == Q3 && q2 == Q2 || q1 == Q2 && q2 == Q3;
}

function isOneLeftOneRight(q1, q2){
  $clinit_Point$Quadrant();
  return q1 == Q1 && q2 == Q2 || q1 == Q1 && q2 == Q3 || q1 == Q4 && q2 == Q3 || q1 == Q4 && q2 == Q2;
}

function values_29(){
  $clinit_Point$Quadrant();
  return stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_compaction_recthull_Point$Quadrant_2_classLit, 1), $intern_13, 201, 0, [Q1, Q4, Q2, Q3]);
}

defineClass(201, 17, {201:1, 3:1, 23:1, 17:1}, Point$Quadrant);
var Q1, Q2, Q3, Q4;
var Lde_cau_cs_kieler_klay_layered_compaction_recthull_Point$Quadrant_2_classLit = createForEnum('de.cau.cs.kieler.klay.layered.compaction.recthull', 'Point/Quadrant', 201, Ljava_lang_Enum_2_classLit, values_29);
function $clinit_RectilinearConvexHull(){
  $clinit_RectilinearConvexHull = emptyMethod;
  RIGHT_HIGH_FIRST = new RectilinearConvexHull$lambda$0$Type;
  RIGHT_LOW_FIRST = new RectilinearConvexHull$lambda$1$Type;
  LEFT_HIGH_FIRST = new RectilinearConvexHull$lambda$2$Type;
  LEFT_LOW_FIRST = new RectilinearConvexHull$lambda$3$Type;
  RIGHT_SPECIAL_ORDER = new RectilinearConvexHull$lambda$4$Type;
}

function $splitIntoRectangles(this$static){
  var handler;
  handler = new RectilinearConvexHull$RectangleEventHandler(this$static);
  execute(this$static.hull, RIGHT_SPECIAL_ORDER, new Arrays$ArrayList(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_compaction_recthull_Scanline$EventHandler_2_classLit, 1), $intern_12, 160, 0, [handler])));
  !!handler.queued && $add_11(handler.rects, handler.queued);
  return handler.rects;
}

function RectilinearConvexHull(){
  this.hull = new ArrayList;
}

function addConcaveCorners(pts, q){
  var last, next, p, pIt;
  pIt = new AbstractList$ListIteratorImpl(pts, 0);
  last = (checkCriticalElement(pIt.i < pIt.this$01_0.size_1()) , castTo(pIt.this$01_0.get_2(pIt.last = pIt.i++), 48));
  while (pIt.i < pIt.this$01_0.size_1()) {
    next = (checkCriticalElement(pIt.i < pIt.this$01_0.size_1()) , castTo(pIt.this$01_0.get_2(pIt.last = pIt.i++), 48));
    p = new Point_0(next.x_0, last.y_0, q);
    checkCriticalElement(pIt.i > 0);
    pIt.this$01.get_2(pIt.last = --pIt.i);
    $add_15(pIt, p);
    checkCriticalElement(pIt.i < pIt.this$01_0.size_1());
    pIt.this$01_0.get_2(pIt.last = pIt.i++);
    p.convex = false;
    last = next;
  }
}

function lambda$4(p1_0, p2_1){
  $clinit_RectilinearConvexHull();
  var val;
  if (p1_0.x_0 == p2_1.x_0) {
    if (p1_0.quadrant == p2_1.quadrant || isBothLeftOrBothRight(p1_0.quadrant, p2_1.quadrant)) {
      val = $isLeft(p1_0.quadrant)?1:-1;
      if (p1_0.convex && !p2_1.convex) {
        return val;
      }
       else if (!p1_0.convex && p2_1.convex) {
        return -val;
      }
    }
    return compare_32(p1_0.quadrant.ordinal, p2_1.quadrant.ordinal);
  }
   else {
    return compare_31(p1_0.x_0, p2_1.x_0);
  }
}

function of_1(points){
  $clinit_RectilinearConvexHull();
  var p, p$iterator, q1, q2, q3, q4, rch;
  rch = new RectilinearConvexHull;
  for (p$iterator = new ArrayList$1(points); p$iterator.i < p$iterator.this$01.array.length;) {
    p = castTo($next_8(p$iterator), 48);
    (!rch.xMax1 || p.x_0 >= rch.xMax1.x_0) && (rch.xMax1 = p);
    if (!rch.xMin1 || p.x_0 <= rch.xMin1.x_0) {
      rch.xMin2 = rch.xMin1;
      rch.xMin1 = p;
    }
    (!rch.yMax1 || p.y_0 >= rch.yMax1.y_0) && (rch.yMax1 = p);
    (!rch.yMin1 || p.y_0 <= rch.yMin1.y_0) && (rch.yMin1 = p);
  }
  q1 = new RectilinearConvexHull$MaximalElementsEventHandler(($clinit_Point$Quadrant() , Q1));
  execute(points, RIGHT_LOW_FIRST, new Arrays$ArrayList(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_compaction_recthull_Scanline$EventHandler_2_classLit, 1), $intern_12, 160, 0, [q1])));
  q4 = new RectilinearConvexHull$MaximalElementsEventHandler(Q4);
  execute(points, RIGHT_HIGH_FIRST, new Arrays$ArrayList(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_compaction_recthull_Scanline$EventHandler_2_classLit, 1), $intern_12, 160, 0, [q4])));
  q2 = new RectilinearConvexHull$MaximalElementsEventHandler(Q2);
  execute(points, LEFT_LOW_FIRST, new Arrays$ArrayList(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_compaction_recthull_Scanline$EventHandler_2_classLit, 1), $intern_12, 160, 0, [q2])));
  q3 = new RectilinearConvexHull$MaximalElementsEventHandler(Q3);
  execute(points, LEFT_HIGH_FIRST, new Arrays$ArrayList(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_compaction_recthull_Scanline$EventHandler_2_classLit, 1), $intern_12, 160, 0, [q3])));
  addConcaveCorners(q1.points, Q1);
  addConcaveCorners(q2.points, Q2);
  addConcaveCorners(q3.points, Q3);
  addConcaveCorners(q4.points, Q4);
  rch.hull.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
  $addAll_6(rch.hull, q1.points);
  $addAll_6(rch.hull, reverse_0(q2.points));
  $addAll_6(rch.hull, q3.points);
  $addAll_6(rch.hull, reverse_0(q4.points));
  return rch;
}

defineClass(569, 1, {}, RectilinearConvexHull);
_.xMax1 = null;
_.xMin1 = null;
_.xMin2 = null;
_.yMax1 = null;
_.yMin1 = null;
var LEFT_HIGH_FIRST, LEFT_LOW_FIRST, RIGHT_HIGH_FIRST, RIGHT_LOW_FIRST, RIGHT_SPECIAL_ORDER;
var Lde_cau_cs_kieler_klay_layered_compaction_recthull_RectilinearConvexHull_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.compaction.recthull', 'RectilinearConvexHull', 569);
function $clinit_RectilinearConvexHull$MaximalElementsEventHandler(){
  $clinit_RectilinearConvexHull$MaximalElementsEventHandler = emptyMethod;
  DBL_CMP = new RectilinearConvexHull$MaximalElementsEventHandler$lambda$0$Type;
}

function $handle_0(this$static, p){
  if (this$static.compare.compare_0(p.y_0, this$static.maximalY) > 0) {
    $add_11(this$static.points, new Point_0(p.x_0, p.y_0, this$static.quadrant));
    this$static.maximalY = p.y_0;
  }
}

function RectilinearConvexHull$MaximalElementsEventHandler(quadrant){
  $clinit_RectilinearConvexHull$MaximalElementsEventHandler();
  this.points = new ArrayList;
  this.quadrant = quadrant;
  switch (quadrant.ordinal) {
    case 0:
    case 2:
      this.compare = reverseOrder(DBL_CMP);
      this.maximalY = $intern_50;
      break;
    case 3:
    case 1:
      this.compare = DBL_CMP;
      this.maximalY = $intern_51;
  }
}

defineClass(243, 1, {160:1}, RectilinearConvexHull$MaximalElementsEventHandler);
_.handle = function handle_0(p){
  $handle_0(this, castTo(p, 48));
}
;
_.maximalY = 0;
var DBL_CMP;
var Lde_cau_cs_kieler_klay_layered_compaction_recthull_RectilinearConvexHull$MaximalElementsEventHandler_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.compaction.recthull', 'RectilinearConvexHull/MaximalElementsEventHandler', 243);
function $compare_1(arg0, arg1){
  return $clinit_RectilinearConvexHull$MaximalElementsEventHandler() , compare_31(checkNotNull_1(castToDouble(arg0)), checkNotNull_1(castToDouble(arg1)));
}

function RectilinearConvexHull$MaximalElementsEventHandler$lambda$0$Type(){
}

defineClass(571, 1, $intern_9, RectilinearConvexHull$MaximalElementsEventHandler$lambda$0$Type);
_.compare_0 = function compare_8(arg0, arg1){
  return $compare_1(arg0, arg1);
}
;
var Lde_cau_cs_kieler_klay_layered_compaction_recthull_RectilinearConvexHull$MaximalElementsEventHandler$lambda$0$Type_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.compaction.recthull', 'RectilinearConvexHull/MaximalElementsEventHandler/lambda$0$Type', 571);
function $handle_1(this$static, p){
  var r;
  if (!!this$static.queued && (p.x_0 != this$static.queuedPnt.x_0 || isOneLeftOneRight(this$static.queuedPnt.quadrant, p.quadrant))) {
    $add_11(this$static.rects, this$static.queued);
    this$static.lastX = this$static.queued.x_0 + this$static.queued.width_0;
    this$static.queued = null;
    this$static.queuedPnt = null;
  }
  $isUpper(p.quadrant)?(this$static.minY = p):(this$static.maxY = p);
  if (p.quadrant == ($clinit_Point$Quadrant() , Q1) && !p.convex || p.quadrant == Q2 && p.convex || p.quadrant == Q3 && p.convex || p.quadrant == Q4 && !p.convex) {
    if (!!this$static.minY && !!this$static.maxY) {
      r = new Rectangle_0(this$static.lastX, this$static.minY.y_0, p.x_0 - this$static.lastX, this$static.maxY.y_0 - this$static.minY.y_0);
      this$static.queued = r;
      this$static.queuedPnt = p;
    }
  }
}

function RectilinearConvexHull$RectangleEventHandler(this$0){
  this.this$01 = this$0;
  this.rects = new ArrayList;
  this.lastX = min_1(this.this$01.xMin1.x_0, this.this$01.xMin2.x_0);
}

defineClass(570, 1, {160:1}, RectilinearConvexHull$RectangleEventHandler);
_.handle = function handle_1(p){
  $handle_1(this, castTo(p, 48));
}
;
_.lastX = 0;
_.maxY = null;
_.minY = null;
_.queued = null;
_.queuedPnt = null;
var Lde_cau_cs_kieler_klay_layered_compaction_recthull_RectilinearConvexHull$RectangleEventHandler_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.compaction.recthull', 'RectilinearConvexHull/RectangleEventHandler', 570);
function RectilinearConvexHull$lambda$0$Type(){
}

defineClass(572, 1, $intern_9, RectilinearConvexHull$lambda$0$Type);
_.compare_0 = function compare_9(arg0, arg1){
  return $clinit_RectilinearConvexHull() , castTo(arg0, 48).x_0 == castTo(arg1, 48).x_0?compare_31(castTo(arg1, 48).y_0, castTo(arg0, 48).y_0):compare_31(castTo(arg0, 48).x_0, castTo(arg1, 48).x_0);
}
;
var Lde_cau_cs_kieler_klay_layered_compaction_recthull_RectilinearConvexHull$lambda$0$Type_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.compaction.recthull', 'RectilinearConvexHull/lambda$0$Type', 572);
function RectilinearConvexHull$lambda$1$Type(){
}

defineClass(573, 1, $intern_9, RectilinearConvexHull$lambda$1$Type);
_.compare_0 = function compare_10(arg0, arg1){
  return $clinit_RectilinearConvexHull() , castTo(arg0, 48).x_0 == castTo(arg1, 48).x_0?compare_31(castTo(arg0, 48).y_0, castTo(arg1, 48).y_0):compare_31(castTo(arg0, 48).x_0, castTo(arg1, 48).x_0);
}
;
var Lde_cau_cs_kieler_klay_layered_compaction_recthull_RectilinearConvexHull$lambda$1$Type_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.compaction.recthull', 'RectilinearConvexHull/lambda$1$Type', 573);
function RectilinearConvexHull$lambda$2$Type(){
}

defineClass(574, 1, $intern_9, RectilinearConvexHull$lambda$2$Type);
_.compare_0 = function compare_11(arg0, arg1){
  return $clinit_RectilinearConvexHull() , castTo(arg0, 48).x_0 == castTo(arg1, 48).x_0?compare_31(castTo(arg1, 48).y_0, castTo(arg0, 48).y_0):compare_31(castTo(arg1, 48).x_0, castTo(arg0, 48).x_0);
}
;
var Lde_cau_cs_kieler_klay_layered_compaction_recthull_RectilinearConvexHull$lambda$2$Type_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.compaction.recthull', 'RectilinearConvexHull/lambda$2$Type', 574);
function RectilinearConvexHull$lambda$3$Type(){
}

defineClass(575, 1, $intern_9, RectilinearConvexHull$lambda$3$Type);
_.compare_0 = function compare_12(arg0, arg1){
  return $clinit_RectilinearConvexHull() , castTo(arg0, 48).x_0 == castTo(arg1, 48).x_0?compare_31(castTo(arg0, 48).y_0, castTo(arg1, 48).y_0):compare_31(castTo(arg1, 48).x_0, castTo(arg0, 48).x_0);
}
;
var Lde_cau_cs_kieler_klay_layered_compaction_recthull_RectilinearConvexHull$lambda$3$Type_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.compaction.recthull', 'RectilinearConvexHull/lambda$3$Type', 575);
function RectilinearConvexHull$lambda$4$Type(){
}

defineClass(576, 1, $intern_9, RectilinearConvexHull$lambda$4$Type);
_.compare_0 = function compare_13(arg0, arg1){
  return lambda$4(arg0, arg1);
}
;
var Lde_cau_cs_kieler_klay_layered_compaction_recthull_RectilinearConvexHull$lambda$4$Type_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.compaction.recthull', 'RectilinearConvexHull/lambda$4$Type', 576);
function $go(this$static){
  var h, h$iterator, p, p$iterator;
  sort_1(this$static.points, this$static.comparator);
  for (p$iterator = new ArrayList$1(this$static.points); p$iterator.i < p$iterator.this$01.array.length;) {
    p = $next_8(p$iterator);
    for (h$iterator = new ArrayList$1(this$static.eventHandlers); h$iterator.i < h$iterator.this$01.array.length;) {
      h = castTo($next_8(h$iterator), 160);
      h.handle(p);
    }
  }
}

function Scanline(points, comparator, eventHandlers){
  this.comparator = comparator;
  this.points = points;
  this.eventHandlers = (checkNotNull(eventHandlers) , new ArrayList_1(($clinit_Collections2() , eventHandlers)));
}

function execute(points, comparator, eventHandlers){
  var copy;
  copy = (checkNotNull(points) , new ArrayList_1(($clinit_Collections2() , points)));
  $go(new Scanline(copy, comparator, eventHandlers));
}

defineClass(469, 1, {}, Scanline);
var Lde_cau_cs_kieler_klay_layered_compaction_recthull_Scanline_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.compaction.recthull', 'Scanline', 469);
function $moveGraph(destGraph, sourceGraph, offsetx, offsety){
  var edge, edge$iterator, graphOffset, junctionPoints, label_0, label$iterator, node, node$iterator, port, port$iterator;
  graphOffset = $add_6(sourceGraph.offset, offsetx, offsety);
  for (node$iterator = new ArrayList$1(sourceGraph.layerlessNodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 9);
    $add_7(node.pos, graphOffset);
    for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_8(port$iterator), 7);
      for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
        edge = castTo($next_8(edge$iterator), 12);
        $offset(edge.bendPoints, graphOffset);
        junctionPoints = castTo($getProperty(edge, ($clinit_LayoutOptions() , JUNCTION_POINTS)), 44);
        !!junctionPoints && $offset(junctionPoints, graphOffset);
        for (label$iterator = new ArrayList$1(edge.labels); label$iterator.i < label$iterator.this$01.array.length;) {
          label_0 = castTo($next_8(label$iterator), 33);
          $add_7(label_0.pos, graphOffset);
        }
      }
    }
    $add_11(destGraph.layerlessNodes, node);
    node.graph = destGraph;
  }
}

function $moveGraphs(destGraph, sourceGraphs){
  var sourceGraph, sourceGraph$iterator;
  for (sourceGraph$iterator = sourceGraphs.iterator_0(); sourceGraph$iterator.hasNext_0();) {
    sourceGraph = castTo(sourceGraph$iterator.next_1(), 55);
    $moveGraph(destGraph, sourceGraph, 0, 0);
  }
}

function $offsetGraph(graph, offsetx, offsety){
  var edge, edge$iterator, graphOffset, junctionPoints, label_0, label$iterator, node, node$iterator, port, port$iterator;
  graphOffset = new KVector_1(offsetx, offsety);
  for (node$iterator = new ArrayList$1(graph.layerlessNodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 9);
    $add_7(node.pos, graphOffset);
    for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_8(port$iterator), 7);
      for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
        edge = castTo($next_8(edge$iterator), 12);
        $offset(edge.bendPoints, graphOffset);
        junctionPoints = castTo($getProperty(edge, ($clinit_LayoutOptions() , JUNCTION_POINTS)), 44);
        !!junctionPoints && $offset(junctionPoints, graphOffset);
        for (label$iterator = new ArrayList$1(edge.labels); label$iterator.i < label$iterator.this$01.array.length;) {
          label_0 = castTo($next_8(label$iterator), 33);
          $add_7(label_0.pos, graphOffset);
        }
      }
    }
  }
}

function $offsetGraphs(graphs, offsetx, offsety){
  var graph, graph$iterator;
  for (graph$iterator = graphs.iterator_0(); graph$iterator.hasNext_0();) {
    graph = castTo(graph$iterator.next_1(), 55);
    $offsetGraph(graph, offsetx, offsety);
  }
}

defineClass(661, 1, {});
var Lde_cau_cs_kieler_klay_layered_components_AbstractGraphPlacer_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.components', 'AbstractGraphPlacer', 661);
function $clinit_ComponentGroup(){
  $clinit_ComponentGroup = emptyMethod;
  CONSTRAINTS = new HashMultimap;
  $put(CONSTRAINTS, ($clinit_PortSide() , SIDES_NONE), SIDES_NORTH_EAST_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_WEST, SIDES_NORTH_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_WEST, SIDES_NORTH_EAST_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_EAST, SIDES_NORTH_EAST_SOUTH);
  $put(CONSTRAINTS, SIDES_EAST, SIDES_NORTH_EAST_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_NORTH, SIDES_NORTH_EAST_WEST);
  $put(CONSTRAINTS, SIDES_NORTH, SIDES_NORTH_EAST_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_SOUTH, SIDES_EAST_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_SOUTH, SIDES_NORTH_EAST_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_SOUTH, SIDES_EAST_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_SOUTH, SIDES_NORTH_EAST_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_SOUTH, SIDES_EAST_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_SOUTH, SIDES_NORTH_EAST_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_EAST_WEST, SIDES_NORTH_SOUTH);
  $put(CONSTRAINTS, SIDES_EAST_WEST, SIDES_NORTH_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_EAST_WEST, SIDES_NORTH_EAST_SOUTH);
  $put(CONSTRAINTS, SIDES_EAST_WEST, SIDES_NORTH_EAST_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_WEST, SIDES_NORTH_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_WEST, SIDES_NORTH_EAST_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_WEST, SIDES_NORTH_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_EAST, SIDES_NORTH_EAST);
  $put(CONSTRAINTS, SIDES_NORTH_EAST, SIDES_NORTH_EAST_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_EAST, SIDES_NORTH_EAST_SOUTH);
  $put(CONSTRAINTS, SIDES_SOUTH_WEST, SIDES_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_SOUTH_WEST, SIDES_EAST_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_SOUTH_WEST, SIDES_NORTH_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_EAST_SOUTH, SIDES_EAST_SOUTH);
  $put(CONSTRAINTS, SIDES_EAST_SOUTH, SIDES_EAST_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_EAST_SOUTH, SIDES_NORTH_EAST_SOUTH);
  $put(CONSTRAINTS, SIDES_NORTH_EAST_WEST, SIDES_NORTH);
  $put(CONSTRAINTS, SIDES_NORTH_EAST_WEST, SIDES_NORTH_SOUTH);
  $put(CONSTRAINTS, SIDES_NORTH_EAST_WEST, SIDES_NORTH_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_EAST_WEST, SIDES_NORTH_EAST);
  $put(CONSTRAINTS, SIDES_NORTH_EAST_WEST, SIDES_NORTH_EAST_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_EAST_WEST, SIDES_NORTH_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_EAST_WEST, SIDES_NORTH_EAST_SOUTH);
  $put(CONSTRAINTS, SIDES_NORTH_EAST_WEST, SIDES_NORTH_EAST_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_EAST_SOUTH_WEST, SIDES_SOUTH);
  $put(CONSTRAINTS, SIDES_EAST_SOUTH_WEST, SIDES_NORTH_SOUTH);
  $put(CONSTRAINTS, SIDES_EAST_SOUTH_WEST, SIDES_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_EAST_SOUTH_WEST, SIDES_EAST_SOUTH);
  $put(CONSTRAINTS, SIDES_EAST_SOUTH_WEST, SIDES_EAST_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_EAST_SOUTH_WEST, SIDES_NORTH_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_EAST_SOUTH_WEST, SIDES_NORTH_EAST_SOUTH);
  $put(CONSTRAINTS, SIDES_EAST_SOUTH_WEST, SIDES_NORTH_EAST_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_SOUTH_WEST, SIDES_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_SOUTH_WEST, SIDES_EAST_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_SOUTH_WEST, SIDES_NORTH_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_SOUTH_WEST, SIDES_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_SOUTH_WEST, SIDES_NORTH_EAST_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_SOUTH_WEST, SIDES_EAST_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_SOUTH_WEST, SIDES_NORTH_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_SOUTH_WEST, SIDES_NORTH_EAST_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_EAST_SOUTH, SIDES_EAST);
  $put(CONSTRAINTS, SIDES_NORTH_EAST_SOUTH, SIDES_EAST_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_EAST_SOUTH, SIDES_NORTH_EAST);
  $put(CONSTRAINTS, SIDES_NORTH_EAST_SOUTH, SIDES_EAST_SOUTH);
  $put(CONSTRAINTS, SIDES_NORTH_EAST_SOUTH, SIDES_NORTH_EAST_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_EAST_SOUTH, SIDES_EAST_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_EAST_SOUTH, SIDES_NORTH_EAST_SOUTH);
  $put(CONSTRAINTS, SIDES_NORTH_EAST_SOUTH, SIDES_NORTH_EAST_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_EAST_SOUTH_WEST, SIDES_NONE);
  $put(CONSTRAINTS, SIDES_NORTH_EAST_SOUTH_WEST, SIDES_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_EAST_SOUTH_WEST, SIDES_EAST);
  $put(CONSTRAINTS, SIDES_NORTH_EAST_SOUTH_WEST, SIDES_NORTH);
  $put(CONSTRAINTS, SIDES_NORTH_EAST_SOUTH_WEST, SIDES_SOUTH);
  $put(CONSTRAINTS, SIDES_NORTH_EAST_SOUTH_WEST, SIDES_NORTH_SOUTH);
  $put(CONSTRAINTS, SIDES_NORTH_EAST_SOUTH_WEST, SIDES_EAST_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_EAST_SOUTH_WEST, SIDES_NORTH_EAST_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_EAST_SOUTH_WEST, SIDES_EAST_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_EAST_SOUTH_WEST, SIDES_NORTH_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_EAST_SOUTH_WEST, SIDES_NORTH_EAST_SOUTH);
  $put(CONSTRAINTS, SIDES_NORTH_EAST_SOUTH_WEST, SIDES_NORTH_EAST_SOUTH_WEST);
}

function $add_9(this$static, component){
  if ($canAdd(this$static, component)) {
    $put(this$static.components, castTo($getProperty(component, ($clinit_InternalProperties() , EXT_PORT_CONNECTIONS)), 18), component);
    return true;
  }
   else {
    return false;
  }
}

function $canAdd(this$static, component){
  var candidateSides, constraint, constraint$iterator, constraints;
  candidateSides = castTo($getProperty(component, ($clinit_InternalProperties() , EXT_PORT_CONNECTIONS)), 18);
  constraints = castTo($get(CONSTRAINTS, candidateSides), 18);
  for (constraint$iterator = constraints.iterator_0(); constraint$iterator.hasNext_0();) {
    constraint = castTo(constraint$iterator.next_1(), 18);
    if (!castTo($get(this$static.components, constraint), 20).isEmpty()) {
      return false;
    }
  }
  return true;
}

function $getComponents(this$static, connections){
  return castTo($get(this$static.components, connections), 20);
}

function ComponentGroup(component){
  $clinit_ComponentGroup();
  this.components = new ArrayListMultimap;
  $add_9(this, component);
}

defineClass(222, 1, {222:1}, ComponentGroup);
var CONSTRAINTS;
var Lde_cau_cs_kieler_klay_layered_components_ComponentGroup_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.components', 'ComponentGroup', 222);
function $addComponent(this$static, component){
  var group, group$iterator;
  for (group$iterator = new ArrayList$1(this$static.componentGroups); group$iterator.i < group$iterator.this$01.array.length;) {
    group = castTo($next_8(group$iterator), 222);
    if ($add_9(group, component)) {
      return;
    }
  }
  $add_11(this$static.componentGroups, new ComponentGroup(component));
}

function $placeComponents(group, spacing){
  var colLeftWidth, colMidWidth, colNsWidth, colRightWidth, componentSize, rowBottomHeight, rowMidHeight, rowTopHeight, rowWeHeight, sizeC, sizeE, sizeENS, sizeN, sizeNE, sizeNESW, sizeNS, sizeNW, sizeNWE, sizeS, sizeSE, sizeSW, sizeSWE, sizeW, sizeWE, sizeWNS;
  sizeC = $placeComponentsInRows($getComponents(group, ($clinit_PortSide() , SIDES_NONE)), spacing);
  sizeN = $placeComponentsHorizontally($getComponents(group, SIDES_NORTH), spacing);
  sizeS = $placeComponentsHorizontally($getComponents(group, SIDES_SOUTH), spacing);
  sizeW = $placeComponentsVertically($getComponents(group, SIDES_WEST), spacing);
  sizeE = $placeComponentsVertically($getComponents(group, SIDES_EAST), spacing);
  sizeNW = $placeComponentsHorizontally($getComponents(group, SIDES_NORTH_WEST), spacing);
  sizeNE = $placeComponentsHorizontally($getComponents(group, SIDES_NORTH_EAST), spacing);
  sizeSW = $placeComponentsHorizontally($getComponents(group, SIDES_SOUTH_WEST), spacing);
  sizeSE = $placeComponentsHorizontally($getComponents(group, SIDES_EAST_SOUTH), spacing);
  sizeWE = $placeComponentsVertically($getComponents(group, SIDES_EAST_WEST), spacing);
  sizeNS = $placeComponentsHorizontally($getComponents(group, SIDES_NORTH_SOUTH), spacing);
  sizeNWE = $placeComponentsHorizontally($getComponents(group, SIDES_NORTH_EAST_WEST), spacing);
  sizeSWE = $placeComponentsHorizontally($getComponents(group, SIDES_EAST_SOUTH_WEST), spacing);
  sizeWNS = $placeComponentsVertically($getComponents(group, SIDES_NORTH_SOUTH_WEST), spacing);
  sizeENS = $placeComponentsVertically($getComponents(group, SIDES_NORTH_EAST_SOUTH), spacing);
  sizeNESW = $placeComponentsHorizontally($getComponents(group, SIDES_NORTH_EAST_SOUTH_WEST), spacing);
  colLeftWidth = maxd(stampJavaTypeInfo(getClassLiteralForArray(D_classLit, 1), $intern_11, 26, 12, [sizeNW.x_0, sizeW.x_0, sizeSW.x_0, sizeWNS.x_0]));
  colMidWidth = maxd(stampJavaTypeInfo(getClassLiteralForArray(D_classLit, 1), $intern_11, 26, 12, [sizeN.x_0, sizeC.x_0, sizeS.x_0, sizeNESW.x_0]));
  colNsWidth = sizeNS.x_0;
  colRightWidth = maxd(stampJavaTypeInfo(getClassLiteralForArray(D_classLit, 1), $intern_11, 26, 12, [sizeNE.x_0, sizeE.x_0, sizeSE.x_0, sizeENS.x_0]));
  rowTopHeight = maxd(stampJavaTypeInfo(getClassLiteralForArray(D_classLit, 1), $intern_11, 26, 12, [sizeNW.y_0, sizeN.y_0, sizeNE.y_0, sizeNWE.y_0]));
  rowMidHeight = maxd(stampJavaTypeInfo(getClassLiteralForArray(D_classLit, 1), $intern_11, 26, 12, [sizeW.y_0, sizeC.y_0, sizeE.y_0, sizeNESW.y_0]));
  rowWeHeight = sizeWE.y_0;
  rowBottomHeight = maxd(stampJavaTypeInfo(getClassLiteralForArray(D_classLit, 1), $intern_11, 26, 12, [sizeSW.y_0, sizeS.y_0, sizeSE.y_0, sizeSWE.y_0]));
  $offsetGraphs($getComponents(group, SIDES_NONE), colLeftWidth + colNsWidth, rowTopHeight + rowWeHeight);
  $offsetGraphs($getComponents(group, SIDES_NORTH_EAST_SOUTH_WEST), colLeftWidth + colNsWidth, rowTopHeight + rowWeHeight);
  $offsetGraphs($getComponents(group, SIDES_NORTH), colLeftWidth + colNsWidth, 0);
  $offsetGraphs($getComponents(group, SIDES_SOUTH), colLeftWidth + colNsWidth, rowTopHeight + rowWeHeight + rowMidHeight);
  $offsetGraphs($getComponents(group, SIDES_WEST), 0, rowTopHeight + rowWeHeight);
  $offsetGraphs($getComponents(group, SIDES_EAST), colLeftWidth + colNsWidth + colMidWidth, rowTopHeight + rowWeHeight);
  $offsetGraphs($getComponents(group, SIDES_NORTH_EAST), colLeftWidth + colNsWidth + colMidWidth, 0);
  $offsetGraphs($getComponents(group, SIDES_SOUTH_WEST), 0, rowTopHeight + rowWeHeight + rowMidHeight);
  $offsetGraphs($getComponents(group, SIDES_EAST_SOUTH), colLeftWidth + colNsWidth + colMidWidth, rowTopHeight + rowWeHeight + rowMidHeight);
  $offsetGraphs($getComponents(group, SIDES_EAST_WEST), 0, rowTopHeight);
  $offsetGraphs($getComponents(group, SIDES_NORTH_SOUTH), colLeftWidth, 0);
  $offsetGraphs($getComponents(group, SIDES_EAST_SOUTH_WEST), 0, rowTopHeight + rowWeHeight + rowMidHeight);
  $offsetGraphs($getComponents(group, SIDES_NORTH_EAST_SOUTH), colLeftWidth + colNsWidth + colMidWidth, 0);
  componentSize = new KVector;
  componentSize.x_0 = maxd(stampJavaTypeInfo(getClassLiteralForArray(D_classLit, 1), $intern_11, 26, 12, [colLeftWidth + colMidWidth + colNsWidth + colRightWidth, sizeWE.x_0, sizeNWE.x_0, sizeSWE.x_0]));
  componentSize.y_0 = maxd(stampJavaTypeInfo(getClassLiteralForArray(D_classLit, 1), $intern_11, 26, 12, [rowTopHeight + rowMidHeight + rowWeHeight + rowBottomHeight, sizeNS.y_0, sizeWNS.y_0, sizeENS.y_0]));
  return componentSize;
}

function $placeComponentsHorizontally(components, spacing){
  var component, component$iterator, size_0;
  size_0 = new KVector;
  for (component$iterator = components.iterator_0(); component$iterator.hasNext_0();) {
    component = castTo(component$iterator.next_1(), 55);
    $offsetGraph(component, size_0.x_0, 0);
    size_0.x_0 += component.size_0.x_0 + spacing;
    size_0.y_0 = max_1(size_0.y_0, component.size_0.y_0);
  }
  size_0.y_0 > 0 && (size_0.y_0 += spacing);
  return size_0;
}

function $placeComponentsInRows(components, spacing){
  var broadestRow, component, component$iterator, componentSize, graph, graph$iterator, highestBox, maxRowWidth, size_0, totalArea, xpos, ypos;
  if (components.isEmpty()) {
    return new KVector;
  }
  maxRowWidth = 0;
  totalArea = 0;
  for (component$iterator = components.iterator_0(); component$iterator.hasNext_0();) {
    component = castTo(component$iterator.next_1(), 55);
    componentSize = component.size_0;
    maxRowWidth = max_1(maxRowWidth, componentSize.x_0);
    totalArea += componentSize.x_0 * componentSize.y_0;
  }
  maxRowWidth = max_1(maxRowWidth, Math.sqrt(totalArea) * castTo($getProperty(castTo(components.iterator_0().next_1(), 55), ($clinit_InternalProperties() , ASPECT_RATIO_0)), 15).value_0);
  xpos = 0;
  ypos = 0;
  highestBox = 0;
  broadestRow = spacing;
  for (graph$iterator = components.iterator_0(); graph$iterator.hasNext_0();) {
    graph = castTo(graph$iterator.next_1(), 55);
    size_0 = graph.size_0;
    if (xpos + size_0.x_0 > maxRowWidth) {
      xpos = 0;
      ypos += highestBox + spacing;
      highestBox = 0;
    }
    $offsetGraph(graph, xpos, ypos);
    broadestRow = max_1(broadestRow, xpos + size_0.x_0);
    highestBox = max_1(highestBox, size_0.y_0);
    xpos += size_0.x_0 + spacing;
  }
  return new KVector_1(broadestRow + spacing, ypos + highestBox + spacing);
}

function $placeComponentsVertically(components, spacing){
  var component, component$iterator, size_0;
  size_0 = new KVector;
  for (component$iterator = components.iterator_0(); component$iterator.hasNext_0();) {
    component = castTo(component$iterator.next_1(), 55);
    $offsetGraph(component, 0, size_0.y_0);
    size_0.y_0 += component.size_0.y_0 + spacing;
    size_0.x_0 = max_1(size_0.x_0, component.size_0.x_0);
  }
  size_0.x_0 > 0 && (size_0.x_0 += spacing);
  return size_0;
}

function ComponentGroupGraphPlacer(){
  this.componentGroups = new ArrayList;
}

defineClass(434, 661, {}, ComponentGroupGraphPlacer);
_.combine = function combine(components, target){
  var compactor, component, component$iterator, firstComponent, group, group$iterator, group$iterator0, groupSize, h, h$iterator, h$iterator0, offset, spacing;
  this.componentGroups.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
  target.layerlessNodes.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
  if (components.isEmpty()) {
    target.size_0.x_0 = 0;
    target.size_0.y_0 = 0;
    return;
  }
  firstComponent = castTo(components.get_2(0), 55);
  $copyProperties(target, firstComponent);
  for (component$iterator = components.iterator_0(); component$iterator.hasNext_0();) {
    component = castTo(component$iterator.next_1(), 55);
    $addComponent(this, component);
  }
  offset = new KVector;
  spacing = 2 * castTo($getProperty(firstComponent, ($clinit_InternalProperties() , SPACING_0)), 15).value_0;
  for (group$iterator0 = new ArrayList$1(this.componentGroups); group$iterator0.i < group$iterator0.this$01.array.length;) {
    group = castTo($next_8(group$iterator0), 222);
    groupSize = $placeComponents(group, spacing);
    $offsetGraphs($values(group.components), offset.x_0, offset.y_0);
    offset.x_0 += groupSize.x_0;
    offset.y_0 += groupSize.y_0;
  }
  target.size_0.x_0 = offset.x_0 - spacing;
  target.size_0.y_0 = offset.y_0 - spacing;
  if (unsafeCast(checkNotNull_1(castToBoolean($getProperty(firstComponent, ($clinit_Properties() , COMPACT_COMPONENTS))))) && maskUndefined($getProperty(firstComponent, ($clinit_LayoutOptions() , EDGE_ROUTING))) === maskUndefined(($clinit_EdgeRouting() , ORTHOGONAL))) {
    for (h$iterator0 = components.iterator_0(); h$iterator0.hasNext_0();) {
      h = castTo(h$iterator0.next_1(), 55);
      $offsetGraph(h, h.offset.x_0, h.offset.y_0);
    }
    compactor = new ComponentsCompactor;
    $compact_2(compactor, components, spacing);
    for (h$iterator = components.iterator_0(); h$iterator.hasNext_0();) {
      h = castTo(h$iterator.next_1(), 55);
      $add_7($reset(h.offset), compactor.yetAnotherOffset);
    }
    $add_7($reset(target.size_0), compactor.compactedGraphSize);
  }
  for (group$iterator = new ArrayList$1(this.componentGroups); group$iterator.i < group$iterator.this$01.array.length;) {
    group = castTo($next_8(group$iterator), 222);
    $moveGraphs(target, $values(group.components));
  }
}
;
var Lde_cau_cs_kieler_klay_layered_components_ComponentGroupGraphPlacer_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.components', 'ComponentGroupGraphPlacer', 434);
function $addLGraphElementBounds(pts, element, offset){
  var margins;
  margins = null;
  !!element && (margins = element.margin);
  $add_13(pts, new Point(element.pos.x_0 - margins.left + offset.x_0, element.pos.y_0 - margins.top_0 + offset.y_0));
  $add_13(pts, new Point(element.pos.x_0 - margins.left + offset.x_0, element.pos.y_0 + element.size_0.y_0 + margins.bottom + offset.y_0));
  $add_13(pts, new Point(element.pos.x_0 + element.size_0.x_0 + margins.right + offset.x_0, element.pos.y_0 - margins.top_0 + offset.y_0));
  $add_13(pts, new Point(element.pos.x_0 + element.size_0.x_0 + margins.right + offset.x_0, element.pos.y_0 + element.size_0.y_0 + margins.bottom + offset.y_0));
}

function $compact_2(this$static, graphs, spacing){
  var c, cc, cc$iterator, cc$iterator0, ccs, e, e$iterator, graph, graph$iterator, graph$iterator0, last, lastArg, n, n$iterator, newPos, node, node$iterator, offset, v, v$iterator, vc, compaction;
  this$static.graphTopLeft = new KVector_1($intern_50, $intern_50);
  this$static.graphBottomRight = new KVector_1($intern_51, $intern_51);
  for (graph$iterator0 = graphs.iterator_0(); graph$iterator0.hasNext_0();) {
    graph = castTo(graph$iterator0.next_1(), 55);
    for (node$iterator = new ArrayList$1(graph.layerlessNodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      this$static.graphTopLeft.x_0 = min_1(this$static.graphTopLeft.x_0, node.pos.x_0 - node.margin.left);
      this$static.graphTopLeft.y_0 = min_1(this$static.graphTopLeft.y_0, node.pos.y_0 - node.margin.top_0);
      this$static.graphBottomRight.x_0 = max_1(this$static.graphBottomRight.x_0, node.pos.x_0 + node.size_0.x_0 + node.margin.right);
      this$static.graphBottomRight.y_0 = max_1(this$static.graphBottomRight.y_0, node.pos.y_0 + node.size_0.y_0 + node.margin.bottom);
    }
  }
  ccs = new ComponentsCompactor$InternalConnectedComponents;
  for (graph$iterator = graphs.iterator_0(); graph$iterator.hasNext_0();) {
    graph = castTo(graph$iterator.next_1(), 55);
    c = $transformLGraph(this$static, graph);
    $add_11(ccs.components, c);
    c.containsRegularNodes = c.containsRegularNodes | !castTo($getProperty(c.graph, ($clinit_InternalProperties() , EXT_PORT_CONNECTIONS)), 18).isEmpty();
  }
  this$static.compactor = ($clinit_OneDimensionalComponentsCompaction() , compaction = new OneDimensionalComponentsCompaction , compaction.transformer = new ComponentsToCGraphTransformer(spacing) , compaction.compactionGraph = $transform_1(compaction.transformer, ccs) , compaction);
  $compact_0((lastArg = this$static.compactor , new BasicProgressMonitor , lastArg));
  this$static.yetAnotherOffset = new KVector;
  this$static.compactedGraphSize = this$static.compactor.transformer.graphSize;
  for (cc$iterator0 = new ArrayList$1(ccs.components); cc$iterator0.i < cc$iterator0.this$01.array.length;) {
    cc = castTo($next_8(cc$iterator0), 347);
    offset = $getOffset_0(this$static.compactor, cc);
    offsetGraph(cc.graph, offset.x_0, offset.y_0);
    for (n$iterator = new ArrayList$1(cc.graph.layerlessNodes); n$iterator.i < n$iterator.this$01.array.length;) {
      n = castTo($next_8(n$iterator), 9);
      if (n.type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
        newPos = $getExternalPortPosition(this$static, n.pos, castTo($getProperty(n, ($clinit_InternalProperties() , EXT_PORT_SIDE)), 32));
        $add_7($reset(n.pos), newPos);
      }
    }
  }
  for (cc$iterator = new ArrayList$1(ccs.components); cc$iterator.i < cc$iterator.this$01.array.length;) {
    cc = castTo($next_8(cc$iterator), 347);
    for (e$iterator = new ArrayList$1($getExternalEdges(cc)); e$iterator.i < e$iterator.this$01.array.length;) {
      e = castTo($next_8(e$iterator), 12);
      vc = new KVectorChain_0(e.bendPoints);
      $add_2(vc, 0, $getAbsoluteAnchor(e.source));
      $add_8(vc, $getAbsoluteAnchor(e.target));
      last = null;
      for (v$iterator = $listIterator_2(vc, 0); v$iterator.currentNode != v$iterator.this$01.tail;) {
        v = castTo($next_11(v$iterator), 10);
        if (!last) {
          last = v;
          continue;
        }
        if (fuzzyEquals(last.x_0, v.x_0)) {
          this$static.yetAnotherOffset.x_0 = min_1(this$static.yetAnotherOffset.x_0, last.x_0);
          this$static.compactedGraphSize.x_0 = max_1(this$static.compactedGraphSize.x_0, last.x_0);
        }
         else if (fuzzyEquals(last.y_0, v.y_0)) {
          this$static.yetAnotherOffset.y_0 = min_1(this$static.yetAnotherOffset.y_0, last.y_0);
          this$static.compactedGraphSize.y_0 = max_1(this$static.compactedGraphSize.y_0, last.y_0);
        }
        last = v;
      }
    }
  }
  $negate(this$static.yetAnotherOffset);
  $add_7(this$static.compactedGraphSize, this$static.yetAnotherOffset);
}

function $componentHullPoints(graph){
  var bp, bp$iterator, edge, edge$iterator, n, n$iterator, pts;
  pts = new ComponentsCompactor$Hullpoints;
  for (n$iterator = new ArrayList$1(graph.layerlessNodes); n$iterator.i < n$iterator.this$01.array.length;) {
    n = castTo($next_8(n$iterator), 9);
    if (n.type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
      continue;
    }
    $addLGraphElementBounds(pts, n, new KVector);
    for (edge$iterator = $iterator($getOutgoingEdges_0(n)); $hasNext_0(edge$iterator);) {
      edge = castTo($next_2(edge$iterator), 12);
      if (edge.source.owner.type_0 == EXTERNAL_PORT || edge.target.owner.type_0 == EXTERNAL_PORT) {
        continue;
      }
      for (bp$iterator = $listIterator_2(edge.bendPoints, 0); bp$iterator.currentNode != bp$iterator.this$01.tail;) {
        bp = castTo($next_11(bp$iterator), 10);
        $add_13(pts, new Point(bp.x_0, bp.y_0));
      }
    }
  }
  return pts;
}

function $createDummyNode(graph){
  var dummy, dummyEdge, dummyPort, extPortDummy, extPortDummyPort;
  extPortDummy = castTo($get_8(graph.layerlessNodes, 0), 9);
  dummy = new LNode(graph);
  $add_11(graph.layerlessNodes, dummy);
  dummy.size_0.x_0 = max_1(1, extPortDummy.size_0.x_0);
  dummy.size_0.y_0 = max_1(1, extPortDummy.size_0.y_0);
  dummy.pos.x_0 = extPortDummy.pos.x_0;
  dummy.pos.y_0 = extPortDummy.pos.y_0;
  switch (castTo($getProperty(extPortDummy, ($clinit_InternalProperties() , EXT_PORT_SIDE)), 32).ordinal) {
    case 4:
      dummy.pos.x_0 += 2;
      break;
    case 1:
      dummy.pos.y_0 += 2;
      break;
    case 2:
      dummy.pos.x_0 -= 2;
      break;
    case 3:
      dummy.pos.y_0 -= 2;
  }
  dummyPort = new LPort;
  $setNode(dummyPort, dummy);
  dummyEdge = new LEdge;
  extPortDummyPort = castTo($get_8(extPortDummy.ports, 0), 7);
  $setSource(dummyEdge, extPortDummyPort);
  $setTarget(dummyEdge, dummyPort);
  $add_7($reset(dummyPort.pos), extPortDummyPort.pos);
  $add_7($reset(dummyPort.anchor), extPortDummyPort.anchor);
  return dummy;
}

function $edgeToSegments(this$static, edge, externalExtension){
  var externalPort, externalPortSide, i, outerSegmentIsFirst, p1, p2, points, segment, segments;
  externalPort = externalExtension.externalPort;
  externalPortSide = externalExtension.externalPortSide;
  p1 = $getAbsoluteAnchor(edge.source);
  p2 = $getAbsoluteAnchor(edge.target);
  if (externalPort == edge.source) {
    p1 = $getExternalPortPosition(this$static, p1, externalPortSide);
    p2 = $getPortPositionOnMargin(edge.target);
  }
   else {
    p1 = $getPortPositionOnMargin(edge.source);
    p2 = $getExternalPortPosition(this$static, p2, externalPortSide);
  }
  points = new KVectorChain_0(edge.bendPoints);
  $addNode_0(points, p1, points.header, points.header.next_0);
  $addNode_0(points, p2, points.tail.prev, points.tail);
  outerSegmentIsFirst = edge.source == externalPort;
  segments = new ComponentsCompactor$Segments;
  for (i = 0; i < points.size_0 - 1; ++i) {
    segment = new Pair(castTo($get_4(points, i), 10), castTo($get_4(points, i + 1), 10));
    outerSegmentIsFirst && i == 0 || !outerSegmentIsFirst && i == points.size_0 - 2?(segments.outerSegment = segment):$add_11(segments.innerSegments, segment);
  }
  return segments;
}

function $getExternalPortPosition(this$static, pos, ps){
  switch (ps.ordinal) {
    case 1:
      return new KVector_1(pos.x_0, min_1(this$static.graphTopLeft.y_0, pos.y_0));
    case 2:
      return new KVector_1(max_1(this$static.graphBottomRight.x_0, pos.x_0), pos.y_0);
    case 3:
      return new KVector_1(pos.x_0, max_1(this$static.graphBottomRight.y_0, pos.y_0));
    case 4:
      return new KVector_1(min_1(pos.x_0, this$static.graphTopLeft.x_0), pos.y_0);
  }
  return new KVector_1(pos.x_0, pos.y_0);
}

function $getPortPositionOnMargin(port){
  var margins, pos;
  pos = $clone(sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [port.owner.pos, port.pos, port.anchor])));
  margins = port.owner.margin;
  switch (port.side.ordinal) {
    case 1:
      pos.y_0 -= margins.top_0;
      break;
    case 2:
      pos.x_0 += margins.right;
      break;
    case 3:
      pos.y_0 += margins.bottom;
      break;
    case 4:
      pos.x_0 -= margins.left;
  }
  return pos;
}

function $portSideToDirection(side){
  switch (side.ordinal) {
    case 1:
      return $clinit_Direction() , UP;
    case 4:
      return $clinit_Direction() , LEFT_0;
    case 2:
      return $clinit_Direction() , RIGHT_0;
    case 3:
      return $clinit_Direction() , DOWN;
  }
  return $clinit_Direction() , UNDEFINED;
}

function $segmentToRectangle(p1, p2, extent){
  return new Rectangle_0(min_1(p1.x_0, p2.x_0) - extent / 2, min_1(p1.y_0, p2.y_0) - extent / 2, abs_0(p1.x_0 - p2.x_0) + extent, abs_0(p1.y_0 - p2.y_0) + extent);
}

function $transformLEdge(this$static, externalEdge, hullPoints, outerSegments){
  var extent, externalExtension, margins, outerSegmentRect, rect, segment, segment$iterator, segments, side, thickness;
  externalExtension = new ComponentsCompactor$InternalExternalExtension(externalEdge);
  segments = $edgeToSegments(this$static, externalEdge, externalExtension);
  thickness = max_1(castTo($getProperty(externalEdge, ($clinit_LayoutOptions() , THICKNESS)), 15).value_0, 1);
  for (segment$iterator = new ArrayList$1(segments.innerSegments); segment$iterator.i < segment$iterator.this$01.array.length;) {
    segment = castTo($next_8(segment$iterator), 27);
    rect = $segmentToRectangle(castTo(segment.first, 10), castTo(segment.second, 10), thickness);
    returnVal = true;
    returnVal = returnVal & $add_12(hullPoints, new KVector_1(rect.x_0, rect.y_0));
    returnVal = returnVal & $add_12(hullPoints, $add_6(new KVector_1(rect.x_0, rect.y_0), rect.width_0, 0));
    returnVal = returnVal & $add_12(hullPoints, $add_6(new KVector_1(rect.x_0, rect.y_0), 0, rect.height));
    returnVal & $add_12(hullPoints, $add_6(new KVector_1(rect.x_0, rect.y_0), rect.width_0, rect.height));
  }
  side = externalExtension.externalPortSide;
  outerSegmentRect = $segmentToRectangle(castTo(segments.outerSegment.first, 10), castTo(segments.outerSegment.second, 10), thickness);
  if (side == ($clinit_PortSide() , WEST) || side == EAST) {
    outerSegments.min_0[side.ordinal] = min_1(outerSegments.min_0[side.ordinal], outerSegmentRect.y_0);
    outerSegments.max_0[side.ordinal] = max_1(outerSegments.max_0[side.ordinal], outerSegmentRect.y_0 + outerSegmentRect.height);
  }
   else {
    outerSegments.min_0[side.ordinal] = min_1(outerSegments.min_0[side.ordinal], outerSegmentRect.x_0);
    outerSegments.max_0[side.ordinal] = max_1(outerSegments.max_0[side.ordinal], outerSegmentRect.x_0 + outerSegmentRect.width_0);
  }
  extent = $intern_51;
  margins = externalExtension.externalPort.owner.margin;
  switch (side.ordinal) {
    case 4:
      extent = margins.right;
      break;
    case 2:
      extent = margins.left;
      break;
    case 1:
      extent = margins.bottom;
      break;
    case 3:
      extent = margins.top_0;
  }
  outerSegments.extent[side.ordinal] = max_1(outerSegments.extent[side.ordinal], extent);
  return externalExtension;
}

function $transformLGraph(this$static, graph){
  var component, edge, edge$iterator, extension, extensions, extent, externalExtensions, hullPoints, iee, iuee, max_0, min_0, node, node$iterator, outerSegments, placeholder, ps, ps$iterator;
  component = new ComponentsCompactor$InternalComponent(graph);
  component.containsRegularNodes || $createDummyNode(graph);
  hullPoints = $componentHullPoints(graph);
  externalExtensions = new HashMultimap;
  outerSegments = new ComponentsCompactor$OuterSegments;
  for (node$iterator = new ArrayList$1(graph.layerlessNodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 9);
    for (edge$iterator = $iterator($getOutgoingEdges_0(node)); $hasNext_0(edge$iterator);) {
      edge = castTo($next_2(edge$iterator), 12);
      if (edge.source.owner.type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT) || edge.target.owner.type_0 == EXTERNAL_PORT) {
        iee = $transformLEdge(this$static, edge, hullPoints, outerSegments);
        $put(externalExtensions, $portSideToDirection(iee.externalPortSide), iee.edge);
      }
    }
  }
  extensions = new ArrayList;
  for (ps$iterator = castTo($getProperty(component.graph, ($clinit_InternalProperties() , EXT_PORT_CONNECTIONS)), 18).iterator_0(); ps$iterator.hasNext_0();) {
    ps = castTo(ps$iterator.next_1(), 32);
    min_0 = outerSegments.min_0[ps.ordinal];
    max_0 = outerSegments.max_0[ps.ordinal];
    extent = outerSegments.extent[ps.ordinal];
    extension = null;
    placeholder = null;
    switch (ps.ordinal) {
      case 4:
        extension = new Rectangle_0(this$static.graphTopLeft.x_0, min_0, hullPoints.topLeft.x_0 - this$static.graphTopLeft.x_0, max_0 - min_0);
        placeholder = new Rectangle_0(this$static.graphTopLeft.x_0, min_0, extent, max_0 - min_0);
        $add_12(hullPoints, new KVector_1(extension.x_0 + extension.width_0, extension.y_0));
        $add_12(hullPoints, new KVector_1(extension.x_0 + extension.width_0, extension.y_0 + extension.height));
        break;
      case 2:
        extension = new Rectangle_0(hullPoints.bottomRight.x_0, min_0, this$static.graphBottomRight.x_0 - hullPoints.bottomRight.x_0, max_0 - min_0);
        placeholder = new Rectangle_0(this$static.graphBottomRight.x_0 - extent, min_0, extent, max_0 - min_0);
        $add_12(hullPoints, new KVector_1(extension.x_0, extension.y_0));
        $add_12(hullPoints, new KVector_1(extension.x_0, extension.y_0 + extension.height));
        break;
      case 1:
        extension = new Rectangle_0(min_0, this$static.graphTopLeft.y_0, max_0 - min_0, hullPoints.topLeft.y_0 - this$static.graphTopLeft.y_0);
        placeholder = new Rectangle_0(min_0, this$static.graphTopLeft.y_0, max_0 - min_0, extent);
        $add_12(hullPoints, new KVector_1(extension.x_0, extension.y_0 + extension.height));
        $add_12(hullPoints, new KVector_1(extension.x_0 + extension.width_0, extension.y_0 + extension.height));
        break;
      case 3:
        extension = new Rectangle_0(min_0, hullPoints.bottomRight.y_0, max_0 - min_0, this$static.graphBottomRight.y_0 - hullPoints.bottomRight.y_0);
        placeholder = new Rectangle_0(min_0, this$static.graphBottomRight.y_0 - extent, max_0 - min_0, extent);
        $add_12(hullPoints, new KVector_1(extension.x_0, extension.y_0));
        $add_12(hullPoints, new KVector_1(extension.x_0 + extension.width_0, extension.y_0));
    }
    if (extension) {
      iuee = new ComponentsCompactor$InternalUnionExternalExtension;
      iuee.side = ps;
      iuee.extension = extension;
      iuee.placeholder = placeholder;
      iuee.edges = newHashSet(castTo($get(externalExtensions, $portSideToDirection(ps)), 18));
      extensions.array[extensions.array.length] = iuee;
    }
  }
  $addAll_6(component.externalExtensions, extensions);
  component.rectilinearConvexHull = $splitIntoRectangles(of_1(hullPoints));
  return component;
}

function ComponentsCompactor(){
}

defineClass(322, 1, {}, ComponentsCompactor);
var Lde_cau_cs_kieler_klay_layered_components_ComponentsCompactor_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.components', 'ComponentsCompactor', 322);
function $$init_3(this$static){
  this$static.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
}

function $add_10(this$static, index_0, o){
  checkCriticalPositionIndex(index_0, this$static.array.length);
  insertTo(this$static.array, index_0, o);
}

function $add_11(this$static, o){
  this$static.array[this$static.array.length] = o;
  return true;
}

function $addAll_5(this$static, c){
  var cArray, len;
  checkCriticalPositionIndex(0, this$static.array.length);
  cArray = $toArray(c, initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, c.map_0.size_1(), 4, 1));
  len = cArray.length;
  if (len == 0) {
    return false;
  }
  insertTo_0(this$static.array, 0, cArray);
  return true;
}

function $addAll_6(this$static, c){
  var cArray, len;
  cArray = c.toArray();
  len = cArray.length;
  if (len == 0) {
    return false;
  }
  insertTo_0(this$static.array, this$static.array.length, cArray);
  return true;
}

function $get_8(this$static, index_0){
  checkCriticalElementIndex(index_0, this$static.array.length);
  return this$static.array[index_0];
}

function $indexOf_0(this$static, o, index_0){
  for (; index_0 < this$static.array.length; ++index_0) {
    if (equals_50(o, this$static.array[index_0])) {
      return index_0;
    }
  }
  return -1;
}

function $remove_6(this$static, index_0){
  var previous;
  previous = (checkCriticalElementIndex(index_0, this$static.array.length) , this$static.array[index_0]);
  removeFrom(this$static.array, index_0, 1);
  return previous;
}

function $remove_7(this$static, o){
  var i;
  i = $indexOf_0(this$static, o, 0);
  if (i == -1) {
    return false;
  }
  this$static.remove_2(i);
  return true;
}

function $removeRange(this$static, fromIndex, endIndex){
  var count;
  checkCriticalPositionIndexes(fromIndex, endIndex, this$static.array.length);
  count = endIndex - fromIndex;
  removeFrom(this$static.array, fromIndex, count);
}

function $set_3(this$static, index_0, o){
  var previous;
  previous = (checkCriticalElementIndex(index_0, this$static.array.length) , this$static.array[index_0]);
  this$static.array[index_0] = o;
  return previous;
}

function $toArray_0(this$static){
  return clone_2(this$static.array, this$static.array.length);
}

function $toArray_1(this$static, out){
  var i, result, size_0;
  size_0 = this$static.array.length;
  out.length < size_0 && (out = (result = new Array(size_0) , stampJavaTypeInfo_0(result, out)));
  for (i = 0; i < size_0; ++i) {
    setCheck(out, i, this$static.array[i]);
  }
  out.length > size_0 && setCheck(out, size_0, null);
  return out;
}

function ArrayList(){
  $$init_3(this);
}

function ArrayList_0(initialCapacity){
  $$init_3(this);
  checkCriticalArgument_0(initialCapacity >= 0, 'Initial capacity must not be negative');
}

function ArrayList_1(c){
  $$init_3(this);
  insertTo_0(this.array, 0, c.toArray());
}

defineClass(13, 646, $intern_53, ArrayList, ArrayList_0, ArrayList_1);
_.add_2 = function add_22(index_0, o){
  $add_10(this, index_0, o);
}
;
_.add_1 = function add_23(o){
  return $add_11(this, o);
}
;
_.addAll = function addAll_6(c){
  return $addAll_6(this, c);
}
;
_.clear_0 = function clear_22(){
  this.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
}
;
_.contains = function contains_24(o){
  return $indexOf_0(this, o, 0) != -1;
}
;
_.get_2 = function get_17(index_0){
  return $get_8(this, index_0);
}
;
_.isEmpty = function isEmpty_18(){
  return this.array.length == 0;
}
;
_.iterator_0 = function iterator_42(){
  return new ArrayList$1(this);
}
;
_.remove_2 = function remove_43(index_0){
  return $remove_6(this, index_0);
}
;
_.remove_1 = function remove_44(o){
  return $remove_7(this, o);
}
;
_.removeRange = function removeRange_1(fromIndex, endIndex){
  $removeRange(this, fromIndex, endIndex);
}
;
_.set_2 = function set_12(index_0, o){
  return $set_3(this, index_0, o);
}
;
_.size_1 = function size_34(){
  return this.array.length;
}
;
_.toArray = function toArray_10(){
  return $toArray_0(this);
}
;
_.toArray_0 = function toArray_11(out){
  return $toArray_1(this, out);
}
;
var Ljava_util_ArrayList_2_classLit = createForClass('java.util', 'ArrayList', 13);
function $add_12(this$static, e){
  return $add_13(this$static, new Point(e.x_0, e.y_0));
}

function $add_13(this$static, e){
  this$static.topLeft.x_0 = min_1(this$static.topLeft.x_0, e.x_0);
  this$static.topLeft.y_0 = min_1(this$static.topLeft.y_0, e.y_0);
  this$static.bottomRight.x_0 = max_1(this$static.bottomRight.x_0, e.x_0);
  this$static.bottomRight.y_0 = max_1(this$static.bottomRight.y_0, e.y_0);
  return this$static.array[this$static.array.length] = e , true;
}

function ComponentsCompactor$Hullpoints(){
  $$init_3(this);
  this.topLeft = new KVector_1($intern_50, $intern_50);
  this.bottomRight = new KVector_1($intern_51, $intern_51);
}

defineClass(532, 13, $intern_53, ComponentsCompactor$Hullpoints);
_.add_1 = function add_24(e){
  return $add_13(this, castTo(e, 48));
}
;
var Lde_cau_cs_kieler_klay_layered_components_ComponentsCompactor$Hullpoints_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.components', 'ComponentsCompactor/Hullpoints', 532);
function $getExternalEdges(this$static){
  var edges, ee, ee$iterator;
  edges = new ArrayList;
  for (ee$iterator = new ArrayList$1(this$static.externalExtensions); ee$iterator.i < ee$iterator.this$01.array.length;) {
    ee = castTo($next_8(ee$iterator), 251);
    $addAll_6(edges, castTo(ee.getRepresentative(), 19));
  }
  return edges;
}

function ComponentsCompactor$InternalComponent(graph){
  var n, n$iterator;
  this.externalExtensions = new ArrayList;
  this.graph = graph;
  this.containsRegularNodes = false;
  for (n$iterator = new ArrayList$1(graph.layerlessNodes); n$iterator.i < n$iterator.this$01.array.length;) {
    n = castTo($next_8(n$iterator), 9);
    this.containsRegularNodes = this.containsRegularNodes | n.type_0 == ($clinit_LNode$NodeType() , NORMAL);
  }
}

defineClass(529, 1, {347:1}, ComponentsCompactor$InternalComponent);
_.containsRegularNodes = false;
var Lde_cau_cs_kieler_klay_layered_components_ComponentsCompactor$InternalComponent_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.components', 'ComponentsCompactor/InternalComponent', 529);
function ComponentsCompactor$InternalConnectedComponents(){
  this.components = new ArrayList;
}

defineClass(528, 1, $intern_30, ComponentsCompactor$InternalConnectedComponents);
_.iterator_0 = function iterator_43(){
  return new ArrayList$1(this.components);
}
;
var Lde_cau_cs_kieler_klay_layered_components_ComponentsCompactor$InternalConnectedComponents_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.components', 'ComponentsCompactor/InternalConnectedComponents', 528);
function ComponentsCompactor$InternalExternalExtension(edge){
  this.edge = edge;
  if (edge.source.owner.type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
    this.externalPort = edge.source;
    this.externalPortSide = castTo($getProperty(edge.source.owner, ($clinit_InternalProperties() , EXT_PORT_SIDE)), 32);
  }
   else if (edge.target.owner.type_0 == EXTERNAL_PORT) {
    this.externalPort = edge.target;
    this.externalPortSide = castTo($getProperty(edge.target.owner, ($clinit_InternalProperties() , EXT_PORT_SIDE)), 32);
  }
   else {
    throw new IllegalArgumentException_0('Edge ' + edge + ' is not an external edge.');
  }
}

defineClass(531, 1, {251:1}, ComponentsCompactor$InternalExternalExtension);
_.getPlaceholder = function getPlaceholder(){
  return null;
}
;
_.getRepresentative = function getRepresentative(){
  return this.edge;
}
;
_.getDirection = function getDirection(){
  return $portSideToDirection(this.externalPortSide);
}
;
_.getRepresentor = function getRepresentor(){
  return this.externalExtension;
}
;
var Lde_cau_cs_kieler_klay_layered_components_ComponentsCompactor$InternalExternalExtension_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.components', 'ComponentsCompactor/InternalExternalExtension', 531);
function ComponentsCompactor$InternalUnionExternalExtension(){
  this.edges = new HashSet;
}

defineClass(530, 1, {251:1}, ComponentsCompactor$InternalUnionExternalExtension);
_.getRepresentative = function getRepresentative_0(){
  return this.edges;
}
;
_.getDirection = function getDirection_0(){
  return $portSideToDirection(this.side);
}
;
_.getPlaceholder = function getPlaceholder_0(){
  return this.placeholder;
}
;
_.getRepresentor = function getRepresentor_0(){
  return this.extension;
}
;
var Lde_cau_cs_kieler_klay_layered_components_ComponentsCompactor$InternalUnionExternalExtension_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.components', 'ComponentsCompactor/InternalUnionExternalExtension', 530);
function ComponentsCompactor$OuterSegments(){
  this.min_0 = initUnidimensionalArray(D_classLit, $intern_11, 26, ($clinit_PortSide() , stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_PortSide_2_classLit, 1), $intern_13, 32, 0, [UNDEFINED_4, NORTH, EAST, SOUTH, WEST])).length, 12, 1);
  this.max_0 = initUnidimensionalArray(D_classLit, $intern_11, 26, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_PortSide_2_classLit, 1), $intern_13, 32, 0, [UNDEFINED_4, NORTH, EAST, SOUTH, WEST]).length, 12, 1);
  this.extent = initUnidimensionalArray(D_classLit, $intern_11, 26, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_PortSide_2_classLit, 1), $intern_13, 32, 0, [UNDEFINED_4, NORTH, EAST, SOUTH, WEST]).length, 12, 1);
  fill(this.min_0, $intern_50);
  fill(this.max_0, $intern_51);
  fill(this.extent, $intern_51);
}

defineClass(534, 1, {}, ComponentsCompactor$OuterSegments);
var Lde_cau_cs_kieler_klay_layered_components_ComponentsCompactor$OuterSegments_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.components', 'ComponentsCompactor/OuterSegments', 534);
function ComponentsCompactor$Segments(){
  this.innerSegments = new ArrayList;
}

defineClass(533, 1, {}, ComponentsCompactor$Segments);
var Lde_cau_cs_kieler_klay_layered_components_ComponentsCompactor$Segments_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.components', 'ComponentsCompactor/Segments', 533);
function $combine(this$static, components, target){
  this$static.graphPlacer.combine(components, target);
}

function $dfs(this$static, node, data_0){
  var all, component, extPortSides, mutableData, port1, port1$iterator, port2, port2$iterator;
  if (node.id_0 == 0) {
    node.id_0 = 1;
    mutableData = data_0;
    if (!data_0) {
      component = new ArrayList;
      extPortSides = (all = castTo($getEnumConstants(Lde_cau_cs_kieler_kiml_options_PortSide_2_classLit), 11) , new EnumSet$EnumSetImpl(all, castTo(createFrom(all, all.length), 11), 0));
      mutableData = new Pair(component, extPortSides);
    }
    castTo(mutableData.first, 20).add_1(node);
    node.type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT) && castTo(mutableData.second, 18).add_1(castTo($getProperty(node, ($clinit_InternalProperties() , EXT_PORT_SIDE)), 32));
    for (port1$iterator = new ArrayList$1(node.ports); port1$iterator.i < port1$iterator.this$01.array.length;) {
      port1 = castTo($next_8(port1$iterator), 7);
      for (port2$iterator = $iterator(concat(($clinit_ImmutableList() , new RegularImmutableList(nullCheckedList(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [new LPort$7(port1), new LPort$8(port1)])))))); $hasNext_0(port2$iterator);) {
        port2 = castTo($next_2(port2$iterator), 7);
        $dfs(this$static, port2.owner, mutableData);
      }
    }
    return mutableData;
  }
  return null;
}

function $split(this$static, graph){
  var compatiblePortConstraints, componentData, extPortConstraints, extPorts, n, n$iterator, newGraph, node, node$iterator, node$iterator0, result, separate, separateProperty;
  this$static.graphPlacer = this$static.simpleRowGraphPlacer;
  separateProperty = castToBoolean($getProperty(graph, ($clinit_LayoutOptions() , SEPARATE_CC)));
  separate = separateProperty == null || unsafeCast((checkCriticalNotNull(separateProperty) , separateProperty));
  extPorts = castTo($getProperty(graph, ($clinit_InternalProperties() , GRAPH_PROPERTIES)), 18).contains(($clinit_GraphProperties() , EXTERNAL_PORTS));
  extPortConstraints = castTo($getProperty(graph, PORT_CONSTRAINTS), 28);
  compatiblePortConstraints = !(extPortConstraints == ($clinit_PortConstraints() , FIXED_ORDER) || extPortConstraints == FIXED_RATIO || extPortConstraints == FIXED_POS);
  if (separate && (compatiblePortConstraints || !extPorts)) {
    for (node$iterator0 = new ArrayList$1(graph.layerlessNodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
      node = castTo($next_8(node$iterator0), 9);
      node.id_0 = 0;
    }
    result = new ArrayList;
    for (node$iterator = new ArrayList$1(graph.layerlessNodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      componentData = $dfs(this$static, node, null);
      if (componentData) {
        newGraph = new LGraph;
        $copyProperties(newGraph, graph);
        $setProperty(newGraph, EXT_PORT_CONNECTIONS, castTo(componentData.second, 18));
        $copy(newGraph.insets, graph.insets);
        for (n$iterator = castTo(componentData.first, 20).iterator_0(); n$iterator.hasNext_0();) {
          n = castTo(n$iterator.next_1(), 9);
          $add_11(newGraph.layerlessNodes, n);
          n.graph = newGraph;
        }
        result.add_1(newGraph);
      }
    }
    extPorts && (this$static.graphPlacer = this$static.componentGroupGraphPlacer);
  }
   else {
    result = new Arrays$ArrayList(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_graph_LGraph_2_classLit, 1), {38:1, 40:1, 42:1, 3:1, 8:1, 5:1, 6:1}, 55, 0, [graph]));
  }
  return result;
}

function ComponentsProcessor(){
  this.componentGroupGraphPlacer = new ComponentGroupGraphPlacer;
  this.simpleRowGraphPlacer = new SimpleRowGraphPlacer;
}

defineClass(381, 1, {}, ComponentsProcessor);
var Lde_cau_cs_kieler_klay_layered_components_ComponentsProcessor_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.components', 'ComponentsProcessor', 381);
function SimpleRowGraphPlacer(){
}

defineClass(432, 661, {}, SimpleRowGraphPlacer);
_.combine = function combine_0(components, target){
  var broadestRow, compactor, firstComponent, graph, graph$iterator, graph$iterator0, graph$iterator1, h, h$iterator, highestBox, maxRowWidth, node, node$iterator, offset, priority, regularSpacing, size_0, source, spacing, totalArea, xpos, ypos;
  if (components.size_1() == 1) {
    source = castTo(components.get_2(0), 55);
    if (source != target) {
      target.layerlessNodes.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
      $moveGraph(target, source, 0, 0);
      $copyProperties(target, source);
      $copy(target.insets, source.insets);
      target.size_0.x_0 = source.size_0.x_0;
      target.size_0.y_0 = source.size_0.y_0;
    }
    return;
  }
   else if (components.isEmpty()) {
    target.layerlessNodes.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
    target.size_0.x_0 = 0;
    target.size_0.y_0 = 0;
    return;
  }
  for (graph$iterator0 = components.iterator_0(); graph$iterator0.hasNext_0();) {
    graph = castTo(graph$iterator0.next_1(), 55);
    priority = 0;
    for (node$iterator = new ArrayList$1(graph.layerlessNodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      priority += castTo($getProperty(node, ($clinit_InternalProperties() , PRIORITY_0)), 24).value_0;
    }
    graph.id_0 = priority;
  }
  sort_1(components, new SimpleRowGraphPlacer$1);
  firstComponent = castTo(components.get_2(0), 55);
  target.layerlessNodes.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
  $copyProperties(target, firstComponent);
  maxRowWidth = 0;
  totalArea = 0;
  for (graph$iterator1 = components.iterator_0(); graph$iterator1.hasNext_0();) {
    graph = castTo(graph$iterator1.next_1(), 55);
    size_0 = graph.size_0;
    maxRowWidth = max_1(maxRowWidth, size_0.x_0);
    totalArea += size_0.x_0 * size_0.y_0;
  }
  maxRowWidth = max_1(maxRowWidth, Math.sqrt(totalArea) * castTo($getProperty(target, ($clinit_InternalProperties() , ASPECT_RATIO_0)), 15).value_0);
  spacing = $intern_54 * castTo($getProperty(target, SPACING_0), 15).value_0;
  xpos = 0;
  ypos = 0;
  highestBox = 0;
  broadestRow = spacing;
  for (graph$iterator = components.iterator_0(); graph$iterator.hasNext_0();) {
    graph = castTo(graph$iterator.next_1(), 55);
    size_0 = graph.size_0;
    if (xpos + size_0.x_0 > maxRowWidth) {
      xpos = 0;
      ypos += highestBox + spacing;
      highestBox = 0;
    }
    offset = graph.offset;
    $offsetGraph(graph, xpos + offset.x_0, ypos + offset.y_0);
    offset.x_0 = 0;
    offset.y_0 = 0;
    broadestRow = max_1(broadestRow, xpos + size_0.x_0);
    highestBox = max_1(highestBox, size_0.y_0);
    xpos += size_0.x_0 + spacing;
  }
  target.size_0.x_0 = broadestRow;
  target.size_0.y_0 = ypos + highestBox;
  regularSpacing = castTo($getProperty(target, SPACING_0), 15).value_0;
  if (unsafeCast(checkNotNull_1(castToBoolean($getProperty(firstComponent, ($clinit_Properties() , COMPACT_COMPONENTS)))))) {
    compactor = new ComponentsCompactor;
    $compact_2(compactor, components, regularSpacing);
    for (h$iterator = components.iterator_0(); h$iterator.hasNext_0();) {
      h = castTo(h$iterator.next_1(), 55);
      $add_7($reset(h.offset), compactor.yetAnotherOffset);
    }
    $add_7($reset(target.size_0), compactor.compactedGraphSize);
  }
  $moveGraphs(target, components);
}
;
var Lde_cau_cs_kieler_klay_layered_components_SimpleRowGraphPlacer_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.components', 'SimpleRowGraphPlacer', 432);
function $compare_2(graph1, graph2){
  var prio, size1, size2;
  prio = graph2.id_0 - graph1.id_0;
  if (prio == 0) {
    size1 = graph1.size_0.x_0 * graph1.size_0.y_0;
    size2 = graph2.size_0.x_0 * graph2.size_0.y_0;
    return compare_31(size1, size2);
  }
  return prio;
}

function SimpleRowGraphPlacer$1(){
}

defineClass(433, 1, $intern_9, SimpleRowGraphPlacer$1);
_.compare_0 = function compare_14(graph1, graph2){
  return $compare_2(castTo(graph1, 55), castTo(graph2, 55));
}
;
var Lde_cau_cs_kieler_klay_layered_components_SimpleRowGraphPlacer$1_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.components', 'SimpleRowGraphPlacer/1', 433);
function $clinit_CompoundGraphPostprocessor(){
  $clinit_CompoundGraphPostprocessor = emptyMethod;
  HAS_JUNCTION_POINTS_PREDICATE = new CompoundGraphPostprocessor$1;
}

function $process_1(graph, monitor){
  var addUnnecessaryBendpoints, bendPoints, chEdge, chEdge$iterator, crossHierarchyEdges, crossHierarchyMap, currLabel, dummyEdge, dummyEdge$iterator, dummyEdges, entry, jpCopies, junctionPoints, labelIterator, lastPoint, ledge, ledgeJPs, nextPoint, offset, origEdge, origEdge$iterator, outerIter, referenceGraph, referenceNode, sourcePoint, sourcePort, targetPoint, targetPort, xDiffEnough, yDiffEnough;
  $begin(monitor, 'Compound graph postprocessor', 1);
  addUnnecessaryBendpoints = unsafeCast(checkNotNull_1(castToBoolean($getProperty(graph, ($clinit_Properties() , ADD_UNNECESSARY_BENDPOINTS)))));
  crossHierarchyMap = castTo($getProperty(graph, ($clinit_InternalProperties() , CROSS_HIERARCHY_MAP)), 144);
  dummyEdges = new HashSet;
  for (origEdge$iterator = crossHierarchyMap.keySet_0().iterator_0(); origEdge$iterator.hasNext_0();) {
    origEdge = castTo(origEdge$iterator.next_1(), 12);
    crossHierarchyEdges = new ArrayList_1(crossHierarchyMap.get_0(origEdge));
    sort_1(crossHierarchyEdges, new CrossHierarchyEdgeComparator(graph));
    sourcePort = $getActualSource((checkCriticalElementIndex(0, crossHierarchyEdges.array.length) , castTo(crossHierarchyEdges.array[0], 114)));
    targetPort = $getActualTarget(castTo($get_8(crossHierarchyEdges, crossHierarchyEdges.array.length - 1), 114));
    $reset_0(origEdge.bendPoints);
    referenceNode = sourcePort.owner;
    isDescendant(targetPort.owner, referenceNode)?(referenceGraph = castTo($getProperty(referenceNode, NESTED_LGRAPH), 55)):(referenceGraph = $getGraph(referenceNode));
    junctionPoints = castTo($getProperty(origEdge, ($clinit_LayoutOptions() , JUNCTION_POINTS)), 44);
    if (any(crossHierarchyEdges, HAS_JUNCTION_POINTS_PREDICATE)) {
      if (!junctionPoints) {
        junctionPoints = new KVectorChain;
        $setProperty(origEdge, JUNCTION_POINTS, junctionPoints);
      }
       else {
        $reset_0(junctionPoints);
      }
    }
     else 
      !!junctionPoints && $setProperty(origEdge, JUNCTION_POINTS, null);
    lastPoint = null;
    for (chEdge$iterator = new ArrayList$1(crossHierarchyEdges); chEdge$iterator.i < chEdge$iterator.this$01.array.length;) {
      chEdge = castTo($next_8(chEdge$iterator), 114);
      offset = new KVector;
      changeCoordSystem(offset, chEdge.graph, referenceGraph);
      ledge = chEdge.newEdge;
      bendPoints = new KVectorChain;
      $addAllAsCopies(bendPoints, 0, ledge.bendPoints);
      $offset(bendPoints, offset);
      sourcePoint = new KVector_2($getAbsoluteAnchor(ledge.source));
      targetPoint = new KVector_2($getAbsoluteAnchor(ledge.target));
      sourcePoint.x_0 += offset.x_0;
      sourcePoint.y_0 += offset.y_0;
      targetPoint.x_0 += offset.x_0;
      targetPoint.y_0 += offset.y_0;
      if (lastPoint) {
        bendPoints.size_0 == 0?(nextPoint = targetPoint):(nextPoint = (checkCriticalElement(bendPoints.size_0 != 0) , castTo(bendPoints.header.next_0.value_0, 10)));
        xDiffEnough = abs_0(lastPoint.x_0 - nextPoint.x_0) > $intern_55;
        yDiffEnough = abs_0(lastPoint.y_0 - nextPoint.y_0) > $intern_55;
        (!addUnnecessaryBendpoints && xDiffEnough && yDiffEnough || addUnnecessaryBendpoints && (xDiffEnough || yDiffEnough)) && $add_8(origEdge.bendPoints, sourcePoint);
      }
      $addAll(origEdge.bendPoints, bendPoints);
      bendPoints.size_0 == 0?(lastPoint = sourcePoint):(lastPoint = (checkCriticalElement(bendPoints.size_0 != 0) , castTo(bendPoints.tail.prev.value_0, 10)));
      ledgeJPs = castTo($getProperty(ledge, JUNCTION_POINTS), 44);
      if (ledgeJPs) {
        jpCopies = new KVectorChain;
        $addAllAsCopies(jpCopies, 0, ledgeJPs);
        $offset(jpCopies, offset);
        $addAll(junctionPoints, jpCopies);
      }
      if ($getActualTarget(chEdge) == targetPort) {
        if ($getGraph(targetPort.owner) != chEdge.graph) {
          offset = new KVector;
          changeCoordSystem(offset, $getGraph(targetPort.owner), referenceGraph);
        }
        $setProperty(origEdge, TARGET_OFFSET, offset);
      }
      labelIterator = new AbstractList$ListIteratorImpl(ledge.labels, 0);
      while (labelIterator.i < labelIterator.this$01_0.size_1()) {
        currLabel = (checkCriticalElement(labelIterator.i < labelIterator.this$01_0.size_1()) , castTo(labelIterator.this$01_0.get_2(labelIterator.last = labelIterator.i++), 33));
        if (maskUndefined($getProperty(currLabel, ORIGINAL_LABEL_EDGE)) !== maskUndefined(origEdge)) {
          continue;
        }
        changeCoordSystem(currLabel.pos, $getGraph(ledge.source.owner), referenceGraph);
        $remove_11(labelIterator);
        $add_11(origEdge.labels, currLabel);
      }
      dummyEdges.map_0.put(ledge, dummyEdges);
    }
    $setSource(origEdge, sourcePort);
    $setTarget(origEdge, targetPort);
  }
  for (dummyEdge$iterator = (outerIter = (new AbstractMap$1(dummyEdges.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter)); dummyEdge$iterator.val$outerIter2.hasNext_0();) {
    dummyEdge = (entry = castTo(dummyEdge$iterator.val$outerIter2.next_1(), 21) , castTo(entry.getKey(), 12));
    $setSource(dummyEdge, null);
    $setTarget(dummyEdge, null);
  }
  $done(monitor);
}

function CompoundGraphPostprocessor(){
  $clinit_CompoundGraphPostprocessor();
}

defineClass(369, 1, $intern_56, CompoundGraphPostprocessor);
_.process = function process(graph, monitor){
  $process_1(graph, monitor);
}
;
var HAS_JUNCTION_POINTS_PREDICATE;
var Lde_cau_cs_kieler_klay_layered_compound_CompoundGraphPostprocessor_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.compound', 'CompoundGraphPostprocessor', 369);
function CompoundGraphPostprocessor$1(){
}

defineClass(370, 1, $intern_52, CompoundGraphPostprocessor$1);
_.apply_1 = function apply_18(chEdge){
  var jps;
  return jps = castTo($getProperty(castTo(chEdge, 114).newEdge, ($clinit_LayoutOptions() , JUNCTION_POINTS)), 44) , !!jps && jps.size_0 != 0;
}
;
var Lde_cau_cs_kieler_klay_layered_compound_CompoundGraphPostprocessor$1_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.compound', 'CompoundGraphPostprocessor/1', 370);
function $connectChild(this$static, graph, externalPort, origEdge, sourcePort, targetPort){
  var dummyEdge;
  dummyEdge = $createDummyEdge(origEdge);
  $setSource(dummyEdge, sourcePort);
  $setTarget(dummyEdge, targetPort);
  $put(this$static.crossHierarchyMap, origEdge, new CrossHierarchyEdge(dummyEdge, graph, externalPort.type_0));
}

function $connectSiblings(this$static, graph, externalOutputPort, containedExternalPorts, origEdge){
  var dummyEdge, externalPort2, externalPort2$iterator, targetExternalPort;
  targetExternalPort = null;
  for (externalPort2$iterator = new ArrayList$1(containedExternalPorts); externalPort2$iterator.i < externalPort2$iterator.this$01.array.length;) {
    externalPort2 = castTo($next_8(externalPort2$iterator), 187);
    if (externalPort2 != externalOutputPort && $indexOf_0(externalPort2.origEdges, origEdge, 0) != -1) {
      targetExternalPort = externalPort2;
      break;
    }
  }
  dummyEdge = $createDummyEdge(origEdge);
  $setSource(dummyEdge, externalOutputPort.dummyPort);
  $setTarget(dummyEdge, targetExternalPort.dummyPort);
  $put(this$static.crossHierarchyMap, origEdge, new CrossHierarchyEdge(dummyEdge, graph, externalOutputPort.type_0));
}

function $createDummyEdge(origEdge){
  var dummyEdge;
  dummyEdge = new LEdge;
  $copyProperties(dummyEdge, origEdge);
  $setProperty(dummyEdge, ($clinit_LayoutOptions() , JUNCTION_POINTS), null);
  return dummyEdge;
}

function $createExternalPortDummy(this$static, graph, parentNode, portType, portSide, edge){
  var dummyNode, dummyPort, layoutDirection, outsidePort, thickness, propertyHolder, offset;
  outsidePort = portType == ($clinit_PortType() , INPUT)?edge.source:edge.target;
  layoutDirection = getDirection_1(graph);
  if (outsidePort.owner == parentNode) {
    dummyNode = castTo($get_9(this$static.dummyNodeMap, outsidePort), 9);
    if (!dummyNode) {
      dummyNode = createExternalPortDummy(outsidePort, castTo($getProperty(parentNode, ($clinit_LayoutOptions() , PORT_CONSTRAINTS)), 28), portSide, portType == INPUT?-1:1, outsidePort.size_0, layoutDirection, graph);
      $setProperty(dummyNode, ($clinit_InternalProperties() , ORIGIN), outsidePort);
      $put_2(this$static.dummyNodeMap, outsidePort, dummyNode);
    }
  }
   else {
    thickness = castTo($getProperty(edge, ($clinit_LayoutOptions() , THICKNESS)), 15).value_0;
    dummyNode = createExternalPortDummy((propertyHolder = new MapPropertyHolder , offset = castTo($getProperty(graph, ($clinit_InternalProperties() , SPACING_0)), 15).value_0 * castTo($getProperty(graph, ($clinit_Properties() , EDGE_SPACING_FACTOR)), 15).value_0 / 2 , $setProperty(propertyHolder, OFFSET_0, new Float_0(offset)) , propertyHolder), castTo($getProperty(parentNode, PORT_CONSTRAINTS), 28), portSide, portType == INPUT?-1:1, new KVector_1(thickness, thickness), layoutDirection, graph);
    dummyPort = $createPortForDummy(this$static, dummyNode, parentNode, portType);
    $setProperty(dummyNode, ORIGIN, dummyPort);
    $put_2(this$static.dummyNodeMap, dummyPort, dummyNode);
  }
  castTo($getProperty(graph, ($clinit_InternalProperties() , GRAPH_PROPERTIES)), 18).add_1(($clinit_GraphProperties() , EXTERNAL_PORTS));
  $isSideFixed(castTo($getProperty(graph, ($clinit_LayoutOptions() , PORT_CONSTRAINTS)), 28))?$setProperty(graph, PORT_CONSTRAINTS, ($clinit_PortConstraints() , FIXED_SIDE)):$setProperty(graph, PORT_CONSTRAINTS, ($clinit_PortConstraints() , FREE));
  return dummyNode;
}

function $createPortForDummy(this$static, dummyNode, parentNode, type_0){
  var graph, layoutDirection, port;
  graph = $getGraph(parentNode);
  layoutDirection = getDirection_1(graph);
  port = new LPort;
  $setNode(port, parentNode);
  switch (type_0.ordinal) {
    case 1:
      $setSide(port, $opposed(fromDirection(layoutDirection)));
      break;
    case 2:
      $setSide(port, fromDirection(layoutDirection));
  }
  $setProperty(port, ($clinit_InternalProperties() , OFFSET_0), castTo($getProperty(dummyNode, OFFSET_0), 15));
  $setProperty(dummyNode, ORIGIN, port);
  $put_2(this$static.dummyNodeMap, port, dummyNode);
  return port;
}

function $introduceHierarchicalEdgeSegment(this$static, graph, parentNode, origEdge, oppositePort, portType, defaultExternalPort){
  var dummyEdge, dummyNode, externalPort, externalPortSide, mergeExternalPorts, parentEndPort, thickness;
  mergeExternalPorts = unsafeCast(checkNotNull_1(castToBoolean($getProperty(graph, ($clinit_Properties() , MERGE_HIERARCHICAL_EDGES)))));
  parentEndPort = null;
  portType == ($clinit_PortType() , INPUT) && origEdge.source.owner == parentNode?(parentEndPort = origEdge.source):portType == OUTPUT && origEdge.target.owner == parentNode && (parentEndPort = origEdge.target);
  externalPort = defaultExternalPort;
  if (!defaultExternalPort || !mergeExternalPorts || !!parentEndPort) {
    externalPortSide = ($clinit_PortSide() , UNDEFINED_4);
    parentEndPort?(externalPortSide = parentEndPort.side):$isSideFixed(castTo($getProperty(parentNode, ($clinit_LayoutOptions() , PORT_CONSTRAINTS)), 28)) && (externalPortSide = portType == INPUT?WEST:EAST);
    dummyNode = $createExternalPortDummy(this$static, graph, parentNode, portType, externalPortSide, origEdge);
    dummyEdge = $createDummyEdge(($getGraph(parentNode) , origEdge));
    if (portType == INPUT) {
      $setSource(dummyEdge, castTo($get_8(dummyNode.ports, 0), 7));
      $setTarget(dummyEdge, oppositePort);
    }
     else {
      $setSource(dummyEdge, oppositePort);
      $setTarget(dummyEdge, castTo($get_8(dummyNode.ports, 0), 7));
    }
    externalPort = new CompoundGraphPreprocessor$ExternalPort(origEdge, dummyEdge, dummyNode, castTo($getProperty(dummyNode, ($clinit_InternalProperties() , ORIGIN)), 7), portType, !parentEndPort);
  }
   else {
    $add_11(defaultExternalPort.origEdges, origEdge);
    thickness = max_2(castTo($getProperty(defaultExternalPort.newEdge, ($clinit_LayoutOptions() , THICKNESS)), 15).value_0, castTo($getProperty(origEdge, THICKNESS), 15).value_0);
    $setProperty(defaultExternalPort.newEdge, THICKNESS, new Float_0(thickness));
  }
  $put(this$static.crossHierarchyMap, origEdge, new CrossHierarchyEdge(externalPort.newEdge, graph, portType));
  return externalPort;
}

function $moveLabelsAndRemoveOriginalEdges(this$static, graph){
  var currLabel, edgeSegments, labelIterator, origEdge, origEdge$iterator, targetDummyEdgeIndex, targetSegment;
  for (origEdge$iterator = $keySet(this$static.crossHierarchyMap).iterator_0(); origEdge$iterator.hasNext_0();) {
    origEdge = castTo(origEdge$iterator.next_1(), 12);
    if (origEdge.labels.array.length > 0) {
      edgeSegments = new ArrayList_1(castTo($get(this$static.crossHierarchyMap, origEdge), 18));
      sort_1(edgeSegments, new CrossHierarchyEdgeComparator(graph));
      labelIterator = new AbstractList$ListIteratorImpl(origEdge.labels, 0);
      while (labelIterator.i < labelIterator.this$01_0.size_1()) {
        currLabel = (checkCriticalElement(labelIterator.i < labelIterator.this$01_0.size_1()) , castTo(labelIterator.this$01_0.get_2(labelIterator.last = labelIterator.i++), 33));
        targetDummyEdgeIndex = -1;
        switch (castTo($getProperty(currLabel, ($clinit_LayoutOptions() , EDGE_LABEL_PLACEMENT)), 107).ordinal) {
          case 2:
            targetDummyEdgeIndex = edgeSegments.array.length - 1;
            break;
          case 1:
            targetDummyEdgeIndex = edgeSegments.array.length / 2 | 0;
            break;
          case 3:
            targetDummyEdgeIndex = 0;
        }
        if (targetDummyEdgeIndex != -1) {
          targetSegment = (checkCriticalElementIndex(targetDummyEdgeIndex, edgeSegments.array.length) , castTo(edgeSegments.array[targetDummyEdgeIndex], 114));
          $add_11(targetSegment.newEdge.labels, currLabel);
          castTo($getProperty($getGraph(targetSegment.newEdge.source.owner), ($clinit_InternalProperties() , GRAPH_PROPERTIES)), 18).add_1(($clinit_GraphProperties() , END_LABELS));
          castTo($getProperty($getGraph(targetSegment.newEdge.source.owner), GRAPH_PROPERTIES), 18).add_1(CENTER_LABELS);
          $remove_11(labelIterator);
          $setProperty(currLabel, ORIGINAL_LABEL_EDGE, origEdge);
        }
      }
    }
    $setSource(origEdge, null);
    $setTarget(origEdge, null);
  }
}

function $process_2(this$static, graph, monitor){
  $begin(monitor, 'Compound graph preprocessor', 1);
  this$static.crossHierarchyMap = new HashMultimap;
  $transformHierarchyEdges(this$static, graph, null);
  $moveLabelsAndRemoveOriginalEdges(this$static, graph);
  $setProperty(graph, ($clinit_InternalProperties() , CROSS_HIERARCHY_MAP), this$static.crossHierarchyMap);
  this$static.crossHierarchyMap = null;
  $reset_3(this$static.dummyNodeMap);
  $done(monitor);
}

function $processInnerHierarchicalEdgeSegments(this$static, graph, parentNode, containedExternalPorts, exportedExternalPorts){
  var createdExternalPorts, currentExternalPort, externalPort, externalPort$iterator, externalPort$iterator0, inEdge, inEdge$iterator, newExternalPort, outEdge, outEdge$iterator, sourceNode, targetNode;
  createdExternalPorts = new ArrayList;
  for (externalPort$iterator0 = new ArrayList$1(containedExternalPorts); externalPort$iterator0.i < externalPort$iterator0.this$01.array.length;) {
    externalPort = castTo($next_8(externalPort$iterator0), 187);
    currentExternalPort = null;
    if (externalPort.type_0 == ($clinit_PortType() , OUTPUT)) {
      for (outEdge$iterator = new ArrayList$1(externalPort.origEdges); outEdge$iterator.i < outEdge$iterator.this$01.array.length;) {
        outEdge = castTo($next_8(outEdge$iterator), 12);
        targetNode = outEdge.target.owner;
        if ($getGraph(targetNode) == graph) {
          $connectChild(this$static, graph, externalPort, outEdge, externalPort.dummyPort, outEdge.target);
        }
         else if (!parentNode || isDescendant(targetNode, parentNode)) {
          $connectSiblings(this$static, graph, externalPort, containedExternalPorts, outEdge);
        }
         else {
          newExternalPort = $introduceHierarchicalEdgeSegment(this$static, graph, parentNode, outEdge, externalPort.dummyPort, OUTPUT, currentExternalPort);
          newExternalPort != currentExternalPort && (createdExternalPorts.array[createdExternalPorts.array.length] = newExternalPort , true);
          newExternalPort.exported && (currentExternalPort = newExternalPort);
        }
      }
    }
     else {
      for (inEdge$iterator = new ArrayList$1(externalPort.origEdges); inEdge$iterator.i < inEdge$iterator.this$01.array.length;) {
        inEdge = castTo($next_8(inEdge$iterator), 12);
        sourceNode = inEdge.source.owner;
        if ($getGraph(sourceNode) == graph) {
          $connectChild(this$static, graph, externalPort, inEdge, inEdge.source, externalPort.dummyPort);
        }
         else if (!parentNode || isDescendant(sourceNode, parentNode)) {
          continue;
        }
         else {
          newExternalPort = $introduceHierarchicalEdgeSegment(this$static, graph, parentNode, inEdge, externalPort.dummyPort, INPUT, currentExternalPort);
          newExternalPort != currentExternalPort && (createdExternalPorts.array[createdExternalPorts.array.length] = newExternalPort , true);
          newExternalPort.exported && (currentExternalPort = newExternalPort);
        }
      }
    }
  }
  for (externalPort$iterator = new ArrayList$1(createdExternalPorts); externalPort$iterator.i < externalPort$iterator.this$01.array.length;) {
    externalPort = castTo($next_8(externalPort$iterator), 187);
    $indexOf_0(graph.layerlessNodes, externalPort.dummyNode, 0) != -1 || $add_11(graph.layerlessNodes, externalPort.dummyNode);
    externalPort.exported && (exportedExternalPorts.array[exportedExternalPorts.array.length] = externalPort , true);
  }
}

function $processInsideSelfLoops(this$static, nestedGraph, node){
  var dummyEdge, isInsideSelfLoop, isSelfLoop, lport, lport$iterator, outEdge, outEdge$index, outEdge$max, outEdges, sourceExtPortDummy, sourcePort, targetExtPortDummy, targetPort;
  if (!unsafeCast(checkNotNull_1(castToBoolean($getProperty(node, ($clinit_LayoutOptions() , SELF_LOOP_INSIDE)))))) {
    return;
  }
  for (lport$iterator = new ArrayList$1(node.ports); lport$iterator.i < lport$iterator.this$01.array.length;) {
    lport = castTo($next_8(lport$iterator), 7);
    outEdges = castTo($toArray_1(lport.outgoingEdges, initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LEdge_2_classLit, $intern_57, 12, lport.outgoingEdges.array.length, 0, 1)), 47);
    for (outEdge$index = 0 , outEdge$max = outEdges.length; outEdge$index < outEdge$max; ++outEdge$index) {
      outEdge = outEdges[outEdge$index];
      isSelfLoop = outEdge.target.owner == node;
      isInsideSelfLoop = isSelfLoop && unsafeCast(checkNotNull_1(castToBoolean($getProperty(outEdge, SELF_LOOP_INSIDE))));
      if (isInsideSelfLoop) {
        sourcePort = outEdge.source;
        sourceExtPortDummy = castTo($get_9(this$static.dummyNodeMap, sourcePort), 9);
        if (!sourceExtPortDummy) {
          sourceExtPortDummy = createExternalPortDummy(sourcePort, ($clinit_PortConstraints() , FREE), sourcePort.side, -1, sourcePort.size_0, castTo($getProperty(nestedGraph, DIRECTION), 59), nestedGraph);
          $setProperty(sourceExtPortDummy, ($clinit_InternalProperties() , ORIGIN), sourcePort);
          $put_2(this$static.dummyNodeMap, sourcePort, sourceExtPortDummy);
          $add_11(nestedGraph.layerlessNodes, sourceExtPortDummy);
        }
        targetPort = outEdge.target;
        targetExtPortDummy = castTo($get_9(this$static.dummyNodeMap, targetPort), 9);
        if (!targetExtPortDummy) {
          targetExtPortDummy = createExternalPortDummy(targetPort, ($clinit_PortConstraints() , FREE), targetPort.side, 1, targetPort.size_0, castTo($getProperty(nestedGraph, DIRECTION), 59), nestedGraph);
          $setProperty(targetExtPortDummy, ($clinit_InternalProperties() , ORIGIN), targetPort);
          $put_2(this$static.dummyNodeMap, targetPort, targetExtPortDummy);
          $add_11(nestedGraph.layerlessNodes, targetExtPortDummy);
        }
        dummyEdge = $createDummyEdge(outEdge);
        $setSource(dummyEdge, castTo($get_8(sourceExtPortDummy.ports, 0), 7));
        $setTarget(dummyEdge, castTo($get_8(targetExtPortDummy.ports, 0), 7));
        $put(this$static.crossHierarchyMap, outEdge, new CrossHierarchyEdge(dummyEdge, nestedGraph, ($clinit_PortType() , OUTPUT)));
        castTo($getProperty(nestedGraph, ($clinit_InternalProperties() , GRAPH_PROPERTIES)), 18).add_1(($clinit_GraphProperties() , EXTERNAL_PORTS));
      }
    }
  }
}

function $processOuterHierarchicalEdgeSegments(this$static, graph, parentNode, exportedExternalPorts){
  var childNode, childNode$iterator, childPort, childPort$iterator, createdExternalPorts, currentExternalInputPort, currentExternalOutputPort, externalPort, externalPort$iterator, inEdge, inEdge$array, inEdge$index, inEdge$max, newExternalPort, outEdge, outEdge$array, outEdge$index, outEdge$max;
  createdExternalPorts = new ArrayList;
  for (childNode$iterator = new ArrayList$1(graph.layerlessNodes); childNode$iterator.i < childNode$iterator.this$01.array.length;) {
    childNode = castTo($next_8(childNode$iterator), 9);
    for (childPort$iterator = new ArrayList$1(childNode.ports); childPort$iterator.i < childPort$iterator.this$01.array.length;) {
      childPort = castTo($next_8(childPort$iterator), 7);
      currentExternalOutputPort = null;
      for (outEdge$array = castTo($toArray_1(childPort.outgoingEdges, initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LEdge_2_classLit, $intern_57, 12, 0, 0, 1)), 47) , outEdge$index = 0 , outEdge$max = outEdge$array.length; outEdge$index < outEdge$max; ++outEdge$index) {
        outEdge = outEdge$array[outEdge$index];
        if (!isDescendant(outEdge.target.owner, parentNode)) {
          newExternalPort = $introduceHierarchicalEdgeSegment(this$static, graph, parentNode, outEdge, outEdge.source, ($clinit_PortType() , OUTPUT), currentExternalOutputPort);
          newExternalPort != currentExternalOutputPort && (createdExternalPorts.array[createdExternalPorts.array.length] = newExternalPort , true);
          newExternalPort.exported && (currentExternalOutputPort = newExternalPort);
        }
      }
      currentExternalInputPort = null;
      for (inEdge$array = castTo($toArray_1(childPort.incomingEdges, initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LEdge_2_classLit, $intern_57, 12, 0, 0, 1)), 47) , inEdge$index = 0 , inEdge$max = inEdge$array.length; inEdge$index < inEdge$max; ++inEdge$index) {
        inEdge = inEdge$array[inEdge$index];
        if (!isDescendant(inEdge.source.owner, parentNode)) {
          newExternalPort = $introduceHierarchicalEdgeSegment(this$static, graph, parentNode, inEdge, inEdge.target, ($clinit_PortType() , INPUT), currentExternalInputPort);
          newExternalPort != currentExternalInputPort && (createdExternalPorts.array[createdExternalPorts.array.length] = newExternalPort , true);
          newExternalPort.exported && (currentExternalInputPort = newExternalPort);
        }
      }
    }
  }
  for (externalPort$iterator = new ArrayList$1(createdExternalPorts); externalPort$iterator.i < externalPort$iterator.this$01.array.length;) {
    externalPort = castTo($next_8(externalPort$iterator), 187);
    $indexOf_0(graph.layerlessNodes, externalPort.dummyNode, 0) != -1 || $add_11(graph.layerlessNodes, externalPort.dummyNode);
    externalPort.exported && (exportedExternalPorts.array[exportedExternalPorts.array.length] = externalPort , true);
  }
}

function $transformHierarchyEdges(this$static, graph, parentNode){
  var childPorts, containedExternalPorts, dummyNode, exportedExternalPorts, nestedGraph, node, node$iterator, port, port$iterator;
  containedExternalPorts = new ArrayList;
  for (node$iterator = new ArrayList$1(graph.layerlessNodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 9);
    nestedGraph = castTo($getProperty(node, ($clinit_InternalProperties() , NESTED_LGRAPH)), 55);
    if (nestedGraph) {
      childPorts = $transformHierarchyEdges(this$static, nestedGraph, node);
      $addAll_6(containedExternalPorts, childPorts);
      $processInsideSelfLoops(this$static, nestedGraph, node);
      if (castTo($getProperty(nestedGraph, GRAPH_PROPERTIES), 18).contains(($clinit_GraphProperties() , EXTERNAL_PORTS))) {
        for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
          port = castTo($next_8(port$iterator), 7);
          if ($get_9(this$static.dummyNodeMap, port) == null) {
            dummyNode = createExternalPortDummy(port, ($clinit_PortConstraints() , FREE), port.side, -(port.incomingEdges.array.length - port.outgoingEdges.array.length), port.size_0, castTo($getProperty(nestedGraph, ($clinit_LayoutOptions() , DIRECTION)), 59), nestedGraph);
            $setProperty(dummyNode, ORIGIN, port);
            $put_2(this$static.dummyNodeMap, port, dummyNode);
            $add_11(nestedGraph.layerlessNodes, dummyNode);
          }
        }
      }
    }
  }
  exportedExternalPorts = new ArrayList;
  $processInnerHierarchicalEdgeSegments(this$static, graph, parentNode, containedExternalPorts, exportedExternalPorts);
  !!parentNode && $processOuterHierarchicalEdgeSegments(this$static, graph, parentNode, exportedExternalPorts);
  return exportedExternalPorts;
}

function CompoundGraphPreprocessor(){
  this.dummyNodeMap = ($clinit_Maps() , new HashMap);
}

defineClass(368, 1, $intern_56, CompoundGraphPreprocessor);
_.process = function process_0(graph, monitor){
  $process_2(this, graph, monitor);
}
;
var Lde_cau_cs_kieler_klay_layered_compound_CompoundGraphPreprocessor_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.compound', 'CompoundGraphPreprocessor', 368);
function CompoundGraphPreprocessor$ExternalPort(origEdge, newEdge, dummyNode, dummyPort, portType, exported){
  this.origEdges = new ArrayList;
  this.type_0 = ($clinit_PortType() , UNDEFINED_7);
  $add_11(this.origEdges, origEdge);
  this.newEdge = newEdge;
  this.dummyNode = dummyNode;
  this.dummyPort = dummyPort;
  this.type_0 = portType;
  this.exported = exported;
}

defineClass(187, 1, {187:1}, CompoundGraphPreprocessor$ExternalPort);
_.exported = false;
var Lde_cau_cs_kieler_klay_layered_compound_CompoundGraphPreprocessor$ExternalPort_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.compound', 'CompoundGraphPreprocessor/ExternalPort', 187);
function $getActualSource(this$static){
  if (this$static.newEdge.source.owner.type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
    return castTo($getProperty(this$static.newEdge.source.owner, ($clinit_InternalProperties() , ORIGIN)), 7);
  }
  return this$static.newEdge.source;
}

function $getActualTarget(this$static){
  if (this$static.newEdge.target.owner.type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
    return castTo($getProperty(this$static.newEdge.target.owner, ($clinit_InternalProperties() , ORIGIN)), 7);
  }
  return this$static.newEdge.target;
}

function CrossHierarchyEdge(newEdge, graph, type_0){
  this.newEdge = newEdge;
  this.graph = graph;
  this.type_0 = type_0;
}

defineClass(114, 1, {114:1}, CrossHierarchyEdge);
_.toString_0 = function toString_48(){
  return $toString_2(this.type_0) + ':' + $toString_7(this.newEdge);
}
;
var Lde_cau_cs_kieler_klay_layered_compound_CrossHierarchyEdge_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.compound', 'CrossHierarchyEdge', 114);
function $compare_3(this$static, edge1, edge2){
  var level1, level2;
  if (edge1.type_0 == ($clinit_PortType() , OUTPUT) && edge2.type_0 == INPUT) {
    return -1;
  }
   else if (edge1.type_0 == INPUT && edge2.type_0 == OUTPUT) {
    return 1;
  }
  level1 = hierarchyLevel(edge1.graph, this$static.graph);
  level2 = hierarchyLevel(edge2.graph, this$static.graph);
  return edge1.type_0 == OUTPUT?level2 - level1:level1 - level2;
}

function CrossHierarchyEdgeComparator(graph){
  this.graph = graph;
}

function hierarchyLevel(nestedGraph, topLevelGraph){
  var currentGraph, currentNode, level;
  currentGraph = nestedGraph;
  level = 0;
  do {
    if (currentGraph == topLevelGraph) {
      return level;
    }
    currentNode = castTo($getProperty(currentGraph, ($clinit_InternalProperties() , PARENT_LNODE)), 9);
    if (!currentNode) {
      throw new IllegalArgumentException;
    }
    currentGraph = $getGraph(currentNode);
    ++level;
  }
   while (true);
}

defineClass(310, 1, $intern_9, CrossHierarchyEdgeComparator);
_.compare_0 = function compare_15(edge1, edge2){
  return $compare_3(this, castTo(edge1, 114), castTo(edge2, 114));
}
;
var Lde_cau_cs_kieler_klay_layered_compound_CrossHierarchyEdgeComparator_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.compound', 'CrossHierarchyEdgeComparator', 310);
defineClass(147, 131, {179:1, 131:1, 147:1, 3:1});
_.id_0 = 0;
var Lde_cau_cs_kieler_klay_layered_graph_LGraphElement_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.graph', 'LGraphElement', 147);
function $isSelfLoop(this$static){
  if (!this$static.source || !this$static.target) {
    return false;
  }
  return !!this$static.source.owner && this$static.source.owner == this$static.target.owner;
}

function $reverse_0(this$static, adaptPorts){
  var label_0, label$iterator, labelPlacement, oldSource, oldTarget, reversed;
  oldSource = this$static.source;
  oldTarget = this$static.target;
  $setSource(this$static, null);
  $setTarget(this$static, null);
  adaptPorts && unsafeCast(checkNotNull_1(castToBoolean($getProperty(oldTarget, ($clinit_InternalProperties() , INPUT_COLLECT)))))?$setSource(this$static, provideCollectorPort(oldTarget.owner, ($clinit_PortType() , OUTPUT), ($clinit_PortSide() , EAST))):$setSource(this$static, oldTarget);
  adaptPorts && unsafeCast(checkNotNull_1(castToBoolean($getProperty(oldSource, ($clinit_InternalProperties() , OUTPUT_COLLECT)))))?$setTarget(this$static, provideCollectorPort(oldSource.owner, ($clinit_PortType() , INPUT), ($clinit_PortSide() , WEST))):$setTarget(this$static, oldSource);
  for (label$iterator = new ArrayList$1(this$static.labels); label$iterator.i < label$iterator.this$01.array.length;) {
    label_0 = castTo($next_8(label$iterator), 33);
    labelPlacement = castTo($getProperty(label_0, ($clinit_LayoutOptions() , EDGE_LABEL_PLACEMENT)), 107);
    labelPlacement == ($clinit_EdgeLabelPlacement() , TAIL)?$setProperty(label_0, EDGE_LABEL_PLACEMENT, HEAD):labelPlacement == HEAD && $setProperty(label_0, EDGE_LABEL_PLACEMENT, TAIL);
  }
  reversed = unsafeCast(checkNotNull_1(castToBoolean($getProperty(this$static, ($clinit_InternalProperties() , REVERSED)))));
  $setProperty(this$static, REVERSED, ($clinit_Boolean() , reversed?FALSE_0:TRUE_0));
  this$static.bendPoints = reverse_1(this$static.bendPoints);
}

function $setSource(this$static, source){
  !!this$static.source && $remove_7(this$static.source.outgoingEdges, this$static);
  this$static.source = source;
  !!this$static.source && $add_11(this$static.source.outgoingEdges, this$static);
}

function $setTarget(this$static, target){
  !!this$static.target && $remove_7(this$static.target.incomingEdges, this$static);
  this$static.target = target;
  !!this$static.target && $add_11(this$static.target.incomingEdges, this$static);
}

function $setTargetAndInsertAtIndex(this$static, targetPort, index_0){
  !!this$static.target && $remove_7(this$static.target.incomingEdges, this$static);
  this$static.target = targetPort;
  !!this$static.target && $add_10(this$static.target.incomingEdges, index_0, this$static);
}

function $toString_7(this$static){
  return !!this$static.source && !!this$static.target?this$static.source.owner + '(' + this$static.source + ')->' + this$static.target.owner + '(' + this$static.target + ')':'e_' + getObjectIdentityHashCode(this$static);
}

function LEdge(){
  this.bendPoints = new KVectorChain;
  this.labels = (checkNonnegative(3, 'initialArraySize') , new ArrayList_0(3));
}

defineClass(12, 147, {179:1, 131:1, 12:1, 147:1, 3:1}, LEdge);
_.toString_0 = function toString_49(){
  return $toString_7(this);
}
;
var Lde_cau_cs_kieler_klay_layered_graph_LEdge_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.graph', 'LEdge', 12);
function $toNodeArray(this$static){
  var layer, layerIndex, layerIter, lgraphArray;
  lgraphArray = initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LNode_2_classLit, $intern_0, 51, this$static.layers.array.length, 0, 2);
  layerIter = new AbstractList$ListIteratorImpl(this$static.layers, 0);
  while (layerIter.i < layerIter.this$01_0.size_1()) {
    layer = (checkCriticalElement(layerIter.i < layerIter.this$01_0.size_1()) , castTo(layerIter.this$01_0.get_2(layerIter.last = layerIter.i++), 16));
    layerIndex = layerIter.i - 1;
    lgraphArray[layerIndex] = castTo($toArray_1(layer.nodes, initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LNode_2_classLit, $intern_49, 9, layer.nodes.array.length, 0, 1)), 51);
  }
  return lgraphArray;
}

function LGraph(){
  this.size_0 = new KVector;
  this.insets = new LInsets_0;
  this.offset = new KVector;
  this.layerlessNodes = new ArrayList;
  this.layers = new ArrayList;
}

defineClass(55, 147, {179:1, 131:1, 55:1, 147:1, 3:1, 22:1}, LGraph);
_.iterator_0 = function iterator_44(){
  return new ArrayList$1(this.layers);
}
;
_.toString_0 = function toString_50(){
  if (this.layers.array.length == 0) {
    return 'G-unlayered' + $toString_5(this.layerlessNodes);
  }
   else if (this.layerlessNodes.array.length == 0) {
    return 'G-layered' + $toString_5(this.layers);
  }
  return 'G[layerless' + $toString_5(this.layerlessNodes) + ', layers' + $toString_5(this.layers) + ']';
}
;
var Lde_cau_cs_kieler_klay_layered_graph_LGraph_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.graph', 'LGraph', 55);
function $clinit_LGraphAdapters(){
  $clinit_LGraphAdapters = emptyMethod;
  new LGraphAdapters$PortComparator;
}

function $getProperty_0(this$static, prop){
  if ($equals_4(prop, ($clinit_LayoutOptions() , SPACING))) {
    return $getProperty(this$static.element, ($clinit_InternalProperties() , SPACING_0));
  }
   else if ($equals_4(prop, OFFSET)) {
    return $getProperty(this$static.element, ($clinit_InternalProperties() , OFFSET_0));
  }
  return $getProperty(this$static.element, prop);
}

function $setSize(this$static, size_0){
  this$static.element.size_0.x_0 = size_0.x_0;
  this$static.element.size_0.y_0 = size_0.y_0;
}

function $setVolatileId(this$static, volatileId){
  this$static.element.id_0 = volatileId;
}

defineClass(273, 1, {});
_.getSize = function getSize(){
  return this.element.size_0;
}
;
var Lde_cau_cs_kieler_klay_layered_graph_LGraphAdapters$AbstractLShapeAdapter_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.graph', 'LGraphAdapters/AbstractLShapeAdapter', 273);
function $getLabels(this$static){
  var l, l$iterator;
  if (!this$static.labelAdapters) {
    this$static.labelAdapters = newArrayListWithCapacity(this$static.element.labels.array.length);
    for (l$iterator = new ArrayList$1(this$static.element.labels); l$iterator.i < l$iterator.this$01.array.length;) {
      l = castTo($next_8(l$iterator), 33);
      $add_11(this$static.labelAdapters, new LGraphAdapters$LLabelAdapter(l));
    }
  }
  return this$static.labelAdapters;
}

function LGraphAdapters$LEdgeAdapter(edge){
  this.element = edge;
}

defineClass(240, 1, {626:1}, LGraphAdapters$LEdgeAdapter);
_.labelAdapters = null;
var Lde_cau_cs_kieler_klay_layered_graph_LGraphAdapters$LEdgeAdapter_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.graph', 'LGraphAdapters/LEdgeAdapter', 240);
function $getNodes(this$static){
  var l, l$iterator, n, n$iterator;
  if (!this$static.nodeAdapters) {
    this$static.nodeAdapters = new ArrayList;
    for (l$iterator = new ArrayList$1(this$static.element.layers); l$iterator.i < l$iterator.this$01.array.length;) {
      l = castTo($next_8(l$iterator), 16);
      for (n$iterator = new ArrayList$1(l.nodes); n$iterator.i < n$iterator.this$01.array.length;) {
        n = castTo($next_8(n$iterator), 9);
        $add_11(this$static.nodeAdapters, new LGraphAdapters$LNodeAdapter(n, this$static.transparentNorthSouthEdges));
      }
    }
  }
  return this$static.nodeAdapters;
}

function $getProperty_1(this$static, prop){
  return $getProperty(this$static.element, prop);
}

function LGraphAdapters$LGraphAdapter(element, transparentNorthSouthEdges){
  this.element = element;
  this.transparentNorthSouthEdges = transparentNorthSouthEdges;
}

defineClass(325, 1, {}, LGraphAdapters$LGraphAdapter);
_.getSize = function getSize_0(){
  return this.element.size_0;
}
;
_.nodeAdapters = null;
_.transparentNorthSouthEdges = false;
var Lde_cau_cs_kieler_klay_layered_graph_LGraphAdapters$LGraphAdapter_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.graph', 'LGraphAdapters/LGraphAdapter', 325);
function LGraphAdapters$LLabelAdapter(element){
  this.element = element;
}

defineClass(224, 273, {129:1, 224:1}, LGraphAdapters$LLabelAdapter);
var Lde_cau_cs_kieler_klay_layered_graph_LGraphAdapters$LLabelAdapter_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.graph', 'LGraphAdapters/LLabelAdapter', 224);
function $getLabels_0(this$static){
  var l, l$iterator;
  if (!this$static.labelAdapters) {
    this$static.labelAdapters = newArrayListWithCapacity(castTo(this$static.element, 9).labels.array.length);
    for (l$iterator = new ArrayList$1(castTo(this$static.element, 9).labels); l$iterator.i < l$iterator.this$01.array.length;) {
      l = castTo($next_8(l$iterator), 33);
      $add_11(this$static.labelAdapters, new LGraphAdapters$LLabelAdapter(l));
    }
  }
  return this$static.labelAdapters;
}

function $getPorts(this$static){
  var p, p$iterator;
  if (!this$static.portAdapters) {
    this$static.portAdapters = newArrayListWithCapacity(castTo(this$static.element, 9).ports.array.length);
    for (p$iterator = new ArrayList$1(castTo(this$static.element, 9).ports); p$iterator.i < p$iterator.this$01.array.length;) {
      p = castTo($next_8(p$iterator), 7);
      $add_11(this$static.portAdapters, new LGraphAdapters$LPortAdapter(p, this$static.transparentNorthSouthEdges));
    }
  }
  return this$static.portAdapters;
}

function LGraphAdapters$LNodeAdapter(element, transparentNorthSouthEdges){
  this.element = element;
  this.transparentNorthSouthEdges = transparentNorthSouthEdges;
}

defineClass(555, 273, {625:1}, LGraphAdapters$LNodeAdapter);
_.labelAdapters = null;
_.portAdapters = null;
_.transparentNorthSouthEdges = false;
var Lde_cau_cs_kieler_klay_layered_graph_LGraphAdapters$LNodeAdapter_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.graph', 'LGraphAdapters/LNodeAdapter', 555);
function $getIncomingEdges(this$static){
  var e, e$iterator, e$iterator0, portDummy;
  if (this$static.transparentNorthSouthEdges && castTo(this$static.element, 7).owner.type_0 == ($clinit_LNode$NodeType() , NORTH_SOUTH_PORT)) {
    return $clinit_Collections() , $clinit_Collections() , EMPTY_LIST;
  }
   else if (!this$static.incomingEdgeAdapters) {
    this$static.incomingEdgeAdapters = new ArrayList;
    for (e$iterator0 = new ArrayList$1(castTo(this$static.element, 7).incomingEdges); e$iterator0.i < e$iterator0.this$01.array.length;) {
      e = castTo($next_8(e$iterator0), 12);
      $add_11(this$static.incomingEdgeAdapters, new LGraphAdapters$LEdgeAdapter(e));
    }
    if (this$static.transparentNorthSouthEdges) {
      portDummy = castTo($getProperty(castTo(this$static.element, 7), ($clinit_InternalProperties() , PORT_DUMMY)), 9);
      if (portDummy) {
        for (e$iterator = $iterator($getIncomingEdges_0(portDummy)); $hasNext_0(e$iterator);) {
          e = castTo($next_2(e$iterator), 12);
          $add_11(this$static.incomingEdgeAdapters, new LGraphAdapters$LEdgeAdapter(e));
        }
      }
    }
  }
  return this$static.incomingEdgeAdapters;
}

function $getLabels_1(this$static){
  var l, l$iterator;
  if (!this$static.labelAdapters) {
    this$static.labelAdapters = newArrayListWithCapacity(castTo(this$static.element, 7).labels.array.length);
    for (l$iterator = new ArrayList$1(castTo(this$static.element, 7).labels); l$iterator.i < l$iterator.this$01.array.length;) {
      l = castTo($next_8(l$iterator), 33);
      $add_11(this$static.labelAdapters, new LGraphAdapters$LLabelAdapter(l));
    }
  }
  return this$static.labelAdapters;
}

function $getOutgoingEdges(this$static){
  var e, e$iterator, e$iterator0, portDummy;
  if (this$static.transparentNorthSouthEdges && castTo(this$static.element, 7).owner.type_0 == ($clinit_LNode$NodeType() , NORTH_SOUTH_PORT)) {
    return $clinit_Collections() , $clinit_Collections() , EMPTY_LIST;
  }
   else if (!this$static.outgoingEdgeAdapters) {
    this$static.outgoingEdgeAdapters = new ArrayList;
    for (e$iterator0 = new ArrayList$1(castTo(this$static.element, 7).outgoingEdges); e$iterator0.i < e$iterator0.this$01.array.length;) {
      e = castTo($next_8(e$iterator0), 12);
      $add_11(this$static.outgoingEdgeAdapters, new LGraphAdapters$LEdgeAdapter(e));
    }
    if (this$static.transparentNorthSouthEdges) {
      portDummy = castTo($getProperty(castTo(this$static.element, 7), ($clinit_InternalProperties() , PORT_DUMMY)), 9);
      if (portDummy) {
        for (e$iterator = $iterator($getOutgoingEdges_0(portDummy)); $hasNext_0(e$iterator);) {
          e = castTo($next_2(e$iterator), 12);
          $add_11(this$static.outgoingEdgeAdapters, new LGraphAdapters$LEdgeAdapter(e));
        }
      }
    }
  }
  return this$static.outgoingEdgeAdapters;
}

function LGraphAdapters$LPortAdapter(element, transparentNorthSouthEdges){
  this.element = element;
  this.transparentNorthSouthEdges = transparentNorthSouthEdges;
}

defineClass(556, 273, {161:1}, LGraphAdapters$LPortAdapter);
_.incomingEdgeAdapters = null;
_.labelAdapters = null;
_.outgoingEdgeAdapters = null;
_.transparentNorthSouthEdges = false;
var Lde_cau_cs_kieler_klay_layered_graph_LGraphAdapters$LPortAdapter_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.graph', 'LGraphAdapters/LPortAdapter', 556);
function $compare_4(port1, port2){
  var index1, index2, indexDifference, ordinalDifference;
  ordinalDifference = port1.side.ordinal - port2.side.ordinal;
  if (ordinalDifference != 0) {
    return ordinalDifference;
  }
  index1 = castTo($getProperty(port1, ($clinit_LayoutOptions() , PORT_INDEX)), 24);
  index2 = castTo($getProperty(port2, PORT_INDEX), 24);
  if (!!index1 && !!index2) {
    indexDifference = index1.value_0 - index2.value_0;
    if (indexDifference != 0) {
      return indexDifference;
    }
  }
  switch (port1.side.ordinal) {
    case 1:
      return compare_31(port1.pos.x_0, port2.pos.x_0);
    case 2:
      return compare_31(port1.pos.y_0, port2.pos.y_0);
    case 3:
      return compare_31(port2.pos.x_0, port1.pos.x_0);
    case 4:
      return compare_31(port2.pos.y_0, port1.pos.y_0);
    default:throw new IllegalStateException_0('Port side is undefined');
  }
}

function LGraphAdapters$PortComparator(){
}

defineClass(557, 1, $intern_9, LGraphAdapters$PortComparator);
_.compare_0 = function compare_16(port1, port2){
  return $compare_4(castTo(port1, 7), castTo(port2, 7));
}
;
var Lde_cau_cs_kieler_klay_layered_graph_LGraphAdapters$PortComparator_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.graph', 'LGraphAdapters/PortComparator', 557);
function calcPortOffset(port, side){
  var node;
  node = port.owner;
  switch (side.ordinal) {
    case 1:
      return -(port.pos.y_0 + port.size_0.y_0);
    case 2:
      return port.pos.x_0 - node.size_0.x_0;
    case 3:
      return port.pos.y_0 - node.size_0.y_0;
    case 4:
      return -(port.pos.x_0 + port.size_0.x_0);
  }
  return 0;
}

function calcPortSide(port, direction){
  var height, heightPercent, node, nodeHeight, nodeWidth, width_0, widthPercent, xpos, ypos;
  node = port.owner;
  nodeWidth = node.size_0.x_0;
  nodeHeight = node.size_0.y_0;
  if (nodeWidth <= 0 && nodeHeight <= 0) {
    return $clinit_PortSide() , UNDEFINED_4;
  }
  xpos = port.pos.x_0;
  ypos = port.pos.y_0;
  width_0 = port.size_0.x_0;
  height = port.size_0.y_0;
  switch (direction.ordinal) {
    case 2:
    case 1:
      if (xpos < 0) {
        return $clinit_PortSide() , WEST;
      }
       else if (xpos + width_0 > nodeWidth) {
        return $clinit_PortSide() , EAST;
      }

      break;
    case 4:
    case 3:
      if (ypos < 0) {
        return $clinit_PortSide() , NORTH;
      }
       else if (ypos + height > nodeHeight) {
        return $clinit_PortSide() , SOUTH;
      }

  }
  widthPercent = (xpos + width_0 / 2) / nodeWidth;
  heightPercent = (ypos + height / 2) / nodeHeight;
  return widthPercent + heightPercent <= 1 && widthPercent - heightPercent <= 0?($clinit_PortSide() , WEST):widthPercent + heightPercent >= 1 && widthPercent - heightPercent >= 0?($clinit_PortSide() , EAST):heightPercent < 0.5?($clinit_PortSide() , NORTH):($clinit_PortSide() , SOUTH);
}

function centerPoint(point, boundary, side){
  switch (side.ordinal) {
    case 1:
      point.x_0 = boundary.x_0 / 2;
      point.y_0 = 0;
      break;
    case 2:
      point.x_0 = boundary.x_0;
      point.y_0 = boundary.y_0 / 2;
      break;
    case 3:
      point.x_0 = boundary.x_0 / 2;
      point.y_0 = boundary.y_0;
      break;
    case 4:
      point.x_0 = 0;
      point.y_0 = boundary.y_0 / 2;
  }
}

function changeCoordSystem(point, oldGraph, newGraph){
  var graph, insets, node;
  if (oldGraph == newGraph) {
    return;
  }
  graph = oldGraph;
  do {
    $add_7(point, graph.offset);
    node = castTo($getProperty(graph, ($clinit_InternalProperties() , PARENT_LNODE)), 9);
    if (node) {
      insets = graph.insets;
      $add_6(point, insets.left, insets.top_0);
      $add_7(point, node.pos);
      graph = $getGraph(node);
    }
  }
   while (node);
  graph = newGraph;
  do {
    $sub_0(point, graph.offset);
    node = castTo($getProperty(graph, ($clinit_InternalProperties() , PARENT_LNODE)), 9);
    if (node) {
      insets = graph.insets;
      $sub(point, insets.left, insets.top_0);
      $sub_0(point, node.pos);
      graph = $getGraph(node);
    }
  }
   while (node);
}

function createExternalPortDummy(propertyHolder, portConstraints, portSide, netFlow, portSize, layoutDirection, layeredGraph){
  var actualDirection, anchor, dummy, dummyPort, finalExternalPortSide, positionOrRatio;
  finalExternalPortSide = portSide;
  dummy = new LNode(layeredGraph);
  $setType(dummy, ($clinit_LNode$NodeType() , EXTERNAL_PORT));
  $setProperty(dummy, ($clinit_InternalProperties() , EXT_PORT_SIZE), portSize);
  $setProperty(dummy, ($clinit_LayoutOptions() , PORT_CONSTRAINTS), ($clinit_PortConstraints() , FIXED_POS));
  $setProperty(dummy, OFFSET_0, castTo($getProperty(propertyHolder, OFFSET), 15));
  anchor = castTo($getProperty(propertyHolder, PORT_ANCHOR), 10);
  !anchor && (anchor = new KVector_1(portSize.x_0 / 2, portSize.y_0 / 2));
  $setProperty(dummy, PORT_ANCHOR, anchor);
  dummyPort = new LPort;
  $setNode(dummyPort, dummy);
  if (!(portConstraints != FREE && portConstraints != UNDEFINED_3)) {
    actualDirection = layoutDirection != ($clinit_Direction() , UNDEFINED)?layoutDirection:RIGHT_0;
    netFlow > 0?(finalExternalPortSide = fromDirection(actualDirection)):(finalExternalPortSide = $opposed(fromDirection(actualDirection)));
    $setProperty(propertyHolder, PORT_SIDE, finalExternalPortSide);
  }
  switch (finalExternalPortSide.ordinal) {
    case 4:
      $setProperty(dummy, ($clinit_Properties() , LAYER_CONSTRAINT), ($clinit_LayerConstraint() , FIRST_SEPARATE));
      $setProperty(dummy, EDGE_CONSTRAINT, ($clinit_EdgeConstraint() , OUTGOING_ONLY));
      dummy.size_0.y_0 = portSize.y_0;
      $setSide(dummyPort, ($clinit_PortSide() , EAST));
      dummyPort.pos.y_0 = anchor.y_0;
      break;
    case 2:
      $setProperty(dummy, ($clinit_Properties() , LAYER_CONSTRAINT), ($clinit_LayerConstraint() , LAST_SEPARATE));
      $setProperty(dummy, EDGE_CONSTRAINT, ($clinit_EdgeConstraint() , INCOMING_ONLY));
      dummy.size_0.y_0 = portSize.y_0;
      $setSide(dummyPort, ($clinit_PortSide() , WEST));
      dummyPort.pos.y_0 = anchor.y_0;
      break;
    case 1:
      $setProperty(dummy, IN_LAYER_CONSTRAINT, ($clinit_InLayerConstraint() , TOP_0));
      dummy.size_0.x_0 = portSize.x_0;
      $setSide(dummyPort, ($clinit_PortSide() , SOUTH));
      dummyPort.pos.x_0 = anchor.x_0;
      break;
    case 3:
      $setProperty(dummy, IN_LAYER_CONSTRAINT, ($clinit_InLayerConstraint() , BOTTOM_0));
      dummy.size_0.x_0 = portSize.x_0;
      $setSide(dummyPort, ($clinit_PortSide() , NORTH));
      dummyPort.pos.x_0 = anchor.x_0;
  }
  if (portConstraints == FIXED_ORDER || portConstraints == FIXED_RATIO || portConstraints == FIXED_POS) {
    positionOrRatio = 0;
    switch (finalExternalPortSide.ordinal) {
      case 4:
      case 2:
        positionOrRatio = null.$_nullField;
        portConstraints == FIXED_RATIO && (positionOrRatio /= null.$_nullField);
        break;
      case 1:
      case 3:
        positionOrRatio = null.$_nullField;
        portConstraints == FIXED_RATIO && (positionOrRatio /= null.$_nullField);
    }
    $setProperty(dummy, PORT_RATIO_OR_POSITION_0, positionOrRatio);
  }
  $setProperty(dummy, EXT_PORT_SIDE, finalExternalPortSide);
  return dummy;
}

function createPort(node, endPoint, type_0, layeredGraph){
  var defaultSide, direction, graphProperties, mergePorts, port, portSide, pos;
  direction = getDirection_1(layeredGraph);
  mergePorts = unsafeCast(checkNotNull_1(castToBoolean($getProperty(layeredGraph, ($clinit_Properties() , MERGE_EDGES)))));
  if ((mergePorts || unsafeCast(checkNotNull_1(castToBoolean($getProperty(node, ($clinit_LayoutOptions() , HYPERNODE)))))) && !$isSideFixed(castTo($getProperty(node, ($clinit_LayoutOptions() , PORT_CONSTRAINTS)), 28))) {
    defaultSide = fromDirection(direction);
    port = provideCollectorPort(node, type_0, type_0 == ($clinit_PortType() , OUTPUT)?defaultSide:$opposed(defaultSide));
  }
   else {
    port = new LPort;
    $setNode(port, node);
    pos = port.pos;
    pos.x_0 = endPoint.x_0 - node.pos.x_0;
    pos.y_0 = endPoint.y_0 - node.pos.y_0;
    $bound(pos, node.size_0.x_0, node.size_0.y_0);
    $setSide(port, calcPortSide(port, direction));
    graphProperties = castTo($getProperty(layeredGraph, ($clinit_InternalProperties() , GRAPH_PROPERTIES)), 18);
    portSide = port.side;
    switch (direction.ordinal) {
      case 2:
      case 1:
        (portSide == ($clinit_PortSide() , NORTH) || portSide == SOUTH) && graphProperties.add_1(($clinit_GraphProperties() , NORTH_SOUTH_PORTS));
        break;
      case 4:
      case 3:
        (portSide == ($clinit_PortSide() , EAST) || portSide == WEST) && graphProperties.add_1(($clinit_GraphProperties() , NORTH_SOUTH_PORTS));
    }
  }
  return port;
}

function getDirection_1(graph){
  var aspectRatio, direction;
  direction = castTo($getProperty(graph, ($clinit_LayoutOptions() , DIRECTION)), 59);
  if (direction == ($clinit_Direction() , UNDEFINED)) {
    aspectRatio = castTo($getProperty(graph, ($clinit_InternalProperties() , ASPECT_RATIO_0)), 15).value_0;
    return aspectRatio >= 1?RIGHT_0:DOWN;
  }
  return direction;
}

function getExternalPortPosition(graph, portDummy, portWidth, portHeight){
  var graphOffset, graphSize, insets, portOffset, portPosition;
  portPosition = new KVector_2(portDummy.pos);
  portPosition.x_0 += portDummy.size_0.x_0 / 2;
  portPosition.y_0 += portDummy.size_0.y_0 / 2;
  portOffset = castTo($getProperty(portDummy, ($clinit_InternalProperties() , OFFSET_0)), 15).value_0;
  graphSize = graph.size_0;
  insets = graph.insets;
  graphOffset = graph.offset;
  switch (castTo($getProperty(portDummy, EXT_PORT_SIDE), 32).ordinal) {
    case 1:
      portPosition.x_0 += insets.left + graphOffset.x_0 - portWidth / 2;
      portPosition.y_0 = -portHeight - portOffset;
      portDummy.pos.y_0 = -(insets.top_0 + portOffset + graphOffset.y_0);
      break;
    case 2:
      portPosition.x_0 = graphSize.x_0 + insets.left + insets.right + portOffset;
      portPosition.y_0 += insets.top_0 + graphOffset.y_0 - portHeight / 2;
      portDummy.pos.x_0 = graphSize.x_0 + insets.right + portOffset - graphOffset.x_0;
      break;
    case 3:
      portPosition.x_0 += insets.left + graphOffset.x_0 - portWidth / 2;
      portPosition.y_0 = graphSize.y_0 + insets.top_0 + insets.bottom + portOffset;
      portDummy.pos.y_0 = graphSize.y_0 + insets.bottom + portOffset - graphOffset.y_0;
      break;
    case 4:
      portPosition.x_0 = -portWidth - portOffset;
      portPosition.y_0 += insets.top_0 + graphOffset.y_0 - portHeight / 2;
      portDummy.pos.x_0 = -(insets.left + portOffset + graphOffset.x_0);
  }
  return portPosition;
}

function initializePort(port, portConstraints, direction, anchorPos){
  var nodeHeight, nodeWidth, portSide, portSize, ratio;
  portSide = port.side;
  if (portSide == ($clinit_PortSide() , UNDEFINED_4) && portConstraints != ($clinit_PortConstraints() , FREE) && portConstraints != ($clinit_PortConstraints() , UNDEFINED_3)) {
    portSide = calcPortSide(port, direction);
    $setSide(port, portSide);
    $getProperty(port, ($clinit_LayoutOptions() , OFFSET)) == null && portSide != UNDEFINED_4 && (port.pos.x_0 != 0 || port.pos.y_0 != 0) && $setProperty(port, OFFSET, new Float_0(calcPortOffset(port, portSide)));
  }
  if (portConstraints == ($clinit_PortConstraints() , FIXED_RATIO)) {
    ratio = 0;
    switch (portSide.ordinal) {
      case 1:
      case 3:
        nodeWidth = port.owner.size_0.x_0;
        nodeWidth > 0 && (ratio = port.pos.x_0 / nodeWidth);
        break;
      case 2:
      case 4:
        nodeHeight = port.owner.size_0.y_0;
        nodeHeight > 0 && (ratio = port.pos.y_0 / nodeHeight);
    }
    $setProperty(port, ($clinit_InternalProperties() , PORT_RATIO_OR_POSITION_0), ratio);
  }
  portSize = port.size_0;
  if (anchorPos) {
    port.anchor.x_0 = anchorPos.x_0;
    port.anchor.y_0 = anchorPos.y_0;
  }
   else if (portConstraints != FREE && portConstraints != UNDEFINED_3 && portSide != UNDEFINED_4) {
    switch (portSide.ordinal) {
      case 1:
        port.anchor.x_0 = portSize.x_0 / 2;
        break;
      case 2:
        port.anchor.x_0 = portSize.x_0;
        port.anchor.y_0 = portSize.y_0 / 2;
        break;
      case 3:
        port.anchor.x_0 = portSize.x_0 / 2;
        port.anchor.y_0 = portSize.y_0;
        break;
      case 4:
        port.anchor.y_0 = portSize.y_0 / 2;
    }
  }
   else {
    port.anchor.x_0 = portSize.x_0 / 2;
    port.anchor.y_0 = portSize.y_0 / 2;
  }
}

function isDescendant(child, parent_0){
  var next;
  next = castTo($getProperty($getGraph(child), ($clinit_InternalProperties() , PARENT_LNODE)), 9);
  while (next) {
    if (next == parent_0) {
      return true;
    }
    next = castTo($getProperty($getGraph(next), PARENT_LNODE), 9);
  }
  return false;
}

function offsetGraph(graph, offsetx, offsety){
  var edge, edge$iterator, graphOffset, junctionPoints, label_0, label$iterator, node, node$iterator, port, port$iterator;
  graphOffset = new KVector_1(offsetx, offsety);
  for (node$iterator = new ArrayList$1(graph.layerlessNodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 9);
    $add_7(node.pos, graphOffset);
    for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_8(port$iterator), 7);
      for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
        edge = castTo($next_8(edge$iterator), 12);
        $offset(edge.bendPoints, graphOffset);
        junctionPoints = castTo($getProperty(edge, ($clinit_LayoutOptions() , JUNCTION_POINTS)), 44);
        !!junctionPoints && $offset(junctionPoints, graphOffset);
        for (label$iterator = new ArrayList$1(edge.labels); label$iterator.i < label$iterator.this$01.array.length;) {
          label_0 = castTo($next_8(label$iterator), 33);
          $add_7(label_0.pos, graphOffset);
        }
      }
    }
  }
}

function placeNodesHorizontally(layer, xoffset){
  var alignment, inports, leftMargin, maxLeftMargin, maxRightMargin, node, node$iterator, node$iterator0, nodeSize, outports, port, port$iterator, ratio, rightMargin, size_0, xpos;
  maxLeftMargin = 0;
  maxRightMargin = 0;
  for (node$iterator0 = new ArrayList$1(layer.nodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
    node = castTo($next_8(node$iterator0), 9);
    maxLeftMargin = max_1(maxLeftMargin, node.margin.left);
    maxRightMargin = max_1(maxRightMargin, node.margin.right);
  }
  for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 9);
    alignment = castTo($getProperty(node, ($clinit_LayoutOptions() , ALIGNMENT)), 103);
    switch (alignment.ordinal) {
      case 1:
        ratio = 0;
        break;
      case 2:
        ratio = 1;
        break;
      case 5:
        ratio = 0.5;
        break;
      default:inports = 0;
        outports = 0;
        for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
          port = castTo($next_8(port$iterator), 7);
          port.incomingEdges.array.length == 0 || ++inports;
          port.outgoingEdges.array.length == 0 || ++outports;
        }

        inports + outports == 0?(ratio = 0.5):(ratio = outports / (inports + outports));
    }
    size_0 = layer.size_0;
    nodeSize = node.size_0.x_0;
    xpos = (size_0.x_0 - nodeSize) * ratio;
    ratio > 0.5?(xpos -= maxRightMargin * 2 * (ratio - 0.5)):ratio < 0.5 && (xpos += maxLeftMargin * 2 * (0.5 - ratio));
    leftMargin = node.margin.left;
    xpos < leftMargin && (xpos = leftMargin);
    rightMargin = node.margin.right;
    xpos > size_0.x_0 - rightMargin - nodeSize && (xpos = size_0.x_0 - rightMargin - nodeSize);
    node.pos.x_0 = xoffset + xpos;
  }
}

function provideCollectorPort(node, type_0, side){
  var inport, inport$iterator, outport, outport$iterator, port;
  port = null;
  switch (type_0.ordinal) {
    case 1:
      for (inport$iterator = new ArrayList$1(node.ports); inport$iterator.i < inport$iterator.this$01.array.length;) {
        inport = castTo($next_8(inport$iterator), 7);
        if (unsafeCast(checkNotNull_1(castToBoolean($getProperty(inport, ($clinit_InternalProperties() , INPUT_COLLECT)))))) {
          return inport;
        }
      }

      port = new LPort;
      $setProperty(port, ($clinit_InternalProperties() , INPUT_COLLECT), ($clinit_Boolean() , $clinit_Boolean() , TRUE_0));
      break;
    case 2:
      for (outport$iterator = new ArrayList$1(node.ports); outport$iterator.i < outport$iterator.this$01.array.length;) {
        outport = castTo($next_8(outport$iterator), 7);
        if (unsafeCast(checkNotNull_1(castToBoolean($getProperty(outport, ($clinit_InternalProperties() , OUTPUT_COLLECT)))))) {
          return outport;
        }
      }

      port = new LPort;
      $setProperty(port, ($clinit_InternalProperties() , OUTPUT_COLLECT), ($clinit_Boolean() , $clinit_Boolean() , TRUE_0));
  }
  if (port) {
    $setNode(port, node);
    $setSide(port, side);
    centerPoint(port.pos, node.size_0, side);
  }
  return port;
}

function resizeNode(node, newSize, movePorts){
  var all, fixedPorts, heightDiff, heightPercent, heightRatio, label_0, label$iterator, midx, midy, oldSize, port, port$iterator, widthDiff, widthPercent, widthRatio;
  oldSize = new KVector_2(node.size_0);
  widthRatio = newSize.x_0 / oldSize.x_0;
  heightRatio = newSize.y_0 / oldSize.y_0;
  widthDiff = newSize.x_0 - oldSize.x_0;
  heightDiff = newSize.y_0 - oldSize.y_0;
  if (movePorts) {
    fixedPorts = maskUndefined($getProperty(node, ($clinit_LayoutOptions() , PORT_CONSTRAINTS))) === maskUndefined(($clinit_PortConstraints() , FIXED_POS));
    for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_8(port$iterator), 7);
      switch (port.side.ordinal) {
        case 1:
          fixedPorts || (port.pos.x_0 *= widthRatio);
          break;
        case 2:
          port.pos.x_0 += widthDiff;
          fixedPorts || (port.pos.y_0 *= heightRatio);
          break;
        case 3:
          fixedPorts || (port.pos.x_0 *= widthRatio);
          port.pos.y_0 += heightDiff;
          break;
        case 4:
          fixedPorts || (port.pos.y_0 *= heightRatio);
      }
    }
  }
  for (label$iterator = new ArrayList$1(node.labels); label$iterator.i < label$iterator.this$01.array.length;) {
    label_0 = castTo($next_8(label$iterator), 33);
    midx = label_0.pos.x_0 + label_0.size_0.x_0 / 2;
    midy = label_0.pos.y_0 + label_0.size_0.y_0 / 2;
    widthPercent = midx / oldSize.x_0;
    heightPercent = midy / oldSize.y_0;
    if (widthPercent + heightPercent >= 1) {
      if (widthPercent - heightPercent > 0 && midy >= 0) {
        label_0.pos.x_0 += widthDiff;
        label_0.pos.y_0 += heightDiff * heightPercent;
      }
       else if (widthPercent - heightPercent < 0 && midx >= 0) {
        label_0.pos.x_0 += widthDiff * widthPercent;
        label_0.pos.y_0 += heightDiff;
      }
    }
  }
  node.size_0.x_0 = newSize.x_0;
  node.size_0.y_0 = newSize.y_0;
  $setProperty(node, ($clinit_LayoutOptions() , SIZE_CONSTRAINT), ($clinit_SizeConstraint() , all = castTo($getEnumConstants(Lde_cau_cs_kieler_kiml_options_SizeConstraint_2_classLit), 11) , new EnumSet$EnumSetImpl(all, castTo(createFrom(all, all.length), 11), 0)));
}

function $$init_4(this$static){
}

function $copy(this$static, other){
  this$static.left = other.left;
  this$static.right = other.right;
  this$static.top_0 = other.top_0;
  this$static.bottom = other.bottom;
}

function LInsets(){
  $$init_4(this);
}

function LInsets_0(){
  $$init_4(this);
  this.top_0 = 0;
  this.left = 0;
  this.bottom = 0;
  this.right = 0;
}

defineClass(168, 1, {168:1}, LInsets, LInsets_0);
_.equals = function equals_35(obj){
  var other;
  if (instanceOf(obj, 168)) {
    other = castTo(obj, 168);
    return this.top_0 == other.top_0 && this.bottom == other.bottom && this.left == other.left && this.right == other.right;
  }
   else {
    return false;
  }
}
;
_.hashCode_0 = function hashCode_35(){
  var code1, code2;
  code1 = round_int(checkNotNull_1(this.left)) << 16;
  code1 |= round_int(checkNotNull_1(this.bottom)) & $intern_6;
  code2 = round_int(checkNotNull_1(this.right)) << 16;
  code2 |= round_int(checkNotNull_1(this.top_0)) & $intern_6;
  return code1 ^ code2;
}
;
_.toString_0 = function toString_51(){
  return 'Insets[top=' + this.top_0 + ',left=' + this.left + ',bottom=' + this.bottom + ',right=' + this.right + ']';
}
;
_.bottom = 0;
_.left = 0;
_.right = 0;
_.top_0 = 0;
var Lde_cau_cs_kieler_klay_layered_graph_LInsets_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.graph', 'LInsets', 168);
function LShape(){
  this.pos = new KVector;
  this.size_0 = new KVector;
}

defineClass(165, 147, {179:1, 131:1, 147:1, 165:1, 3:1});
var Lde_cau_cs_kieler_klay_layered_graph_LShape_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.graph', 'LShape', 165);
function LLabel(thetext){
  LShape.call(this);
  this.text_0 = thetext;
}

defineClass(33, 165, {179:1, 131:1, 147:1, 33:1, 165:1, 3:1}, LLabel);
_.toString_0 = function toString_52(){
  return this.text_0 == null?'l_' + this.id_0:'l_' + this.text_0;
}
;
var Lde_cau_cs_kieler_klay_layered_graph_LLabel_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.graph', 'LLabel', 33);
function $borderToContentAreaCoordinates(this$static, horizontal, vertical){
  var borderSpacing, graphInsets, offset, pos, thegraph;
  thegraph = $getGraph(this$static);
  graphInsets = thegraph.insets;
  borderSpacing = castTo($getProperty(thegraph, ($clinit_InternalProperties() , BORDER_SPACING_0)), 15).value_0;
  offset = thegraph.offset;
  pos = this$static.pos;
  horizontal && (pos.x_0 = pos.x_0 - graphInsets.left - borderSpacing - offset.x_0);
  vertical && (pos.y_0 = pos.y_0 - graphInsets.top_0 - borderSpacing - offset.y_0);
}

function $getConnectedEdges(this$static){
  var iterables, port, port$iterator;
  iterables = new ArrayList;
  for (port$iterator = new ArrayList$1(this$static.ports); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_8(port$iterator), 7);
    $add_11(iterables, concat(($clinit_ImmutableList() , new RegularImmutableList(nullCheckedList(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [port.incomingEdges, port.outgoingEdges]))))));
  }
  return checkNotNull(iterables) , new FluentIterable$2(iterables);
}

function $getGraph(this$static){
  if (!this$static.graph && !!this$static.layer) {
    return this$static.layer.owner;
  }
  return this$static.graph;
}

function $getIncomingEdges_0(this$static){
  var iterables, port, port$iterator;
  iterables = new ArrayList;
  for (port$iterator = new ArrayList$1(this$static.ports); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_8(port$iterator), 7);
    $add_11(iterables, port.incomingEdges);
  }
  return checkNotNull(iterables) , new FluentIterable$2(iterables);
}

function $getIndex(this$static){
  return !this$static.layer?-1:$indexOf_0(this$static.layer.nodes, this$static, 0);
}

function $getInteractiveReferencePoint(this$static){
  var nodePos, nodeSize;
  switch (castTo($getProperty($getGraph(this$static), ($clinit_Properties() , INTERACTIVE_REFERENCE_POINT)), 174).ordinal) {
    case 0:
      nodePos = this$static.pos;
      nodeSize = this$static.size_0;
      return new KVector_1(nodePos.x_0 + nodeSize.x_0 / 2, nodePos.y_0 + nodeSize.y_0 / 2);
    case 1:
      return new KVector_2(this$static.pos);
    default:return null;
  }
}

function $getName(this$static){
  if (this$static.labels.array.length != 0) {
    return castTo($get_8(this$static.labels, 0), 33).text_0;
  }
  return null;
}

function $getOutgoingEdges_0(this$static){
  var iterables, port, port$iterator;
  iterables = new ArrayList;
  for (port$iterator = new ArrayList$1(this$static.ports); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_8(port$iterator), 7);
    $add_11(iterables, port.outgoingEdges);
  }
  return checkNotNull(iterables) , new FluentIterable$2(iterables);
}

function $getPorts_0(this$static, side){
  switch (side.ordinal) {
    case 1:
      return filter_0(this$static.ports, ($clinit_LPort() , NORTH_PREDICATE));
    case 2:
      return filter_0(this$static.ports, ($clinit_LPort() , EAST_PREDICATE));
    case 3:
      return filter_0(this$static.ports, ($clinit_LPort() , SOUTH_PREDICATE));
    case 4:
      return filter_0(this$static.ports, ($clinit_LPort() , WEST_PREDICATE));
    default:return $clinit_Collections() , $clinit_Collections() , EMPTY_LIST;
  }
}

function $getPorts_1(this$static, portType){
  switch (portType.ordinal) {
    case 1:
      return filter_0(this$static.ports, ($clinit_LPort() , INPUT_PREDICATE));
    case 2:
      return filter_0(this$static.ports, ($clinit_LPort() , OUTPUT_PREDICATE));
    default:return $clinit_Collections() , $clinit_Collections() , EMPTY_LIST;
  }
}

function $getPorts_2(this$static, portType, side){
  var sidePredicate, typePredicate;
  typePredicate = null;
  switch (portType.ordinal) {
    case 1:
      typePredicate = ($clinit_LPort() , INPUT_PREDICATE);
      break;
    case 2:
      typePredicate = ($clinit_LPort() , OUTPUT_PREDICATE);
  }
  sidePredicate = null;
  switch (side.ordinal) {
    case 1:
      sidePredicate = ($clinit_LPort() , NORTH_PREDICATE);
      break;
    case 2:
      sidePredicate = ($clinit_LPort() , EAST_PREDICATE);
      break;
    case 3:
      sidePredicate = ($clinit_LPort() , SOUTH_PREDICATE);
      break;
    case 4:
      sidePredicate = ($clinit_LPort() , WEST_PREDICATE);
  }
  return !!typePredicate && !!sidePredicate?filter_0(this$static.ports, ($clinit_Predicates() , new Predicates$AndPredicate(new Arrays$ArrayList(stampJavaTypeInfo(getClassLiteralForArray(Lcom_google_common_base_Predicate_2_classLit, 1), $intern_12, 68, 0, [castTo(checkNotNull(typePredicate), 68), castTo(checkNotNull(sidePredicate), 68)]))))):($clinit_Collections() , $clinit_Collections() , EMPTY_LIST);
}

function $setLayer(this$static, index_0, newlayer){
  if (!!newlayer && (index_0 < 0 || index_0 > newlayer.nodes.array.length)) {
    throw new IllegalArgumentException_0('index must be >= 0 and <= layer node count');
  }
  !!this$static.layer && $remove_7(this$static.layer.nodes, this$static);
  this$static.layer = newlayer;
  !!newlayer && $add_10(newlayer.nodes, index_0, this$static);
}

function $setLayer_0(this$static, thelayer){
  !!this$static.layer && $remove_7(this$static.layer.nodes, this$static);
  this$static.layer = thelayer;
  !!this$static.layer && $add_11(this$static.layer.nodes, this$static);
}

function $setType(this$static, type_0){
  this$static.type_0 = type_0;
}

function $toString_8(this$static){
  var name_0;
  return name_0 = $getName(this$static) , 'n_' + (name_0 == null?toString_78(this$static.id_0):name_0);
}

function LNode(graph){
  LShape.call(this);
  this.type_0 = ($clinit_LNode$NodeType() , NORMAL);
  this.ports = (checkNonnegative(6, 'initialArraySize') , new ArrayList_0(6));
  this.labels = (checkNonnegative(2, 'initialArraySize') , new ArrayList_0(2));
  this.margin = new LInsets;
  this.insets = new LInsets;
  this.graph = graph;
}

defineClass(9, 165, {179:1, 131:1, 147:1, 9:1, 165:1, 3:1}, LNode);
_.toString_0 = function toString_53(){
  return $toString_8(this);
}
;
var Lde_cau_cs_kieler_klay_layered_graph_LNode_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.graph', 'LNode', 9);
function $clinit_LNode$NodeType(){
  $clinit_LNode$NodeType = emptyMethod;
  NORMAL = new LNode$NodeType('NORMAL', 0);
  LONG_EDGE = new LNode$NodeType('LONG_EDGE', 1);
  EXTERNAL_PORT = new LNode$NodeType('EXTERNAL_PORT', 2);
  NORTH_SOUTH_PORT = new LNode$NodeType('NORTH_SOUTH_PORT', 3);
  LABEL = new LNode$NodeType('LABEL', 4);
  BIG_NODE = new LNode$NodeType('BIG_NODE', 5);
}

function LNode$NodeType(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function values_30(){
  $clinit_LNode$NodeType();
  return stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_graph_LNode$NodeType_2_classLit, 1), $intern_13, 132, 0, [NORMAL, LONG_EDGE, EXTERNAL_PORT, NORTH_SOUTH_PORT, LABEL, BIG_NODE]);
}

defineClass(132, 17, {132:1, 3:1, 23:1, 17:1}, LNode$NodeType);
var BIG_NODE, EXTERNAL_PORT, LABEL, LONG_EDGE, NORMAL, NORTH_SOUTH_PORT;
var Lde_cau_cs_kieler_klay_layered_graph_LNode$NodeType_2_classLit = createForEnum('de.cau.cs.kieler.klay.layered.graph', 'LNode/NodeType', 132, Ljava_lang_Enum_2_classLit, values_30);
function $clinit_LPort(){
  $clinit_LPort = emptyMethod;
  OUTPUT_PREDICATE = new LPort$1;
  INPUT_PREDICATE = new LPort$2;
  NORTH_PREDICATE = new LPort$3;
  EAST_PREDICATE = new LPort$4;
  SOUTH_PREDICATE = new LPort$5;
  WEST_PREDICATE = new LPort$6;
}

function $getAbsoluteAnchor(this$static){
  return sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [this$static.owner.pos, this$static.pos, this$static.anchor]));
}

function $getDegree(this$static){
  return this$static.incomingEdges.array.length + this$static.outgoingEdges.array.length;
}

function $getName_0(this$static){
  if (this$static.labels.array.length != 0) {
    return castTo($get_8(this$static.labels, 0), 33).text_0;
  }
  return null;
}

function $setNode(this$static, node){
  !!this$static.owner && $remove_7(this$static.owner.ports, this$static);
  this$static.owner = node;
  !!this$static.owner && $add_11(this$static.owner.ports, this$static);
}

function $setSide(this$static, theside){
  if (!theside) {
    throw new NullPointerException;
  }
  this$static.side = theside;
}

function LPort(){
  $clinit_LPort();
  LShape.call(this);
  this.side = ($clinit_PortSide() , UNDEFINED_4);
  this.anchor = new KVector;
  this.margin = new LInsets;
  this.labels = (checkNonnegative(2, 'initialArraySize') , new ArrayList_0(2));
  this.incomingEdges = (checkNonnegative(4, 'initialArraySize') , new ArrayList_0(4));
  this.outgoingEdges = (checkNonnegative(4, 'initialArraySize') , new ArrayList_0(4));
}

defineClass(7, 165, {179:1, 131:1, 147:1, 7:1, 165:1, 3:1}, LPort);
_.toString_0 = function toString_54(){
  var text_0;
  return text_0 = $getName_0(this) , text_0 == null?'p_' + this.id_0:'p_' + text_0;
}
;
var EAST_PREDICATE, INPUT_PREDICATE, NORTH_PREDICATE, OUTPUT_PREDICATE, SOUTH_PREDICATE, WEST_PREDICATE;
var Lde_cau_cs_kieler_klay_layered_graph_LPort_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.graph', 'LPort', 7);
function $apply_0(port){
  return castTo(port, 7).outgoingEdges.array.length != 0;
}

function LPort$1(){
}

defineClass(399, 1, $intern_52, LPort$1);
_.apply_1 = function apply_19(port){
  return $apply_0(port);
}
;
var Lde_cau_cs_kieler_klay_layered_graph_LPort$1_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.graph', 'LPort/1', 399);
function $apply_1(port){
  return castTo(port, 7).incomingEdges.array.length != 0;
}

function LPort$2(){
}

defineClass(400, 1, $intern_52, LPort$2);
_.apply_1 = function apply_20(port){
  return $apply_1(port);
}
;
var Lde_cau_cs_kieler_klay_layered_graph_LPort$2_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.graph', 'LPort/2', 400);
function LPort$3(){
}

defineClass(401, 1, $intern_52, LPort$3);
_.apply_1 = function apply_21(port){
  return castTo(port, 7).side == ($clinit_PortSide() , NORTH);
}
;
var Lde_cau_cs_kieler_klay_layered_graph_LPort$3_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.graph', 'LPort/3', 401);
function LPort$4(){
}

defineClass(402, 1, $intern_52, LPort$4);
_.apply_1 = function apply_22(port){
  return castTo(port, 7).side == ($clinit_PortSide() , EAST);
}
;
var Lde_cau_cs_kieler_klay_layered_graph_LPort$4_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.graph', 'LPort/4', 402);
function LPort$5(){
}

defineClass(403, 1, $intern_52, LPort$5);
_.apply_1 = function apply_23(port){
  return castTo(port, 7).side == ($clinit_PortSide() , SOUTH);
}
;
var Lde_cau_cs_kieler_klay_layered_graph_LPort$5_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.graph', 'LPort/5', 403);
function LPort$6(){
}

defineClass(404, 1, $intern_52, LPort$6);
_.apply_1 = function apply_24(port){
  return castTo(port, 7).side == ($clinit_PortSide() , WEST);
}
;
var Lde_cau_cs_kieler_klay_layered_graph_LPort$6_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.graph', 'LPort/6', 404);
function LPort$7(this$0){
  this.this$01 = this$0;
}

defineClass(190, 1, $intern_30, LPort$7);
_.iterator_0 = function iterator_45(){
  var edgesIter;
  edgesIter = new ArrayList$1(this.this$01.incomingEdges);
  return new LPort$7$1(edgesIter);
}
;
var Lde_cau_cs_kieler_klay_layered_graph_LPort$7_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.graph', 'LPort/7', 190);
function LPort$7$1(val$edgesIter){
  this.val$edgesIter2 = val$edgesIter;
}

defineClass(405, 1, $intern_18, LPort$7$1);
_.next_1 = function next_22(){
  return castTo($next_8(this.val$edgesIter2), 12).source;
}
;
_.hasNext_0 = function hasNext_21(){
  return $hasNext_3(this.val$edgesIter2);
}
;
_.remove = function remove_45(){
  $remove_12(this.val$edgesIter2);
}
;
var Lde_cau_cs_kieler_klay_layered_graph_LPort$7$1_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.graph', 'LPort/7/1', 405);
function LPort$8(this$0){
  this.this$01 = this$0;
}

defineClass(169, 1, $intern_30, LPort$8);
_.iterator_0 = function iterator_46(){
  var edgesIter;
  return edgesIter = new ArrayList$1(this.this$01.outgoingEdges) , new LPort$8$1(edgesIter);
}
;
var Lde_cau_cs_kieler_klay_layered_graph_LPort$8_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.graph', 'LPort/8', 169);
function LPort$8$1(val$edgesIter){
  this.val$edgesIter2 = val$edgesIter;
}

defineClass(304, 1, $intern_18, LPort$8$1);
_.next_1 = function next_23(){
  return castTo($next_8(this.val$edgesIter2), 12).target;
}
;
_.hasNext_0 = function hasNext_22(){
  return $hasNext_3(this.val$edgesIter2);
}
;
_.remove = function remove_46(){
  $remove_12(this.val$edgesIter2);
}
;
var Lde_cau_cs_kieler_klay_layered_graph_LPort$8$1_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.graph', 'LPort/8/1', 304);
function $getIndex_0(this$static){
  return $indexOf_0(this$static.owner.layers, this$static, 0);
}

function Layer(graph){
  this.size_0 = new KVector;
  this.nodes = new ArrayList;
  this.owner = graph;
}

defineClass(16, 147, {179:1, 131:1, 147:1, 16:1, 3:1, 22:1}, Layer);
_.iterator_0 = function iterator_47(){
  return new ArrayList$1(this.nodes);
}
;
_.toString_0 = function toString_55(){
  return 'L_' + $indexOf_0(this.owner.layers, this, 0) + $toString_5(this.nodes);
}
;
var Lde_cau_cs_kieler_klay_layered_graph_Layer_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.graph', 'Layer', 16);
function $condenseBigNodesChain(this$static, start_0, left){
  var edge, edge$iterator, gap, newIndex, newLayer, outs, target;
  outs = newLinkedList($getOutgoingEdges_0(start_0));
  for (edge$iterator = $listIterator_2(outs, 0); edge$iterator.currentNode != edge$iterator.this$01.tail;) {
    edge = castTo($next_11(edge$iterator), 12);
    target = edge.target.owner;
    if (!(unsafeCast(checkNotNull_1(castToBoolean($getProperty(target, ($clinit_InternalProperties() , BIG_NODE_INITIAL))))) && $getProperty(target, ORIGIN) != null) && target.type_0 == ($clinit_LNode$NodeType() , BIG_NODE) && !unsafeCast(checkNotNull_1(castToBoolean($getProperty(edge, REVERSED)))) && edge.target.side == ($clinit_PortSide() , WEST)) {
      gap = $getIndex_0(target.layer) - $getIndex_0(start_0.layer);
      if (gap > 1) {
        left?(newIndex = $getIndex_0(start_0.layer) + 1):(newIndex = $getIndex_0(target.layer) - 1);
        newLayer = castTo($get_8(this$static.layeredGraph.layers, newIndex), 16);
        $setLayer_0(target, newLayer);
      }
      $condenseBigNodesChain(this$static, target, left);
    }
  }
  return start_0;
}

function BigNodesIntermediateProcessor(){
}

defineClass(437, 1, $intern_56, BigNodesIntermediateProcessor);
_.process = function process_1(theLayeredGraph, monitor){
  var bigNodes, last, layer, layer$iterator, node, node$iterator, nodes;
  $begin(monitor, 'Big nodes intermediate-processing', 1);
  this.layeredGraph = theLayeredGraph;
  for (layer$iterator = new ArrayList$1(this.layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator), 16);
    nodes = newLinkedList(layer.nodes);
    bigNodes = filter_0(nodes, new BigNodesIntermediateProcessor$1);
    for (node$iterator = filter_1(bigNodes.val$unfiltered1.iterator_0(), bigNodes.val$retainIfTrue2); $hasNext(node$iterator);) {
      node = castTo($next(node$iterator), 9);
      if (maskUndefined($getProperty(node, ($clinit_Properties() , LAYER_CONSTRAINT))) === maskUndefined(($clinit_LayerConstraint() , LAST)) || maskUndefined($getProperty(node, LAYER_CONSTRAINT)) === maskUndefined(LAST_SEPARATE)) {
        last = $condenseBigNodesChain(this, node, false);
        $setProperty(last, LAYER_CONSTRAINT, castTo($getProperty(node, LAYER_CONSTRAINT), 85));
        $setProperty(node, LAYER_CONSTRAINT, NONE_5);
      }
       else {
        $condenseBigNodesChain(this, node, true);
      }
    }
  }
  $done(monitor);
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_BigNodesIntermediateProcessor_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'BigNodesIntermediateProcessor', 437);
function $apply_2(node){
  return unsafeCast(checkNotNull_1(castToBoolean($getProperty(node, ($clinit_InternalProperties() , BIG_NODE_INITIAL))))) && $getProperty(node, ORIGIN) != null;
}

function BigNodesIntermediateProcessor$1(){
}

defineClass(438, 1, $intern_52, BigNodesIntermediateProcessor$1);
_.apply_1 = function apply_25(node){
  return $apply_2(castTo(node, 9));
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_BigNodesIntermediateProcessor$1_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'BigNodesIntermediateProcessor/1', 438);
function $apply_3(this$static){
  var f, f$array, f$index, f$max;
  for (f$array = this$static.funs , f$index = 0 , f$max = f$array.length; f$index < f$max; ++f$index) {
    f = f$array[f$index];
    f.apply_0(null);
  }
  return null;
}

function BigNodesLabelHandler$CompoundFunction(funs){
  this.funs = funs;
}

function of_2(funs){
  var f, f$iterator, funsArr, i;
  funsArr = initUnidimensionalArray(Lcom_google_common_base_Function_2_classLit, $intern_12, 63, funs.array.length, 0, 1);
  i = 0;
  for (f$iterator = new ArrayList$1(funs); f$iterator.i < f$iterator.this$01.array.length;) {
    f = castTo($next_8(f$iterator), 63);
    funsArr[i++] = f;
  }
  return new BigNodesLabelHandler$CompoundFunction(funsArr);
}

defineClass(582, 1, $intern_35, BigNodesLabelHandler$CompoundFunction);
_.apply_0 = function apply_26(v){
  var lastArg;
  return $apply_3((lastArg = this , throwClassCastExceptionUnlessNull(v) , lastArg));
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_BigNodesLabelHandler$CompoundFunction_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'BigNodesLabelHandler/CompoundFunction', 582);
function $handleLabels(this$static){
  var i, l, l$iterator, placement, postProcess;
  $setProperty(this$static.node, ($clinit_InternalProperties() , BIGNODES_ORIG_LABELS), newLinkedList(this$static.node.labels));
  for (i = 1; i < this$static.dummies.array.length - 1; ++i) {
    $setProperty(castTo($get_8(this$static.dummies, i), 9), ($clinit_LayoutOptions() , NODE_LABEL_PLACEMENT), ($clinit_NodeLabelPlacement() , of_4(INSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_NodeLabelPlacement_2_classLit, 1), $intern_13, 41, 0, [V_CENTER, H_CENTER]))));
  }
  for (l$iterator = $listIterator_2(newLinkedList(this$static.node.labels), 0); l$iterator.currentNode != l$iterator.this$01.tail;) {
    l = castTo($next_11(l$iterator), 33);
    placement = castTo($getProperty(this$static.node, ($clinit_LayoutOptions() , NODE_LABEL_PLACEMENT)), 86);
    if ($containsAll(placement, of_4(($clinit_NodeLabelPlacement() , OUTSIDE), stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_NodeLabelPlacement_2_classLit, 1), $intern_13, 41, 0, [H_LEFT, V_CENTER]))))
    ;
    else if ($containsAll(placement, of_4(OUTSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_NodeLabelPlacement_2_classLit, 1), $intern_13, 41, 0, [H_RIGHT, V_CENTER])))) {
      $add_11(this$static.lastDummy.labels, l);
      $remove_7(this$static.node.labels, l);
      postProcess = new BigNodesLabelHandler$Handler$2(this$static, l);
      $setProperty(this$static.node, BIGNODES_POST_PROCESS, postProcess);
    }
     else {
      $splitAndDistributeLabel(this$static, l);
      $add_11(this$static.postProcs, this$static.funRemoveLabelDummies);
      $setProperty(this$static.node, BIGNODES_POST_PROCESS, of_2(this$static.postProcs));
    }
  }
}

function $splitAndDistributeLabel(this$static, lab){
  var dumLab, dummy, fun, i, lPos, labelChunkSize, length_0, rPos, subLabel, text_0;
  length_0 = length_1(lab.text_0);
  labelChunkSize = round_int(ceil_0(length_0 / this$static.chunks));
  text_0 = lab.text_0;
  lPos = 0;
  rPos = labelChunkSize;
  for (i = 0; i < this$static.chunks; ++i) {
    subLabel = ($clinit_String() , text_0.substr((0 > lPos?0:lPos) < length_0?0 > lPos?0:lPos:length_0, (0 > (rPos < length_0?rPos:length_0)?0:rPos < length_0?rPos:length_0) - ((0 > lPos?0:lPos) < length_0?0 > lPos?0:lPos:length_0)));
    lPos = rPos;
    rPos += labelChunkSize;
    dummy = castTo($get_8(this$static.dummies, i), 9);
    dumLab = new LLabel(subLabel);
    dumLab.size_0.y_0 = lab.size_0.y_0;
    $put(this$static.dumLabs, lab, dumLab);
    $add_11(dummy.labels, dumLab);
  }
  $remove_7(this$static.node.labels, lab);
  $add_11(this$static.postProcs, (fun = new BigNodesLabelHandler$Handler$3(this$static, lab) , fun));
}

function BigNodesLabelHandler$Handler(node, dummies, chunkWidth){
  this.dumLabs = new ArrayListMultimap;
  this.postProcs = new ArrayList;
  this.funRemoveLabelDummies = new BigNodesLabelHandler$Handler$1(this);
  this.node = node;
  this.chunks = dummies.array.length;
  this.dummies = dummies;
  this.lastDummy = castTo($get_8(this.dummies, this.dummies.array.length - 1), 9);
  this.minWidth = chunkWidth;
  $handleLabels(this);
}

defineClass(332, 1, {}, BigNodesLabelHandler$Handler);
_.chunks = 0;
_.lastDummy = null;
_.minWidth = 0;
var Lde_cau_cs_kieler_klay_layered_intermediate_BigNodesLabelHandler$Handler_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'BigNodesLabelHandler/Handler', 332);
function $apply_4(this$static){
  var dummy, dummy$iterator, l, l$iterator;
  for (dummy$iterator = new ArrayList$1(this$static.this$11.dummies); dummy$iterator.i < dummy$iterator.this$01.array.length;) {
    dummy = castTo($next_8(dummy$iterator), 9);
    for (l$iterator = $listIterator_2(newLinkedList(dummy.labels), 0); l$iterator.currentNode != l$iterator.this$01.tail;) {
      l = castTo($next_11(l$iterator), 33);
      $getProperty(l, ($clinit_InternalProperties() , ORIGIN)) == null && $remove_7(dummy.labels, l);
    }
  }
  return null;
}

function BigNodesLabelHandler$Handler$1(this$1){
  this.this$11 = this$1;
}

defineClass(583, 1, $intern_35, BigNodesLabelHandler$Handler$1);
_.apply_0 = function apply_27(v){
  var lastArg;
  return $apply_4((lastArg = this , throwClassCastExceptionUnlessNull(v) , lastArg));
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_BigNodesLabelHandler$Handler$1_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'BigNodesLabelHandler/Handler/1', 583);
function $apply_5(this$static){
  this$static.val$l2.pos.x_0 += this$static.this$11.minWidth * (this$static.this$11.chunks - 1);
  return null;
}

function BigNodesLabelHandler$Handler$2(this$1, val$l){
  this.this$11 = this$1;
  this.val$l2 = val$l;
}

defineClass(584, 1, $intern_35, BigNodesLabelHandler$Handler$2);
_.apply_0 = function apply_28(v){
  var lastArg;
  return $apply_5((lastArg = this , throwClassCastExceptionUnlessNull(v) , lastArg));
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_BigNodesLabelHandler$Handler$2_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'BigNodesLabelHandler/Handler/2', 584);
function $apply_6(this$static){
  var all, dumLab, placement, rightMostDum, rightMostLab, rightOffset;
  placement = castTo($getProperty(this$static.this$11.node, ($clinit_LayoutOptions() , NODE_LABEL_PLACEMENT)), 86);
  if ($equals_0(placement, ($clinit_NodeLabelPlacement() , all = castTo($getEnumConstants(Lde_cau_cs_kieler_kiml_options_NodeLabelPlacement_2_classLit), 11) , new EnumSet$EnumSetImpl(all, castTo(createFrom(all, all.length), 11), 0))))
  ;
  else if ($containsAll(placement, of_3(H_LEFT))) {
    dumLab = castTo(castTo($get(this$static.this$11.dumLabs, this$static.val$label2), 20).get_2(0), 33);
    this$static.val$label2.pos.x_0 = dumLab.pos.x_0;
    this$static.val$label2.pos.y_0 = dumLab.pos.y_0;
  }
   else if ($containsAll(placement, of_3(H_RIGHT))) {
    rightMostDum = castTo($get_8(this$static.this$11.dummies, this$static.this$11.dummies.array.length - 1), 9);
    rightMostLab = castTo(castTo($get(this$static.this$11.dumLabs, this$static.val$label2), 20).get_2(castTo($get(this$static.this$11.dumLabs, this$static.val$label2), 20).size_1() - 1), 33);
    rightOffset = rightMostDum.size_0.x_0 - (rightMostLab.pos.x_0 + rightMostLab.size_0.x_0);
    this$static.val$label2.pos.x_0 = this$static.this$11.node.size_0.x_0 - rightOffset - this$static.val$label2.size_0.x_0;
    this$static.val$label2.pos.y_0 = rightMostLab.pos.y_0;
  }
   else if ($containsAll(placement, of_4(V_CENTER, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_NodeLabelPlacement_2_classLit, 1), $intern_13, 41, 0, [H_CENTER])))) {
    dumLab = castTo(castTo($get(this$static.this$11.dumLabs, this$static.val$label2), 20).get_2(0), 33);
    this$static.val$label2.pos.x_0 = (this$static.this$11.node.size_0.x_0 - this$static.val$label2.size_0.x_0) / 2;
    this$static.val$label2.pos.y_0 = dumLab.pos.y_0;
  }
   else if ($containsAll(placement, of_3(V_CENTER))) {
    dumLab = castTo(castTo($get(this$static.this$11.dumLabs, this$static.val$label2), 20).get_2(0), 33);
    this$static.val$label2.pos.y_0 = dumLab.pos.y_0;
  }
   else if ($containsAll(placement, of_3(H_CENTER))) {
    dumLab = castTo(castTo($get(this$static.this$11.dumLabs, this$static.val$label2), 20).get_2(0), 33);
    this$static.val$label2.pos.x_0 = (this$static.this$11.node.size_0.x_0 - this$static.val$label2.size_0.x_0) / 2;
    this$static.val$label2.pos.y_0 = dumLab.pos.y_0;
  }
  return null;
}

function BigNodesLabelHandler$Handler$3(this$1, val$label){
  this.this$11 = this$1;
  this.val$label2 = val$label;
}

defineClass(585, 1, $intern_35, BigNodesLabelHandler$Handler$3);
_.apply_0 = function apply_29(v){
  var lastArg;
  return $apply_6((lastArg = this , throwClassCastExceptionUnlessNull(v) , lastArg));
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_BigNodesLabelHandler$Handler$3_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'BigNodesLabelHandler/Handler/3', 585);
function $removeBigNodeChain(this$static, start_0){
  var edge, edge$iterator, outs, target;
  outs = newLinkedList($getOutgoingEdges_0(start_0));
  for (edge$iterator = $listIterator_2(outs, 0); edge$iterator.currentNode != edge$iterator.this$01.tail;) {
    edge = castTo($next_11(edge$iterator), 12);
    target = edge.target.owner;
    if (target.type_0 == ($clinit_LNode$NodeType() , BIG_NODE) && !(unsafeCast(checkNotNull_1(castToBoolean($getProperty(target, ($clinit_InternalProperties() , BIG_NODE_INITIAL))))) && $getProperty(target, ORIGIN) != null)) {
      $remove_7(target.layer.nodes, target);
      $setNode(edge.source, null);
      $setNode(edge.target, null);
      return $removeBigNodeChain(this$static, target);
    }
     else {
      return start_0;
    }
  }
  return start_0;
}

function BigNodesPostProcessor(){
}

defineClass(439, 1, $intern_56, BigNodesPostProcessor);
_.process = function process_2(theLayeredGraph, monitor){
  var bigNodes, f, labels, lastDummy, layer, layer$iterator, node, node$iterator, offset, originalSize, p, p$iterator, p$iterator0, toMove;
  $begin(monitor, 'Big nodes post-processing', 1);
  this.layeredGraph = theLayeredGraph;
  for (layer$iterator = new ArrayList$1(this.layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator), 16);
    bigNodes = filter_0(layer.nodes, new BigNodesPostProcessor$1);
    for (node$iterator = filter_1(bigNodes.val$unfiltered1.iterator_0(), bigNodes.val$retainIfTrue2); $hasNext(node$iterator);) {
      node = castTo($next(node$iterator), 9);
      originalSize = castTo($getProperty(node, ($clinit_InternalProperties() , BIG_NODE_ORIGINAL_SIZE)), 15);
      lastDummy = $removeBigNodeChain(this, node);
      toMove = new ArrayList;
      for (p$iterator0 = $getPorts_0(lastDummy, ($clinit_PortSide() , EAST)).iterator_0(); p$iterator0.hasNext_0();) {
        p = castTo(p$iterator0.next_1(), 7);
        toMove.array[toMove.array.length] = p;
        offset = p.pos.x_0 - lastDummy.size_0.x_0;
        p.pos.x_0 = originalSize.value_0 + offset;
      }
      node.size_0.x_0 = originalSize.value_0;
      for (p$iterator = new ArrayList$1(toMove); p$iterator.i < p$iterator.this$01.array.length;) {
        p = castTo($next_8(p$iterator), 7);
        $setNode(p, node);
      }
      this.layeredGraph.size_0.x_0 < node.pos.x_0 + node.size_0.x_0 && (this.layeredGraph.size_0.x_0 = node.pos.x_0 + node.size_0.x_0);
      labels = castTo($getProperty(node, BIGNODES_ORIG_LABELS), 20);
      $addAll_6(node.labels, labels);
      f = castTo($getProperty(node, BIGNODES_POST_PROCESS), 63);
      !!f && f.apply_0(null);
    }
  }
  $done(monitor);
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_BigNodesPostProcessor_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'BigNodesPostProcessor', 439);
function $apply_7(node){
  return unsafeCast(checkNotNull_1(castToBoolean($getProperty(node, ($clinit_InternalProperties() , BIG_NODE_INITIAL))))) && $getProperty(node, ORIGIN) != null;
}

function BigNodesPostProcessor$1(){
}

defineClass(440, 1, $intern_52, BigNodesPostProcessor$1);
_.apply_1 = function apply_30(node){
  return $apply_7(castTo(node, 9));
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_BigNodesPostProcessor$1_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'BigNodesPostProcessor/1', 440);
function $isProcessorApplicable(node){
  var edge, edge$iterator, p, p$iterator, port, port$iterator;
  if (maskUndefined($getProperty(node, ($clinit_LayoutOptions() , PORT_CONSTRAINTS))) === maskUndefined(($clinit_PortConstraints() , FIXED_RATIO)) || maskUndefined($getProperty(node, PORT_CONSTRAINTS)) === maskUndefined(FIXED_POS)) {
    for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_8(port$iterator), 7);
      if (port.side == ($clinit_PortSide() , NORTH) || port.side == SOUTH) {
        return false;
      }
    }
  }
  if ($isSideFixed(castTo($getProperty(node, PORT_CONSTRAINTS), 28))) {
    for (p$iterator = $getPorts_0(node, ($clinit_PortSide() , EAST)).iterator_0(); p$iterator.hasNext_0();) {
      p = castTo(p$iterator.next_1(), 7);
      if (p.incomingEdges.array.length != 0) {
        return false;
      }
    }
  }
  for (edge$iterator = $iterator($getOutgoingEdges_0(node)); $hasNext_0(edge$iterator);) {
    edge = castTo($next_2(edge$iterator), 12);
    if (edge.source.owner == edge.target.owner) {
      return false;
    }
  }
  return true;
}

function BigNodesPreProcessor(){
  this.direction = ($clinit_Direction() , UNDEFINED);
}

defineClass(441, 1, $intern_56, BigNodesPreProcessor);
_.process = function process_3(theLayeredGraph, monitor){
  var bigNodes, chunkWidth, counter, minWidth, node, node$iterator, node$iterator0, node$iterator1, node$iterator2, nodes, parts, threshold;
  $begin(monitor, 'Big nodes pre-processing', 1);
  this.layeredGraph = theLayeredGraph;
  nodes = this.layeredGraph.layerlessNodes;
  counter = 0;
  for (node$iterator0 = new ArrayList$1(nodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
    node = castTo($next_8(node$iterator0), 9);
    node.id_0 = counter++;
  }
  this.spacing = castTo($getProperty(this.layeredGraph, ($clinit_InternalProperties() , SPACING_0)), 15).value_0;
  this.direction = castTo($getProperty(this.layeredGraph, ($clinit_LayoutOptions() , DIRECTION)), 59);
  this.dummyID = nodes.array.length;
  minWidth = $intern_58;
  for (node$iterator1 = new ArrayList$1(nodes); node$iterator1.i < node$iterator1.this$01.array.length;) {
    node = castTo($next_8(node$iterator1), 9);
    node.type_0 == ($clinit_LNode$NodeType() , NORMAL) && node.size_0.x_0 < minWidth && (minWidth = node.size_0.x_0);
  }
  minWidth = 50 > minWidth?50:minWidth;
  bigNodes = new ArrayList;
  threshold = minWidth + this.spacing;
  for (node$iterator2 = new ArrayList$1(nodes); node$iterator2.i < node$iterator2.this$01.array.length;) {
    node = castTo($next_8(node$iterator2), 9);
    if (node.type_0 == ($clinit_LNode$NodeType() , NORMAL) && node.size_0.x_0 > threshold) {
      parts = 1;
      chunkWidth = node.size_0.x_0;
      while (chunkWidth > minWidth) {
        ++parts;
        chunkWidth = (node.size_0.x_0 - (parts - 1) * this.spacing) / parts;
      }
      $add_11(bigNodes, new BigNodesPreProcessor$BigNode(this, node, parts, chunkWidth));
    }
  }
  for (node$iterator = new ArrayList$1(bigNodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 267);
    $isProcessorApplicable(node.node) && $process_3(node);
  }
  $done(monitor);
}
;
_.dummyID = 0;
_.spacing = 0;
var Lde_cau_cs_kieler_klay_layered_intermediate_BigNodesPreProcessor_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'BigNodesPreProcessor', 441);
function $process_3(this$static){
  var dummyWidth, e, e$iterator, eastPorts, originalWidth, port, port$iterator, port$iterator0, start_0, tmpChunks, dummy, outPort, inPort, edge;
  eastPorts = new ArrayList;
  for (port$iterator0 = new ArrayList$1(this$static.node.ports); port$iterator0.i < port$iterator0.this$01.array.length;) {
    port = castTo($next_8(port$iterator0), 7);
    port.side == ($clinit_PortSide() , EAST) && (eastPorts.array[eastPorts.array.length] = port , true);
  }
  if (this$static.this$01.direction == ($clinit_Direction() , RIGHT_0) && !$isSideFixed(castTo($getProperty(this$static.node, ($clinit_LayoutOptions() , PORT_CONSTRAINTS)), 28))) {
    for (e$iterator = $iterator($getOutgoingEdges_0(this$static.node)); $hasNext_0(e$iterator);) {
      e = castTo($next_2(e$iterator), 12);
      $add_11(eastPorts, e.source);
    }
  }
  originalWidth = this$static.node.size_0.x_0;
  $setProperty(this$static.node, ($clinit_InternalProperties() , BIG_NODE_ORIGINAL_SIZE), new Float_0(this$static.node.size_0.x_0));
  this$static.node.size_0.x_0 = this$static.minWidth;
  $setProperty(this$static.node, BIG_NODE_INITIAL, ($clinit_Boolean() , $clinit_Boolean() , TRUE_0));
  $add_11(this$static.dummies, this$static.node);
  start_0 = this$static.node;
  originalWidth -= this$static.minWidth;
  tmpChunks = this$static.chunks;
  while (tmpChunks > 1) {
    dummyWidth = min_1(originalWidth, this$static.minWidth);
    start_0 = (dummy = new LNode(this$static.this$01.layeredGraph) , $setType(dummy, ($clinit_LNode$NodeType() , BIG_NODE)) , $setProperty(dummy, ($clinit_LayoutOptions() , PORT_CONSTRAINTS), castTo($getProperty(start_0, PORT_CONSTRAINTS), 28)) , $setProperty(dummy, NODE_LABEL_PLACEMENT, castTo($getProperty(start_0, NODE_LABEL_PLACEMENT), 86)) , dummy.id_0 = this$static.this$01.dummyID++ , $add_11(this$static.dummies, dummy) , dummy.size_0.y_0 = start_0.size_0.y_0 , dummy.size_0.x_0 = dummyWidth , outPort = new LPort , $setSide(outPort, ($clinit_PortSide() , EAST)) , $setNode(outPort, start_0) , outPort.pos.x_0 = dummy.size_0.x_0 , outPort.pos.y_0 = dummy.size_0.y_0 / 2 , inPort = new LPort , $setSide(inPort, WEST) , $setNode(inPort, dummy) , inPort.pos.y_0 = dummy.size_0.y_0 / 2 , inPort.pos.x_0 = -inPort.size_0.x_0 , edge = new LEdge , $setSource(edge, outPort) , $setTarget(edge, inPort) , dummy);
    $add_11(this$static.this$01.layeredGraph.layerlessNodes, start_0);
    --tmpChunks;
    originalWidth -= this$static.minWidth + this$static.this$01.spacing;
  }
  new BigNodesLabelHandler$Handler(this$static.node, this$static.dummies, this$static.minWidth);
  for (port$iterator = new ArrayList$1(eastPorts); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_8(port$iterator), 7);
    $remove_7(this$static.node.ports, port);
    $setNode(port, start_0);
  }
}

function BigNodesPreProcessor$BigNode(this$0, node, chunks, minWidth){
  this.this$01 = this$0;
  this.dummies = new ArrayList;
  this.node = node;
  this.chunks = chunks;
  this.minWidth = minWidth;
}

defineClass(267, 1, {267:1}, BigNodesPreProcessor$BigNode);
_.chunks = 0;
_.minWidth = 0;
var Lde_cau_cs_kieler_klay_layered_intermediate_BigNodesPreProcessor$BigNode_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'BigNodesPreProcessor/BigNode', 267);
function $isProcessorApplicable_0(node){
  var eastwardEdges, edge, edge$iterator, hasIncoming, hasOutgoing, p, p$iterator, p$iterator0, port, port$iterator, source, target, tmp, westwardEdges;
  if (maskUndefined($getProperty(node.node, ($clinit_LayoutOptions() , PORT_CONSTRAINTS))) === maskUndefined(($clinit_PortConstraints() , FIXED_RATIO)) || maskUndefined($getProperty(node.node, PORT_CONSTRAINTS)) === maskUndefined(FIXED_POS)) {
    for (port$iterator = new ArrayList$1(node.node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_8(port$iterator), 7);
      if (port.side == ($clinit_PortSide() , NORTH) || port.side == SOUTH) {
        return false;
      }
    }
  }
  for (edge$iterator = $iterator($getOutgoingEdges_0(node.node)); $hasNext_0(edge$iterator);) {
    edge = castTo($next_2(edge$iterator), 12);
    if (edge.source.owner == edge.target.owner) {
      return false;
    }
  }
  if ($isSideFixed(castTo($getProperty(node.node, PORT_CONSTRAINTS), 28))) {
    tmp = new ArrayList;
    for (p$iterator0 = $getPorts_0(node.node, ($clinit_PortSide() , WEST)).iterator_0(); p$iterator0.hasNext_0();) {
      p = castTo(p$iterator0.next_1(), 7);
      $add_11(tmp, concat(($clinit_ImmutableList() , new RegularImmutableList(nullCheckedList(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [p.incomingEdges, p.outgoingEdges]))))));
    }
    westwardEdges = (checkNotNull(tmp) , new FluentIterable$2(tmp));
    tmp = new ArrayList;
    for (p$iterator = $getPorts_0(node.node, EAST).iterator_0(); p$iterator.hasNext_0();) {
      p = castTo(p$iterator.next_1(), 7);
      $add_11(tmp, concat(($clinit_ImmutableList() , new RegularImmutableList(nullCheckedList(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [p.incomingEdges, p.outgoingEdges]))))));
    }
    eastwardEdges = (checkNotNull(tmp) , new FluentIterable$2(tmp));
  }
   else {
    westwardEdges = $getIncomingEdges_0(node.node);
    eastwardEdges = $getOutgoingEdges_0(node.node);
  }
  hasOutgoing = !isEmpty_12($getOutgoingEdges_0(node.node));
  hasIncoming = !isEmpty_12($getIncomingEdges_0(node.node));
  if (!hasOutgoing && !hasIncoming) {
    return false;
  }
  if (!hasOutgoing) {
    node.type_0 = 1;
    return true;
  }
  if (!hasIncoming) {
    node.type_0 = 0;
    return true;
  }
  if (size_19(($clinit_Iterators() , new Iterators$ConcatenatedIterator($iterator_1(transform_1(westwardEdges.val$inputs1, new Iterables$12))))) == 1) {
    source = (checkNotNull(westwardEdges) , castTo(get_10(new Iterators$ConcatenatedIterator($iterator_1(transform_1(westwardEdges.val$inputs1, new Iterables$12)))), 12)).source.owner;
    if (source.type_0 == ($clinit_LNode$NodeType() , LONG_EDGE) && castTo($getProperty(source, ($clinit_InternalProperties() , LONG_EDGE_SOURCE)), 7).owner != node.node) {
      node.type_0 = 2;
      return true;
    }
  }
  if (size_19(new Iterators$ConcatenatedIterator($iterator_1(transform_1(eastwardEdges.val$inputs1, new Iterables$12)))) == 1) {
    target = (checkNotNull(eastwardEdges) , castTo(get_10(new Iterators$ConcatenatedIterator($iterator_1(transform_1(eastwardEdges.val$inputs1, new Iterables$12)))), 12)).target.owner;
    if (target.type_0 == ($clinit_LNode$NodeType() , LONG_EDGE) && castTo($getProperty(target, ($clinit_InternalProperties() , LONG_EDGE_TARGET)), 7).owner != node.node) {
      node.type_0 = 3;
      return true;
    }
  }
  return false;
}

function BigNodesSplitter(){
  this.direction = ($clinit_Direction() , UNDEFINED);
}

defineClass(442, 1, $intern_56, BigNodesSplitter);
_.process = function process_4(theLayeredGraph, monitor){
  var bigNodes, chunkWidth, counter, l, l$iterator, minWidth, node, node$iterator, node$iterator0, node$iterator1, node$iterator2, nodes, parts, threshold;
  $begin(monitor, 'Big nodes pre-processing', 1);
  debug = unsafeCast(checkNotNull_1(castToBoolean($getProperty(theLayeredGraph, ($clinit_LayoutOptions() , DEBUG_MODE)))));
  this.layeredGraph = theLayeredGraph;
  nodes = new ArrayList;
  for (l$iterator = new ArrayList$1(theLayeredGraph.layers); l$iterator.i < l$iterator.this$01.array.length;) {
    l = castTo($next_8(l$iterator), 16);
    $addAll_6(nodes, l.nodes);
  }
  counter = 0;
  for (node$iterator0 = new ArrayList$1(nodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
    node = castTo($next_8(node$iterator0), 9);
    node.id_0 = counter++;
  }
  this.spacing = castTo($getProperty(this.layeredGraph, ($clinit_InternalProperties() , SPACING_0)), 15).value_0;
  this.direction = castTo($getProperty(this.layeredGraph, DIRECTION), 59);
  this.dummyID = nodes.array.length;
  minWidth = $intern_58;
  for (node$iterator1 = new ArrayList$1(nodes); node$iterator1.i < node$iterator1.this$01.array.length;) {
    node = castTo($next_8(node$iterator1), 9);
    node.type_0 == ($clinit_LNode$NodeType() , NORMAL) && node.size_0.x_0 < minWidth && (minWidth = node.size_0.x_0);
  }
  minWidth = 50 > minWidth?50:minWidth;
  bigNodes = new ArrayList;
  threshold = minWidth + this.spacing;
  for (node$iterator2 = new ArrayList$1(nodes); node$iterator2.i < node$iterator2.this$01.array.length;) {
    node = castTo($next_8(node$iterator2), 9);
    if (node.type_0 == ($clinit_LNode$NodeType() , NORMAL) && node.size_0.x_0 > threshold) {
      parts = 1;
      chunkWidth = node.size_0.x_0;
      while (chunkWidth > minWidth) {
        ++parts;
        chunkWidth = (node.size_0.x_0 - (parts - 1) * this.spacing) / parts;
      }
      $add_11(bigNodes, new BigNodesSplitter$BigNode(this, node, parts));
    }
  }
  for (node$iterator = new ArrayList$1(bigNodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 268);
    $isProcessorApplicable_0(node) && $process_4(node);
  }
  $done(monitor);
}
;
_.dummyID = 0;
_.spacing = 0;
var debug = false;
var Lde_cau_cs_kieler_klay_layered_intermediate_BigNodesSplitter_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'BigNodesSplitter', 442);
function $findPossibleDummyPositions(this$static, dir_0, inLayerPos, layerIndex, maxLayer, remainingChunks){
  var connectedEdges, currentLayer, e, e$iterator, e$iterator0, entry, i, i0, lower, lowerPrime, maxUprime, minLprime, n, n$iterator, n$iterator0, n$iterator1, n$iterator2, n$iterator3, nextLayer, old, old0, outerIter, outerIter0, outerIter1, outerIter2, rec, upper, upperPrime, upperStrokeMax;
  currentLayer = castTo($get_8(this$static.this$01.layeredGraph.layers, layerIndex), 16);
  upper = new HashSet;
  lower = new HashSet;
  for (i0 = 0; i0 < currentLayer.nodes.array.length; ++i0) {
    n = castTo($get_8(currentLayer.nodes, i0), 9);
    i0 < inLayerPos?(old0 = upper.map_0.put(n, upper) , old0 == null):i0 > inLayerPos && (old = lower.map_0.put(n, lower) , old == null);
  }
  upperPrime = new HashSet;
  lowerPrime = new HashSet;
  for (n$iterator0 = (outerIter0 = (new AbstractMap$1(upper.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter0)); n$iterator0.val$outerIter2.hasNext_0();) {
    n = (entry = castTo(n$iterator0.val$outerIter2.next_1(), 21) , castTo(entry.getKey(), 9));
    connectedEdges = dir_0 == 1?$getOutgoingEdges_0(n):$getIncomingEdges_0(n);
    for (e$iterator = ($clinit_Iterators() , new Iterators$ConcatenatedIterator($iterator_1(transform_1(connectedEdges.val$inputs1, new Iterables$12)))); $hasNext_0(e$iterator);) {
      e = castTo($next_2(e$iterator), 12);
      $getIndex_0(n.layer) != $getIndex_0(e.target.owner.layer) && $add_18(upperPrime, e.target.owner);
    }
  }
  for (n$iterator1 = (outerIter1 = (new AbstractMap$1(lower.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter1)); n$iterator1.val$outerIter2.hasNext_0();) {
    n = (entry = castTo(n$iterator1.val$outerIter2.next_1(), 21) , castTo(entry.getKey(), 9));
    connectedEdges = dir_0 == 1?$getOutgoingEdges_0(n):$getIncomingEdges_0(n);
    for (e$iterator = ($clinit_Iterators() , new Iterators$ConcatenatedIterator($iterator_1(transform_1(connectedEdges.val$inputs1, new Iterables$12)))); $hasNext_0(e$iterator);) {
      e = castTo($next_2(e$iterator), 12);
      $getIndex_0(n.layer) != $getIndex_0(e.target.owner.layer) && $add_18(lowerPrime, e.target.owner);
    }
  }
  if (debug) {
    $clinit_System();
  }
  nextLayer = castTo($get_8(this$static.this$01.layeredGraph.layers, layerIndex + (dir_0 == 1?1:-1)), 16);
  maxUprime = $intern_8;
  minLprime = $intern_3;
  for (i = 0; i < nextLayer.nodes.array.length; i++) {
    n = castTo($get_8(nextLayer.nodes, i), 9);
    upperPrime.map_0.containsKey(n)?(maxUprime = maxUprime > i?maxUprime:i):lowerPrime.map_0.containsKey(n) && (minLprime = minLprime < i?minLprime:i);
  }
  if (maxUprime < minLprime) {
    for (n$iterator2 = (outerIter2 = (new AbstractMap$1(upperPrime.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter2)); n$iterator2.val$outerIter2.hasNext_0();) {
      n = (entry = castTo(n$iterator2.val$outerIter2.next_1(), 21) , castTo(entry.getKey(), 9));
      for (e$iterator0 = $iterator($getOutgoingEdges_0(n)); $hasNext_0(e$iterator0);) {
        e = castTo($next_2(e$iterator0), 12);
        if ($getIndex_0(n.layer) == $getIndex_0(e.target.owner.layer)) {
          return null;
        }
      }
      for (e$iterator = $iterator($getIncomingEdges_0(n)); $hasNext_0(e$iterator);) {
        e = castTo($next_2(e$iterator), 12);
        if ($getIndex_0(n.layer) == $getIndex_0(e.source.owner.layer)) {
          return null;
        }
      }
    }
    for (n$iterator3 = (outerIter = (new AbstractMap$1(lowerPrime.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter)); n$iterator3.val$outerIter2.hasNext_0();) {
      n = (entry = castTo(n$iterator3.val$outerIter2.next_1(), 21) , castTo(entry.getKey(), 9));
      for (e$iterator0 = $iterator($getOutgoingEdges_0(n)); $hasNext_0(e$iterator0);) {
        e = castTo($next_2(e$iterator0), 12);
        if ($getIndex_0(n.layer) == $getIndex_0(e.target.owner.layer)) {
          return null;
        }
      }
      for (e$iterator = $iterator($getIncomingEdges_0(n)); $hasNext_0(e$iterator);) {
        e = castTo($next_2(e$iterator), 12);
        if ($getIndex_0(n.layer) == $getIndex_0(e.source.owner.layer)) {
          return null;
        }
      }
    }
    upper.map_0.size_1() == 0?(upperStrokeMax = 0):lower.map_0.size_1() == 0?(upperStrokeMax = nextLayer.nodes.array.length):(upperStrokeMax = maxUprime + 1);
    for (n$iterator = new ArrayList$1(currentLayer.nodes); n$iterator.i < n$iterator.this$01.array.length;) {
      n = castTo($next_8(n$iterator), 9);
      if (n.type_0 == ($clinit_LNode$NodeType() , NORTH_SOUTH_PORT)) {
        return null;
      }
    }
    if (remainingChunks == 1) {
      return newArrayList_1(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Integer_2_classLit, 1), $intern_0, 24, 0, [valueOf_0(upperStrokeMax)]));
    }
     else if (dir_0 == 1 && layerIndex == maxLayer - 2 || dir_0 == 0 && layerIndex == 1) {
      return newArrayList_1(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Integer_2_classLit, 1), $intern_0, 24, 0, [valueOf_0(upperStrokeMax)]));
    }
     else {
      rec = $findPossibleDummyPositions(this$static, dir_0, upperStrokeMax, layerIndex + (dir_0 == 1?1:-1), maxLayer, remainingChunks - 1);
      !!rec && dir_0 == 1 && rec.add_2(0, valueOf_0(upperStrokeMax));
      return rec;
    }
  }
  return null;
}

function $introduceDummyNode(this$static, src_0){
  var dummy, edge, inPort, movePorts, outPort, p, p$iterator, portSide;
  dummy = new LNode(this$static.this$01.layeredGraph);
  $setType(dummy, ($clinit_LNode$NodeType() , BIG_NODE));
  $setProperty(dummy, ($clinit_LayoutOptions() , PORT_CONSTRAINTS), castTo($getProperty(src_0, PORT_CONSTRAINTS), 28));
  $setProperty(dummy, NODE_LABEL_PLACEMENT, castTo($getProperty(src_0, NODE_LABEL_PLACEMENT), 86));
  dummy.id_0 = this$static.this$01.dummyID++;
  $add_11(this$static.dummies, dummy);
  dummy.size_0.y_0 = src_0.size_0.y_0;
  dummy.size_0.x_0 = 0;
  portSide = ($clinit_PortSide() , EAST);
  movePorts = newArrayList($getPorts_0(src_0, portSide));
  for (p$iterator = new ArrayList$1(movePorts); p$iterator.i < p$iterator.this$01.array.length;) {
    p = castTo($next_8(p$iterator), 7);
    $setNode(p, dummy);
  }
  outPort = new LPort;
  $setSide(outPort, portSide);
  $setNode(outPort, src_0);
  outPort.pos.x_0 = dummy.size_0.x_0;
  outPort.pos.y_0 = dummy.size_0.y_0 / 2;
  inPort = new LPort;
  $setSide(inPort, $opposed(portSide));
  $setNode(inPort, dummy);
  inPort.pos.y_0 = dummy.size_0.y_0 / 2;
  inPort.pos.x_0 = -inPort.size_0.x_0;
  edge = new LEdge;
  $setSource(edge, outPort);
  $setTarget(edge, inPort);
  return dummy;
}

function $process_4(this$static){
  var created, e, e$iterator, eastPorts, port, port$iterator;
  eastPorts = new ArrayList;
  for (port$iterator = new ArrayList$1(this$static.node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_8(port$iterator), 7);
    port.side == ($clinit_PortSide() , EAST) && (eastPorts.array[eastPorts.array.length] = port , true);
  }
  if (this$static.this$01.direction == ($clinit_Direction() , RIGHT_0) && !$isSideFixed(castTo($getProperty(this$static.node, ($clinit_LayoutOptions() , PORT_CONSTRAINTS)), 28))) {
    for (e$iterator = $iterator($getOutgoingEdges_0(this$static.node)); $hasNext_0(e$iterator);) {
      e = castTo($next_2(e$iterator), 12);
      $add_11(eastPorts, e.source);
    }
  }
  $setProperty(this$static.node, ($clinit_InternalProperties() , BIG_NODE_ORIGINAL_SIZE), new Float_0(this$static.node.size_0.x_0));
  $setProperty(this$static.node, BIG_NODE_INITIAL, ($clinit_Boolean() , $clinit_Boolean() , TRUE_0));
  $add_11(this$static.dummies, this$static.node);
  created = null;
  this$static.type_0 == 1?(created = $processNoOutgoingEdge(this$static, this$static.node, $getIndex_0(this$static.node.layer), this$static.node.size_0.x_0)):this$static.type_0 == 0?(created = $processNoIncomingEdge(this$static, this$static.node, $getIndex_0(this$static.node.layer), this$static.node.size_0.x_0)):this$static.type_0 == 3?(created = $processOutLongEdge(this$static, this$static.node, this$static.node.size_0.x_0)):this$static.type_0 == 2 && (created = $processIncLongEdge(this$static, this$static.node, this$static.node.size_0.x_0));
  !!created && new BigNodesLabelHandler$Handler(this$static.node, this$static.dummies, checkNotNull_1(castToDouble(created.second)));
}

function $processIncLongEdge(this$static, bignode, originalWidth){
  var chainOfNodes, d, d$iterator, newWidth, replacedDummies, start_0;
  chainOfNodes = new ArrayList;
  chainOfNodes.array[chainOfNodes.array.length] = bignode;
  start_0 = bignode;
  replacedDummies = 0;
  do {
    start_0 = $swapIncLongEdgeDummy(this$static, start_0);
    !!start_0 && (chainOfNodes.array[chainOfNodes.array.length] = start_0 , true);
    ++replacedDummies;
  }
   while (start_0);
  newWidth = (originalWidth - (chainOfNodes.array.length - 1) * this$static.this$01.spacing) / chainOfNodes.array.length;
  for (d$iterator = new ArrayList$1(chainOfNodes); d$iterator.i < d$iterator.this$01.array.length;) {
    d = castTo($next_8(d$iterator), 9);
    d.size_0.x_0 = newWidth;
  }
  return new Pair(valueOf_0(replacedDummies), newWidth);
}

function $processNoIncomingEdge(this$static, bignode, startLayerIndex, originalWidth){
  var chainOfNodes, createdChunks, currentLayer, currentLayerLayer, d, d$iterator, dummy, dummyLayer, i, i0, inLayerPos, inLayerPositions, n, newInLayerPos, newWidth, prevInLayerPosition, start_0, tmpChunks, upperStrokeMax;
  if (startLayerIndex <= 0) {
    return null;
  }
  chainOfNodes = new ArrayList;
  chainOfNodes.array[chainOfNodes.array.length] = bignode;
  start_0 = bignode;
  currentLayer = startLayerIndex;
  inLayerPos = -1;
  currentLayerLayer = castTo($get_8(this$static.this$01.layeredGraph.layers, startLayerIndex), 16);
  for (i0 = 0; i0 < currentLayerLayer.nodes.array.length; ++i0) {
    n = castTo($get_8(currentLayerLayer.nodes, i0), 9);
    if (n == bignode) {
      inLayerPos = i0;
      break;
    }
  }
  inLayerPositions = $findPossibleDummyPositions(this$static, 0, inLayerPos, startLayerIndex, this$static.this$01.layeredGraph.layers.array.length, this$static.chunks);
  if (!inLayerPositions) {
    return null;
  }
  tmpChunks = this$static.chunks;
  i = 0;
  createdChunks = 0;
  prevInLayerPosition = inLayerPos;
  while (!!start_0 && tmpChunks > 1 && currentLayer > 1) {
    dummy = $introduceDummyNode(this$static, start_0);
    currentLayerLayer = castTo($get_8(this$static.this$01.layeredGraph.layers, currentLayer), 16);
    dummyLayer = castTo($get_8(this$static.this$01.layeredGraph.layers, currentLayer - 1), 16);
    upperStrokeMax = castTo(inLayerPositions.get_2(i++), 24).value_0;
    newInLayerPos = min_3(upperStrokeMax, dummyLayer.nodes.array.length);
    $setLayer(start_0, newInLayerPos, dummyLayer);
    $setLayer(dummy, prevInLayerPosition, currentLayerLayer);
    prevInLayerPosition = newInLayerPos;
    !!start_0 && (chainOfNodes.array[chainOfNodes.array.length] = start_0 , true);
    start_0 = dummy;
    --tmpChunks;
    ++createdChunks;
    --currentLayer;
  }
  newWidth = (originalWidth - (chainOfNodes.array.length - 1) * this$static.this$01.spacing) / chainOfNodes.array.length;
  for (d$iterator = new ArrayList$1(chainOfNodes); d$iterator.i < d$iterator.this$01.array.length;) {
    d = castTo($next_8(d$iterator), 9);
    d.size_0.x_0 = newWidth;
  }
  return new Pair(valueOf_0(createdChunks), newWidth);
}

function $processNoOutgoingEdge(this$static, bignode, startLayerIndex, originalWidth){
  var chainOfNodes, createdChunks, currentLayer, currentLayerLayer, d, d$iterator, dummy, dummyLayer, i, i0, inLayerPos, inLayerPositions, maxLayer, n, newInLayerPos, newWidth, start_0, tmpChunks, upperStrokeMax;
  maxLayer = this$static.this$01.layeredGraph.layers.array.length;
  if (startLayerIndex >= maxLayer - 1) {
    return null;
  }
  chainOfNodes = new ArrayList;
  chainOfNodes.array[chainOfNodes.array.length] = bignode;
  start_0 = bignode;
  currentLayer = startLayerIndex;
  inLayerPos = -1;
  currentLayerLayer = castTo($get_8(this$static.this$01.layeredGraph.layers, startLayerIndex), 16);
  for (i0 = 0; i0 < currentLayerLayer.nodes.array.length; ++i0) {
    n = castTo($get_8(currentLayerLayer.nodes, i0), 9);
    if (n == bignode) {
      inLayerPos = i0;
      break;
    }
  }
  inLayerPositions = $findPossibleDummyPositions(this$static, 1, inLayerPos, startLayerIndex, maxLayer, this$static.chunks);
  if (!inLayerPositions) {
    return null;
  }
  tmpChunks = this$static.chunks;
  i = 0;
  createdChunks = 0;
  while (!!start_0 && tmpChunks > 1 && currentLayer < maxLayer - 1) {
    dummy = $introduceDummyNode(this$static, start_0);
    dummyLayer = castTo($get_8(this$static.this$01.layeredGraph.layers, currentLayer + 1), 16);
    upperStrokeMax = castTo(inLayerPositions.get_2(i++), 24).value_0;
    newInLayerPos = min_3(upperStrokeMax, dummyLayer.nodes.array.length);
    $setLayer(dummy, newInLayerPos, dummyLayer);
    !!start_0 && (chainOfNodes.array[chainOfNodes.array.length] = start_0 , true);
    start_0 = dummy;
    --tmpChunks;
    ++createdChunks;
    ++currentLayer;
  }
  newWidth = (originalWidth - (chainOfNodes.array.length - 1) * this$static.this$01.spacing) / chainOfNodes.array.length;
  for (d$iterator = new ArrayList$1(chainOfNodes); d$iterator.i < d$iterator.this$01.array.length;) {
    d = castTo($next_8(d$iterator), 9);
    d.size_0.x_0 = newWidth;
  }
  return new Pair(valueOf_0(createdChunks), newWidth);
}

function $processOutLongEdge(this$static, bignode, originalWidth){
  var chainOfNodes, d, d$iterator, newWidth, replacedDummies, start_0;
  chainOfNodes = new ArrayList;
  chainOfNodes.array[chainOfNodes.array.length] = bignode;
  start_0 = bignode;
  replacedDummies = 0;
  do {
    start_0 = $replaceOutLongEdgeDummy(this$static, start_0);
    !!start_0 && (chainOfNodes.array[chainOfNodes.array.length] = start_0 , true);
    ++replacedDummies;
  }
   while (start_0);
  newWidth = (originalWidth - (chainOfNodes.array.length - 1) * this$static.this$01.spacing) / chainOfNodes.array.length;
  for (d$iterator = new ArrayList$1(chainOfNodes); d$iterator.i < d$iterator.this$01.array.length;) {
    d = castTo($next_8(d$iterator), 9);
    d.size_0.x_0 = newWidth;
  }
  return new Pair(valueOf_0(replacedDummies), newWidth);
}

function $replaceOutLongEdgeDummy(this$static, start_0){
  var longEdgeDummy, newPort, origin, outEdge, outPort, p, p$iterator, p$iterator0, src_0;
  if (size_18($getOutgoingEdges_0(start_0)) != 1 || castTo(get_9($getOutgoingEdges_0(start_0)), 12).target.owner.type_0 != ($clinit_LNode$NodeType() , LONG_EDGE)) {
    return null;
  }
  outEdge = castTo(get_9($getOutgoingEdges_0(start_0)), 12);
  longEdgeDummy = outEdge.target.owner;
  $setType(longEdgeDummy, ($clinit_LNode$NodeType() , BIG_NODE));
  $setProperty(longEdgeDummy, ($clinit_InternalProperties() , LONG_EDGE_SOURCE), null);
  $setProperty(longEdgeDummy, LONG_EDGE_TARGET, null);
  $setProperty(longEdgeDummy, ($clinit_LayoutOptions() , PORT_CONSTRAINTS), castTo($getProperty(start_0, PORT_CONSTRAINTS), 28));
  $setProperty(longEdgeDummy, NODE_LABEL_PLACEMENT, castTo($getProperty(start_0, NODE_LABEL_PLACEMENT), 86));
  origin = $getProperty(outEdge.source, ORIGIN);
  outPort = null;
  for (p$iterator0 = $getPorts_0(longEdgeDummy, ($clinit_PortSide() , EAST)).iterator_0(); p$iterator0.hasNext_0();) {
    p = castTo(p$iterator0.next_1(), 7);
    if (p.outgoingEdges.array.length != 0) {
      $setProperty(p, ORIGIN, origin);
      src_0 = outEdge.source;
      p.size_0.x_0 = src_0.size_0.x_0;
      p.size_0.y_0 = src_0.size_0.y_0;
      p.anchor.x_0 = src_0.anchor.x_0;
      p.anchor.y_0 = src_0.anchor.y_0;
      $addAll_6(p.labels, src_0.labels);
      src_0.labels.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
      outPort = p;
      break;
    }
  }
  $setProperty(outEdge.source, ORIGIN, null);
  if (!isEmpty_12($getPorts_0(start_0, EAST))) {
    for (p$iterator = new ArrayList$1(newArrayList($getPorts_0(start_0, EAST))); p$iterator.i < p$iterator.this$01.array.length;) {
      p = castTo($next_8(p$iterator), 7);
      if (p.outgoingEdges.array.length == 0) {
        newPort = new LPort;
        $setSide(newPort, EAST);
        newPort.size_0.x_0 = p.size_0.x_0;
        newPort.size_0.y_0 = p.size_0.y_0;
        $setNode(newPort, longEdgeDummy);
        $setProperty(newPort, ORIGIN, $getProperty(p, ORIGIN));
        $setNode(p, null);
      }
       else {
        $setNode(outPort, longEdgeDummy);
      }
    }
  }
  longEdgeDummy.size_0.y_0 = start_0.size_0.y_0;
  $add_11(this$static.dummies, longEdgeDummy);
  return longEdgeDummy;
}

function $swapIncLongEdgeDummy(this$static, start_0){
  var incEdge, longEdgeDummy, newPort, origin, outPort, p, p$iterator, p$iterator0, tgt;
  if (size_18($getIncomingEdges_0(start_0)) != 1 || castTo(get_9($getIncomingEdges_0(start_0)), 12).source.owner.type_0 != ($clinit_LNode$NodeType() , LONG_EDGE)) {
    return null;
  }
  incEdge = castTo(get_9($getIncomingEdges_0(start_0)), 12);
  longEdgeDummy = incEdge.source.owner;
  $setType(longEdgeDummy, ($clinit_LNode$NodeType() , NORMAL));
  $setProperty(longEdgeDummy, ($clinit_InternalProperties() , LONG_EDGE_SOURCE), null);
  $setProperty(longEdgeDummy, LONG_EDGE_TARGET, null);
  $setProperty(longEdgeDummy, BIG_NODE_ORIGINAL_SIZE, castTo($getProperty(start_0, BIG_NODE_ORIGINAL_SIZE), 15));
  $setProperty(longEdgeDummy, BIG_NODE_INITIAL, ($clinit_Boolean() , $clinit_Boolean() , TRUE_0));
  $setProperty(longEdgeDummy, ORIGIN, $getProperty(start_0, ORIGIN));
  longEdgeDummy.size_0.y_0 = start_0.size_0.y_0;
  origin = $getProperty(incEdge.target, ORIGIN);
  outPort = null;
  for (p$iterator0 = $getPorts_0(longEdgeDummy, ($clinit_PortSide() , WEST)).iterator_0(); p$iterator0.hasNext_0();) {
    p = castTo(p$iterator0.next_1(), 7);
    if (p.incomingEdges.array.length != 0) {
      $setProperty(p, ORIGIN, origin);
      tgt = incEdge.target;
      p.size_0.x_0 = tgt.size_0.x_0;
      p.size_0.y_0 = tgt.size_0.y_0;
      p.anchor.x_0 = tgt.anchor.x_0;
      p.anchor.y_0 = tgt.anchor.y_0;
      $addAll_6(p.labels, tgt.labels);
      tgt.labels.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
      outPort = p;
      break;
    }
  }
  $setProperty(incEdge.target, ORIGIN, null);
  if (size_18($getPorts_0(start_0, WEST)) > 1) {
    for (p$iterator = $listIterator_2(newLinkedList($getPorts_0(start_0, WEST)), 0); p$iterator.currentNode != p$iterator.this$01.tail;) {
      p = castTo($next_11(p$iterator), 7);
      if (p.incomingEdges.array.length == 0) {
        newPort = new LPort;
        $setSide(newPort, WEST);
        newPort.size_0.x_0 = p.size_0.x_0;
        newPort.size_0.y_0 = p.size_0.y_0;
        $setNode(newPort, longEdgeDummy);
        $setProperty(newPort, ORIGIN, $getProperty(p, ORIGIN));
        $setNode(p, null);
      }
       else {
        $setNode(outPort, longEdgeDummy);
      }
    }
  }
  $setProperty(start_0, ORIGIN, null);
  $setProperty(start_0, BIG_NODE_INITIAL, (null , FALSE_0));
  $setType(start_0, BIG_NODE);
  $setProperty(longEdgeDummy, ($clinit_LayoutOptions() , PORT_CONSTRAINTS), castTo($getProperty(start_0, PORT_CONSTRAINTS), 28));
  $setProperty(longEdgeDummy, NODE_LABEL_PLACEMENT, castTo($getProperty(start_0, NODE_LABEL_PLACEMENT), 86));
  $add_10(this$static.dummies, 0, longEdgeDummy);
  return longEdgeDummy;
}

function BigNodesSplitter$BigNode(this$0, node, chunks){
  this.this$01 = this$0;
  this.dummies = new ArrayList;
  this.node = node;
  this.chunks = chunks;
}

defineClass(268, 1, {268:1}, BigNodesSplitter$BigNode);
_.chunks = 0;
_.type_0 = 4;
var Lde_cau_cs_kieler_klay_layered_intermediate_BigNodesSplitter$BigNode_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'BigNodesSplitter/BigNode', 268);
function $getBoxPort(commentBox){
  var edge, edge$iterator, edge$iterator0, nodePort, port, port$iterator;
  nodePort = castTo($getProperty(commentBox, ($clinit_InternalProperties() , COMMENT_CONN_PORT)), 7);
  for (port$iterator = new ArrayList$1(commentBox.ports); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_8(port$iterator), 7);
    for (edge$iterator0 = new ArrayList$1(port.outgoingEdges); edge$iterator0.i < edge$iterator0.this$01.array.length;) {
      edge = castTo($next_8(edge$iterator0), 12);
      $setTarget(edge, nodePort);
      return port;
    }
    for (edge$iterator = new ArrayList$1(port.incomingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
      edge = castTo($next_8(edge$iterator), 12);
      $setSource(edge, nodePort);
      return port;
    }
  }
  return null;
}

function $process_5(node, topBoxes, bottomBoxes, spacing){
  var anchorInc, anchorX, baseLine, box, box$iterator, box$iterator0, boxPort, boxesWidth, margin, maxHeight, nodePort, nodePos, nodeSize, x_0;
  nodePos = node.pos;
  nodeSize = node.size_0;
  margin = node.margin;
  if (topBoxes) {
    boxesWidth = spacing / 2 * (topBoxes.size_1() - 1);
    maxHeight = 0;
    for (box$iterator0 = topBoxes.iterator_0(); box$iterator0.hasNext_0();) {
      box = castTo(box$iterator0.next_1(), 9);
      boxesWidth += box.size_0.x_0;
      maxHeight = max_1(maxHeight, box.size_0.y_0);
    }
    x_0 = nodePos.x_0 - (boxesWidth - nodeSize.x_0) / 2;
    baseLine = nodePos.y_0 - margin.top_0 + maxHeight;
    anchorInc = nodeSize.x_0 / (topBoxes.size_1() + 1);
    anchorX = anchorInc;
    for (box$iterator = topBoxes.iterator_0(); box$iterator.hasNext_0();) {
      box = castTo(box$iterator.next_1(), 9);
      box.pos.x_0 = x_0;
      box.pos.y_0 = baseLine - box.size_0.y_0;
      x_0 += box.size_0.x_0 + spacing / 2;
      boxPort = $getBoxPort(box);
      boxPort.pos.x_0 = box.size_0.x_0 / 2 - boxPort.anchor.x_0;
      boxPort.pos.y_0 = box.size_0.y_0;
      nodePort = castTo($getProperty(box, ($clinit_InternalProperties() , COMMENT_CONN_PORT)), 7);
      if (nodePort.incomingEdges.array.length + nodePort.outgoingEdges.array.length == 1) {
        nodePort.pos.x_0 = anchorX - nodePort.anchor.x_0;
        nodePort.pos.y_0 = 0;
        $setNode(nodePort, node);
      }
      anchorX += anchorInc;
    }
  }
  if (bottomBoxes) {
    boxesWidth = spacing / 2 * (bottomBoxes.size_1() - 1);
    maxHeight = 0;
    for (box$iterator0 = bottomBoxes.iterator_0(); box$iterator0.hasNext_0();) {
      box = castTo(box$iterator0.next_1(), 9);
      boxesWidth += box.size_0.x_0;
      maxHeight = max_1(maxHeight, box.size_0.y_0);
    }
    x_0 = nodePos.x_0 - (boxesWidth - nodeSize.x_0) / 2;
    baseLine = nodePos.y_0 + nodeSize.y_0 + margin.bottom - maxHeight;
    anchorInc = nodeSize.x_0 / (bottomBoxes.size_1() + 1);
    anchorX = anchorInc;
    for (box$iterator = bottomBoxes.iterator_0(); box$iterator.hasNext_0();) {
      box = castTo(box$iterator.next_1(), 9);
      box.pos.x_0 = x_0;
      box.pos.y_0 = baseLine;
      x_0 += box.size_0.x_0 + spacing / 2;
      boxPort = $getBoxPort(box);
      boxPort.pos.x_0 = box.size_0.x_0 / 2 - boxPort.anchor.x_0;
      boxPort.pos.y_0 = 0;
      nodePort = castTo($getProperty(box, ($clinit_InternalProperties() , COMMENT_CONN_PORT)), 7);
      if (nodePort.incomingEdges.array.length + nodePort.outgoingEdges.array.length == 1) {
        nodePort.pos.x_0 = anchorX - nodePort.anchor.x_0;
        nodePort.pos.y_0 = nodeSize.y_0;
        $setNode(nodePort, node);
      }
      anchorX += anchorInc;
    }
  }
}

function CommentPostprocessor(){
}

defineClass(443, 1, $intern_56, CommentPostprocessor);
_.process = function process_5(layeredGraph, monitor){
  var bottomBoxes, boxes, layer, layer$iterator, node, node$iterator, spacing, topBoxes;
  $begin(monitor, 'Comment post-processing', 1);
  spacing = castTo($getProperty(layeredGraph, ($clinit_InternalProperties() , SPACING_0)), 15).value_0;
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator), 16);
    boxes = new ArrayList;
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      topBoxes = castTo($getProperty(node, TOP_COMMENTS), 20);
      bottomBoxes = castTo($getProperty(node, BOTTOM_COMMENTS), 20);
      if (!!topBoxes || !!bottomBoxes) {
        $process_5(node, topBoxes, bottomBoxes, spacing);
        !!topBoxes && $addAll_6(boxes, topBoxes);
        !!bottomBoxes && $addAll_6(boxes, bottomBoxes);
      }
    }
    $addAll_6(layer.nodes, boxes);
  }
  $done(monitor);
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_CommentPostprocessor_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'CommentPostprocessor', 443);
function $processBox(box, edge, oppositePort, realNode){
  var bottomBoxes, boxList, hasNorth, hasSouth, label_0, label$iterator, labelPos, onlyBottom, onlyTop, port1, port1$iterator, port2, port2$iterator, topBoxes, topFirst;
  onlyTop = false;
  onlyBottom = false;
  if ($isSideFixed(castTo($getProperty(realNode, ($clinit_LayoutOptions() , PORT_CONSTRAINTS)), 28))) {
    hasNorth = false;
    hasSouth = false;
    portLoop: for (port1$iterator = new ArrayList$1(realNode.ports); port1$iterator.i < port1$iterator.this$01.array.length;) {
      port1 = castTo($next_8(port1$iterator), 7);
      for (port2$iterator = $iterator(concat(($clinit_ImmutableList() , new RegularImmutableList(nullCheckedList(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [new LPort$7(port1), new LPort$8(port1)])))))); $hasNext_0(port2$iterator);) {
        port2 = castTo($next_2(port2$iterator), 7);
        if (!unsafeCast(checkNotNull_1(castToBoolean($getProperty(port2.owner, COMMENT_BOX))))) {
          if (port1.side == ($clinit_PortSide() , NORTH)) {
            hasNorth = true;
            break portLoop;
          }
          if (port1.side == SOUTH) {
            hasSouth = true;
            break portLoop;
          }
        }
      }
    }
    onlyTop = hasSouth && !hasNorth;
    onlyBottom = hasNorth && !hasSouth;
  }
  if (!onlyTop && !onlyBottom && realNode.labels.array.length != 0) {
    labelPos = 0;
    for (label$iterator = new ArrayList$1(realNode.labels); label$iterator.i < label$iterator.this$01.array.length;) {
      label_0 = castTo($next_8(label$iterator), 33);
      labelPos += label_0.pos.y_0 + label_0.size_0.y_0 / 2;
    }
    labelPos /= realNode.labels.array.length;
    topFirst = labelPos >= realNode.size_0.y_0 / 2;
  }
   else {
    topFirst = !onlyBottom;
  }
  if (topFirst) {
    topBoxes = castTo($getProperty(realNode, ($clinit_InternalProperties() , TOP_COMMENTS)), 20);
    if (!topBoxes) {
      boxList = new ArrayList;
      $setProperty(realNode, TOP_COMMENTS, boxList);
    }
     else if (onlyTop) {
      boxList = topBoxes;
    }
     else {
      bottomBoxes = castTo($getProperty(realNode, BOTTOM_COMMENTS), 20);
      if (!bottomBoxes) {
        boxList = new ArrayList;
        $setProperty(realNode, BOTTOM_COMMENTS, boxList);
      }
       else {
        topBoxes.size_1() <= bottomBoxes.size_1()?(boxList = topBoxes):(boxList = bottomBoxes);
      }
    }
  }
   else {
    bottomBoxes = castTo($getProperty(realNode, ($clinit_InternalProperties() , BOTTOM_COMMENTS)), 20);
    if (!bottomBoxes) {
      boxList = new ArrayList;
      $setProperty(realNode, BOTTOM_COMMENTS, boxList);
    }
     else if (onlyBottom) {
      boxList = bottomBoxes;
    }
     else {
      topBoxes = castTo($getProperty(realNode, TOP_COMMENTS), 20);
      if (!topBoxes) {
        boxList = new ArrayList;
        $setProperty(realNode, TOP_COMMENTS, boxList);
      }
       else {
        bottomBoxes.size_1() <= topBoxes.size_1()?(boxList = bottomBoxes):(boxList = topBoxes);
      }
    }
  }
  boxList.add_1(box);
  $setProperty(box, ($clinit_InternalProperties() , COMMENT_CONN_PORT), oppositePort);
  if (edge.target == oppositePort) {
    $setTarget(edge, null);
    oppositePort.incomingEdges.array.length + oppositePort.outgoingEdges.array.length == 0 && $setNode(oppositePort, null);
  }
   else {
    $setSource(edge, null);
    oppositePort.incomingEdges.array.length + oppositePort.outgoingEdges.array.length == 0 && $setNode(oppositePort, null);
  }
  $reset_0(edge.bendPoints);
}

function CommentPreprocessor(){
}

defineClass(444, 1, $intern_56, CommentPreprocessor);
_.process = function process_6(layeredGraph, monitor){
  var edge, edgeCount, inedge, inedge$iterator, node, nodeIter, oppositePort, outedge, outedge$iterator, port, port$iterator, port$iterator0, re, re$iterator, revEdges;
  $begin(monitor, 'Comment pre-processing', 1);
  nodeIter = new ArrayList$1(layeredGraph.layerlessNodes);
  while (nodeIter.i < nodeIter.this$01.array.length) {
    node = castTo($next_8(nodeIter), 9);
    if (unsafeCast(checkNotNull_1(castToBoolean($getProperty(node, ($clinit_LayoutOptions() , COMMENT_BOX)))))) {
      edgeCount = 0;
      edge = null;
      oppositePort = null;
      for (port$iterator0 = new ArrayList$1(node.ports); port$iterator0.i < port$iterator0.this$01.array.length;) {
        port = castTo($next_8(port$iterator0), 7);
        edgeCount += port.incomingEdges.array.length + port.outgoingEdges.array.length;
        if (port.incomingEdges.array.length == 1) {
          edge = castTo($get_8(port.incomingEdges, 0), 12);
          oppositePort = edge.source;
        }
        if (port.outgoingEdges.array.length == 1) {
          edge = castTo($get_8(port.outgoingEdges, 0), 12);
          oppositePort = edge.target;
        }
      }
      if (edgeCount == 1 && oppositePort.incomingEdges.array.length + oppositePort.outgoingEdges.array.length == 1 && !unsafeCast(checkNotNull_1(castToBoolean($getProperty(oppositePort.owner, COMMENT_BOX))))) {
        $processBox(node, edge, oppositePort, oppositePort.owner);
        $remove_12(nodeIter);
      }
       else {
        revEdges = new ArrayList;
        for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
          port = castTo($next_8(port$iterator), 7);
          for (outedge$iterator = new ArrayList$1(port.outgoingEdges); outedge$iterator.i < outedge$iterator.this$01.array.length;) {
            outedge = castTo($next_8(outedge$iterator), 12);
            outedge.target.outgoingEdges.array.length == 0 || (revEdges.array[revEdges.array.length] = outedge , true);
          }
          for (inedge$iterator = new ArrayList$1(port.incomingEdges); inedge$iterator.i < inedge$iterator.this$01.array.length;) {
            inedge = castTo($next_8(inedge$iterator), 12);
            inedge.source.incomingEdges.array.length == 0 || (revEdges.array[revEdges.array.length] = inedge , true);
          }
        }
        for (re$iterator = new ArrayList$1(revEdges); re$iterator.i < re$iterator.this$01.array.length;) {
          re = castTo($next_8(re$iterator), 12);
          $reverse_0(re, true);
        }
      }
    }
  }
  $done(monitor);
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_CommentPreprocessor_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'CommentPreprocessor', 444);
function $reverseEdges(node, nodeLayerConstraint, type_0){
  var edge, edge$index, edge$max, incoming, outgoing, port, port$index, port$max, ports, sourceLayerConstraint, targetLayerConstraint;
  ports = castTo($toArray_1(node.ports, initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LPort_2_classLit, $intern_59, 7, node.ports.array.length, 0, 1)), 346);
  for (port$index = 0 , port$max = ports.length; port$index < port$max; ++port$index) {
    port = ports[port$index];
    if (type_0 != ($clinit_PortType() , INPUT)) {
      outgoing = castTo($toArray_1(port.outgoingEdges, initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LEdge_2_classLit, $intern_57, 12, port.outgoingEdges.array.length, 0, 1)), 47);
      for (edge$index = 0 , edge$max = outgoing.length; edge$index < edge$max; ++edge$index) {
        edge = outgoing[edge$index];
        targetLayerConstraint = castTo($getProperty(edge.target.owner, ($clinit_Properties() , LAYER_CONSTRAINT)), 85);
        !unsafeCast(checkNotNull_1(castToBoolean($getProperty(edge, ($clinit_InternalProperties() , REVERSED))))) && !(nodeLayerConstraint == ($clinit_LayerConstraint() , LAST) && targetLayerConstraint == LAST_SEPARATE) && $reverse_0(edge, true);
      }
    }
    if (type_0 != OUTPUT) {
      incoming = castTo($toArray_1(port.incomingEdges, initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LEdge_2_classLit, $intern_57, 12, port.incomingEdges.array.length, 0, 1)), 47);
      for (edge$index = 0 , edge$max = incoming.length; edge$index < edge$max; ++edge$index) {
        edge = incoming[edge$index];
        sourceLayerConstraint = castTo($getProperty(edge.source.owner, ($clinit_Properties() , LAYER_CONSTRAINT)), 85);
        !unsafeCast(checkNotNull_1(castToBoolean($getProperty(edge, ($clinit_InternalProperties() , REVERSED))))) && !(nodeLayerConstraint == ($clinit_LayerConstraint() , FIRST) && sourceLayerConstraint == FIRST_SEPARATE) && $reverse_0(edge, true);
      }
    }
  }
}

function EdgeAndLayerConstraintEdgeReverser(){
}

defineClass(445, 1, $intern_56, EdgeAndLayerConstraintEdgeReverser);
_.process = function process_7(layeredGraph, monitor){
  var allPortsReversed, e, e$iterator, edgeConstraint, layerConstraint, lc, node, node$iterator, port, port$iterator;
  $begin(monitor, 'Edge and layer constraint edge reversal', 1);
  for (node$iterator = new ArrayList$1(layeredGraph.layerlessNodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 9);
    layerConstraint = castTo($getProperty(node, ($clinit_Properties() , LAYER_CONSTRAINT)), 85);
    edgeConstraint = null;
    switch (layerConstraint.ordinal) {
      case 1:
      case 2:
        edgeConstraint = ($clinit_EdgeConstraint() , OUTGOING_ONLY);
        break;
      case 3:
      case 4:
        edgeConstraint = ($clinit_EdgeConstraint() , INCOMING_ONLY);
    }
    if (edgeConstraint) {
      $setProperty(node, ($clinit_InternalProperties() , EDGE_CONSTRAINT), ($clinit_EdgeConstraint() , OUTGOING_ONLY));
      edgeConstraint == INCOMING_ONLY?$reverseEdges(node, layerConstraint, ($clinit_PortType() , OUTPUT)):edgeConstraint == OUTGOING_ONLY && $reverseEdges(node, layerConstraint, ($clinit_PortType() , INPUT));
    }
     else {
      if ($isSideFixed(castTo($getProperty(node, ($clinit_LayoutOptions() , PORT_CONSTRAINTS)), 28)) && node.ports.array.length != 0) {
        allPortsReversed = true;
        for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
          port = castTo($next_8(port$iterator), 7);
          if (!(port.side == ($clinit_PortSide() , EAST) && port.incomingEdges.array.length - port.outgoingEdges.array.length > 0 || port.side == WEST && port.incomingEdges.array.length - port.outgoingEdges.array.length < 0)) {
            allPortsReversed = false;
            break;
          }
          if (port.side == WEST) {
            for (e$iterator = new ArrayList$1(port.outgoingEdges); e$iterator.i < e$iterator.this$01.array.length;) {
              e = castTo($next_8(e$iterator), 12);
              lc = castTo($getProperty(e.target.owner, LAYER_CONSTRAINT), 85);
              if (lc == ($clinit_LayerConstraint() , LAST) || lc == LAST_SEPARATE) {
                allPortsReversed = false;
                break;
              }
            }
          }
          if (port.side == EAST) {
            for (e$iterator = new ArrayList$1(port.incomingEdges); e$iterator.i < e$iterator.this$01.array.length;) {
              e = castTo($next_8(e$iterator), 12);
              lc = castTo($getProperty(e.source.owner, LAYER_CONSTRAINT), 85);
              if (lc == ($clinit_LayerConstraint() , FIRST) || lc == FIRST_SEPARATE) {
                allPortsReversed = false;
                break;
              }
            }
          }
        }
        allPortsReversed && $reverseEdges(node, layerConstraint, ($clinit_PortType() , UNDEFINED_7));
      }
    }
  }
  $done(monitor);
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_EdgeAndLayerConstraintEdgeReverser_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'EdgeAndLayerConstraintEdgeReverser', 445);
function $placeEndLabelDownwards(label_0, port, labelSpacing){
  var absolutePortAnchor, absolutePortPosition, labelPosition, portMargin;
  labelPosition = label_0.pos;
  absolutePortPosition = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [port.pos, port.owner.pos]));
  absolutePortAnchor = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [port.owner.pos, port.pos, port.anchor]));
  portMargin = port.margin;
  switch (port.side.ordinal) {
    case 4:
      labelPosition.x_0 = min_1(absolutePortPosition.x_0, absolutePortAnchor.x_0) - portMargin.left - label_0.size_0.x_0 - labelSpacing;
      labelPosition.y_0 = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [port.owner.pos, port.pos, port.anchor])).y_0 + labelSpacing;
      break;
    case 2:
      labelPosition.x_0 = max_1(absolutePortPosition.x_0 + port.size_0.x_0, absolutePortAnchor.x_0) + portMargin.right + labelSpacing;
      labelPosition.y_0 = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [port.owner.pos, port.pos, port.anchor])).y_0 + labelSpacing;
      break;
    case 1:
      labelPosition.x_0 = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [port.owner.pos, port.pos, port.anchor])).x_0 + labelSpacing;
      labelPosition.y_0 = min_1(absolutePortPosition.y_0, absolutePortAnchor.y_0) - portMargin.top_0 - label_0.size_0.y_0 - labelSpacing;
      break;
    case 3:
      labelPosition.x_0 = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [port.owner.pos, port.pos, port.anchor])).x_0 + labelSpacing;
      labelPosition.y_0 = max_1(absolutePortPosition.y_0 + port.size_0.y_0, absolutePortAnchor.y_0) + portMargin.bottom + labelSpacing;
  }
}

function $placeEndLabelUpwards(label_0, port, labelSpacing){
  var absolutePortAnchor, absolutePortPosition, labelPosition, portMargin;
  labelPosition = label_0.pos;
  absolutePortPosition = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [port.pos, port.owner.pos]));
  absolutePortAnchor = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [port.owner.pos, port.pos, port.anchor]));
  portMargin = port.margin;
  switch (port.side.ordinal) {
    case 4:
      labelPosition.x_0 = min_1(absolutePortPosition.x_0, absolutePortAnchor.x_0) - portMargin.left - label_0.size_0.x_0 - labelSpacing;
      labelPosition.y_0 = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [port.owner.pos, port.pos, port.anchor])).y_0 - label_0.size_0.y_0 - labelSpacing;
      break;
    case 2:
      labelPosition.x_0 = max_1(absolutePortPosition.x_0 + port.size_0.x_0, absolutePortAnchor.x_0) + portMargin.right + labelSpacing;
      labelPosition.y_0 = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [port.owner.pos, port.pos, port.anchor])).y_0 - label_0.size_0.y_0 - labelSpacing;
      break;
    case 1:
      labelPosition.x_0 = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [port.owner.pos, port.pos, port.anchor])).x_0 + labelSpacing;
      labelPosition.y_0 = min_1(absolutePortPosition.y_0, absolutePortAnchor.y_0) - portMargin.top_0 - label_0.size_0.y_0 - labelSpacing;
      break;
    case 3:
      labelPosition.x_0 = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [port.owner.pos, port.pos, port.anchor])).x_0 + labelSpacing;
      labelPosition.y_0 = max_1(absolutePortPosition.y_0 + port.size_0.y_0, absolutePortAnchor.y_0) + portMargin.bottom + labelSpacing;
  }
}

function EndLabelProcessor(){
}

defineClass(446, 1, $intern_56, EndLabelProcessor);
_.process = function process_8(layeredGraph, monitor){
  var edge, edge$iterator, label_0, label$iterator, labelSpacing, layer, layer$iterator, node, node$iterator, port;
  $begin(monitor, 'End label placement', 1);
  labelSpacing = castTo($getProperty(layeredGraph, ($clinit_LayoutOptions() , LABEL_SPACING)), 15).value_0;
  this.northOffset = ($clinit_Maps() , new HashMap);
  this.southOffset = new HashMap;
  this.portLabelOffsetHint = new HashMap;
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator), 16);
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      for (edge$iterator = $iterator($getOutgoingEdges_0(node)); $hasNext_0(edge$iterator);) {
        edge = castTo($next_2(edge$iterator), 12);
        for (label$iterator = new ArrayList$1(edge.labels); label$iterator.i < label$iterator.this$01.array.length;) {
          label_0 = castTo($next_8(label$iterator), 33);
          (maskUndefined($getProperty(label_0, EDGE_LABEL_PLACEMENT)) === maskUndefined(($clinit_EdgeLabelPlacement() , TAIL)) || maskUndefined($getProperty(label_0, EDGE_LABEL_PLACEMENT)) === maskUndefined(HEAD)) && (port = null , maskUndefined($getProperty(label_0, EDGE_LABEL_PLACEMENT)) === maskUndefined(TAIL)?(port = edge.source):maskUndefined($getProperty(label_0, EDGE_LABEL_PLACEMENT)) === maskUndefined(HEAD) && (port = edge.target) , $containsKey_1(this.northOffset, port.owner) || $put_2(this.northOffset, port.owner, 0) , $containsKey_1(this.southOffset, port.owner) || $put_2(this.southOffset, port.owner, 0) , $containsKey_1(this.portLabelOffsetHint, port) || $put_2(this.portLabelOffsetHint, port, 0) , maskUndefined($getProperty(label_0, ($clinit_InternalProperties() , LABEL_SIDE_0))) === maskUndefined(($clinit_LabelSide() , ABOVE))?$placeEndLabelUpwards(label_0, port, labelSpacing):$placeEndLabelDownwards(label_0, port, labelSpacing) , undefined);
        }
      }
    }
  }
  $done(monitor);
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_EndLabelProcessor_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'EndLabelProcessor', 446);
function $getMirroredPortSideX(side){
  switch (side.ordinal) {
    case 2:
      return $clinit_PortSide() , WEST;
    case 4:
      return $clinit_PortSide() , EAST;
    default:return side;
  }
}

function $getMirroredPortSideY(side){
  switch (side.ordinal) {
    case 1:
      return $clinit_PortSide() , SOUTH;
    case 3:
      return $clinit_PortSide() , NORTH;
    default:return side;
  }
}

function $mirrorInLayerConstraintY(node){
  switch (castTo($getProperty(node, ($clinit_InternalProperties() , IN_LAYER_CONSTRAINT)), 140).ordinal) {
    case 1:
      $setProperty(node, IN_LAYER_CONSTRAINT, ($clinit_InLayerConstraint() , BOTTOM_0));
      break;
    case 2:
      $setProperty(node, IN_LAYER_CONSTRAINT, ($clinit_InLayerConstraint() , TOP_0));
  }
}

function $mirrorLayerConstraintX(node){
  switch (castTo($getProperty(node, ($clinit_Properties() , LAYER_CONSTRAINT)), 85).ordinal) {
    case 1:
      $setProperty(node, LAYER_CONSTRAINT, ($clinit_LayerConstraint() , LAST));
      break;
    case 2:
      $setProperty(node, LAYER_CONSTRAINT, ($clinit_LayerConstraint() , LAST_SEPARATE));
      break;
    case 3:
      $setProperty(node, LAYER_CONSTRAINT, ($clinit_LayerConstraint() , FIRST));
      break;
    case 4:
      $setProperty(node, LAYER_CONSTRAINT, ($clinit_LayerConstraint() , FIRST_SEPARATE));
  }
}

function $mirrorNodeLabelPlacementX(node){
  var oldPlacement;
  oldPlacement = castTo($getProperty(node, ($clinit_LayoutOptions() , NODE_LABEL_PLACEMENT)), 18);
  if (oldPlacement.isEmpty()) {
    return;
  }
  if (oldPlacement.contains(($clinit_NodeLabelPlacement() , H_LEFT))) {
    oldPlacement.remove_1(H_LEFT);
    oldPlacement.add_1(H_RIGHT);
  }
   else if (oldPlacement.contains(H_RIGHT)) {
    oldPlacement.remove_1(H_RIGHT);
    oldPlacement.add_1(H_LEFT);
  }
}

function $mirrorNodeLabelPlacementY(node){
  var oldPlacement;
  oldPlacement = castTo($getProperty(node, ($clinit_LayoutOptions() , NODE_LABEL_PLACEMENT)), 18);
  if (oldPlacement.isEmpty()) {
    return;
  }
  if (oldPlacement.contains(($clinit_NodeLabelPlacement() , V_TOP))) {
    oldPlacement.remove_1(V_TOP);
    oldPlacement.add_1(V_BOTTOM);
  }
   else if (oldPlacement.contains(V_BOTTOM)) {
    oldPlacement.remove_1(V_BOTTOM);
    oldPlacement.add_1(V_TOP);
  }
}

function $mirrorX(v, offset){
  v.x_0 = offset - v.x_0;
}

function $mirrorX_0(nodes, graph){
  var bendPoint, bendPoint$iterator, edge, edge$iterator, index_0, jp, jp$iterator, junctionPoints, label_0, label$iterator, label$iterator0, label$iterator1, node, node$iterator, node$iterator0, nodeSize, offset, port, port$iterator;
  offset = 0;
  if (graph.size_0.x_0 == 0) {
    for (node$iterator0 = new ArrayList$1(nodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
      node = castTo($next_8(node$iterator0), 9);
      offset = max_1(offset, node.pos.x_0 + node.size_0.x_0 + node.margin.right);
    }
  }
   else {
    offset = graph.size_0.x_0 - graph.offset.x_0;
  }
  offset -= graph.offset.x_0;
  for (node$iterator = new ArrayList$1(nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 9);
    $mirrorX(node.pos, offset - node.size_0.x_0);
    $mirrorNodeLabelPlacementX(node);
    switch (castTo($getProperty(node, ($clinit_LayoutOptions() , ALIGNMENT)), 103).ordinal) {
      case 1:
        $setProperty(node, ALIGNMENT, ($clinit_Alignment() , RIGHT));
        break;
      case 2:
        $setProperty(node, ALIGNMENT, ($clinit_Alignment() , LEFT));
    }
    nodeSize = node.size_0;
    for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_8(port$iterator), 7);
      $mirrorX(port.pos, nodeSize.x_0 - port.size_0.x_0);
      $mirrorX(port.anchor, port.size_0.x_0);
      $setSide(port, $getMirroredPortSideX(port.side));
      index_0 = castTo($getProperty(port, PORT_INDEX), 24);
      !!index_0 && $setProperty(port, PORT_INDEX, valueOf_0(-index_0.value_0));
      for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
        edge = castTo($next_8(edge$iterator), 12);
        for (bendPoint$iterator = $listIterator_2(edge.bendPoints, 0); bendPoint$iterator.currentNode != bendPoint$iterator.this$01.tail;) {
          bendPoint = castTo($next_11(bendPoint$iterator), 10);
          bendPoint.x_0 = offset - bendPoint.x_0;
        }
        junctionPoints = castTo($getProperty(edge, JUNCTION_POINTS), 44);
        if (junctionPoints) {
          for (jp$iterator = $listIterator_2(junctionPoints, 0); jp$iterator.currentNode != jp$iterator.this$01.tail;) {
            jp = castTo($next_11(jp$iterator), 10);
            jp.x_0 = offset - jp.x_0;
          }
        }
        for (label$iterator0 = new ArrayList$1(edge.labels); label$iterator0.i < label$iterator0.this$01.array.length;) {
          label_0 = castTo($next_8(label$iterator0), 33);
          $mirrorX(label_0.pos, offset - label_0.size_0.x_0);
        }
      }
      for (label$iterator1 = new ArrayList$1(port.labels); label$iterator1.i < label$iterator1.this$01.array.length;) {
        label_0 = castTo($next_8(label$iterator1), 33);
        $mirrorX(label_0.pos, -label_0.size_0.x_0);
      }
    }
    if (node.type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
      $setProperty(node, ($clinit_InternalProperties() , EXT_PORT_SIDE), $getMirroredPortSideX(castTo($getProperty(node, EXT_PORT_SIDE), 32)));
      $mirrorLayerConstraintX(node);
    }
    for (label$iterator = new ArrayList$1(node.labels); label$iterator.i < label$iterator.this$01.array.length;) {
      label_0 = castTo($next_8(label$iterator), 33);
      $mirrorX(label_0.pos, nodeSize.x_0 - label_0.size_0.x_0);
    }
  }
}

function $mirrorY(v, offset){
  v.y_0 = offset - v.y_0;
}

function $mirrorY_0(nodes, graph){
  var bendPoint, bendPoint$iterator, edge, edge$iterator, index_0, jp, jp$iterator, junctionPoints, label_0, label$iterator, label$iterator0, label$iterator1, node, node$iterator, node$iterator0, nodeSize, offset, port, port$iterator;
  offset = 0;
  if (graph.size_0.y_0 == 0) {
    for (node$iterator0 = new ArrayList$1(nodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
      node = castTo($next_8(node$iterator0), 9);
      offset = max_1(offset, node.pos.y_0 + node.size_0.y_0 + node.margin.bottom);
    }
  }
   else {
    offset = graph.size_0.y_0 - graph.offset.y_0;
  }
  offset -= graph.offset.y_0;
  for (node$iterator = new ArrayList$1(nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 9);
    $mirrorY(node.pos, offset - node.size_0.y_0);
    $mirrorNodeLabelPlacementY(node);
    switch (castTo($getProperty(node, ($clinit_LayoutOptions() , ALIGNMENT)), 103).ordinal) {
      case 3:
        $setProperty(node, ALIGNMENT, ($clinit_Alignment() , BOTTOM));
        break;
      case 4:
        $setProperty(node, ALIGNMENT, ($clinit_Alignment() , TOP));
    }
    nodeSize = node.size_0;
    for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_8(port$iterator), 7);
      $mirrorY(port.pos, nodeSize.y_0 - port.size_0.y_0);
      $mirrorY(port.anchor, port.size_0.y_0);
      $setSide(port, $getMirroredPortSideY(port.side));
      index_0 = castTo($getProperty(port, PORT_INDEX), 24);
      !!index_0 && $setProperty(port, PORT_INDEX, valueOf_0(-index_0.value_0));
      for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
        edge = castTo($next_8(edge$iterator), 12);
        for (bendPoint$iterator = $listIterator_2(edge.bendPoints, 0); bendPoint$iterator.currentNode != bendPoint$iterator.this$01.tail;) {
          bendPoint = castTo($next_11(bendPoint$iterator), 10);
          bendPoint.y_0 = offset - bendPoint.y_0;
        }
        junctionPoints = castTo($getProperty(edge, JUNCTION_POINTS), 44);
        if (junctionPoints) {
          for (jp$iterator = $listIterator_2(junctionPoints, 0); jp$iterator.currentNode != jp$iterator.this$01.tail;) {
            jp = castTo($next_11(jp$iterator), 10);
            jp.y_0 = offset - jp.y_0;
          }
        }
        for (label$iterator0 = new ArrayList$1(edge.labels); label$iterator0.i < label$iterator0.this$01.array.length;) {
          label_0 = castTo($next_8(label$iterator0), 33);
          $mirrorY(label_0.pos, offset - label_0.size_0.y_0);
        }
      }
      for (label$iterator1 = new ArrayList$1(port.labels); label$iterator1.i < label$iterator1.this$01.array.length;) {
        label_0 = castTo($next_8(label$iterator1), 33);
        $mirrorY(label_0.pos, -label_0.size_0.y_0);
      }
    }
    if (node.type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
      $setProperty(node, ($clinit_InternalProperties() , EXT_PORT_SIDE), $getMirroredPortSideY(castTo($getProperty(node, EXT_PORT_SIDE), 32)));
      $mirrorInLayerConstraintY(node);
    }
    for (label$iterator = new ArrayList$1(node.labels); label$iterator.i < label$iterator.this$01.array.length;) {
      label_0 = castTo($next_8(label$iterator), 33);
      $mirrorY(label_0.pos, nodeSize.y_0 - label_0.size_0.y_0);
    }
  }
}

function $transpose(v){
  var temp;
  temp = v.x_0;
  v.x_0 = v.y_0;
  v.y_0 = temp;
}

function $transpose_0(nodes){
  var bendPoint, bendPoint$iterator, edge, edge$iterator, index_0, jp, jp$iterator, junctionPoints, label_0, label$iterator, label$iterator0, label$iterator1, node, node$iterator, port, port$iterator;
  for (node$iterator = new ArrayList$1(nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 9);
    $transpose(node.pos);
    $transpose(node.size_0);
    $transposeNodeLabelPlacement(node);
    $transposeProperties(node);
    for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_8(port$iterator), 7);
      $transpose(port.pos);
      $transpose(port.anchor);
      $transpose(port.size_0);
      $setSide(port, $transposePortSide(port.side));
      index_0 = castTo($getProperty(port, ($clinit_LayoutOptions() , PORT_INDEX)), 24);
      !!index_0 && $setProperty(port, PORT_INDEX, valueOf_0(-index_0.value_0));
      for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
        edge = castTo($next_8(edge$iterator), 12);
        for (bendPoint$iterator = $listIterator_2(edge.bendPoints, 0); bendPoint$iterator.currentNode != bendPoint$iterator.this$01.tail;) {
          bendPoint = castTo($next_11(bendPoint$iterator), 10);
          $transpose(bendPoint);
        }
        junctionPoints = castTo($getProperty(edge, JUNCTION_POINTS), 44);
        if (junctionPoints) {
          for (jp$iterator = $listIterator_2(junctionPoints, 0); jp$iterator.currentNode != jp$iterator.this$01.tail;) {
            jp = castTo($next_11(jp$iterator), 10);
            $transpose(jp);
          }
        }
        for (label$iterator0 = new ArrayList$1(edge.labels); label$iterator0.i < label$iterator0.this$01.array.length;) {
          label_0 = castTo($next_8(label$iterator0), 33);
          $transpose(label_0.pos);
          $transpose(label_0.size_0);
        }
      }
      for (label$iterator1 = new ArrayList$1(port.labels); label$iterator1.i < label$iterator1.this$01.array.length;) {
        label_0 = castTo($next_8(label$iterator1), 33);
        $transpose(label_0.pos);
        $transpose(label_0.size_0);
      }
    }
    if (node.type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
      $setProperty(node, ($clinit_InternalProperties() , EXT_PORT_SIDE), $transposePortSide(castTo($getProperty(node, EXT_PORT_SIDE), 32)));
      $transposeLayerConstraint(node);
    }
    for (label$iterator = new ArrayList$1(node.labels); label$iterator.i < label$iterator.this$01.array.length;) {
      label_0 = castTo($next_8(label$iterator), 33);
      $transpose(label_0.size_0);
      $transpose(label_0.pos);
    }
  }
}

function $transposeLayerConstraint(node){
  var inLayerConstraint, layerConstraint;
  layerConstraint = castTo($getProperty(node, ($clinit_Properties() , LAYER_CONSTRAINT)), 85);
  inLayerConstraint = castTo($getProperty(node, ($clinit_InternalProperties() , IN_LAYER_CONSTRAINT)), 140);
  if (layerConstraint == ($clinit_LayerConstraint() , FIRST_SEPARATE)) {
    $setProperty(node, LAYER_CONSTRAINT, NONE_5);
    $setProperty(node, IN_LAYER_CONSTRAINT, ($clinit_InLayerConstraint() , TOP_0));
  }
   else if (layerConstraint == LAST_SEPARATE) {
    $setProperty(node, LAYER_CONSTRAINT, NONE_5);
    $setProperty(node, IN_LAYER_CONSTRAINT, ($clinit_InLayerConstraint() , BOTTOM_0));
  }
   else if (inLayerConstraint == ($clinit_InLayerConstraint() , TOP_0)) {
    $setProperty(node, LAYER_CONSTRAINT, FIRST_SEPARATE);
    $setProperty(node, IN_LAYER_CONSTRAINT, NONE_4);
  }
   else if (inLayerConstraint == BOTTOM_0) {
    $setProperty(node, LAYER_CONSTRAINT, LAST_SEPARATE);
    $setProperty(node, IN_LAYER_CONSTRAINT, NONE_4);
  }
}

function $transposeNodeLabelPlacement(node){
  var all, newPlacement, oldPlacement;
  oldPlacement = castTo($getProperty(node, ($clinit_LayoutOptions() , NODE_LABEL_PLACEMENT)), 18);
  if (oldPlacement.isEmpty()) {
    return;
  }
  newPlacement = (all = castTo($getEnumConstants(Lde_cau_cs_kieler_kiml_options_NodeLabelPlacement_2_classLit), 11) , new EnumSet$EnumSetImpl(all, castTo(createFrom(all, all.length), 11), 0));
  oldPlacement.contains(($clinit_NodeLabelPlacement() , INSIDE))?$add_17(newPlacement, INSIDE):$add_17(newPlacement, OUTSIDE);
  oldPlacement.contains(H_PRIORITY) || $add_17(newPlacement, H_PRIORITY);
  oldPlacement.contains(H_LEFT)?$add_17(newPlacement, V_TOP):oldPlacement.contains(H_CENTER)?$add_17(newPlacement, V_CENTER):oldPlacement.contains(H_RIGHT) && $add_17(newPlacement, V_BOTTOM);
  oldPlacement.contains(V_TOP)?$add_17(newPlacement, H_LEFT):oldPlacement.contains(V_CENTER)?$add_17(newPlacement, H_CENTER):oldPlacement.contains(V_BOTTOM) && $add_17(newPlacement, H_RIGHT);
  $setProperty(node, NODE_LABEL_PLACEMENT, newPlacement);
}

function $transposePortSide(side){
  switch (side.ordinal) {
    case 1:
      return $clinit_PortSide() , WEST;
    case 4:
      return $clinit_PortSide() , NORTH;
    case 3:
      return $clinit_PortSide() , EAST;
    case 2:
      return $clinit_PortSide() , SOUTH;
    default:return $clinit_PortSide() , UNDEFINED_4;
  }
}

function $transposeProperties(node){
  var minHeight, minWidth;
  minHeight = castTo($getProperty(node, ($clinit_LayoutOptions() , MIN_HEIGHT)), 15).value_0;
  minWidth = castTo($getProperty(node, MIN_WIDTH), 15).value_0;
  $setProperty(node, MIN_WIDTH, new Float_0(minHeight));
  $setProperty(node, MIN_HEIGHT, new Float_0(minWidth));
  switch (castTo($getProperty(node, ALIGNMENT), 103).ordinal) {
    case 1:
      $setProperty(node, ALIGNMENT, ($clinit_Alignment() , TOP));
      break;
    case 2:
      $setProperty(node, ALIGNMENT, ($clinit_Alignment() , BOTTOM));
      break;
    case 3:
      $setProperty(node, ALIGNMENT, ($clinit_Alignment() , LEFT));
      break;
    case 4:
      $setProperty(node, ALIGNMENT, ($clinit_Alignment() , RIGHT));
  }
}

function GraphTransformer(themode){
  this.mode = themode;
}

defineClass(269, 1, $intern_56, GraphTransformer);
_.process = function process_9(layeredGraph, monitor){
  var layer, layer$iterator, nodes, oldSide, oldSide0;
  $begin(monitor, 'Graph transformation (' + this.mode + ')', 1);
  nodes = newArrayList(layeredGraph.layerlessNodes);
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator), 16);
    $addAll_6(nodes, layer.nodes);
  }
  switch (this.mode.ordinal) {
    case 0:
      $mirrorX_0(nodes, layeredGraph);
      break;
    case 1:
      $transpose_0(nodes);
      oldSide0 = castTo($getProperty(layeredGraph, ($clinit_Properties() , EDGE_LABEL_SIDE_SELECTION)), 115);
      !!oldSide0 && $setProperty(layeredGraph, EDGE_LABEL_SIDE_SELECTION, $transpose_1(oldSide0));
      $transpose(layeredGraph.offset);
      $transpose(layeredGraph.size_0);
      break;
    case 2:
      $mirrorX_0(nodes, layeredGraph);
      $mirrorY_0(nodes, layeredGraph);
      $transpose_0(nodes);
      oldSide = castTo($getProperty(layeredGraph, ($clinit_Properties() , EDGE_LABEL_SIDE_SELECTION)), 115);
      !!oldSide && $setProperty(layeredGraph, EDGE_LABEL_SIDE_SELECTION, $transpose_1(oldSide));
      $transpose(layeredGraph.offset);
      $transpose(layeredGraph.size_0);
  }
  $done(monitor);
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_GraphTransformer_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'GraphTransformer', 269);
function $clinit_GraphTransformer$Mode(){
  $clinit_GraphTransformer$Mode = emptyMethod;
  MIRROR_X = new GraphTransformer$Mode('MIRROR_X', 0);
  TRANSPOSE = new GraphTransformer$Mode('TRANSPOSE', 1);
  MIRROR_AND_TRANSPOSE = new GraphTransformer$Mode('MIRROR_AND_TRANSPOSE', 2);
}

function GraphTransformer$Mode(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function values_31(){
  $clinit_GraphTransformer$Mode();
  return stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_intermediate_GraphTransformer$Mode_2_classLit, 1), $intern_13, 221, 0, [MIRROR_X, TRANSPOSE, MIRROR_AND_TRANSPOSE]);
}

defineClass(221, 17, {221:1, 3:1, 23:1, 17:1}, GraphTransformer$Mode);
var MIRROR_AND_TRANSPOSE, MIRROR_X, TRANSPOSE;
var Lde_cau_cs_kieler_klay_layered_intermediate_GraphTransformer$Mode_2_classLit = createForEnum('de.cau.cs.kieler.klay.layered.intermediate', 'GraphTransformer/Mode', 221, Ljava_lang_Enum_2_classLit, values_31);
function $createDummy(layeredGraph, originalDummy){
  var inputPort, newDummy, outputPort;
  newDummy = new LNode(layeredGraph);
  $copyProperties(newDummy, originalDummy);
  $setProperty(newDummy, ($clinit_InternalProperties() , EXT_PORT_REPLACED_DUMMY), originalDummy);
  $setProperty(newDummy, ($clinit_LayoutOptions() , PORT_CONSTRAINTS), ($clinit_PortConstraints() , FIXED_POS));
  $setProperty(newDummy, ALIGNMENT, ($clinit_Alignment() , CENTER));
  $setType(newDummy, ($clinit_LNode$NodeType() , EXTERNAL_PORT));
  inputPort = new LPort;
  $setNode(inputPort, newDummy);
  $setSide(inputPort, ($clinit_PortSide() , WEST));
  outputPort = new LPort;
  $setNode(outputPort, newDummy);
  $setSide(outputPort, EAST);
  return newDummy;
}

function $isNorthernSouthernDummy(node){
  var nodeType, portSide;
  nodeType = node.type_0;
  if (nodeType == ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
    portSide = castTo($getProperty(node, ($clinit_InternalProperties() , EXT_PORT_SIDE)), 32);
    return portSide == ($clinit_PortSide() , NORTH) || portSide == SOUTH;
  }
  return false;
}

function $processEasternAndWesternPortDummies(layeredGraph){
  var layers;
  if (!$isOrderFixed(castTo($getProperty(layeredGraph, ($clinit_LayoutOptions() , PORT_CONSTRAINTS)), 28))) {
    return;
  }
  layers = layeredGraph.layers;
  $processEasternAndWesternPortDummies_0((checkCriticalElementIndex(0, layers.array.length) , castTo(layers.array[0], 16)));
  $processEasternAndWesternPortDummies_0(castTo($get_8(layers, layers.array.length - 1), 16));
}

function $processEasternAndWesternPortDummies_0(layer){
  var externalPortSide, lastHierarchicalDummy, node, node$index, node$max, nodes;
  nodes = castTo($toArray_1(layer.nodes, initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LNode_2_classLit, $intern_49, 9, layer.nodes.array.length, 0, 1)), 51);
  sort_0(nodes, new HierarchicalPortConstraintProcessor$NodeComparator);
  lastHierarchicalDummy = null;
  for (node$index = 0 , node$max = nodes.length; node$index < node$max; ++node$index) {
    node = nodes[node$index];
    if (node.type_0 != ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
      break;
    }
    externalPortSide = castTo($getProperty(node, ($clinit_InternalProperties() , EXT_PORT_SIDE)), 32);
    if (externalPortSide != ($clinit_PortSide() , WEST) && externalPortSide != EAST) {
      continue;
    }
    !!lastHierarchicalDummy && castTo($getProperty(lastHierarchicalDummy, IN_LAYER_SUCCESSOR_CONSTRAINTS), 20).add_1(node);
    lastHierarchicalDummy = node;
  }
}

function $processNorthernAndSouthernPortDummies(layeredGraph){
  var currLayerIdx, currentLayer, currentNode, currentNode$iterator, dummy, dummy$iterator, edge, edge$iterator, edge$iterator0, entry, extPortToDummyNodeMap, i, layer, layerCount, layers, newDummyNodes, nextExtPortToDummyNodesMap, nextLayerDummy, nextNewDummyNodes, nodeList, originalDummy, originalDummy$iterator, originalExternalPortDummies, outerIter, portConstraints, prevExtPortToDummyNodesMap, prevLayerDummy, prevNewDummyNodes, sourceNode, targetNode;
  portConstraints = castTo($getProperty(layeredGraph, ($clinit_LayoutOptions() , PORT_CONSTRAINTS)), 28);
  if (!(portConstraints != ($clinit_PortConstraints() , FREE) && portConstraints != UNDEFINED_3)) {
    return;
  }
  layers = layeredGraph.layers;
  layerCount = layers.array.length;
  extPortToDummyNodeMap = new ArrayList_0((checkNonnegative(layerCount + 2, 'arraySize') , saturatedCast(add_20(add_20(5, layerCount + 2), (layerCount + 2) / 10 | 0))));
  newDummyNodes = new ArrayList_0((checkNonnegative(layerCount + 2, 'arraySize') , saturatedCast(add_20(add_20(5, layerCount + 2), (layerCount + 2) / 10 | 0))));
  $add_11(extPortToDummyNodeMap, new HashMap);
  $add_11(extPortToDummyNodeMap, new HashMap);
  $add_11(newDummyNodes, new ArrayList);
  $add_11(newDummyNodes, new ArrayList);
  originalExternalPortDummies = new HashSet;
  for (currLayerIdx = 0; currLayerIdx < layerCount; currLayerIdx++) {
    currentLayer = (checkCriticalElementIndex(currLayerIdx, layers.array.length) , castTo(layers.array[currLayerIdx], 16));
    prevExtPortToDummyNodesMap = (checkCriticalElementIndex(currLayerIdx, extPortToDummyNodeMap.array.length) , castTo(extPortToDummyNodeMap.array[currLayerIdx], 57));
    nextExtPortToDummyNodesMap = ($clinit_Maps() , new HashMap);
    extPortToDummyNodeMap.array[extPortToDummyNodeMap.array.length] = nextExtPortToDummyNodesMap;
    prevNewDummyNodes = (checkCriticalElementIndex(currLayerIdx, newDummyNodes.array.length) , castTo(newDummyNodes.array[currLayerIdx], 20));
    nextNewDummyNodes = new ArrayList;
    newDummyNodes.array[newDummyNodes.array.length] = nextNewDummyNodes;
    for (currentNode$iterator = new ArrayList$1(currentLayer.nodes); currentNode$iterator.i < currentNode$iterator.this$01.array.length;) {
      currentNode = castTo($next_8(currentNode$iterator), 9);
      for (edge$iterator0 = $iterator($getIncomingEdges_0(currentNode)); $hasNext_0(edge$iterator0);) {
        edge = castTo($next_2(edge$iterator0), 12);
        sourceNode = edge.source.owner;
        if (!$isNorthernSouthernDummy(sourceNode)) {
          continue;
        }
        originalExternalPortDummies.map_0.put(sourceNode, originalExternalPortDummies);
        prevLayerDummy = castTo(prevExtPortToDummyNodesMap.get_1($getProperty(sourceNode, ($clinit_InternalProperties() , ORIGIN))), 9);
        if (!prevLayerDummy) {
          prevLayerDummy = $createDummy(layeredGraph, sourceNode);
          prevExtPortToDummyNodesMap.put($getProperty(sourceNode, ORIGIN), prevLayerDummy);
          prevNewDummyNodes.add_1(prevLayerDummy);
        }
        $setSource(edge, castTo($get_8(prevLayerDummy.ports, 1), 7));
      }
      for (edge$iterator = $iterator($getOutgoingEdges_0(currentNode)); $hasNext_0(edge$iterator);) {
        edge = castTo($next_2(edge$iterator), 12);
        targetNode = edge.target.owner;
        if (!$isNorthernSouthernDummy(targetNode)) {
          continue;
        }
        originalExternalPortDummies.map_0.put(targetNode, originalExternalPortDummies);
        nextLayerDummy = castTo($get_9(nextExtPortToDummyNodesMap, $getProperty(targetNode, ($clinit_InternalProperties() , ORIGIN))), 9);
        if (!nextLayerDummy) {
          nextLayerDummy = $createDummy(layeredGraph, targetNode);
          $put_2(nextExtPortToDummyNodesMap, $getProperty(targetNode, ORIGIN), nextLayerDummy);
          nextNewDummyNodes.array[nextNewDummyNodes.array.length] = nextLayerDummy;
        }
        $setTarget(edge, castTo($get_8(nextLayerDummy.ports, 0), 7));
      }
    }
  }
  for (i = 0; i < newDummyNodes.array.length; i++) {
    nodeList = (checkCriticalElementIndex(i, newDummyNodes.array.length) , castTo(newDummyNodes.array[i], 20));
    if (nodeList.isEmpty()) {
      continue;
    }
    if (i == 0) {
      layer = new Layer(layeredGraph);
      checkCriticalPositionIndex(0, layers.array.length);
      insertTo(layers.array, 0, layer);
    }
     else if (i == extPortToDummyNodeMap.array.length - 1) {
      layer = new Layer(layeredGraph);
      layers.array[layers.array.length] = layer;
    }
     else {
      layer = (checkCriticalElementIndex(i - 1, layers.array.length) , castTo(layers.array[i - 1], 16));
    }
    for (dummy$iterator = nodeList.iterator_0(); dummy$iterator.hasNext_0();) {
      dummy = castTo(dummy$iterator.next_1(), 9);
      $setLayer_0(dummy, layer);
    }
  }
  for (originalDummy$iterator = (outerIter = (new AbstractMap$1(originalExternalPortDummies.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter)); originalDummy$iterator.val$outerIter2.hasNext_0();) {
    originalDummy = (entry = castTo(originalDummy$iterator.val$outerIter2.next_1(), 21) , castTo(entry.getKey(), 9));
    $setLayer_0(originalDummy, null);
  }
}

function HierarchicalPortConstraintProcessor(){
}

defineClass(448, 1, $intern_56, HierarchicalPortConstraintProcessor);
_.process = function process_10(layeredGraph, monitor){
  $begin(monitor, 'Hierarchical port constraint processing', 1);
  $processEasternAndWesternPortDummies(layeredGraph);
  $processNorthernAndSouthernPortDummies(layeredGraph);
  $done(monitor);
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_HierarchicalPortConstraintProcessor_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'HierarchicalPortConstraintProcessor', 448);
function $compare_5(node1, node2){
  var nodePos1, nodePos2, nodeType1, nodeType2;
  nodeType1 = node1.type_0;
  nodePos1 = checkNotNull_1(castToDouble($getProperty(node1, ($clinit_InternalProperties() , PORT_RATIO_OR_POSITION_0))));
  nodeType2 = node2.type_0;
  nodePos2 = checkNotNull_1(castToDouble($getProperty(node2, PORT_RATIO_OR_POSITION_0)));
  return nodeType2 != ($clinit_LNode$NodeType() , EXTERNAL_PORT)?-1:nodeType1 != EXTERNAL_PORT?1:nodePos1 == nodePos2?0:nodePos1 < nodePos2?-1:1;
}

function HierarchicalPortConstraintProcessor$NodeComparator(){
}

defineClass(449, 1, $intern_9, HierarchicalPortConstraintProcessor$NodeComparator);
_.compare_0 = function compare_17(node1, node2){
  return $compare_5(castTo(node1, 9), castTo(node2, 9));
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_HierarchicalPortConstraintProcessor$NodeComparator_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'HierarchicalPortConstraintProcessor/NodeComparator', 449);
function $setWidths(nodes, topDown, delta){
  var currentWidth, node, node$iterator, port, port$iterator, step;
  currentWidth = 0;
  step = delta;
  if (!topDown) {
    currentWidth = delta * (nodes.array.length - 1);
    step *= -1;
  }
  for (node$iterator = new ArrayList$1(nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 9);
    $setProperty(node, ($clinit_LayoutOptions() , ALIGNMENT), ($clinit_Alignment() , CENTER));
    node.size_0.x_0 = currentWidth;
    for (port$iterator = $getPorts_0(node, ($clinit_PortSide() , EAST)).iterator_0(); port$iterator.hasNext_0();) {
      port = castTo(port$iterator.next_1(), 7);
      port.pos.x_0 = currentWidth;
    }
    currentWidth += step;
  }
}

function HierarchicalPortDummySizeProcessor(){
}

defineClass(450, 1, $intern_56, HierarchicalPortDummySizeProcessor);
_.process = function process_11(layeredGraph, monitor){
  var delta, layer, layer$iterator, node, node$iterator, normalSpacing, northernDummies, side, smallSpacing, southernDummies;
  $begin(monitor, 'Hierarchical port dummy size processing', 1);
  northernDummies = new ArrayList;
  southernDummies = new ArrayList;
  normalSpacing = castTo($getProperty(layeredGraph, ($clinit_InternalProperties() , SPACING_0)), 15).value_0;
  smallSpacing = normalSpacing * castTo($getProperty(layeredGraph, ($clinit_Properties() , EDGE_SPACING_FACTOR)), 15).value_0;
  delta = smallSpacing * 2;
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator), 16);
    northernDummies.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
    southernDummies.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      if (node.type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
        side = castTo($getProperty(node, EXT_PORT_SIDE), 32);
        side == ($clinit_PortSide() , NORTH)?(northernDummies.array[northernDummies.array.length] = node , true):side == SOUTH && (southernDummies.array[southernDummies.array.length] = node , true);
      }
    }
    $setWidths(northernDummies, true, delta);
    $setWidths(southernDummies, false, delta);
  }
  $done(monitor);
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_HierarchicalPortDummySizeProcessor_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'HierarchicalPortDummySizeProcessor', 450);
function $assignAscendingCoordinates(dummies, graph){
  var currentPosition, currentSize, edgeSpacing, index_0, lastCoordinate;
  edgeSpacing = castTo($getProperty(graph, ($clinit_InternalProperties() , SPACING_0)), 15).value_0 * castTo($getProperty(graph, ($clinit_Properties() , EDGE_SPACING_FACTOR)), 15).value_0;
  lastCoordinate = dummies[0].pos.x_0 + dummies[0].size_0.x_0;
  for (index_0 = 1; index_0 < dummies.length; index_0++) {
    currentPosition = dummies[index_0].pos;
    currentSize = dummies[index_0].size_0;
    currentPosition.x_0 <= lastCoordinate + edgeSpacing && (currentPosition.x_0 = lastCoordinate + edgeSpacing);
    lastCoordinate = currentPosition.x_0 + currentSize.x_0;
  }
}

function $calculateNorthSouthDummyPositions(dummy){
  var anchor, connectedPort, connectedPort$iterator, dummyInPort, offset, posSum;
  dummyInPort = castTo($get_8(dummy.ports, 0), 7);
  posSum = 0;
  for (connectedPort$iterator = $iterator(concat(($clinit_ImmutableList() , new RegularImmutableList(nullCheckedList(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [new LPort$7(dummyInPort), new LPort$8(dummyInPort)])))))); $hasNext_0(connectedPort$iterator);) {
    connectedPort = castTo($next_2(connectedPort$iterator), 7);
    posSum += connectedPort.owner.pos.x_0 + connectedPort.pos.x_0 + connectedPort.anchor.x_0;
  }
  anchor = castTo($getProperty(dummy, ($clinit_LayoutOptions() , PORT_ANCHOR)), 10);
  offset = !anchor?0:anchor.x_0;
  dummy.pos.x_0 = posSum / (dummyInPort.incomingEdges.array.length + dummyInPort.outgoingEdges.array.length) - offset;
}

function $correctSlantedEdgeSegments(layer){
  var bendPoints, edge, edge$iterator, extPortSide, firstBendPoint, lastBendPoint, node, node$iterator, sourcePort, targetPort;
  for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 9);
    if (node.type_0 != ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
      continue;
    }
    extPortSide = castTo($getProperty(node, ($clinit_InternalProperties() , EXT_PORT_SIDE)), 32);
    if (extPortSide == ($clinit_PortSide() , EAST) || extPortSide == WEST) {
      for (edge$iterator = $iterator($getConnectedEdges(node)); $hasNext_0(edge$iterator);) {
        edge = castTo($next_2(edge$iterator), 12);
        bendPoints = edge.bendPoints;
        if (bendPoints.size_0 == 0) {
          continue;
        }
        sourcePort = edge.source;
        if (sourcePort.owner == node) {
          firstBendPoint = (checkCriticalElement(bendPoints.size_0 != 0) , castTo(bendPoints.header.next_0.value_0, 10));
          firstBendPoint.y_0 = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [sourcePort.owner.pos, sourcePort.pos, sourcePort.anchor])).y_0;
        }
        targetPort = edge.target;
        if (targetPort.owner == node) {
          lastBendPoint = (checkCriticalElement(bendPoints.size_0 != 0) , castTo(bendPoints.tail.prev.value_0, 10));
          lastBendPoint.y_0 = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [targetPort.owner.pos, targetPort.pos, targetPort.anchor])).y_0;
        }
      }
    }
  }
}

function $ensureUniquePositions(dummies, graph){
  var dummyArray;
  if (dummies.array.length == 0) {
    return;
  }
  dummyArray = castTo($toArray_1(dummies, initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LNode_2_classLit, $intern_49, 9, dummies.array.length, 0, 1)), 51);
  sort_0(dummyArray, new HierarchicalPortOrthogonalEdgeRouter$1);
  $assignAscendingCoordinates(dummyArray, graph);
}

function $fixCoordinates(layer, constraints, graph){
  var borderSpacing, borderSpacing0, extPortSide, extPortSize, graphActualSize, insets, newActualGraphHeight, node, node$iterator, node$iterator0, nodePosition, offset, ratio, requiredActualGraphHeight;
  insets = graph.insets;
  borderSpacing0 = castTo($getProperty(graph, ($clinit_InternalProperties() , BORDER_SPACING_0)), 15).value_0;
  offset = graph.offset;
  graphActualSize = (borderSpacing = castTo($getProperty(graph, BORDER_SPACING_0), 15).value_0 , new KVector_1(graph.size_0.x_0 + graph.insets.left + graph.insets.right + 2 * borderSpacing, graph.size_0.y_0 + graph.insets.top_0 + graph.insets.bottom + 2 * borderSpacing));
  newActualGraphHeight = graphActualSize.y_0;
  for (node$iterator0 = new ArrayList$1(layer.nodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
    node = castTo($next_8(node$iterator0), 9);
    if (node.type_0 != ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
      continue;
    }
    extPortSide = castTo($getProperty(node, EXT_PORT_SIDE), 32);
    extPortSize = castTo($getProperty(node, EXT_PORT_SIZE), 10);
    nodePosition = node.pos;
    switch (extPortSide.ordinal) {
      case 2:
        nodePosition.x_0 = graph.size_0.x_0 + borderSpacing0 + insets.right - offset.x_0;
        break;
      case 4:
        nodePosition.x_0 = -offset.x_0 - borderSpacing0 - insets.left;
    }
    requiredActualGraphHeight = 0;
    switch (extPortSide.ordinal) {
      case 2:
      case 4:
        if (constraints == ($clinit_PortConstraints() , FIXED_RATIO)) {
          ratio = checkNotNull_1(castToDouble($getProperty(node, PORT_RATIO_OR_POSITION_0)));
          nodePosition.y_0 = graphActualSize.y_0 * ratio - castTo($getProperty(node, ($clinit_LayoutOptions() , PORT_ANCHOR)), 10).y_0;
          requiredActualGraphHeight = nodePosition.y_0 + extPortSize.y_0;
          $borderToContentAreaCoordinates(node, false, true);
        }
         else if (constraints == FIXED_POS) {
          nodePosition.y_0 = checkNotNull_1(castToDouble($getProperty(node, PORT_RATIO_OR_POSITION_0))) - castTo($getProperty(node, ($clinit_LayoutOptions() , PORT_ANCHOR)), 10).y_0;
          requiredActualGraphHeight = nodePosition.y_0 + extPortSize.y_0;
          $borderToContentAreaCoordinates(node, false, true);
        }

    }
    newActualGraphHeight = newActualGraphHeight > requiredActualGraphHeight?newActualGraphHeight:requiredActualGraphHeight;
  }
  graph.size_0.y_0 += newActualGraphHeight - graphActualSize.y_0;
  for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 9);
    if (node.type_0 != ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
      continue;
    }
    extPortSide = castTo($getProperty(node, EXT_PORT_SIDE), 32);
    nodePosition = node.pos;
    switch (extPortSide.ordinal) {
      case 1:
        nodePosition.y_0 = -offset.y_0 - borderSpacing0 - insets.top_0;
        break;
      case 3:
        nodePosition.y_0 = graph.size_0.y_0 + borderSpacing0 + insets.bottom - offset.y_0;
    }
  }
}

function $removeTemporaryNorthSouthDummies(layeredGraph){
  var edge, edge$index, edge$index0, edge$max, edge$max0, edges, firstBendPoint, incomingEdgeBendPoints, iter, lastBendPoint, layer, layer$iterator, node, node$iterator, node$iterator0, nodeInPort, nodeOriginPort, nodeOutPort, nodeToOriginEdge, nodesToRemove, outgoingEdgeBendPoints, port, port$iterator, replacedDummy, replacedDummyPort;
  nodesToRemove = new ArrayList;
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator), 16);
    for (node$iterator0 = new ArrayList$1(layer.nodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
      node = castTo($next_8(node$iterator0), 9);
      if (node.type_0 != ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
        continue;
      }
      if ($getProperty(node, ($clinit_InternalProperties() , EXT_PORT_REPLACED_DUMMY)) == null) {
        continue;
      }
      nodeInPort = null;
      nodeOutPort = null;
      nodeOriginPort = null;
      for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
        port = castTo($next_8(port$iterator), 7);
        switch (port.side.ordinal) {
          case 4:
            nodeInPort = port;
            break;
          case 2:
            nodeOutPort = port;
            break;
          default:nodeOriginPort = port;
        }
      }
      nodeToOriginEdge = castTo($get_8(nodeOriginPort.outgoingEdges, 0), 12);
      incomingEdgeBendPoints = new KVectorChain_0(nodeToOriginEdge.bendPoints);
      firstBendPoint = new KVector_2(nodeOriginPort.pos);
      $add_7(firstBendPoint, node.pos);
      iter = $listIterator_2(incomingEdgeBendPoints, 0);
      $add_19(iter, firstBendPoint);
      outgoingEdgeBendPoints = reverse_1(nodeToOriginEdge.bendPoints);
      lastBendPoint = new KVector_2(nodeOriginPort.pos);
      $add_7(lastBendPoint, node.pos);
      $addNode_0(outgoingEdgeBendPoints, lastBendPoint, outgoingEdgeBendPoints.tail.prev, outgoingEdgeBendPoints.tail);
      replacedDummy = castTo($getProperty(node, EXT_PORT_REPLACED_DUMMY), 9);
      replacedDummyPort = castTo($get_8(replacedDummy.ports, 0), 7);
      edges = castTo($toArray_1(nodeInPort.incomingEdges, initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LEdge_2_classLit, $intern_57, 12, 0, 0, 1)), 47);
      for (edge$index0 = 0 , edge$max0 = edges.length; edge$index0 < edge$max0; ++edge$index0) {
        edge = edges[edge$index0];
        $setTarget(edge, replacedDummyPort);
        $addAllAsCopies(edge.bendPoints, edge.bendPoints.size_0, incomingEdgeBendPoints);
      }
      edges = castTo($toArray_1(nodeOutPort.outgoingEdges, initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LEdge_2_classLit, $intern_57, 12, nodeOutPort.outgoingEdges.array.length, 0, 1)), 47);
      for (edge$index = 0 , edge$max = edges.length; edge$index < edge$max; ++edge$index) {
        edge = edges[edge$index];
        $setSource(edge, replacedDummyPort);
        $addAllAsCopies(edge.bendPoints, 0, outgoingEdgeBendPoints);
      }
      $setSource(nodeToOriginEdge, null);
      $setTarget(nodeToOriginEdge, null);
      nodesToRemove.array[nodesToRemove.array.length] = node;
    }
  }
  for (node$iterator = new ArrayList$1(nodesToRemove); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 9);
    $setLayer_0(node, null);
  }
}

function $restoreDummy(dummy, restoredDummies){
  var dummyPort, portSide;
  if (restoredDummies.map_0.containsKey(dummy)) {
    return;
  }
   else {
    portSide = castTo($getProperty(dummy, ($clinit_InternalProperties() , EXT_PORT_SIDE)), 32);
    dummyPort = castTo($get_8(dummy.ports, 0), 7);
    portSide == ($clinit_PortSide() , NORTH)?$setSide(dummyPort, SOUTH):portSide == SOUTH && $setSide(dummyPort, NORTH);
    restoredDummies.map_0.put(dummy, restoredDummies);
  }
}

function $restoreNorthSouthDummies(layeredGraph){
  var dummy, dummy$iterator, entry, lastLayer, layer, layer$iterator, node, node$iterator, outerIter, replacedDummy, restoredDummies, outPort, extPortSide, inPort, edge;
  restoredDummies = new LinkedHashSet;
  lastLayer = null;
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator), 16);
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      if (node.type_0 != ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
        continue;
      }
      replacedDummy = castTo($getProperty(node, ($clinit_InternalProperties() , EXT_PORT_REPLACED_DUMMY)), 9);
      if (replacedDummy) {
        $restoreDummy(replacedDummy, restoredDummies);
        outPort = new LPort;
        $setNode(outPort, node);
        extPortSide = castTo($getProperty(node, EXT_PORT_SIDE), 32);
        $setSide(outPort, extPortSide);
        inPort = castTo($get_8(replacedDummy.ports, 0), 7);
        edge = new LEdge;
        $setSource(edge, outPort);
        $setTarget(edge, inPort);
      }
    }
    lastLayer = layer;
  }
  for (dummy$iterator = (outerIter = (new AbstractMap$1(restoredDummies.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter)); dummy$iterator.val$outerIter2.hasNext_0();) {
    dummy = (entry = castTo(dummy$iterator.val$outerIter2.next_1(), 21) , castTo(entry.getKey(), 9));
    $setLayer_0(dummy, lastLayer);
  }
  return restoredDummies;
}

function $restoreProperOrder(dummies, graph){
  var dummyArray;
  if (dummies.array.length == 0) {
    return;
  }
  dummyArray = castTo($toArray_1(dummies, initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LNode_2_classLit, $intern_49, 9, dummies.array.length, 0, 1)), 51);
  sort_0(dummyArray, new HierarchicalPortOrthogonalEdgeRouter$2);
  $assignAscendingCoordinates(dummyArray, graph);
}

function $routeEdges(this$static, layeredGraph, northSouthDummies){
  var edge, edge$iterator, edgeSpacing, entry, hierarchicalPortDummy, hierarchicalPortDummy$iterator, nodeSpacing, northernSourceLayer, northernTargetLayer, outerIter, portSide, routingGenerator, slots, southernSourceLayer, southernTargetLayer;
  northernSourceLayer = new LinkedHashSet;
  northernTargetLayer = new LinkedHashSet;
  southernSourceLayer = new LinkedHashSet;
  southernTargetLayer = new LinkedHashSet;
  nodeSpacing = castTo($getProperty(layeredGraph, ($clinit_InternalProperties() , SPACING_0)), 15).value_0;
  edgeSpacing = nodeSpacing * castTo($getProperty(layeredGraph, ($clinit_Properties() , EDGE_SPACING_FACTOR)), 15).value_0;
  unsafeCast(checkNotNull_1(castToBoolean($getProperty(layeredGraph, ($clinit_LayoutOptions() , DEBUG_MODE)))));
  for (hierarchicalPortDummy$iterator = (outerIter = (new AbstractMap$1(northSouthDummies.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter)); hierarchicalPortDummy$iterator.val$outerIter2.hasNext_0();) {
    hierarchicalPortDummy = (entry = castTo(hierarchicalPortDummy$iterator.val$outerIter2.next_1(), 21) , castTo(entry.getKey(), 9));
    portSide = castTo($getProperty(hierarchicalPortDummy, EXT_PORT_SIDE), 32);
    if (portSide == ($clinit_PortSide() , NORTH)) {
      northernTargetLayer.map_0.put(hierarchicalPortDummy, northernTargetLayer);
      for (edge$iterator = $iterator($getIncomingEdges_0(hierarchicalPortDummy)); $hasNext_0(edge$iterator);) {
        edge = castTo($next_2(edge$iterator), 12);
        $add_18(northernSourceLayer, edge.source.owner);
      }
    }
     else if (portSide == SOUTH) {
      southernTargetLayer.map_0.put(hierarchicalPortDummy, southernTargetLayer);
      for (edge$iterator = $iterator($getIncomingEdges_0(hierarchicalPortDummy)); $hasNext_0(edge$iterator);) {
        edge = castTo($next_2(edge$iterator), 12);
        $add_18(southernSourceLayer, edge.source.owner);
      }
    }
  }
  if (northernSourceLayer.map_0.size_1() != 0) {
    routingGenerator = new OrthogonalRoutingGenerator(2, edgeSpacing);
    slots = $routeEdges_0(routingGenerator, layeredGraph, northernSourceLayer, northernTargetLayer, -nodeSpacing - layeredGraph.offset.y_0);
    if (slots > 0) {
      this$static.northernExtPortEdgeRoutingHeight = nodeSpacing + (slots - 1) * edgeSpacing;
      layeredGraph.offset.y_0 += this$static.northernExtPortEdgeRoutingHeight;
      layeredGraph.size_0.y_0 += this$static.northernExtPortEdgeRoutingHeight;
    }
  }
  if (southernSourceLayer.map_0.size_1() != 0) {
    routingGenerator = new OrthogonalRoutingGenerator(1, edgeSpacing);
    slots = $routeEdges_0(routingGenerator, layeredGraph, southernSourceLayer, southernTargetLayer, layeredGraph.size_0.y_0 + nodeSpacing - layeredGraph.offset.y_0);
    slots > 0 && (layeredGraph.size_0.y_0 += nodeSpacing + (slots - 1) * edgeSpacing);
  }
}

function $setNorthSouthDummyCoordinates(layeredGraph, northSouthDummies){
  var borderSpacing, constraints, dummy, dummy$iterator, entry, graphInsets, graphSize, graphWidth, northY, northernDummies, outerIter, southY, southernDummies, anchor, offset, anchor_0, offset_0;
  constraints = castTo($getProperty(layeredGraph, ($clinit_LayoutOptions() , PORT_CONSTRAINTS)), 28);
  graphSize = layeredGraph.size_0;
  graphInsets = layeredGraph.insets;
  borderSpacing = castTo($getProperty(layeredGraph, ($clinit_InternalProperties() , BORDER_SPACING_0)), 15).value_0;
  graphWidth = graphSize.x_0 + graphInsets.left + graphInsets.right + 2 * borderSpacing;
  northY = 0 - graphInsets.top_0 - borderSpacing - layeredGraph.offset.y_0;
  southY = graphSize.y_0 + graphInsets.top_0 + graphInsets.bottom + 2 * borderSpacing - layeredGraph.offset.y_0;
  northernDummies = new ArrayList;
  southernDummies = new ArrayList;
  for (dummy$iterator = (outerIter = (new AbstractMap$1(northSouthDummies.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter)); dummy$iterator.val$outerIter2.hasNext_0();) {
    dummy = (entry = castTo(dummy$iterator.val$outerIter2.next_1(), 21) , castTo(entry.getKey(), 9));
    switch (constraints.ordinal) {
      case 1:
      case 2:
      case 3:
        $calculateNorthSouthDummyPositions(dummy);
        break;
      case 4:
        anchor = castTo($getProperty(dummy, PORT_ANCHOR), 10);
        offset = !anchor?0:anchor.x_0;
        dummy.pos.x_0 = graphWidth * checkNotNull_1(castToDouble($getProperty(dummy, PORT_RATIO_OR_POSITION_0))) - offset;
        $borderToContentAreaCoordinates(dummy, true, false);
        break;
      case 5:
        anchor_0 = castTo($getProperty(dummy, PORT_ANCHOR), 10);
        offset_0 = !anchor_0?0:anchor_0.x_0;
        dummy.pos.x_0 = checkNotNull_1(castToDouble($getProperty(dummy, PORT_RATIO_OR_POSITION_0))) - offset_0;
        $borderToContentAreaCoordinates(dummy, true, false);
        graphSize.x_0 = max_1(graphSize.x_0, dummy.pos.x_0 + dummy.size_0.x_0 / 2);
    }
    switch (castTo($getProperty(dummy, EXT_PORT_SIDE), 32).ordinal) {
      case 1:
        dummy.pos.y_0 = northY;
        northernDummies.array[northernDummies.array.length] = dummy;
        break;
      case 3:
        dummy.pos.y_0 = southY;
        southernDummies.array[southernDummies.array.length] = dummy;
    }
  }
  switch (constraints.ordinal) {
    case 1:
    case 2:
      $ensureUniquePositions(northernDummies, layeredGraph);
      $ensureUniquePositions(southernDummies, layeredGraph);
      break;
    case 3:
      $restoreProperOrder(northernDummies, layeredGraph);
      $restoreProperOrder(southernDummies, layeredGraph);
  }
}

function HierarchicalPortOrthogonalEdgeRouter(){
}

defineClass(451, 1, $intern_56, HierarchicalPortOrthogonalEdgeRouter);
_.process = function process_12(layeredGraph, monitor){
  var northSouthDummies, constraints, layers, layers_0;
  $begin(monitor, 'Orthogonally routing hierarchical port edges', 1);
  this.northernExtPortEdgeRoutingHeight = 0;
  northSouthDummies = $restoreNorthSouthDummies(layeredGraph);
  $setNorthSouthDummyCoordinates(layeredGraph, northSouthDummies);
  $routeEdges(this, layeredGraph, northSouthDummies);
  $removeTemporaryNorthSouthDummies(layeredGraph);
  constraints = castTo($getProperty(layeredGraph, ($clinit_LayoutOptions() , PORT_CONSTRAINTS)), 28);
  layers = layeredGraph.layers;
  $fixCoordinates((checkCriticalElementIndex(0, layers.array.length) , castTo(layers.array[0], 16)), constraints, layeredGraph);
  $fixCoordinates(castTo($get_8(layers, layers.array.length - 1), 16), constraints, layeredGraph);
  layers_0 = layeredGraph.layers;
  $correctSlantedEdgeSegments((checkCriticalElementIndex(0, layers_0.array.length) , castTo(layers_0.array[0], 16)));
  $correctSlantedEdgeSegments(castTo($get_8(layers_0, layers_0.array.length - 1), 16));
  $done(monitor);
}
;
_.northernExtPortEdgeRoutingHeight = 0;
var Lde_cau_cs_kieler_klay_layered_intermediate_HierarchicalPortOrthogonalEdgeRouter_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'HierarchicalPortOrthogonalEdgeRouter', 451);
function $compare_6(a, b){
  return compare_31(a.pos.x_0, b.pos.x_0);
}

function HierarchicalPortOrthogonalEdgeRouter$1(){
}

defineClass(452, 1, $intern_9, HierarchicalPortOrthogonalEdgeRouter$1);
_.compare_0 = function compare_18(a, b){
  return $compare_6(castTo(a, 9), castTo(b, 9));
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_HierarchicalPortOrthogonalEdgeRouter$1_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'HierarchicalPortOrthogonalEdgeRouter/1', 452);
function $compare_7(a, b){
  return compare_31(checkNotNull_1(castToDouble($getProperty(a, ($clinit_InternalProperties() , PORT_RATIO_OR_POSITION_0)))), checkNotNull_1(castToDouble($getProperty(b, PORT_RATIO_OR_POSITION_0))));
}

function HierarchicalPortOrthogonalEdgeRouter$2(){
}

defineClass(453, 1, $intern_9, HierarchicalPortOrthogonalEdgeRouter$2);
_.compare_0 = function compare_19(a, b){
  return $compare_7(castTo(a, 9), castTo(b, 9));
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_HierarchicalPortOrthogonalEdgeRouter$2_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'HierarchicalPortOrthogonalEdgeRouter/2', 453);
function $fixCoordinates_0(layer, layeredGraph){
  var borderSpacing, extPortSide, finalYCoordinate, graphHeight, node, node$iterator, portConstraints;
  portConstraints = castTo($getProperty(layeredGraph, ($clinit_LayoutOptions() , PORT_CONSTRAINTS)), 28);
  if (!(portConstraints == ($clinit_PortConstraints() , FIXED_RATIO) || portConstraints == FIXED_POS)) {
    return;
  }
  graphHeight = (borderSpacing = castTo($getProperty(layeredGraph, ($clinit_InternalProperties() , BORDER_SPACING_0)), 15).value_0 , new KVector_1(layeredGraph.size_0.x_0 + layeredGraph.insets.left + layeredGraph.insets.right + 2 * borderSpacing, layeredGraph.size_0.y_0 + layeredGraph.insets.top_0 + layeredGraph.insets.bottom + 2 * borderSpacing)).y_0;
  for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 9);
    if (node.type_0 != ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
      continue;
    }
    extPortSide = castTo($getProperty(node, EXT_PORT_SIDE), 32);
    if (extPortSide != ($clinit_PortSide() , EAST) && extPortSide != WEST) {
      continue;
    }
    finalYCoordinate = checkNotNull_1(castToDouble($getProperty(node, PORT_RATIO_OR_POSITION_0)));
    portConstraints == FIXED_RATIO && (finalYCoordinate *= graphHeight);
    node.pos.y_0 = finalYCoordinate - castTo($getProperty(node, PORT_ANCHOR), 10).y_0;
    $borderToContentAreaCoordinates(node, false, true);
  }
}

function HierarchicalPortPositionProcessor(){
}

defineClass(454, 1, $intern_56, HierarchicalPortPositionProcessor);
_.process = function process_13(layeredGraph, monitor){
  var layers;
  $begin(monitor, 'Hierarchical port position processing', 1);
  layers = layeredGraph.layers;
  layers.array.length > 0 && $fixCoordinates_0((checkCriticalElementIndex(0, layers.array.length) , castTo(layers.array[0], 16)), layeredGraph);
  layers.array.length > 1 && $fixCoordinates_0(castTo($get_8(layers, layers.array.length - 1), 16), layeredGraph);
  $done(monitor);
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_HierarchicalPortPositionProcessor_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'HierarchicalPortPositionProcessor', 454);
function $mergeNodes(mergeSource, mergeTarget, keepSourcePort, keepTargetPort){
  var mergeTargetInputPort, mergeTargetOutputPort, port, port$iterator;
  mergeTargetInputPort = castTo($getPorts_0(mergeTarget, ($clinit_PortSide() , WEST)).iterator_0().next_1(), 7);
  mergeTargetOutputPort = castTo($getPorts_0(mergeTarget, EAST).iterator_0().next_1(), 7);
  for (port$iterator = new ArrayList$1(mergeSource.ports); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_8(port$iterator), 7);
    while (port.incomingEdges.array.length != 0) {
      $setTarget(castTo($get_8(port.incomingEdges, 0), 12), mergeTargetInputPort);
    }
    while (port.outgoingEdges.array.length != 0) {
      $setSource(castTo($get_8(port.outgoingEdges, 0), 12), mergeTargetOutputPort);
    }
  }
  keepSourcePort || $setProperty(mergeTarget, ($clinit_InternalProperties() , LONG_EDGE_SOURCE), null);
  keepTargetPort || $setProperty(mergeTarget, ($clinit_InternalProperties() , LONG_EDGE_TARGET), null);
}

function HyperedgeDummyMerger(){
}

defineClass(471, 1, $intern_56, HyperedgeDummyMerger);
_.process = function process_14(layeredGraph, monitor){
  var currNode, currNodePropertiesSet, currNodeSource, currNodeTarget, currNodeType, lastNode, lastNodePropertiesSet, lastNodeSource, lastNodeTarget, lastNodeType, layer, layerIter, nodeIndex, nodes;
  $begin(monitor, 'Hyperedge merging', 1);
  layerIter = new AbstractList$ListIteratorImpl(layeredGraph.layers, 0);
  while (layerIter.i < layerIter.this$01_0.size_1()) {
    layer = (checkCriticalElement(layerIter.i < layerIter.this$01_0.size_1()) , castTo(layerIter.this$01_0.get_2(layerIter.last = layerIter.i++), 16));
    nodes = layer.nodes;
    if (nodes.array.length == 0) {
      continue;
    }
    lastNode = null;
    lastNodeType = null;
    for (nodeIndex = 0; nodeIndex < nodes.array.length; nodeIndex++) {
      currNode = (checkCriticalElementIndex(nodeIndex, nodes.array.length) , castTo(nodes.array[nodeIndex], 9));
      currNodeType = currNode.type_0;
      if (currNodeType == ($clinit_LNode$NodeType() , LONG_EDGE) && lastNodeType == LONG_EDGE) {
        currNodeSource = castTo($getProperty(currNode, ($clinit_InternalProperties() , LONG_EDGE_SOURCE)), 7);
        lastNodeSource = castTo($getProperty(lastNode, LONG_EDGE_SOURCE), 7);
        currNodeTarget = castTo($getProperty(currNode, LONG_EDGE_TARGET), 7);
        lastNodeTarget = castTo($getProperty(lastNode, LONG_EDGE_TARGET), 7);
        currNodePropertiesSet = !!currNodeSource || !!currNodeTarget;
        lastNodePropertiesSet = !!lastNodeSource || !!lastNodeTarget;
        if (currNodePropertiesSet && lastNodePropertiesSet && (currNodeSource == lastNodeSource || currNodeTarget == lastNodeTarget)) {
          $mergeNodes(currNode, lastNode, currNodeSource == lastNodeSource, currNodeTarget == lastNodeTarget);
          checkCriticalElementIndex(nodeIndex, nodes.array.length);
          removeFrom(nodes.array, nodeIndex, 1);
          --nodeIndex;
          currNode = lastNode;
          currNodeType = lastNodeType;
        }
      }
      lastNode = currNode;
      lastNodeType = currNodeType;
    }
  }
  $done(monitor);
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_HyperedgeDummyMerger_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'HyperedgeDummyMerger', 471);
function $moveHypernode(layeredGraph, hypernode, right){
  var bendEdges, bendx, diffx, diffy, edge, edge$iterator, first, firstPoint, junctionPoints, lastPoint, northPort, port, port$iterator, second, southPort;
  bendEdges = new ArrayList;
  bendx = $intern_3;
  diffx = $intern_3;
  diffy = $intern_3;
  if (right) {
    bendx = layeredGraph.size_0.x_0;
    for (port$iterator = new ArrayList$1(hypernode.ports); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_8(port$iterator), 7);
      for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
        edge = castTo($next_8(edge$iterator), 12);
        if (edge.bendPoints.size_0 != 0) {
          firstPoint = castTo($getFirst(edge.bendPoints), 10);
          if (firstPoint.x_0 < bendx) {
            diffx = bendx - firstPoint.x_0;
            diffy = $intern_3;
            bendEdges.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
            bendx = firstPoint.x_0;
          }
          if (firstPoint.x_0 <= bendx) {
            bendEdges.array[bendEdges.array.length] = edge;
            edge.bendPoints.size_0 > 1 && (diffy = min_1(diffy, abs_0(castTo($get_4(edge.bendPoints, 1), 10).y_0 - firstPoint.y_0)));
          }
        }
      }
    }
  }
   else {
    for (port$iterator = new ArrayList$1(hypernode.ports); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_8(port$iterator), 7);
      for (edge$iterator = new ArrayList$1(port.incomingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
        edge = castTo($next_8(edge$iterator), 12);
        if (edge.bendPoints.size_0 != 0) {
          lastPoint = castTo($getLast(edge.bendPoints), 10);
          if (lastPoint.x_0 > bendx) {
            diffx = lastPoint.x_0 - bendx;
            diffy = $intern_3;
            bendEdges.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
            bendx = lastPoint.x_0;
          }
          if (lastPoint.x_0 >= bendx) {
            bendEdges.array[bendEdges.array.length] = edge;
            edge.bendPoints.size_0 > 1 && (diffy = min_1(diffy, abs_0(castTo($get_4(edge.bendPoints, edge.bendPoints.size_0 - 2), 10).y_0 - lastPoint.y_0)));
          }
        }
      }
    }
  }
  if (bendEdges.array.length != 0 && diffx > hypernode.size_0.x_0 / 2 && diffy > hypernode.size_0.y_0 / 2) {
    northPort = new LPort;
    $setNode(northPort, hypernode);
    $setSide(northPort, ($clinit_PortSide() , NORTH));
    northPort.pos.x_0 = hypernode.size_0.x_0 / 2;
    southPort = new LPort;
    $setNode(southPort, hypernode);
    $setSide(southPort, SOUTH);
    southPort.pos.x_0 = hypernode.size_0.x_0 / 2;
    southPort.pos.y_0 = hypernode.size_0.y_0;
    for (edge$iterator = new ArrayList$1(bendEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
      edge = castTo($next_8(edge$iterator), 12);
      if (right) {
        first = castTo($removeFirst(edge.bendPoints), 10);
        second = edge.bendPoints.size_0 == 0?$getAbsoluteAnchor(edge.target):castTo($getFirst(edge.bendPoints), 10);
        second.y_0 >= first.y_0?$setSource(edge, southPort):$setSource(edge, northPort);
      }
       else {
        first = castTo($removeLast(edge.bendPoints), 10);
        second = edge.bendPoints.size_0 == 0?$getAbsoluteAnchor(edge.source):castTo($getLast(edge.bendPoints), 10);
        second.y_0 >= first.y_0?$setTarget(edge, southPort):$setTarget(edge, northPort);
      }
      junctionPoints = castTo($getProperty(edge, ($clinit_LayoutOptions() , JUNCTION_POINTS)), 44);
      !!junctionPoints && $advanceToFind(junctionPoints, first, true);
    }
    hypernode.pos.x_0 = bendx - hypernode.size_0.x_0 / 2;
  }
}

function HypernodesProcessor(){
}

defineClass(472, 1, $intern_56, HypernodesProcessor);
_.process = function process_15(layeredGraph, monitor){
  var bottomEdges, layer, layer$iterator, leftEdges, node, node$iterator, port, port$iterator, rightEdges, topEdges;
  $begin(monitor, 'Hypernodes processing', 1);
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator), 16);
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      if (unsafeCast(checkNotNull_1(castToBoolean($getProperty(node, ($clinit_LayoutOptions() , HYPERNODE))))) && node.ports.array.length <= 2) {
        topEdges = 0;
        rightEdges = 0;
        bottomEdges = 0;
        leftEdges = 0;
        for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
          port = castTo($next_8(port$iterator), 7);
          switch (port.side.ordinal) {
            case 1:
              ++topEdges;
              break;
            case 2:
              ++rightEdges;
              break;
            case 3:
              ++bottomEdges;
              break;
            case 4:
              ++leftEdges;
          }
        }
        topEdges == 0 && bottomEdges == 0 && $moveHypernode(layeredGraph, node, leftEdges <= rightEdges);
      }
    }
  }
  $done(monitor);
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_HypernodesProcessor_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'HypernodesProcessor', 472);
function InLayerConstraintProcessor(){
}

defineClass(473, 1, $intern_56, InLayerConstraintProcessor);
_.process = function process_16(layeredGraph, monitor){
  var bottomConstrainedNodes, constraint, i, layer, layer$iterator, node, node$iterator, nodes, topInsertionIndex;
  $begin(monitor, 'Layer constraint edge reversal', 1);
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator), 16);
    topInsertionIndex = -1;
    bottomConstrainedNodes = new ArrayList;
    nodes = castTo($toArray_1(layer.nodes, initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LNode_2_classLit, $intern_49, 9, layer.nodes.array.length, 0, 1)), 51);
    for (i = 0; i < nodes.length; i++) {
      constraint = castTo($getProperty(nodes[i], ($clinit_InternalProperties() , IN_LAYER_CONSTRAINT)), 140);
      if (topInsertionIndex == -1) {
        constraint != ($clinit_InLayerConstraint() , TOP_0) && (topInsertionIndex = i);
      }
       else {
        if (constraint == ($clinit_InLayerConstraint() , TOP_0)) {
          $setLayer_0(nodes[i], null);
          $setLayer(nodes[i], topInsertionIndex++, layer);
        }
      }
      constraint == ($clinit_InLayerConstraint() , BOTTOM_0) && $add_11(bottomConstrainedNodes, nodes[i]);
    }
    for (node$iterator = new ArrayList$1(bottomConstrainedNodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      $setLayer_0(node, null);
      $setLayer_0(node, layer);
    }
  }
  $done(monitor);
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_InLayerConstraintProcessor_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'InLayerConstraintProcessor', 473);
function $findNorthSouthPortXCoordinate(dummy){
  var e, e$iterator, margins, max_0, min_0, n, port;
  port = castTo($get_8(dummy.ports, 0), 7);
  if (port.outgoingEdges.array.length != 0 && port.incomingEdges.array.length != 0) {
    throw new IllegalStateException_0('Interactive layout does not support NORTH/SOUTH ports with incoming _and_ outgoing edges.');
  }
  if (port.outgoingEdges.array.length != 0) {
    min_0 = $intern_50;
    for (e$iterator = new ArrayList$1(port.outgoingEdges); e$iterator.i < e$iterator.this$01.array.length;) {
      e = castTo($next_8(e$iterator), 12);
      n = e.target.owner;
      margins = castTo($getProperty(n, ($clinit_LayoutOptions() , MARGINS)), 64);
      min_0 = min_1(min_0, n.pos.x_0 - margins.left);
    }
    return new Present(checkNotNull(min_0));
  }
  if (port.incomingEdges.array.length != 0) {
    max_0 = $intern_51;
    for (e$iterator = new ArrayList$1(port.incomingEdges); e$iterator.i < e$iterator.this$01.array.length;) {
      e = castTo($next_8(e$iterator), 12);
      n = e.source.owner;
      margins = castTo($getProperty(n, ($clinit_LayoutOptions() , MARGINS)), 64);
      max_0 = max_1(max_0, n.pos.x_0 + n.size_0.x_0 + margins.right);
    }
    return new Present(checkNotNull(max_0));
  }
  return $clinit_Absent() , $clinit_Absent() , INSTANCE;
}

function $findYCoordinate(dummy, funGetOtherNode){
  var e, e$iterator, other;
  for (e$iterator = $iterator($getConnectedEdges(dummy)); $hasNext_0(e$iterator);) {
    e = castTo($next_2(e$iterator), 12);
    other = castTo(funGetOtherNode.apply_0(e), 9);
    return new Present(checkNotNull(other.pos.y_0 + other.size_0.y_0 / 2));
  }
  return $clinit_Absent() , $clinit_Absent() , INSTANCE;
}

function InteractiveExternalPortPositioner(){
}

function lambda$1(node_0, d_1){
  return node_0.pos.y_0 = (checkCriticalNotNull(d_1) , d_1);
}

function lambda$3(node_0, d_1){
  return node_0.pos.y_0 = (checkCriticalNotNull(d_1) , d_1);
}

function lambda$4_0(node_0, x_1){
  return node_0.pos.x_0 = (checkCriticalNotNull(x_1) , x_1) + 10;
}

function lambda$5(node_0, x_1){
  return node_0.pos.x_0 = (checkCriticalNotNull(x_1) , x_1) + 10;
}

defineClass(474, 1, $intern_56, InteractiveExternalPortPositioner);
_.process = function process_17(layeredGraph, progressMonitor){
  var ilc, lc, margins, node, node$iterator, node$iterator0;
  if (!castTo($getProperty(layeredGraph, ($clinit_InternalProperties() , GRAPH_PROPERTIES)), 18).contains(($clinit_GraphProperties() , EXTERNAL_PORTS))) {
    return;
  }
  for (node$iterator0 = new ArrayList$1(layeredGraph.layerlessNodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
    node = castTo($next_8(node$iterator0), 9);
    if (node.type_0 == ($clinit_LNode$NodeType() , NORMAL)) {
      margins = castTo($getProperty(node, ($clinit_LayoutOptions() , MARGINS)), 64);
      this.minX = min_1(this.minX, node.pos.x_0 - margins.left);
      this.maxX = max_1(this.maxX, node.pos.x_0 + node.size_0.x_0 + margins.right);
      this.minY = min_1(this.minY, node.pos.y_0 - margins.top_0);
      this.maxY = max_1(this.maxY, node.pos.y_0 + node.size_0.y_0 + margins.bottom);
    }
  }
  for (node$iterator = new ArrayList$1(layeredGraph.layerlessNodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 9);
    if (node.type_0 != ($clinit_LNode$NodeType() , NORMAL)) {
      switch (node.type_0.ordinal) {
        case 2:
          lc = castTo($getProperty(node, ($clinit_Properties() , LAYER_CONSTRAINT)), 85);
          if (lc == ($clinit_LayerConstraint() , FIRST_SEPARATE)) {
            node.pos.x_0 = this.minX - 10;
            $findYCoordinate(node, new InteractiveExternalPortPositioner$lambda$0$Type).transform(new InteractiveExternalPortPositioner$lambda$1$Type(node));
            break;
          }

          if (lc == LAST_SEPARATE) {
            node.pos.x_0 = this.maxX + 10;
            $findYCoordinate(node, new InteractiveExternalPortPositioner$lambda$2$Type).transform(new InteractiveExternalPortPositioner$lambda$3$Type(node));
            break;
          }

          ilc = castTo($getProperty(node, IN_LAYER_CONSTRAINT), 140);
          if (ilc == ($clinit_InLayerConstraint() , TOP_0)) {
            $findNorthSouthPortXCoordinate(node).transform(new InteractiveExternalPortPositioner$lambda$4$Type(node));
            node.pos.y_0 = this.minY - 10;
            break;
          }

          if (ilc == BOTTOM_0) {
            $findNorthSouthPortXCoordinate(node).transform(new InteractiveExternalPortPositioner$lambda$5$Type(node));
            node.pos.y_0 = this.maxY + 10;
            break;
          }

          break;
        default:throw new IllegalArgumentException_0('The node type ' + node.type_0 + ' is not supported by the ' + Lde_cau_cs_kieler_klay_layered_intermediate_InteractiveExternalPortPositioner_2_classLit);
      }
    }
  }
}
;
_.maxX = $intern_51;
_.maxY = $intern_51;
_.minX = $intern_50;
_.minY = $intern_50;
var Lde_cau_cs_kieler_klay_layered_intermediate_InteractiveExternalPortPositioner_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'InteractiveExternalPortPositioner', 474);
function InteractiveExternalPortPositioner$lambda$0$Type(){
}

defineClass(475, 1, $intern_35, InteractiveExternalPortPositioner$lambda$0$Type);
_.apply_0 = function apply_31(arg0){
  return castTo(arg0, 12).target.owner;
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_InteractiveExternalPortPositioner$lambda$0$Type_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'InteractiveExternalPortPositioner/lambda$0$Type', 475);
function InteractiveExternalPortPositioner$lambda$1$Type(node_0){
  this.node_0 = node_0;
}

defineClass(476, 1, $intern_35, InteractiveExternalPortPositioner$lambda$1$Type);
_.apply_0 = function apply_32(arg0){
  return lambda$1(this.node_0, arg0);
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_InteractiveExternalPortPositioner$lambda$1$Type_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'InteractiveExternalPortPositioner/lambda$1$Type', 476);
function InteractiveExternalPortPositioner$lambda$2$Type(){
}

defineClass(477, 1, $intern_35, InteractiveExternalPortPositioner$lambda$2$Type);
_.apply_0 = function apply_33(arg0){
  return castTo(arg0, 12).source.owner;
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_InteractiveExternalPortPositioner$lambda$2$Type_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'InteractiveExternalPortPositioner/lambda$2$Type', 477);
function InteractiveExternalPortPositioner$lambda$3$Type(node_0){
  this.node_0 = node_0;
}

defineClass(478, 1, $intern_35, InteractiveExternalPortPositioner$lambda$3$Type);
_.apply_0 = function apply_34(arg0){
  return lambda$3(this.node_0, arg0);
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_InteractiveExternalPortPositioner$lambda$3$Type_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'InteractiveExternalPortPositioner/lambda$3$Type', 478);
function InteractiveExternalPortPositioner$lambda$4$Type(node_0){
  this.node_0 = node_0;
}

defineClass(479, 1, $intern_35, InteractiveExternalPortPositioner$lambda$4$Type);
_.apply_0 = function apply_35(arg0){
  return lambda$4_0(this.node_0, arg0);
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_InteractiveExternalPortPositioner$lambda$4$Type_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'InteractiveExternalPortPositioner/lambda$4$Type', 479);
function InteractiveExternalPortPositioner$lambda$5$Type(node_0){
  this.node_0 = node_0;
}

defineClass(480, 1, $intern_35, InteractiveExternalPortPositioner$lambda$5$Type);
_.apply_0 = function apply_36(arg0){
  return lambda$5(this.node_0, arg0);
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_InteractiveExternalPortPositioner$lambda$5$Type_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'InteractiveExternalPortPositioner/lambda$5$Type', 480);
function $clinit_IntermediateProcessorStrategy(){
  $clinit_IntermediateProcessorStrategy = emptyMethod;
  LEFT_DIR_PREPROCESSOR = new IntermediateProcessorStrategy('LEFT_DIR_PREPROCESSOR', 0);
  DOWN_DIR_PREPROCESSOR = new IntermediateProcessorStrategy('DOWN_DIR_PREPROCESSOR', 1);
  UP_DIR_PREPROCESSOR = new IntermediateProcessorStrategy('UP_DIR_PREPROCESSOR', 2);
  COMMENT_PREPROCESSOR = new IntermediateProcessorStrategy('COMMENT_PREPROCESSOR', 3);
  EDGE_AND_LAYER_CONSTRAINT_EDGE_REVERSER = new IntermediateProcessorStrategy('EDGE_AND_LAYER_CONSTRAINT_EDGE_REVERSER', 4);
  SPLINE_SELF_LOOP_PREPROCESSOR = new IntermediateProcessorStrategy('SPLINE_SELF_LOOP_PREPROCESSOR', 5);
  INTERACTIVE_EXTERNAL_PORT_POSITIONER = new IntermediateProcessorStrategy('INTERACTIVE_EXTERNAL_PORT_POSITIONER', 6);
  PARTITION_PREPROCESSOR = new IntermediateProcessorStrategy('PARTITION_PREPROCESSOR', 7);
  BIG_NODES_PREPROCESSOR = new IntermediateProcessorStrategy('BIG_NODES_PREPROCESSOR', 8);
  LABEL_DUMMY_INSERTER = new IntermediateProcessorStrategy('LABEL_DUMMY_INSERTER', 9);
  PARTITION_POSTPROCESSOR = new IntermediateProcessorStrategy('PARTITION_POSTPROCESSOR', 10);
  NODE_PROMOTION = new IntermediateProcessorStrategy('NODE_PROMOTION', 11);
  LAYER_CONSTRAINT_PROCESSOR = new IntermediateProcessorStrategy('LAYER_CONSTRAINT_PROCESSOR', 12);
  HIERARCHICAL_PORT_CONSTRAINT_PROCESSOR = new IntermediateProcessorStrategy('HIERARCHICAL_PORT_CONSTRAINT_PROCESSOR', 13);
  BIG_NODES_INTERMEDIATEPROCESSOR = new IntermediateProcessorStrategy('BIG_NODES_INTERMEDIATEPROCESSOR', 14);
  LONG_EDGE_SPLITTER = new IntermediateProcessorStrategy('LONG_EDGE_SPLITTER', 15);
  PORT_SIDE_PROCESSOR = new IntermediateProcessorStrategy('PORT_SIDE_PROCESSOR', 16);
  LABEL_DUMMY_SWITCHER = new IntermediateProcessorStrategy('LABEL_DUMMY_SWITCHER', 17);
  LABEL_MANAGEMENT_PROCESSOR = new IntermediateProcessorStrategy('LABEL_MANAGEMENT_PROCESSOR', 18);
  INVERTED_PORT_PROCESSOR = new IntermediateProcessorStrategy('INVERTED_PORT_PROCESSOR', 19);
  SELF_LOOP_PROCESSOR = new IntermediateProcessorStrategy('SELF_LOOP_PROCESSOR', 20);
  PORT_LIST_SORTER = new IntermediateProcessorStrategy('PORT_LIST_SORTER', 21);
  NORTH_SOUTH_PORT_PREPROCESSOR = new IntermediateProcessorStrategy('NORTH_SOUTH_PORT_PREPROCESSOR', 22);
  GREEDY_SWITCH = new IntermediateProcessorStrategy('GREEDY_SWITCH', 23);
  PORT_DISTRIBUTER = new IntermediateProcessorStrategy('PORT_DISTRIBUTER', 24);
  SPLINE_SELF_LOOP_POSITIONER = new IntermediateProcessorStrategy('SPLINE_SELF_LOOP_POSITIONER', 25);
  SAUSAGE_COMPACTION = new IntermediateProcessorStrategy('SAUSAGE_COMPACTION', 26);
  IN_LAYER_CONSTRAINT_PROCESSOR = new IntermediateProcessorStrategy('IN_LAYER_CONSTRAINT_PROCESSOR', 27);
  HYPEREDGE_DUMMY_MERGER = new IntermediateProcessorStrategy('HYPEREDGE_DUMMY_MERGER', 28);
  LABEL_SIDE_SELECTOR = new IntermediateProcessorStrategy('LABEL_SIDE_SELECTOR', 29);
  BIG_NODES_SPLITTER = new IntermediateProcessorStrategy('BIG_NODES_SPLITTER', 30);
  LABEL_AND_NODE_SIZE_PROCESSOR = new IntermediateProcessorStrategy('LABEL_AND_NODE_SIZE_PROCESSOR', 31);
  SPLINE_SELF_LOOP_ROUTER = new IntermediateProcessorStrategy('SPLINE_SELF_LOOP_ROUTER', 32);
  NODE_MARGIN_CALCULATOR = new IntermediateProcessorStrategy('NODE_MARGIN_CALCULATOR', 33);
  HIERARCHICAL_PORT_DUMMY_SIZE_PROCESSOR = new IntermediateProcessorStrategy('HIERARCHICAL_PORT_DUMMY_SIZE_PROCESSOR', 34);
  HIERARCHICAL_PORT_POSITION_PROCESSOR = new IntermediateProcessorStrategy('HIERARCHICAL_PORT_POSITION_PROCESSOR', 35);
  LAYER_SIZE_AND_GRAPH_HEIGHT_CALCULATOR = new IntermediateProcessorStrategy('LAYER_SIZE_AND_GRAPH_HEIGHT_CALCULATOR', 36);
  BIG_NODES_POSTPROCESSOR = new IntermediateProcessorStrategy('BIG_NODES_POSTPROCESSOR', 37);
  COMMENT_POSTPROCESSOR = new IntermediateProcessorStrategy('COMMENT_POSTPROCESSOR', 38);
  HYPERNODE_PROCESSOR = new IntermediateProcessorStrategy('HYPERNODE_PROCESSOR', 39);
  HIERARCHICAL_PORT_ORTHOGONAL_EDGE_ROUTER = new IntermediateProcessorStrategy('HIERARCHICAL_PORT_ORTHOGONAL_EDGE_ROUTER', 40);
  LONG_EDGE_JOINER = new IntermediateProcessorStrategy('LONG_EDGE_JOINER', 41);
  NORTH_SOUTH_PORT_POSTPROCESSOR = new IntermediateProcessorStrategy('NORTH_SOUTH_PORT_POSTPROCESSOR', 42);
  LABEL_DUMMY_REMOVER = new IntermediateProcessorStrategy('LABEL_DUMMY_REMOVER', 43);
  HORIZONTAL_COMPACTOR = new IntermediateProcessorStrategy('HORIZONTAL_COMPACTOR', 44);
  REVERSED_EDGE_RESTORER = new IntermediateProcessorStrategy('REVERSED_EDGE_RESTORER', 45);
  LEFT_DIR_POSTPROCESSOR = new IntermediateProcessorStrategy('LEFT_DIR_POSTPROCESSOR', 46);
  DOWN_DIR_POSTPROCESSOR = new IntermediateProcessorStrategy('DOWN_DIR_POSTPROCESSOR', 47);
  UP_DIR_POSTPROCESSOR = new IntermediateProcessorStrategy('UP_DIR_POSTPROCESSOR', 48);
  END_LABEL_PROCESSOR = new IntermediateProcessorStrategy('END_LABEL_PROCESSOR', 49);
}

function $create(this$static){
  switch (this$static.ordinal) {
    case 14:
      return new BigNodesIntermediateProcessor;
    case 37:
      return new BigNodesPostProcessor;
    case 8:
      return new BigNodesPreProcessor;
    case 30:
      return new BigNodesSplitter;
    case 38:
      return new CommentPostprocessor;
    case 3:
      return new CommentPreprocessor;
    case 47:
    case 1:
      return new GraphTransformer(($clinit_GraphTransformer$Mode() , TRANSPOSE));
    case 4:
      return new EdgeAndLayerConstraintEdgeReverser;
    case 49:
      return new EndLabelProcessor;
    case 23:
      return new GreedySwitchProcessor;
    case 13:
      return new HierarchicalPortConstraintProcessor;
    case 34:
      return new HierarchicalPortDummySizeProcessor;
    case 40:
      return new HierarchicalPortOrthogonalEdgeRouter;
    case 35:
      return new HierarchicalPortPositionProcessor;
    case 44:
      return new HorizontalGraphCompactor;
    case 28:
      return new HyperedgeDummyMerger;
    case 39:
      return new HypernodesProcessor;
    case 27:
      return new InLayerConstraintProcessor;
    case 6:
      return new InteractiveExternalPortPositioner;
    case 31:
      return new LabelAndNodeSizeProcessor;
    case 9:
      return new LabelDummyInserter;
    case 43:
      return new LabelDummyRemover;
    case 17:
      return new LabelDummySwitcher;
    case 18:
      return new LabelManagementProcessor;
    case 29:
      return new LabelSideSelector;
    case 11:
      return new NodePromotion;
    case 12:
      return new LayerConstraintProcessor;
    case 36:
      return new LayerSizeAndGraphHeightCalculator;
    case 46:
    case 0:
      return new GraphTransformer(($clinit_GraphTransformer$Mode() , MIRROR_X));
    case 41:
      return new LongEdgeJoiner;
    case 15:
      return new LongEdgeSplitter;
    case 33:
      return new NodeMarginCalculator_0;
    case 42:
      return new NorthSouthPortPostprocessor;
    case 22:
      return new NorthSouthPortPreprocessor;
    case 19:
      return new InvertedPortProcessor;
    case 10:
      return new PartitionPostprocessor;
    case 7:
      return new PartitionPreprocessor;
    case 24:
      return new PortDistributionProcessor;
    case 21:
      return new PortListSorter;
    case 16:
      return new PortSideProcessor;
    case 45:
      return new ReversedEdgeRestorer;
    case 26:
      return new SausageFolding;
    case 20:
      return new SelfLoopProcessor;
    case 25:
      return new SplineSelfLoopPositioner;
    case 5:
      return new SplineSelfLoopPreProcessor;
    case 32:
      return new SplineSelfLoopRouter;
    case 48:
    case 2:
      return new GraphTransformer(($clinit_GraphTransformer$Mode() , MIRROR_AND_TRANSPOSE));
    default:throw new IllegalArgumentException_0('No implementation is available for the layout processor ' + (this$static.name_0 != null?this$static.name_0:'' + this$static.ordinal));
  }
}

function IntermediateProcessorStrategy(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function values_32(){
  $clinit_IntermediateProcessorStrategy();
  return stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_intermediate_IntermediateProcessorStrategy_2_classLit, 1), $intern_13, 37, 0, [LEFT_DIR_PREPROCESSOR, DOWN_DIR_PREPROCESSOR, UP_DIR_PREPROCESSOR, COMMENT_PREPROCESSOR, EDGE_AND_LAYER_CONSTRAINT_EDGE_REVERSER, SPLINE_SELF_LOOP_PREPROCESSOR, INTERACTIVE_EXTERNAL_PORT_POSITIONER, PARTITION_PREPROCESSOR, BIG_NODES_PREPROCESSOR, LABEL_DUMMY_INSERTER, PARTITION_POSTPROCESSOR, NODE_PROMOTION, LAYER_CONSTRAINT_PROCESSOR, HIERARCHICAL_PORT_CONSTRAINT_PROCESSOR, BIG_NODES_INTERMEDIATEPROCESSOR, LONG_EDGE_SPLITTER, PORT_SIDE_PROCESSOR, LABEL_DUMMY_SWITCHER, LABEL_MANAGEMENT_PROCESSOR, INVERTED_PORT_PROCESSOR, SELF_LOOP_PROCESSOR, PORT_LIST_SORTER, NORTH_SOUTH_PORT_PREPROCESSOR, GREEDY_SWITCH, PORT_DISTRIBUTER, SPLINE_SELF_LOOP_POSITIONER, SAUSAGE_COMPACTION, IN_LAYER_CONSTRAINT_PROCESSOR, HYPEREDGE_DUMMY_MERGER, LABEL_SIDE_SELECTOR, BIG_NODES_SPLITTER, LABEL_AND_NODE_SIZE_PROCESSOR, SPLINE_SELF_LOOP_ROUTER, NODE_MARGIN_CALCULATOR, HIERARCHICAL_PORT_DUMMY_SIZE_PROCESSOR, HIERARCHICAL_PORT_POSITION_PROCESSOR, LAYER_SIZE_AND_GRAPH_HEIGHT_CALCULATOR, BIG_NODES_POSTPROCESSOR, COMMENT_POSTPROCESSOR, HYPERNODE_PROCESSOR, HIERARCHICAL_PORT_ORTHOGONAL_EDGE_ROUTER, LONG_EDGE_JOINER, NORTH_SOUTH_PORT_POSTPROCESSOR, LABEL_DUMMY_REMOVER, HORIZONTAL_COMPACTOR, REVERSED_EDGE_RESTORER, LEFT_DIR_POSTPROCESSOR, DOWN_DIR_POSTPROCESSOR, UP_DIR_POSTPROCESSOR, END_LABEL_PROCESSOR]);
}

defineClass(37, 17, {37:1, 3:1, 23:1, 17:1}, IntermediateProcessorStrategy);
var BIG_NODES_INTERMEDIATEPROCESSOR, BIG_NODES_POSTPROCESSOR, BIG_NODES_PREPROCESSOR, BIG_NODES_SPLITTER, COMMENT_POSTPROCESSOR, COMMENT_PREPROCESSOR, DOWN_DIR_POSTPROCESSOR, DOWN_DIR_PREPROCESSOR, EDGE_AND_LAYER_CONSTRAINT_EDGE_REVERSER, END_LABEL_PROCESSOR, GREEDY_SWITCH, HIERARCHICAL_PORT_CONSTRAINT_PROCESSOR, HIERARCHICAL_PORT_DUMMY_SIZE_PROCESSOR, HIERARCHICAL_PORT_ORTHOGONAL_EDGE_ROUTER, HIERARCHICAL_PORT_POSITION_PROCESSOR, HORIZONTAL_COMPACTOR, HYPEREDGE_DUMMY_MERGER, HYPERNODE_PROCESSOR, INTERACTIVE_EXTERNAL_PORT_POSITIONER, INVERTED_PORT_PROCESSOR, IN_LAYER_CONSTRAINT_PROCESSOR, LABEL_AND_NODE_SIZE_PROCESSOR, LABEL_DUMMY_INSERTER, LABEL_DUMMY_REMOVER, LABEL_DUMMY_SWITCHER, LABEL_MANAGEMENT_PROCESSOR, LABEL_SIDE_SELECTOR, LAYER_CONSTRAINT_PROCESSOR, LAYER_SIZE_AND_GRAPH_HEIGHT_CALCULATOR, LEFT_DIR_POSTPROCESSOR, LEFT_DIR_PREPROCESSOR, LONG_EDGE_JOINER, LONG_EDGE_SPLITTER, NODE_MARGIN_CALCULATOR, NODE_PROMOTION, NORTH_SOUTH_PORT_POSTPROCESSOR, NORTH_SOUTH_PORT_PREPROCESSOR, PARTITION_POSTPROCESSOR, PARTITION_PREPROCESSOR, PORT_DISTRIBUTER, PORT_LIST_SORTER, PORT_SIDE_PROCESSOR, REVERSED_EDGE_RESTORER, SAUSAGE_COMPACTION, SELF_LOOP_PROCESSOR, SPLINE_SELF_LOOP_POSITIONER, SPLINE_SELF_LOOP_PREPROCESSOR, SPLINE_SELF_LOOP_ROUTER, UP_DIR_POSTPROCESSOR, UP_DIR_PREPROCESSOR;
var Lde_cau_cs_kieler_klay_layered_intermediate_IntermediateProcessorStrategy_2_classLit = createForEnum('de.cau.cs.kieler.klay.layered.intermediate', 'IntermediateProcessorStrategy', 37, Ljava_lang_Enum_2_classLit, values_32);
function $createEastPortSideDummies(layeredGraph, eastwardPort, edge, layerNodeList){
  var dummy, dummyEdge, dummyInput, dummyOutput, label_0, labelIterator, labelPlacement;
  if (edge.source.owner == eastwardPort.owner) {
    return;
  }
  dummy = new LNode(layeredGraph);
  $setType(dummy, ($clinit_LNode$NodeType() , LONG_EDGE));
  $setProperty(dummy, ($clinit_InternalProperties() , ORIGIN), edge);
  $setProperty(dummy, ($clinit_LayoutOptions() , PORT_CONSTRAINTS), ($clinit_PortConstraints() , FIXED_POS));
  layerNodeList.array[layerNodeList.array.length] = dummy;
  dummyInput = new LPort;
  $setNode(dummyInput, dummy);
  $setSide(dummyInput, ($clinit_PortSide() , WEST));
  dummyOutput = new LPort;
  $setNode(dummyOutput, dummy);
  $setSide(dummyOutput, EAST);
  $setTarget(edge, dummyInput);
  dummyEdge = new LEdge;
  $copyProperties(dummyEdge, edge);
  $setProperty(dummyEdge, JUNCTION_POINTS, null);
  $setSource(dummyEdge, dummyOutput);
  $setTarget(dummyEdge, eastwardPort);
  $setLongEdgeSourceAndTarget(dummy, dummyInput, dummyOutput);
  labelIterator = new AbstractList$ListIteratorImpl(edge.labels, 0);
  while (labelIterator.i < labelIterator.this$01_0.size_1()) {
    label_0 = (checkCriticalElement(labelIterator.i < labelIterator.this$01_0.size_1()) , castTo(labelIterator.this$01_0.get_2(labelIterator.last = labelIterator.i++), 33));
    labelPlacement = castTo($getProperty(label_0, EDGE_LABEL_PLACEMENT), 107);
    if (labelPlacement == ($clinit_EdgeLabelPlacement() , HEAD)) {
      $remove_11(labelIterator);
      $add_11(dummyEdge.labels, label_0);
    }
  }
}

function $createWestPortSideDummies(layeredGraph, westwardPort, edge, layerNodeList){
  var dummy, dummyEdge, dummyInput, dummyOutput, originalTarget;
  if (edge.target.owner == westwardPort.owner) {
    return;
  }
  dummy = new LNode(layeredGraph);
  $setType(dummy, ($clinit_LNode$NodeType() , LONG_EDGE));
  $setProperty(dummy, ($clinit_InternalProperties() , ORIGIN), edge);
  $setProperty(dummy, ($clinit_LayoutOptions() , PORT_CONSTRAINTS), ($clinit_PortConstraints() , FIXED_POS));
  layerNodeList.array[layerNodeList.array.length] = dummy;
  dummyInput = new LPort;
  $setNode(dummyInput, dummy);
  $setSide(dummyInput, ($clinit_PortSide() , WEST));
  dummyOutput = new LPort;
  $setNode(dummyOutput, dummy);
  $setSide(dummyOutput, EAST);
  originalTarget = edge.target;
  $setTarget(edge, dummyInput);
  dummyEdge = new LEdge;
  $copyProperties(dummyEdge, edge);
  $setProperty(dummyEdge, JUNCTION_POINTS, null);
  $setSource(dummyEdge, dummyOutput);
  $setTarget(dummyEdge, originalTarget);
  $setLongEdgeSourceAndTarget(dummy, dummyInput, dummyOutput);
}

function $setLongEdgeSourceAndTarget(longEdgeDummy, dummyInputPort, dummyOutputPort){
  var sourceNode, sourceNodeType, sourcePort, targetNode, targetNodeType, targetPort;
  sourcePort = castTo($get_8(dummyInputPort.incomingEdges, 0), 12).source;
  sourceNode = sourcePort.owner;
  sourceNodeType = sourceNode.type_0;
  targetPort = castTo($get_8(dummyOutputPort.outgoingEdges, 0), 12).target;
  targetNode = targetPort.owner;
  targetNodeType = targetNode.type_0;
  sourceNodeType == ($clinit_LNode$NodeType() , LONG_EDGE)?$setProperty(longEdgeDummy, ($clinit_InternalProperties() , LONG_EDGE_SOURCE), castTo($getProperty(sourceNode, LONG_EDGE_SOURCE), 7)):$setProperty(longEdgeDummy, ($clinit_InternalProperties() , LONG_EDGE_SOURCE), sourcePort);
  targetNodeType == LONG_EDGE?$setProperty(longEdgeDummy, ($clinit_InternalProperties() , LONG_EDGE_TARGET), castTo($getProperty(targetNode, LONG_EDGE_TARGET), 7)):$setProperty(longEdgeDummy, ($clinit_InternalProperties() , LONG_EDGE_TARGET), targetPort);
}

function InvertedPortProcessor(){
}

defineClass(503, 1, $intern_56, InvertedPortProcessor);
_.process = function process_18(layeredGraph, monitor){
  var currentLayer, edge, edge$index, edge$max, edgeArray, edges, layerIterator, layers, node, node$iterator, node$iterator0, node$iterator1, port, port$iterator, port$iterator0, previousLayer, unassignedNodes;
  $begin(monitor, 'Inverted port preprocessing', 1);
  layers = layeredGraph.layers;
  layerIterator = new AbstractList$ListIteratorImpl(layers, 0);
  currentLayer = null;
  unassignedNodes = new ArrayList;
  while (layerIterator.i < layerIterator.this$01_0.size_1()) {
    previousLayer = currentLayer;
    currentLayer = (checkCriticalElement(layerIterator.i < layerIterator.this$01_0.size_1()) , castTo(layerIterator.this$01_0.get_2(layerIterator.last = layerIterator.i++), 16));
    for (node$iterator0 = new ArrayList$1(unassignedNodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
      node = castTo($next_8(node$iterator0), 9);
      $setLayer_0(node, previousLayer);
    }
    unassignedNodes.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
    for (node$iterator1 = new ArrayList$1(currentLayer.nodes); node$iterator1.i < node$iterator1.this$01.array.length;) {
      node = castTo($next_8(node$iterator1), 9);
      if (node.type_0 != ($clinit_LNode$NodeType() , NORMAL)) {
        continue;
      }
      if (!$isSideFixed(castTo($getProperty(node, ($clinit_LayoutOptions() , PORT_CONSTRAINTS)), 28))) {
        continue;
      }
      for (port$iterator0 = $getPorts_2(node, ($clinit_PortType() , INPUT), ($clinit_PortSide() , EAST)).iterator_0(); port$iterator0.hasNext_0();) {
        port = castTo(port$iterator0.next_1(), 7);
        edges = port.incomingEdges;
        edgeArray = castTo($toArray_1(edges, initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LEdge_2_classLit, $intern_57, 12, edges.array.length, 0, 1)), 47);
        for (edge$index = 0 , edge$max = edgeArray.length; edge$index < edge$max; ++edge$index) {
          edge = edgeArray[edge$index];
          $createEastPortSideDummies(layeredGraph, port, edge, unassignedNodes);
        }
      }
      for (port$iterator = $getPorts_2(node, OUTPUT, WEST).iterator_0(); port$iterator.hasNext_0();) {
        port = castTo(port$iterator.next_1(), 7);
        edges = port.outgoingEdges;
        edgeArray = castTo($toArray_1(edges, initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LEdge_2_classLit, $intern_57, 12, edges.array.length, 0, 1)), 47);
        for (edge$index = 0 , edge$max = edgeArray.length; edge$index < edge$max; ++edge$index) {
          edge = edgeArray[edge$index];
          $createWestPortSideDummies(layeredGraph, port, edge, unassignedNodes);
        }
      }
    }
  }
  for (node$iterator = new ArrayList$1(unassignedNodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 9);
    $setLayer_0(node, currentLayer);
  }
  $done(monitor);
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_InvertedPortProcessor_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'InvertedPortProcessor', 503);
function LabelAndNodeSizeProcessor(){
}

defineClass(481, 1, $intern_56, LabelAndNodeSizeProcessor);
_.process = function process_19(layeredGraph, monitor){
  $begin(monitor, 'Node and Port Label Placement and Node Sizing', 1);
  calculateLabelAndNodeSizes(($clinit_LGraphAdapters() , $clinit_LGraphAdapters() , new LGraphAdapters$LGraphAdapter(layeredGraph, false)));
  $done(monitor);
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_LabelAndNodeSizeProcessor_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'LabelAndNodeSizeProcessor', 481);
function $clinit_LabelDummyInserter(){
  $clinit_LabelDummyInserter = emptyMethod;
  CENTER_LABEL = new LabelDummyInserter$1;
}

function LabelDummyInserter(){
  $clinit_LabelDummyInserter();
}

defineClass(482, 1, $intern_56, LabelDummyInserter);
_.process = function process_20(layeredGraph, monitor){
  var dummyNode, dummyPort, dummyPort$iterator, dummySize, edge, edge$iterator, iterator, label_0, labelSpacing, layoutDirection, newDummyNodes, node, node$iterator, port, port$iterator, portPos, representedLabels, thickness;
  $begin(monitor, 'Label dummy insertions', 1);
  newDummyNodes = new ArrayList;
  labelSpacing = castTo($getProperty(layeredGraph, ($clinit_LayoutOptions() , LABEL_SPACING)), 15).value_0;
  layoutDirection = castTo($getProperty(layeredGraph, DIRECTION), 59);
  for (node$iterator = new ArrayList$1(layeredGraph.layerlessNodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 9);
    for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_8(port$iterator), 7);
      for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
        edge = castTo($next_8(edge$iterator), 12);
        if (edge.source.owner != edge.target.owner && any(edge.labels, CENTER_LABEL)) {
          representedLabels = newArrayListWithCapacity(edge.labels.array.length);
          dummyNode = new LNode(layeredGraph);
          $setType(dummyNode, ($clinit_LNode$NodeType() , LABEL));
          $setProperty(dummyNode, ($clinit_InternalProperties() , ORIGIN), edge);
          $setProperty(dummyNode, REPRESENTED_LABELS, representedLabels);
          $setProperty(dummyNode, PORT_CONSTRAINTS, ($clinit_PortConstraints() , FIXED_POS));
          $setProperty(dummyNode, LONG_EDGE_SOURCE, edge.source);
          $setProperty(dummyNode, LONG_EDGE_TARGET, edge.target);
          newDummyNodes.array[newDummyNodes.array.length] = dummyNode;
          splitEdge(edge, dummyNode);
          thickness = castTo($getProperty(edge, THICKNESS), 15).value_0;
          if (thickness < 0) {
            thickness = 0;
            $setProperty(edge, THICKNESS, new Float_0(thickness));
          }
          portPos = Math.floor(thickness / 2);
          for (dummyPort$iterator = new ArrayList$1(dummyNode.ports); dummyPort$iterator.i < dummyPort$iterator.this$01.array.length;) {
            dummyPort = castTo($next_8(dummyPort$iterator), 7);
            dummyPort.pos.y_0 = portPos;
          }
          dummySize = dummyNode.size_0;
          iterator = new AbstractList$ListIteratorImpl(edge.labels, 0);
          while (iterator.i < iterator.this$01_0.size_1()) {
            label_0 = (checkCriticalElement(iterator.i < iterator.this$01_0.size_1()) , castTo(iterator.this$01_0.get_2(iterator.last = iterator.i++), 33));
            if (maskUndefined($getProperty(label_0, EDGE_LABEL_PLACEMENT)) === maskUndefined(($clinit_EdgeLabelPlacement() , CENTER_0))) {
              if (layoutDirection == ($clinit_Direction() , UP) || layoutDirection == DOWN) {
                dummySize.x_0 += label_0.size_0.x_0 + labelSpacing;
                dummySize.y_0 = max_1(dummySize.y_0, label_0.size_0.y_0);
              }
               else {
                dummySize.x_0 = max_1(dummySize.x_0, label_0.size_0.x_0);
                dummySize.y_0 += label_0.size_0.y_0 + labelSpacing;
              }
              representedLabels.array[representedLabels.array.length] = label_0;
              $remove_11(iterator);
            }
          }
          if (layoutDirection == ($clinit_Direction() , UP) || layoutDirection == DOWN) {
            dummySize.x_0 -= labelSpacing;
            dummySize.y_0 += labelSpacing + thickness;
          }
           else {
            dummySize.y_0 += labelSpacing + thickness;
          }
        }
      }
    }
  }
  $addAll_6(layeredGraph.layerlessNodes, newDummyNodes);
  $done(monitor);
}
;
var CENTER_LABEL;
var Lde_cau_cs_kieler_klay_layered_intermediate_LabelDummyInserter_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'LabelDummyInserter', 482);
function LabelDummyInserter$1(){
}

defineClass(483, 1, $intern_52, LabelDummyInserter$1);
_.apply_1 = function apply_37(label_0){
  return maskUndefined($getProperty(castTo(label_0, 33), ($clinit_LayoutOptions() , EDGE_LABEL_PLACEMENT))) === maskUndefined(($clinit_EdgeLabelPlacement() , CENTER_0));
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_LabelDummyInserter$1_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'LabelDummyInserter/1', 483);
function $placeLabelsForHorizontalLayout(labels, labelPos, labelSpacing, labelSpace){
  var label_0, label$iterator;
  for (label$iterator = labels.iterator_0(); label$iterator.hasNext_0();) {
    label_0 = castTo(label$iterator.next_1(), 33);
    label_0.pos.x_0 = labelPos.x_0 + (labelSpace.x_0 - label_0.size_0.x_0) / 2;
    label_0.pos.y_0 = labelPos.y_0;
    labelPos.y_0 += label_0.size_0.y_0 + labelSpacing;
  }
}

function $placeLabelsForVerticalLayout(labels, labelPos, labelSpacing, labelSpace, leftAligned){
  var label_0, label$iterator;
  for (label$iterator = labels.iterator_0(); label$iterator.hasNext_0();) {
    label_0 = castTo(label$iterator.next_1(), 33);
    label_0.pos.x_0 = labelPos.x_0;
    label_0.pos.y_0 = leftAligned?labelPos.y_0:labelPos.y_0 + labelSpace.y_0 - label_0.size_0.y_0;
    labelPos.x_0 += label_0.size_0.x_0 + labelSpacing;
  }
}

function LabelDummyRemover(){
}

defineClass(484, 1, $intern_56, LabelDummyRemover);
_.process = function process_21(layeredGraph, monitor){
  var currLabelPos, labelSpace, labelSpacing, layer, layer$iterator, layoutDirection, node, nodeIterator, originEdge, representedLabels, thickness;
  $begin(monitor, 'Label dummy removal', 1);
  labelSpacing = castTo($getProperty(layeredGraph, ($clinit_LayoutOptions() , LABEL_SPACING)), 15).value_0;
  layoutDirection = castTo($getProperty(layeredGraph, DIRECTION), 59);
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator), 16);
    nodeIterator = new AbstractList$ListIteratorImpl(layer.nodes, 0);
    while (nodeIterator.i < nodeIterator.this$01_0.size_1()) {
      node = (checkCriticalElement(nodeIterator.i < nodeIterator.this$01_0.size_1()) , castTo(nodeIterator.this$01_0.get_2(nodeIterator.last = nodeIterator.i++), 9));
      if (node.type_0 == ($clinit_LNode$NodeType() , LABEL)) {
        originEdge = castTo($getProperty(node, ($clinit_InternalProperties() , ORIGIN)), 12);
        thickness = castTo($getProperty(originEdge, THICKNESS), 15).value_0;
        currLabelPos = new KVector_2(node.pos);
        maskUndefined($getProperty(node, LABEL_SIDE_0)) === maskUndefined(($clinit_LabelSide() , BELOW)) && (currLabelPos.y_0 += thickness + labelSpacing);
        labelSpace = new KVector_1(node.size_0.x_0, node.size_0.y_0 - thickness - labelSpacing);
        representedLabels = castTo($getProperty(node, REPRESENTED_LABELS), 20);
        layoutDirection == ($clinit_Direction() , UP) || layoutDirection == DOWN?$placeLabelsForVerticalLayout(representedLabels, currLabelPos, labelSpacing, labelSpace, maskUndefined($getProperty(node, LABEL_SIDE_0)) !== maskUndefined(ABOVE)):$placeLabelsForHorizontalLayout(representedLabels, currLabelPos, labelSpacing, labelSpace);
        $addAll_6(originEdge.labels, representedLabels);
        joinAt(node, false);
        $remove_11(nodeIterator);
      }
    }
  }
  $done(monitor);
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_LabelDummyRemover_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'LabelDummyRemover', 484);
function $doUpdateLongEdgeSourceTargetInfo(labelDummy, nextElement, longEdgeProperty){
  var longEdgeDummy;
  longEdgeDummy = castTo(nextElement.apply_0(labelDummy), 9);
  while (longEdgeDummy.type_0 == ($clinit_LNode$NodeType() , LONG_EDGE)) {
    !longEdgeDummy.propertyMap && (longEdgeDummy.propertyMap = new HashMap);
    $remove_9(longEdgeDummy.propertyMap, longEdgeProperty);
    longEdgeDummy = castTo(nextElement.apply_0(longEdgeDummy), 9);
  }
}

function $swapNodes(dummy1, dummy2){
  var edge, edge$index, edge$index0, edge$index1, edge$index2, edge$max, edge$max0, edge$max1, edge$max2, incomingEdges1, incomingEdges2, inputPort1, inputPort2, layer1, layer2, outgoingEdges1, outgoingEdges2, outputPort1, outputPort2;
  layer1 = dummy1.layer;
  layer2 = dummy2.layer;
  inputPort1 = castTo($getPorts_1(dummy1, ($clinit_PortType() , INPUT)).iterator_0().next_1(), 7);
  outputPort1 = castTo($getPorts_1(dummy1, OUTPUT).iterator_0().next_1(), 7);
  inputPort2 = castTo($getPorts_1(dummy2, INPUT).iterator_0().next_1(), 7);
  outputPort2 = castTo($getPorts_1(dummy2, OUTPUT).iterator_0().next_1(), 7);
  incomingEdges1 = castTo($toArray_1(inputPort1.incomingEdges, initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LEdge_2_classLit, $intern_57, 12, 1, 0, 1)), 47);
  outgoingEdges1 = castTo($toArray_1(outputPort1.outgoingEdges, initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LEdge_2_classLit, $intern_57, 12, 1, 0, 1)), 47);
  incomingEdges2 = castTo($toArray_1(inputPort2.incomingEdges, initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LEdge_2_classLit, $intern_57, 12, 1, 0, 1)), 47);
  outgoingEdges2 = castTo($toArray_1(outputPort2.outgoingEdges, initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LEdge_2_classLit, $intern_57, 12, 1, 0, 1)), 47);
  $setLayer_0(dummy1, layer2);
  for (edge$index0 = 0 , edge$max0 = incomingEdges2.length; edge$index0 < edge$max0; ++edge$index0) {
    edge = incomingEdges2[edge$index0];
    $setTarget(edge, inputPort1);
  }
  for (edge$index1 = 0 , edge$max1 = outgoingEdges2.length; edge$index1 < edge$max1; ++edge$index1) {
    edge = outgoingEdges2[edge$index1];
    $setSource(edge, outputPort1);
  }
  $setLayer_0(dummy2, layer1);
  for (edge$index2 = 0 , edge$max2 = incomingEdges1.length; edge$index2 < edge$max2; ++edge$index2) {
    edge = incomingEdges1[edge$index2];
    $setTarget(edge, inputPort2);
  }
  for (edge$index = 0 , edge$max = outgoingEdges1.length; edge$index < edge$max; ++edge$index) {
    edge = outgoingEdges1[edge$index];
    $setSource(edge, outputPort2);
  }
}

function LabelDummySwitcher(){
}

defineClass(485, 1, $intern_56, LabelDummySwitcher);
_.process = function process_22(layeredGraph, monitor){
  var labelDummies, labelDummy, labelDummy$iterator, layer, layer$iterator, leftLongEdgeDummies, leftSize, node, node$iterator, nodesToSwap, pos, rightLongEdgeDummies, rightSize, source, swapPair, swapPair$iterator, target;
  $begin(monitor, 'Label dummy switching', 1);
  labelDummies = new ArrayList;
  nodesToSwap = new ArrayList;
  leftLongEdgeDummies = new ArrayList;
  rightLongEdgeDummies = new ArrayList;
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator), 16);
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      if (node.type_0 == ($clinit_LNode$NodeType() , LABEL)) {
        labelDummies.array[labelDummies.array.length] = node;
        leftLongEdgeDummies.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
        rightLongEdgeDummies.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
        source = node;
        do {
          source = castTo($next_2($iterator($getIncomingEdges_0(source))), 12).source.owner;
          source.type_0 == LONG_EDGE && (leftLongEdgeDummies.array[leftLongEdgeDummies.array.length] = source , true);
        }
         while (source.type_0 == LONG_EDGE);
        target = node;
        do {
          target = castTo($next_2($iterator($getOutgoingEdges_0(target))), 12).target.owner;
          target.type_0 == LONG_EDGE && (rightLongEdgeDummies.array[rightLongEdgeDummies.array.length] = target , true);
        }
         while (target.type_0 == LONG_EDGE);
        leftSize = leftLongEdgeDummies.array.length;
        rightSize = rightLongEdgeDummies.array.length;
        if (leftSize > rightSize + 1) {
          pos = (leftSize + rightSize) / 2 | 0;
          $add_11(nodesToSwap, new Pair(node, (checkCriticalElementIndex(pos, leftLongEdgeDummies.array.length) , castTo(leftLongEdgeDummies.array[pos], 9))));
        }
         else if (rightSize > leftSize + 1) {
          pos = ((rightSize - leftSize) / 2 | 0) - 1;
          $add_11(nodesToSwap, new Pair(node, (checkCriticalElementIndex(pos, rightLongEdgeDummies.array.length) , castTo(rightLongEdgeDummies.array[pos], 9))));
        }
      }
    }
  }
  for (swapPair$iterator = new ArrayList$1(nodesToSwap); swapPair$iterator.i < swapPair$iterator.this$01.array.length;) {
    swapPair = castTo($next_8(swapPair$iterator), 27);
    $swapNodes(castTo(swapPair.first, 9), castTo(swapPair.second, 9));
  }
  for (labelDummy$iterator = new ArrayList$1(labelDummies); labelDummy$iterator.i < labelDummy$iterator.this$01.array.length;) {
    labelDummy = castTo($next_8(labelDummy$iterator), 9);
    $doUpdateLongEdgeSourceTargetInfo(labelDummy, new LabelDummySwitcher$lambda$0$Type, ($clinit_InternalProperties() , LONG_EDGE_TARGET));
    $doUpdateLongEdgeSourceTargetInfo(labelDummy, new LabelDummySwitcher$lambda$1$Type, LONG_EDGE_SOURCE);
  }
  $done(monitor);
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_LabelDummySwitcher_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'LabelDummySwitcher', 485);
function LabelDummySwitcher$lambda$0$Type(){
}

defineClass(486, 1, $intern_35, LabelDummySwitcher$lambda$0$Type);
_.apply_0 = function apply_38(arg0){
  return castTo($next_2($iterator($getIncomingEdges_0(castTo(arg0, 9)))), 12).source.owner;
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_LabelDummySwitcher$lambda$0$Type_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'LabelDummySwitcher/lambda$0$Type', 486);
function LabelDummySwitcher$lambda$1$Type(){
}

defineClass(487, 1, $intern_35, LabelDummySwitcher$lambda$1$Type);
_.apply_0 = function apply_39(arg0){
  return castTo($next_2($iterator($getOutgoingEdges_0(castTo(arg0, 9)))), 12).target.owner;
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_LabelDummySwitcher$lambda$1$Type_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'LabelDummySwitcher/lambda$1$Type', 487);
function LabelManagementProcessor(){
}

defineClass(488, 1, $intern_56, LabelManagementProcessor);
_.process = function process_23(layeredGraph, monitor){
  $begin(monitor, 'Label management', 1);
  throwClassCastExceptionUnlessNull($getProperty(layeredGraph, ($clinit_LabelManagementOptions() , LABEL_MANAGER)));
  $done(monitor);
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_LabelManagementProcessor_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'LabelManagementProcessor', 488);
function $clinit_LabelSideSelector(){
  $clinit_LabelSideSelector = emptyMethod;
  DEFAULT_LABEL_SIDE = ($clinit_LabelSide() , BELOW);
}

function $alwaysDown(nodes){
  var edge, edge$iterator, node, node$iterator;
  for (node$iterator = ($clinit_Iterators() , new Iterators$ConcatenatedIterator($iterator_1(transform_1(nodes.val$inputs1, new Iterables$12)))); $hasNext_0(node$iterator);) {
    node = castTo($next_2(node$iterator), 9);
    node.type_0 == ($clinit_LNode$NodeType() , LABEL) && $setProperty(node, ($clinit_InternalProperties() , LABEL_SIDE_0), ($clinit_LabelSide() , BELOW));
    for (edge$iterator = $iterator($getOutgoingEdges_0(node)); $hasNext_0(edge$iterator);) {
      edge = castTo($next_2(edge$iterator), 12);
      $applyLabelSide(edge, ($clinit_LabelSide() , BELOW));
    }
  }
}

function $alwaysUp(nodes){
  var edge, edge$iterator, node, node$iterator;
  for (node$iterator = ($clinit_Iterators() , new Iterators$ConcatenatedIterator($iterator_1(transform_1(nodes.val$inputs1, new Iterables$12)))); $hasNext_0(node$iterator);) {
    node = castTo($next_2(node$iterator), 9);
    node.type_0 == ($clinit_LNode$NodeType() , LABEL) && $setProperty(node, ($clinit_InternalProperties() , LABEL_SIDE_0), ($clinit_LabelSide() , ABOVE));
    for (edge$iterator = $iterator($getOutgoingEdges_0(node)); $hasNext_0(edge$iterator);) {
      edge = castTo($next_2(edge$iterator), 12);
      $applyLabelSide(edge, ($clinit_LabelSide() , ABOVE));
    }
  }
}

function $applyLabelSide(edge, side){
  var label_0, label$iterator, portLabel, portLabel$iterator, portLabel$iterator0;
  for (label$iterator = new ArrayList$1(edge.labels); label$iterator.i < label$iterator.this$01.array.length;) {
    label_0 = castTo($next_8(label$iterator), 33);
    $setProperty(label_0, ($clinit_InternalProperties() , LABEL_SIDE_0), side);
  }
  for (portLabel$iterator0 = new ArrayList$1(edge.source.labels); portLabel$iterator0.i < portLabel$iterator0.this$01.array.length;) {
    portLabel = castTo($next_8(portLabel$iterator0), 33);
    $setProperty(portLabel, ($clinit_InternalProperties() , LABEL_SIDE_0), side);
  }
  for (portLabel$iterator = new ArrayList$1(edge.target.labels); portLabel$iterator.i < portLabel$iterator.this$01.array.length;) {
    portLabel = castTo($next_8(portLabel$iterator), 33);
    $setProperty(portLabel, ($clinit_InternalProperties() , LABEL_SIDE_0), side);
  }
}

function $directionDown(nodes){
  var edge, edge$iterator, node, node$iterator, side;
  for (node$iterator = ($clinit_Iterators() , new Iterators$ConcatenatedIterator($iterator_1(transform_1(nodes.val$inputs1, new Iterables$12)))); $hasNext_0(node$iterator);) {
    node = castTo($next_2(node$iterator), 9);
    if (node.type_0 == ($clinit_LNode$NodeType() , LABEL)) {
      side = $doesEdgePointRight(node)?($clinit_LabelSide() , BELOW):($clinit_LabelSide() , ABOVE);
      $setProperty(node, ($clinit_InternalProperties() , LABEL_SIDE_0), side);
    }
    for (edge$iterator = $iterator($getOutgoingEdges_0(node)); $hasNext_0(edge$iterator);) {
      edge = castTo($next_2(edge$iterator), 12);
      side = unsafeCast(checkNotNull_1(castToBoolean($getProperty(edge, ($clinit_InternalProperties() , REVERSED)))))?($clinit_LabelSide() , ABOVE):($clinit_LabelSide() , BELOW);
      $applyLabelSide(edge, side);
    }
  }
}

function $directionUp(nodes){
  var edge, edge$iterator, node, node$iterator, side;
  for (node$iterator = ($clinit_Iterators() , new Iterators$ConcatenatedIterator($iterator_1(transform_1(nodes.val$inputs1, new Iterables$12)))); $hasNext_0(node$iterator);) {
    node = castTo($next_2(node$iterator), 9);
    if (node.type_0 == ($clinit_LNode$NodeType() , LABEL)) {
      side = $doesEdgePointRight(node)?($clinit_LabelSide() , ABOVE):($clinit_LabelSide() , BELOW);
      $setProperty(node, ($clinit_InternalProperties() , LABEL_SIDE_0), side);
    }
    for (edge$iterator = $iterator($getOutgoingEdges_0(node)); $hasNext_0(edge$iterator);) {
      edge = castTo($next_2(edge$iterator), 12);
      side = unsafeCast(checkNotNull_1(castToBoolean($getProperty(edge, ($clinit_InternalProperties() , REVERSED)))))?($clinit_LabelSide() , BELOW):($clinit_LabelSide() , ABOVE);
      $applyLabelSide(edge, side);
    }
  }
}

function $doesEdgePointRight(labelDummy){
  var incoming, outgoing;
  incoming = castTo($next_2($iterator($getIncomingEdges_0(labelDummy))), 12);
  outgoing = castTo($next_2($iterator($getOutgoingEdges_0(labelDummy))), 12);
  return !unsafeCast(checkNotNull_1(castToBoolean($getProperty(incoming, ($clinit_InternalProperties() , REVERSED))))) || !unsafeCast(checkNotNull_1(castToBoolean($getProperty(outgoing, REVERSED))));
}

function $getPortsBySide(node, portSide){
  var port, port$iterator, result;
  result = new ArrayList;
  for (port$iterator = $getPorts_0(node, portSide).iterator_0(); port$iterator.hasNext_0();) {
    port = castTo(port$iterator.next_1(), 7);
    result.array[result.array.length] = port;
  }
  sort_1(result, new LabelSideSelector$1);
  return result;
}

function $smart(nodes){
  var chosenSide, eastPort, eastPort$iterator, eastPorts, edge, edge$iterator, label_0, label$iterator, node, node$iterator, nodeMarkers, portLabel, portLabel$iterator, portLabel$iterator0, targetNode;
  nodeMarkers = ($clinit_Maps() , new HashMap);
  for (node$iterator = ($clinit_Iterators() , new Iterators$ConcatenatedIterator($iterator_1(transform_1(nodes.val$inputs1, new Iterables$12)))); $hasNext_0(node$iterator);) {
    node = castTo($next_2(node$iterator), 9);
    eastPorts = $getPortsBySide(node, ($clinit_PortSide() , EAST));
    for (eastPort$iterator = new ArrayList$1(eastPorts); eastPort$iterator.i < eastPort$iterator.this$01.array.length;) {
      eastPort = castTo($next_8(eastPort$iterator), 7);
      for (edge$iterator = new ArrayList$1(eastPort.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
        edge = castTo($next_8(edge$iterator), 12);
        $clinit_LabelSide();
        targetNode = edge.target.owner;
        (targetNode.type_0 == ($clinit_LNode$NodeType() , LONG_EDGE) || targetNode.type_0 == LABEL) && (targetNode = castTo($getProperty(targetNode, ($clinit_InternalProperties() , LONG_EDGE_TARGET)), 7).owner);
        if ($getEntry(nodeMarkers.hashCodeMap, targetNode)) {
          chosenSide = castTo(getEntryValueOrNull($getEntry(nodeMarkers.hashCodeMap, targetNode)), 171);
        }
         else {
          eastPorts.array.length == 2?maskUndefined(eastPort) === maskUndefined((checkCriticalElementIndex(0, eastPorts.array.length) , eastPorts.array[0]))?(chosenSide = ABOVE):(chosenSide = BELOW):(chosenSide = ABOVE);
          $put_5(nodeMarkers.hashCodeMap, targetNode, chosenSide);
        }
        for (label$iterator = new ArrayList$1(edge.labels); label$iterator.i < label$iterator.this$01.array.length;) {
          label_0 = castTo($next_8(label$iterator), 33);
          $setProperty(label_0, ($clinit_InternalProperties() , LABEL_SIDE_0), chosenSide);
        }
        for (portLabel$iterator0 = new ArrayList$1(edge.source.labels); portLabel$iterator0.i < portLabel$iterator0.this$01.array.length;) {
          portLabel = castTo($next_8(portLabel$iterator0), 33);
          $setProperty(portLabel, ($clinit_InternalProperties() , LABEL_SIDE_0), chosenSide);
        }
        for (portLabel$iterator = new ArrayList$1(edge.target.labels); portLabel$iterator.i < portLabel$iterator.this$01.array.length;) {
          portLabel = castTo($next_8(portLabel$iterator), 33);
          $setProperty(portLabel, ($clinit_InternalProperties() , LABEL_SIDE_0), chosenSide);
        }
      }
    }
  }
}

function LabelSideSelector(){
  $clinit_LabelSideSelector();
}

defineClass(489, 1, $intern_56, LabelSideSelector);
_.process = function process_24(layeredGraph, monitor){
  var lNode, lNode$iterator, label_0, label$iterator, layer, layer$iterator, mode, nodes, originEdge, port, port$iterator, port$iterator0, portPos, thickness;
  mode = castTo($getProperty(layeredGraph, ($clinit_Properties() , EDGE_LABEL_SIDE_SELECTION)), 115);
  $begin(monitor, 'Label side selection (' + mode + ')', 1);
  nodes = (checkNotNull(layeredGraph) , new FluentIterable$2(layeredGraph));
  switch (mode.ordinal) {
    case 0:
      $alwaysUp(nodes);
      break;
    case 1:
      $alwaysDown(nodes);
      break;
    case 2:
      $directionUp(nodes);
      break;
    case 3:
      $directionDown(nodes);
      break;
    case 4:
      $smart(nodes);
  }
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator), 16);
    for (lNode$iterator = new ArrayList$1(layer.nodes); lNode$iterator.i < lNode$iterator.this$01.array.length;) {
      lNode = castTo($next_8(lNode$iterator), 9);
      for (port$iterator0 = new ArrayList$1(lNode.ports); port$iterator0.i < port$iterator0.this$01.array.length;) {
        port = castTo($next_8(port$iterator0), 7);
        for (label$iterator = new ArrayList$1(port.labels); label$iterator.i < label$iterator.this$01.array.length;) {
          label_0 = castTo($next_8(label$iterator), 33);
          maskUndefined($getProperty(label_0, ($clinit_InternalProperties() , LABEL_SIDE_0))) === maskUndefined(($clinit_LabelSide() , UNKNOWN)) && $setProperty(label_0, LABEL_SIDE_0, DEFAULT_LABEL_SIDE);
        }
      }
      if (lNode.type_0 == ($clinit_LNode$NodeType() , LABEL)) {
        if (maskUndefined($getProperty(lNode, ($clinit_InternalProperties() , LABEL_SIDE_0))) === maskUndefined(($clinit_LabelSide() , ABOVE))) {
          originEdge = castTo($getProperty(lNode, ORIGIN), 12);
          thickness = castTo($getProperty(originEdge, ($clinit_LayoutOptions() , THICKNESS)), 15).value_0;
          portPos = lNode.size_0.y_0 - Math.ceil(thickness / 2);
          for (port$iterator = new ArrayList$1(lNode.ports); port$iterator.i < port$iterator.this$01.array.length;) {
            port = castTo($next_8(port$iterator), 7);
            port.pos.y_0 = portPos;
          }
        }
      }
    }
  }
  $done(monitor);
}
;
var DEFAULT_LABEL_SIDE;
var Lde_cau_cs_kieler_klay_layered_intermediate_LabelSideSelector_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'LabelSideSelector', 489);
function $compare_8(o1, o2){
  return o1.pos.y_0 < o2.pos.y_0?-1:o1.pos.y_0 == o2.pos.y_0?0:1;
}

function LabelSideSelector$1(){
}

defineClass(490, 1, $intern_9, LabelSideSelector$1);
_.compare_0 = function compare_20(o1, o2){
  return $compare_8(castTo(o1, 7), castTo(o2, 7));
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_LabelSideSelector$1_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'LabelSideSelector/1', 490);
function $assertNoIncoming(node, strict){
  var incoming, incoming$iterator, name_0, port, port$iterator;
  for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_8(port$iterator), 7);
    if (strict) {
      if (port.incomingEdges.array.length != 0) {
        throw new UnsupportedConfigurationException((name_0 = $getName(node) , "Node '" + (name_0 == null?toString_78(node.id_0):name_0) + "' has its layer constraint set to FIRST or FIRST_SEPARATE, but has " + 'at least one incoming edge. Connections between nodes with these ' + 'layer constraints are not supported.'));
      }
    }
     else {
      for (incoming$iterator = new ArrayList$1(port.incomingEdges); incoming$iterator.i < incoming$iterator.this$01.array.length;) {
        incoming = castTo($next_8(incoming$iterator), 12);
        if (maskUndefined($getProperty(incoming.source.owner, ($clinit_Properties() , LAYER_CONSTRAINT))) !== maskUndefined(($clinit_LayerConstraint() , FIRST_SEPARATE))) {
          throw new UnsupportedConfigurationException((name_0 = $getName(node) , "Node '" + (name_0 == null?toString_78(node.id_0):name_0) + "' has its layer constraint set to FIRST or FIRST_SEPARATE, but has " + 'at least one incoming edge. Connections between nodes with these ' + 'layer constraints are not supported.'));
        }
      }
    }
  }
}

function $assertNoOutgoing(node){
  var name_0, outgoing, outgoing$iterator, port, port$iterator;
  for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_8(port$iterator), 7);
    for (outgoing$iterator = new ArrayList$1(port.outgoingEdges); outgoing$iterator.i < outgoing$iterator.this$01.array.length;) {
      outgoing = castTo($next_8(outgoing$iterator), 12);
      if (maskUndefined($getProperty(outgoing.target.owner, ($clinit_Properties() , LAYER_CONSTRAINT))) !== maskUndefined(($clinit_LayerConstraint() , LAST_SEPARATE))) {
        throw new UnsupportedConfigurationException((name_0 = $getName(node) , "Node '" + (name_0 == null?toString_78(node.id_0):name_0) + "' has its layer constraint set to LAST or LAST_SEPARATE, but has " + 'at least one outgoing edge. Connections between nodes with these ' + 'layer constraints are not supported.'));
      }
    }
  }
}

function LayerConstraintProcessor(){
}

defineClass(495, 1, $intern_56, LayerConstraintProcessor);
_.process = function process_25(layeredGraph, monitor){
  var constraint, edge, edge$iterator, firstLayer, lastLayer, layer, layer$iterator, layers, moveAllowed, node, node$index, node$iterator, node$max, nodes, sndFirstLayer, sndLastLayer, veryFirstLayer, veryLastLayer;
  $begin(monitor, 'Layer constraint application', 1);
  layers = layeredGraph.layers;
  if (layers.array.length == 0) {
    $done(monitor);
    return;
  }
  firstLayer = (checkCriticalElementIndex(0, layers.array.length) , castTo(layers.array[0], 16));
  lastLayer = castTo($get_8(layers, layers.array.length - 1), 16);
  veryFirstLayer = new Layer(layeredGraph);
  veryLastLayer = new Layer(layeredGraph);
  for (layer$iterator = new ArrayList$1(layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator), 16);
    nodes = castTo($toArray_1(layer.nodes, initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LNode_2_classLit, $intern_49, 9, layer.nodes.array.length, 0, 1)), 51);
    for (node$index = 0 , node$max = nodes.length; node$index < node$max; ++node$index) {
      node = nodes[node$index];
      constraint = castTo($getProperty(node, ($clinit_Properties() , LAYER_CONSTRAINT)), 85);
      switch (constraint.ordinal) {
        case 1:
          $setLayer_0(node, firstLayer);
          $assertNoIncoming(node, false);
          break;
        case 2:
          $setLayer_0(node, veryFirstLayer);
          $assertNoIncoming(node, true);
          break;
        case 3:
          $setLayer_0(node, lastLayer);
          $assertNoOutgoing(node);
          break;
        case 4:
          $setLayer_0(node, veryLastLayer);
          $assertNoOutgoing(node);
      }
    }
  }
  if (layers.array.length >= 2) {
    moveAllowed = true;
    sndFirstLayer = (checkCriticalElementIndex(1, layers.array.length) , castTo(layers.array[1], 16));
    for (node$iterator = new ArrayList$1(firstLayer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      if (maskUndefined($getProperty(node, ($clinit_Properties() , LAYER_CONSTRAINT))) === maskUndefined(($clinit_LayerConstraint() , NONE_5))) {
        moveAllowed = false;
        break;
      }
      for (edge$iterator = $iterator($getOutgoingEdges_0(node)); $hasNext_0(edge$iterator);) {
        edge = castTo($next_2(edge$iterator), 12);
        if (edge.target.owner.layer == sndFirstLayer) {
          moveAllowed = false;
          break;
        }
      }
      if (!moveAllowed) {
        break;
      }
    }
    if (moveAllowed) {
      nodes = castTo($toArray_1(firstLayer.nodes, initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LNode_2_classLit, $intern_49, 9, firstLayer.nodes.array.length, 0, 1)), 51);
      for (node$index = 0 , node$max = nodes.length; node$index < node$max; ++node$index) {
        node = nodes[node$index];
        $setLayer_0(node, sndFirstLayer);
      }
      $remove_7(layers, firstLayer);
    }
  }
  if (layers.array.length >= 2) {
    moveAllowed = true;
    sndLastLayer = castTo($get_8(layers, layers.array.length - 2), 16);
    for (node$iterator = new ArrayList$1(lastLayer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      if (maskUndefined($getProperty(node, ($clinit_Properties() , LAYER_CONSTRAINT))) === maskUndefined(($clinit_LayerConstraint() , NONE_5))) {
        moveAllowed = false;
        break;
      }
      for (edge$iterator = $iterator($getIncomingEdges_0(node)); $hasNext_0(edge$iterator);) {
        edge = castTo($next_2(edge$iterator), 12);
        if (edge.source.owner.layer == sndLastLayer) {
          moveAllowed = false;
          break;
        }
      }
      if (!moveAllowed) {
        break;
      }
    }
    if (moveAllowed) {
      nodes = castTo($toArray_1(lastLayer.nodes, initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LNode_2_classLit, $intern_49, 9, lastLayer.nodes.array.length, 0, 1)), 51);
      for (node$index = 0 , node$max = nodes.length; node$index < node$max; ++node$index) {
        node = nodes[node$index];
        $setLayer_0(node, sndLastLayer);
      }
      $remove_7(layers, lastLayer);
    }
  }
  layers.array.length == 1 && (checkCriticalElementIndex(0, layers.array.length) , castTo(layers.array[0], 16)).nodes.array.length == 0 && $remove_6(layers, 0);
  veryFirstLayer.nodes.array.length == 0 || (checkCriticalPositionIndex(0, layers.array.length) , insertTo(layers.array, 0, veryFirstLayer));
  veryLastLayer.nodes.array.length == 0 || (layers.array[layers.array.length] = veryLastLayer , true);
  $done(monitor);
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_LayerConstraintProcessor_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'LayerConstraintProcessor', 495);
function LayerSizeAndGraphHeightCalculator(){
}

defineClass(496, 1, $intern_56, LayerSizeAndGraphHeightCalculator);
_.process = function process_26(layeredGraph, monitor){
  var bottom, firstNode, lastNode, layer, layer$iterator, layerSize, maxY, minY, node, node$iterator, nodeMargin, nodeSize, top_0;
  $begin(monitor, 'Layer size calculation', 1);
  minY = $intern_60;
  maxY = 4.9E-324;
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator), 16);
    layerSize = layer.size_0;
    layerSize.x_0 = 0;
    layerSize.y_0 = 0;
    if (layer.nodes.array.length == 0) {
      continue;
    }
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      nodeSize = node.size_0;
      nodeMargin = node.margin;
      layerSize.x_0 = max_1(layerSize.x_0, nodeSize.x_0 + nodeMargin.left + nodeMargin.right);
    }
    firstNode = castTo($get_8(layer.nodes, 0), 9);
    top_0 = firstNode.pos.y_0 - firstNode.margin.top_0;
    lastNode = castTo($get_8(layer.nodes, layer.nodes.array.length - 1), 9);
    bottom = lastNode.pos.y_0 + lastNode.size_0.y_0 + lastNode.margin.bottom;
    layerSize.y_0 = bottom - top_0;
    minY = minY < top_0?minY:top_0;
    maxY = maxY > bottom?maxY:bottom;
  }
  layeredGraph.size_0.y_0 = maxY - minY;
  layeredGraph.offset.y_0 -= minY;
  $done(monitor);
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_LayerSizeAndGraphHeightCalculator_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'LayerSizeAndGraphHeightCalculator', 496);
function LongEdgeJoiner(){
}

function joinAt(longEdgeDummy, addUnnecessaryBendpoints){
  var bendPoint, bendPoint$iterator, droppedEdge, droppedEdgeListIndex, droppedJunctionsPoints, edgeCount, inputPortEdges, jp, jp$iterator, label_0, label$iterator, outputPortEdges, survivingBendPoints, survivingEdge, survivingJunctionPoints, survivingLabels, targetIncomingEdges, unnecessaryBendpoint;
  inputPortEdges = castTo($getPorts_0(longEdgeDummy, ($clinit_PortSide() , WEST)).iterator_0().next_1(), 7).incomingEdges;
  outputPortEdges = castTo($getPorts_0(longEdgeDummy, EAST).iterator_0().next_1(), 7).outgoingEdges;
  edgeCount = inputPortEdges.array.length;
  unnecessaryBendpoint = $getAbsoluteAnchor(castTo($get_8(longEdgeDummy.ports, 0), 7));
  while (edgeCount-- > 0) {
    survivingEdge = (checkCriticalElementIndex(0, inputPortEdges.array.length) , castTo(inputPortEdges.array[0], 12));
    droppedEdge = (checkCriticalElementIndex(0, outputPortEdges.array.length) , castTo(outputPortEdges.array[0], 12));
    targetIncomingEdges = droppedEdge.target.incomingEdges;
    droppedEdgeListIndex = $indexOf_0(targetIncomingEdges, droppedEdge, 0);
    $setTargetAndInsertAtIndex(survivingEdge, droppedEdge.target, droppedEdgeListIndex);
    $setSource(droppedEdge, null);
    $setTarget(droppedEdge, null);
    survivingBendPoints = survivingEdge.bendPoints;
    addUnnecessaryBendpoints && $add_8(survivingBendPoints, new KVector_2(unnecessaryBendpoint));
    for (bendPoint$iterator = $listIterator_2(droppedEdge.bendPoints, 0); bendPoint$iterator.currentNode != bendPoint$iterator.this$01.tail;) {
      bendPoint = castTo($next_11(bendPoint$iterator), 10);
      $add_8(survivingBendPoints, new KVector_2(bendPoint));
    }
    survivingLabels = survivingEdge.labels;
    for (label$iterator = new ArrayList$1(droppedEdge.labels); label$iterator.i < label$iterator.this$01.array.length;) {
      label_0 = castTo($next_8(label$iterator), 33);
      survivingLabels.array[survivingLabels.array.length] = label_0;
    }
    survivingJunctionPoints = castTo($getProperty(survivingEdge, ($clinit_LayoutOptions() , JUNCTION_POINTS)), 44);
    droppedJunctionsPoints = castTo($getProperty(droppedEdge, JUNCTION_POINTS), 44);
    if (droppedJunctionsPoints) {
      if (!survivingJunctionPoints) {
        survivingJunctionPoints = new KVectorChain;
        $setProperty(survivingEdge, JUNCTION_POINTS, survivingJunctionPoints);
      }
      for (jp$iterator = $listIterator_2(droppedJunctionsPoints, 0); jp$iterator.currentNode != jp$iterator.this$01.tail;) {
        jp = castTo($next_11(jp$iterator), 10);
        $add_8(survivingJunctionPoints, new KVector_2(jp));
      }
    }
  }
}

defineClass(497, 1, $intern_56, LongEdgeJoiner);
_.process = function process_27(layeredGraph, monitor){
  var addUnnecessaryBendpoints, layer, layer$iterator, node, nodeIterator;
  $begin(monitor, 'Edge joining', 1);
  addUnnecessaryBendpoints = unsafeCast(checkNotNull_1(castToBoolean($getProperty(layeredGraph, ($clinit_Properties() , ADD_UNNECESSARY_BENDPOINTS)))));
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator), 16);
    nodeIterator = new AbstractList$ListIteratorImpl(layer.nodes, 0);
    while (nodeIterator.i < nodeIterator.this$01_0.size_1()) {
      node = (checkCriticalElement(nodeIterator.i < nodeIterator.this$01_0.size_1()) , castTo(nodeIterator.this$01_0.get_2(nodeIterator.last = nodeIterator.i++), 9));
      if (node.type_0 == ($clinit_LNode$NodeType() , LONG_EDGE)) {
        joinAt(node, addUnnecessaryBendpoints);
        $remove_11(nodeIterator);
      }
    }
  }
  $done(monitor);
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_LongEdgeJoiner_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'LongEdgeJoiner', 497);
function LongEdgeSplitter(){
}

function moveHeadLabels(oldEdge, newEdge){
  var label_0, labelIterator, labelPlacement;
  labelIterator = new AbstractList$ListIteratorImpl(oldEdge.labels, 0);
  while (labelIterator.i < labelIterator.this$01_0.size_1()) {
    label_0 = (checkCriticalElement(labelIterator.i < labelIterator.this$01_0.size_1()) , castTo(labelIterator.this$01_0.get_2(labelIterator.last = labelIterator.i++), 33));
    labelPlacement = castTo($getProperty(label_0, ($clinit_LayoutOptions() , EDGE_LABEL_PLACEMENT)), 107);
    if (labelPlacement == ($clinit_EdgeLabelPlacement() , HEAD)) {
      $remove_11(labelIterator);
      $add_11(newEdge.labels, label_0);
    }
  }
}

function setDummyNodeProperties(dummyNode, inEdge, outEdge){
  var inEdgeSourceNode;
  inEdgeSourceNode = inEdge.source.owner;
  if (inEdgeSourceNode.type_0 == ($clinit_LNode$NodeType() , LONG_EDGE)) {
    $setProperty(dummyNode, ($clinit_InternalProperties() , LONG_EDGE_SOURCE), castTo($getProperty(inEdgeSourceNode, LONG_EDGE_SOURCE), 7));
    $setProperty(dummyNode, LONG_EDGE_TARGET, castTo($getProperty(inEdgeSourceNode, LONG_EDGE_TARGET), 7));
  }
   else {
    $setProperty(dummyNode, ($clinit_InternalProperties() , LONG_EDGE_SOURCE), inEdge.source);
    $setProperty(dummyNode, LONG_EDGE_TARGET, outEdge.target);
  }
}

function splitEdge(edge, dummyNode){
  var dummyEdge, dummyInput, dummyOutput, oldEdgeTarget, portPos, thickness;
  oldEdgeTarget = edge.target;
  thickness = castTo($getProperty(edge, ($clinit_LayoutOptions() , THICKNESS)), 15).value_0;
  if (thickness < 0) {
    thickness = 0;
    $setProperty(edge, THICKNESS, new Float_0(thickness));
  }
  dummyNode.size_0.y_0 = thickness;
  portPos = Math.floor(thickness / 2);
  dummyInput = new LPort;
  $setSide(dummyInput, ($clinit_PortSide() , WEST));
  $setNode(dummyInput, dummyNode);
  dummyInput.pos.y_0 = portPos;
  dummyOutput = new LPort;
  $setSide(dummyOutput, EAST);
  $setNode(dummyOutput, dummyNode);
  dummyOutput.pos.y_0 = portPos;
  $setTarget(edge, dummyInput);
  dummyEdge = new LEdge;
  $copyProperties(dummyEdge, edge);
  $setProperty(dummyEdge, JUNCTION_POINTS, null);
  $setSource(dummyEdge, dummyOutput);
  $setTarget(dummyEdge, oldEdgeTarget);
  setDummyNodeProperties(dummyNode, edge, dummyEdge);
  moveHeadLabels(edge, dummyEdge);
  return dummyEdge;
}

defineClass(498, 1, $intern_56, LongEdgeSplitter);
_.process = function process_28(layeredGraph, monitor){
  var edge, edge$iterator, layer, layerIter, nextLayer, node, node$iterator, port, port$iterator, targetLayer, targetPort, dummyNode;
  $begin(monitor, 'Edge splitting', 1);
  if (layeredGraph.layers.array.length <= 2) {
    $done(monitor);
    return;
  }
  layerIter = new AbstractList$ListIteratorImpl(layeredGraph.layers, 0);
  nextLayer = (checkCriticalElement(layerIter.i < layerIter.this$01_0.size_1()) , castTo(layerIter.this$01_0.get_2(layerIter.last = layerIter.i++), 16));
  while (layerIter.i < layerIter.this$01_0.size_1()) {
    layer = nextLayer;
    nextLayer = (checkCriticalElement(layerIter.i < layerIter.this$01_0.size_1()) , castTo(layerIter.this$01_0.get_2(layerIter.last = layerIter.i++), 16));
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
        port = castTo($next_8(port$iterator), 7);
        for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
          edge = castTo($next_8(edge$iterator), 12);
          targetPort = edge.target;
          targetLayer = targetPort.owner.layer;
          targetLayer != layer && targetLayer != nextLayer && splitEdge(edge, (dummyNode = new LNode(layeredGraph) , $setType(dummyNode, ($clinit_LNode$NodeType() , LONG_EDGE)) , $setProperty(dummyNode, ($clinit_InternalProperties() , ORIGIN), edge) , $setProperty(dummyNode, ($clinit_LayoutOptions() , PORT_CONSTRAINTS), ($clinit_PortConstraints() , FIXED_POS)) , $setLayer_0(dummyNode, nextLayer) , dummyNode));
        }
      }
    }
  }
  $done(monitor);
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_LongEdgeSplitter_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'LongEdgeSplitter', 498);
function $processComments(node, spacing){
  var bottomBoxes, bottomWidth, commentBox, commentBox$iterator, margin, maxCommentWidth, maxHeight, protrusion, topBoxes, topWidth;
  margin = node.margin;
  topBoxes = castTo($getProperty(node, ($clinit_InternalProperties() , TOP_COMMENTS)), 20);
  topWidth = 0;
  if (topBoxes) {
    maxHeight = 0;
    for (commentBox$iterator = topBoxes.iterator_0(); commentBox$iterator.hasNext_0();) {
      commentBox = castTo(commentBox$iterator.next_1(), 9);
      maxHeight = max_1(maxHeight, commentBox.size_0.y_0);
      topWidth += commentBox.size_0.x_0;
    }
    topWidth += spacing / 2 * (topBoxes.size_1() - 1);
    margin.top_0 += maxHeight + spacing;
  }
  bottomBoxes = castTo($getProperty(node, BOTTOM_COMMENTS), 20);
  bottomWidth = 0;
  if (bottomBoxes) {
    maxHeight = 0;
    for (commentBox$iterator = bottomBoxes.iterator_0(); commentBox$iterator.hasNext_0();) {
      commentBox = castTo(commentBox$iterator.next_1(), 9);
      maxHeight = max_1(maxHeight, commentBox.size_0.y_0);
      bottomWidth += commentBox.size_0.x_0;
    }
    bottomWidth += spacing / 2 * (bottomBoxes.size_1() - 1);
    margin.bottom += maxHeight + spacing;
  }
  maxCommentWidth = topWidth > bottomWidth?topWidth:bottomWidth;
  if (maxCommentWidth > node.size_0.x_0) {
    protrusion = (maxCommentWidth - node.size_0.x_0) / 2;
    margin.left = max_1(margin.left, protrusion);
    margin.right = max_1(margin.right, protrusion);
  }
}

function NodeMarginCalculator_0(){
}

defineClass(499, 1, $intern_56, NodeMarginCalculator_0);
_.process = function process_29(layeredGraph, monitor){
  var calcu, layer, layer$iterator, node, node$iterator, spacing, nodeMargin, selfLoopMargin;
  $begin(monitor, 'Node margin calculation', 1);
  calcu = new NodeMarginCalculator(($clinit_LGraphAdapters() , new LGraphAdapters$LGraphAdapter(layeredGraph, true)));
  $process_0(calcu);
  spacing = castTo($getProperty(layeredGraph, ($clinit_InternalProperties() , SPACING_0)), 15).value_0;
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator), 16);
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      $processComments(node, spacing);
      nodeMargin = node.margin;
      selfLoopMargin = castTo($getProperty(node, SPLINE_SELF_LOOP_MARGINS), 64);
      nodeMargin.left = max_1(nodeMargin.left, selfLoopMargin.left);
      nodeMargin.right = max_1(nodeMargin.right, selfLoopMargin.right);
      nodeMargin.bottom = max_1(nodeMargin.bottom, selfLoopMargin.bottom);
      nodeMargin.top_0 = max_1(nodeMargin.top_0, selfLoopMargin.top_0);
    }
  }
  $done(monitor);
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_NodeMarginCalculator_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'NodeMarginCalculator', 499);
function $precalculateAndSetInformation(this$static){
  var dummyBaggage, inDegree, incoming, layer, layer$iterator, layer$iterator0, layerID, layerSize, layerSizePixel, node, node$iterator, nodeID, nodesNdummies, outDegree, outcoming;
  this$static.nodeSizeAffix = castTo($getProperty(this$static.masterGraph, ($clinit_InternalProperties() , SPACING_0)), 15).value_0 * castTo($getProperty(this$static.masterGraph, ($clinit_Properties() , OBJ_SPACING_IN_LAYER_FACTOR)), 15).value_0;
  this$static.dummySize = this$static.nodeSizeAffix * castTo($getProperty(this$static.masterGraph, EDGE_SPACING_FACTOR), 15).value_0;
  this$static.maxHeight = this$static.masterGraph.layers.array.length;
  layerID = this$static.maxHeight - 1;
  nodeID = 0;
  this$static.maxWidth = 0;
  this$static.maxWidthPixel = 0;
  this$static.currentWidth = newArrayList_1(initUnidimensionalArray(Ljava_lang_Integer_2_classLit, $intern_0, 24, this$static.maxHeight, 0, 1));
  this$static.currentWidthPixel = newArrayList_1(initUnidimensionalArray(Ljava_lang_Double_2_classLit, $intern_0, 184, this$static.maxHeight, 6, 1));
  for (layer$iterator0 = new ArrayList$1(this$static.masterGraph.layers); layer$iterator0.i < layer$iterator0.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator0), 16);
    layer.id_0 = layerID;
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      node.id_0 = nodeID;
      ++nodeID;
    }
    --layerID;
  }
  this$static.layers = initUnidimensionalArray(I_classLit, $intern_37, 26, nodeID, 12, 1);
  this$static.degreeDiff = initMultidimensionalArray(I_classLit, [$intern_0, $intern_37], [52, 26], 12, [nodeID, 3], 2);
  this$static.nodes = new ArrayList;
  this$static.nodesWithIncomingEdges = new ArrayList;
  dummyBaggage = 0;
  this$static.dummyNodeCount = 0;
  for (layer$iterator = new ArrayList$1(this$static.masterGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator), 16);
    layerID = layer.id_0;
    incoming = 0;
    outcoming = 0;
    layerSize = layer.nodes.array.length;
    layerSizePixel = 0;
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      nodeID = node.id_0;
      this$static.layers[nodeID] = node.layer.id_0;
      layerSizePixel += node.size_0.y_0 + this$static.nodeSizeAffix;
      inDegree = size_18($getIncomingEdges_0(node));
      outDegree = size_18($getOutgoingEdges_0(node));
      this$static.degreeDiff[nodeID][0] = outDegree - inDegree;
      this$static.degreeDiff[nodeID][1] = inDegree;
      this$static.degreeDiff[nodeID][2] = outDegree;
      incoming += inDegree;
      outcoming += outDegree;
      inDegree > 0 && $add_11(this$static.nodesWithIncomingEdges, node);
      $add_11(this$static.nodes, node);
    }
    dummyBaggage -= incoming;
    nodesNdummies = layerSize + dummyBaggage;
    layerSizePixel += dummyBaggage * this$static.dummySize;
    $set_3(this$static.currentWidth, layerID, valueOf_0(nodesNdummies));
    $set_3(this$static.currentWidthPixel, layerID, layerSizePixel);
    this$static.maxWidth = max_3(this$static.maxWidth, nodesNdummies);
    this$static.maxWidthPixel = max_1(this$static.maxWidthPixel, layerSizePixel);
    this$static.dummyNodeCount += dummyBaggage;
    dummyBaggage += outcoming;
  }
}

function $promoteNode(this$static, node){
  var dummiesBuilt, dummiesReduced, dummydiff, edge, edge$iterator, masterNode, maxWidthNotExceeded, nodeLayerPos, nodeSize, promotion;
  maxWidthNotExceeded = true;
  dummydiff = 0;
  nodeLayerPos = this$static.layers[node.id_0];
  nodeSize = node.size_0.y_0 + this$static.nodeSizeAffix;
  dummiesBuilt = this$static.degreeDiff[node.id_0][2];
  $set_3(this$static.currentWidth, nodeLayerPos, valueOf_0(castTo($get_8(this$static.currentWidth, nodeLayerPos), 24).value_0 - 1 + dummiesBuilt));
  $set_3(this$static.currentWidthPixel, nodeLayerPos, checkNotNull_1(castToDouble($get_8(this$static.currentWidthPixel, nodeLayerPos))) - nodeSize + dummiesBuilt * this$static.dummySize);
  ++nodeLayerPos;
  if (nodeLayerPos >= this$static.maxHeight) {
    ++this$static.maxHeight;
    $add_11(this$static.currentWidth, valueOf_0(1));
    $add_11(this$static.currentWidthPixel, nodeSize);
  }
   else {
    dummiesReduced = this$static.degreeDiff[node.id_0][1];
    $set_3(this$static.currentWidth, nodeLayerPos, valueOf_0(castTo($get_8(this$static.currentWidth, nodeLayerPos), 24).value_0 + 1 - dummiesReduced));
    $set_3(this$static.currentWidthPixel, nodeLayerPos, checkNotNull_1(castToDouble($get_8(this$static.currentWidthPixel, nodeLayerPos))) + nodeSize - dummiesReduced * this$static.dummySize);
  }
  (this$static.promotionStrategy == ($clinit_NodePromotionStrategy() , NIKOLOV) && (castTo($get_8(this$static.currentWidth, nodeLayerPos), 24).value_0 > this$static.maxWidth || castTo($get_8(this$static.currentWidth, nodeLayerPos - 1), 24).value_0 > this$static.maxWidth) || this$static.promotionStrategy == NIKOLOV_PIXEL && (checkNotNull_1(castToDouble($get_8(this$static.currentWidthPixel, nodeLayerPos))) > this$static.maxWidthPixel || checkNotNull_1(castToDouble($get_8(this$static.currentWidthPixel, nodeLayerPos - 1))) > this$static.maxWidthPixel)) && (maxWidthNotExceeded = false);
  for (edge$iterator = $iterator($getIncomingEdges_0(node)); $hasNext_0(edge$iterator);) {
    edge = castTo($next_2(edge$iterator), 12);
    masterNode = edge.source.owner;
    if (this$static.layers[masterNode.id_0] == nodeLayerPos) {
      promotion = $promoteNode(this$static, masterNode);
      dummydiff = dummydiff + castTo(promotion.first, 24).value_0;
      maxWidthNotExceeded = maxWidthNotExceeded && unsafeCast(checkNotNull_1(castToBoolean(promotion.second)));
    }
  }
  this$static.layers[node.id_0] = nodeLayerPos;
  dummydiff = dummydiff + this$static.degreeDiff[node.id_0][0];
  return new Pair(valueOf_0(dummydiff), ($clinit_Boolean() , maxWidthNotExceeded?TRUE_0:FALSE_0));
}

function $promotionMagic(this$static, funky){
  var apply_0, currentWidthBackup, currentWidthPixelBackup, dummyBackup, heightBackup, iterationCounter, layeringBackup, node, node$iterator, promotionFlag, promotionPair, promotions, reducedDummies;
  iterationCounter = 0;
  reducedDummies = 0;
  layeringBackup = copyOf_2(this$static.layers, this$static.layers.length);
  dummyBackup = this$static.dummyNodeCount;
  heightBackup = this$static.maxHeight;
  currentWidthBackup = this$static.currentWidth;
  currentWidthPixelBackup = this$static.currentWidthPixel;
  do {
    promotions = 0;
    for (node$iterator = new ArrayList$1(this$static.nodesWithIncomingEdges); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      promotionPair = $promoteNode(this$static, node);
      apply_0 = true;
      (this$static.promotionStrategy == ($clinit_NodePromotionStrategy() , NIKOLOV) || this$static.promotionStrategy == NIKOLOV_PIXEL) && (apply_0 = unsafeCast(checkNotNull_1(castToBoolean(promotionPair.second))));
      if (castTo(promotionPair.first, 24).value_0 < 0 && apply_0) {
        ++promotions;
        layeringBackup = copyOf_2(this$static.layers, this$static.layers.length);
        this$static.dummyNodeCount = this$static.dummyNodeCount + castTo(promotionPair.first, 24).value_0;
        reducedDummies += dummyBackup - this$static.dummyNodeCount;
        dummyBackup = this$static.dummyNodeCount + castTo(promotionPair.first, 24).value_0;
        heightBackup = this$static.maxHeight;
        currentWidthBackup = newArrayList(this$static.currentWidth);
        currentWidthPixelBackup = newArrayList(this$static.currentWidthPixel);
      }
       else {
        this$static.layers = copyOf_2(layeringBackup, layeringBackup.length);
        this$static.dummyNodeCount = dummyBackup;
        this$static.currentWidth = (checkNotNull(currentWidthBackup) , currentWidthBackup?new ArrayList_1(($clinit_Collections2() , currentWidthBackup)):newArrayList_0(new ArrayList$1(null)));
        this$static.currentWidthPixel = (checkNotNull(currentWidthPixelBackup) , currentWidthPixelBackup?new ArrayList_1(($clinit_Collections2() , currentWidthPixelBackup)):newArrayList_0(new ArrayList$1(null)));
        this$static.maxHeight = heightBackup;
      }
    }
    ++iterationCounter;
    promotionFlag = promotions != 0 && unsafeCast(checkNotNull_1(castToBoolean(funky.apply_0(new Pair(valueOf_0(reducedDummies), valueOf_0(iterationCounter))))));
  }
   while (promotionFlag);
}

function $setNewLayering(this$static, layeredGraph){
  var i, laLaLayer, layList, layerIt, node, node$iterator, possiblyEvilLayer;
  layList = new ArrayList;
  for (i = 0; i <= this$static.maxHeight; i++) {
    laLaLayer = new Layer(layeredGraph);
    laLaLayer.id_0 = this$static.maxHeight - i;
    layList.array[layList.array.length] = laLaLayer;
  }
  for (node$iterator = new ArrayList$1(this$static.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 9);
    $setLayer_0(node, castTo($get_8(layList, this$static.maxHeight - this$static.layers[node.id_0]), 16));
  }
  layerIt = new ArrayList$1(layList);
  while (layerIt.i < layerIt.this$01.array.length) {
    possiblyEvilLayer = castTo($next_8(layerIt), 16);
    possiblyEvilLayer.nodes.array.length == 0 && $remove_12(layerIt);
  }
  layeredGraph.layers.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
  $addAll_6(layeredGraph.layers, layList);
}

function NodePromotion(){
}

function lambda$1_0(promoteUntilN_0, pair_1){
  return $clinit_Boolean() , castTo(pair_1.second, 24).value_0 < promoteUntilN_0?TRUE_0:FALSE_0;
}

function lambda$2(promoteUntilD_0, pair_1){
  return $clinit_Boolean() , castTo(pair_1.first, 24).value_0 < promoteUntilD_0?TRUE_0:FALSE_0;
}

defineClass(491, 1, $intern_56, NodePromotion);
_.process = function process_30(layeredGraph, progressMonitor){
  var donna, donna$iterator, funFunction, martha, martha$iterator, newMaxWidth, newMaxWidthPixel, promoteUntil, promoteUntilD, promoteUntilN;
  $begin(progressMonitor, 'Node promotion heuristic', 1);
  this.masterGraph = layeredGraph;
  $precalculateAndSetInformation(this);
  this.promotionStrategy = castTo($getProperty(layeredGraph, ($clinit_Properties() , NODE_PROMOTION_0)), 109);
  promoteUntil = castTo($getProperty(this.masterGraph, NODE_PROMOTION_BOUNDARY), 24).value_0;
  funFunction = new NodePromotion$lambda$0$Type;
  switch (this.promotionStrategy.ordinal) {
    case 2:
    case 1:
      $promotionMagic(this, funFunction);
      break;
    case 3:
      this.promotionStrategy = ($clinit_NodePromotionStrategy() , NO_BOUNDARY);
      $promotionMagic(this, funFunction);
      newMaxWidth = 0;
      for (martha$iterator = new ArrayList$1(this.currentWidth); martha$iterator.i < martha$iterator.this$01.array.length;) {
        martha = castTo($next_8(martha$iterator), 24);
        newMaxWidth = max_3(newMaxWidth, martha.value_0);
      }

      if (newMaxWidth > this.maxWidth) {
        this.promotionStrategy = NIKOLOV;
        $promotionMagic(this, funFunction);
      }

      break;
    case 4:
      this.promotionStrategy = ($clinit_NodePromotionStrategy() , NO_BOUNDARY);
      $promotionMagic(this, funFunction);
      newMaxWidthPixel = 0;
      for (donna$iterator = new ArrayList$1(this.currentWidthPixel); donna$iterator.i < donna$iterator.this$01.array.length;) {
        donna = castToDouble($next_8(donna$iterator));
        newMaxWidthPixel = max_1(newMaxWidthPixel, (checkCriticalNotNull(donna) , donna));
      }

      if (newMaxWidthPixel > this.maxWidthPixel) {
        this.promotionStrategy = NIKOLOV_PIXEL;
        $promotionMagic(this, funFunction);
      }

      break;
    case 6:
      promoteUntilN = round_int(ceil_0(this.layers.length * promoteUntil / 100));
      $promotionMagic(this, new NodePromotion$lambda$1$Type(promoteUntilN));
      break;
    case 5:
      promoteUntilD = round_int(ceil_0(this.dummyNodeCount * promoteUntil / 100));
      $promotionMagic(this, new NodePromotion$lambda$2$Type(promoteUntilD));
      break;
    default:$promotionMagic(this, funFunction);
  }
  $setNewLayering(this, layeredGraph);
  $done(progressMonitor);
}
;
_.dummyNodeCount = 0;
_.dummySize = 0;
_.maxHeight = 0;
_.maxWidth = 0;
_.maxWidthPixel = 0;
_.nodeSizeAffix = 0;
var Lde_cau_cs_kieler_klay_layered_intermediate_NodePromotion_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'NodePromotion', 491);
function NodePromotion$lambda$0$Type(){
}

defineClass(492, 1, $intern_35, NodePromotion$lambda$0$Type);
_.apply_0 = function apply_40(arg0){
  return $clinit_Boolean() , $clinit_Boolean() , TRUE_0;
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_NodePromotion$lambda$0$Type_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'NodePromotion/lambda$0$Type', 492);
function NodePromotion$lambda$1$Type(promoteUntilN_0){
  this.promoteUntilN_0 = promoteUntilN_0;
}

defineClass(493, 1, $intern_35, NodePromotion$lambda$1$Type);
_.apply_0 = function apply_41(arg0){
  return lambda$1_0(this.promoteUntilN_0, arg0);
}
;
_.promoteUntilN_0 = 0;
var Lde_cau_cs_kieler_klay_layered_intermediate_NodePromotion$lambda$1$Type_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'NodePromotion/lambda$1$Type', 493);
function NodePromotion$lambda$2$Type(promoteUntilD_0){
  this.promoteUntilD_0 = promoteUntilD_0;
}

defineClass(494, 1, $intern_35, NodePromotion$lambda$2$Type);
_.apply_0 = function apply_42(arg0){
  return lambda$2(this.promoteUntilD_0, arg0);
}
;
_.promoteUntilD_0 = 0;
var Lde_cau_cs_kieler_klay_layered_intermediate_NodePromotion$lambda$2$Type_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'NodePromotion/lambda$2$Type', 494);
function $clinit_NodePromotionStrategy(){
  $clinit_NodePromotionStrategy = emptyMethod;
  NONE_0 = new NodePromotionStrategy('NONE', 0);
  NIKOLOV = new NodePromotionStrategy('NIKOLOV', 1);
  NIKOLOV_PIXEL = new NodePromotionStrategy('NIKOLOV_PIXEL', 2);
  NIKOLOV_IMPROVED = new NodePromotionStrategy('NIKOLOV_IMPROVED', 3);
  NIKOLOV_IMPROVED_PIXEL = new NodePromotionStrategy('NIKOLOV_IMPROVED_PIXEL', 4);
  DUMMYNODE_PERCENTAGE = new NodePromotionStrategy('DUMMYNODE_PERCENTAGE', 5);
  NODECOUNT_PERCENTAGE = new NodePromotionStrategy('NODECOUNT_PERCENTAGE', 6);
  NO_BOUNDARY = new NodePromotionStrategy('NO_BOUNDARY', 7);
}

function NodePromotionStrategy(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function values_33(){
  $clinit_NodePromotionStrategy();
  return stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_intermediate_NodePromotionStrategy_2_classLit, 1), $intern_13, 109, 0, [NONE_0, NIKOLOV, NIKOLOV_PIXEL, NIKOLOV_IMPROVED, NIKOLOV_IMPROVED_PIXEL, DUMMYNODE_PERCENTAGE, NODECOUNT_PERCENTAGE, NO_BOUNDARY]);
}

defineClass(109, 17, {109:1, 3:1, 23:1, 17:1}, NodePromotionStrategy);
var DUMMYNODE_PERCENTAGE, NIKOLOV, NIKOLOV_IMPROVED, NIKOLOV_IMPROVED_PIXEL, NIKOLOV_PIXEL, NODECOUNT_PERCENTAGE, NONE_0, NO_BOUNDARY;
var Lde_cau_cs_kieler_klay_layered_intermediate_NodePromotionStrategy_2_classLit = createForEnum('de.cau.cs.kieler.klay.layered.intermediate', 'NodePromotionStrategy', 109, Ljava_lang_Enum_2_classLit, values_33);
function $clinit_NodePromotionStrategy$Map(){
  $clinit_NodePromotionStrategy$Map = emptyMethod;
  $MAP_12 = createValueOfMap(($clinit_NodePromotionStrategy() , stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_intermediate_NodePromotionStrategy_2_classLit, 1), $intern_13, 109, 0, [NONE_0, NIKOLOV, NIKOLOV_PIXEL, NIKOLOV_IMPROVED, NIKOLOV_IMPROVED_PIXEL, DUMMYNODE_PERCENTAGE, NODECOUNT_PERCENTAGE, NO_BOUNDARY])));
}

var $MAP_12;
function $processInputPort(inputPort, addJunctionPoints){
  var edgeArray, inEdge, inEdge$index, inEdge$max, junctionPoints, originPort, x_0, y_0;
  originPort = castTo($getProperty(inputPort, ($clinit_InternalProperties() , ORIGIN)), 7);
  x_0 = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [originPort.owner.pos, originPort.pos, originPort.anchor])).x_0;
  y_0 = inputPort.owner.pos.y_0;
  edgeArray = castTo($toArray_1(inputPort.incomingEdges, initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LEdge_2_classLit, $intern_57, 12, inputPort.incomingEdges.array.length, 0, 1)), 47);
  for (inEdge$index = 0 , inEdge$max = edgeArray.length; inEdge$index < inEdge$max; ++inEdge$index) {
    inEdge = edgeArray[inEdge$index];
    $setTarget(inEdge, originPort);
    $addLast(inEdge.bendPoints, new KVector_1(x_0, y_0));
    if (addJunctionPoints) {
      junctionPoints = castTo($getProperty(inEdge, ($clinit_LayoutOptions() , JUNCTION_POINTS)), 44);
      if (!junctionPoints) {
        junctionPoints = new KVectorChain;
        $setProperty(inEdge, JUNCTION_POINTS, junctionPoints);
      }
      $add_8(junctionPoints, new KVector_1(x_0, y_0));
    }
  }
}

function $processOutputPort(outputPort, addJunctionPoints){
  var edgeArray, junctionPoints, originPort, outEdge, outEdge$index, outEdge$max, x_0, y_0;
  originPort = castTo($getProperty(outputPort, ($clinit_InternalProperties() , ORIGIN)), 7);
  x_0 = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [originPort.owner.pos, originPort.pos, originPort.anchor])).x_0;
  y_0 = outputPort.owner.pos.y_0;
  edgeArray = castTo($toArray_1(outputPort.outgoingEdges, initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LEdge_2_classLit, $intern_57, 12, outputPort.outgoingEdges.array.length, 0, 1)), 47);
  for (outEdge$index = 0 , outEdge$max = edgeArray.length; outEdge$index < outEdge$max; ++outEdge$index) {
    outEdge = edgeArray[outEdge$index];
    $setSource(outEdge, originPort);
    $addFirst(outEdge.bendPoints, new KVector_1(x_0, y_0));
    if (addJunctionPoints) {
      junctionPoints = castTo($getProperty(outEdge, ($clinit_LayoutOptions() , JUNCTION_POINTS)), 44);
      if (!junctionPoints) {
        junctionPoints = new KVectorChain;
        $setProperty(outEdge, JUNCTION_POINTS, junctionPoints);
      }
      $add_8(junctionPoints, new KVector_1(x_0, y_0));
    }
  }
}

function $processSplineInputPort(inputPort){
  var edgeArray, inEdge, inEdge$index, inEdge$max, originPort;
  originPort = castTo($getProperty(inputPort, ($clinit_InternalProperties() , ORIGIN)), 7);
  edgeArray = castTo($toArray_1(inputPort.incomingEdges, initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LEdge_2_classLit, $intern_57, 12, inputPort.incomingEdges.array.length, 0, 1)), 47);
  for (inEdge$index = 0 , inEdge$max = edgeArray.length; inEdge$index < inEdge$max; ++inEdge$index) {
    inEdge = edgeArray[inEdge$index];
    $setTarget(inEdge, originPort);
  }
}

function $processSplineOutputPort(outputPort){
  var edgeArray, originPort, outEdge, outEdge$index, outEdge$max;
  originPort = castTo($getProperty(outputPort, ($clinit_InternalProperties() , ORIGIN)), 7);
  edgeArray = castTo($toArray_1(outputPort.outgoingEdges, initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LEdge_2_classLit, $intern_57, 12, outputPort.outgoingEdges.array.length, 0, 1)), 47);
  for (outEdge$index = 0 , outEdge$max = edgeArray.length; outEdge$index < outEdge$max; ++outEdge$index) {
    outEdge = edgeArray[outEdge$index];
    $setSource(outEdge, originPort);
  }
}

function NorthSouthPortPostprocessor(){
}

defineClass(500, 1, $intern_56, NorthSouthPortPostprocessor);
_.process = function process_31(layeredGraph, monitor){
  var currentPort, layer, layer$iterator, node, node$index, node$max, nodeArray, port, port$iterator, portIterator, previousPort, routing, sameOriginPort, selfLoop, inputPort, outputPort, originInputPort, originOutputPort, bendPoint;
  $begin(monitor, 'Odd port side processing', 1);
  routing = castTo($getProperty(layeredGraph, ($clinit_LayoutOptions() , EDGE_ROUTING)), 122);
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator), 16);
    nodeArray = castTo($toArray_1(layer.nodes, initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LNode_2_classLit, $intern_49, 9, layer.nodes.array.length, 0, 1)), 51);
    for (node$index = 0 , node$max = nodeArray.length; node$index < node$max; ++node$index) {
      node = nodeArray[node$index];
      if (node.type_0 != ($clinit_LNode$NodeType() , NORTH_SOUTH_PORT)) {
        continue;
      }
      if (routing == ($clinit_EdgeRouting() , SPLINES)) {
        for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
          port = castTo($next_8(port$iterator), 7);
          port.incomingEdges.array.length == 0 || $processSplineInputPort(port);
          port.outgoingEdges.array.length == 0 || $processSplineOutputPort(port);
        }
      }
       else if (instanceOf($getProperty(node, ($clinit_InternalProperties() , ORIGIN)), 12)) {
        selfLoop = castTo($getProperty(node, ORIGIN), 12);
        inputPort = castTo($getPorts_0(node, ($clinit_PortSide() , WEST)).iterator_0().next_1(), 7);
        outputPort = castTo($getPorts_0(node, EAST).iterator_0().next_1(), 7);
        originInputPort = castTo($getProperty(inputPort, ORIGIN), 7);
        originOutputPort = castTo($getProperty(outputPort, ORIGIN), 7);
        $setSource(selfLoop, originOutputPort);
        $setTarget(selfLoop, originInputPort);
        bendPoint = new KVector_2(outputPort.owner.pos);
        bendPoint.x_0 = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [originOutputPort.owner.pos, originOutputPort.pos, originOutputPort.anchor])).x_0;
        $add_8(selfLoop.bendPoints, bendPoint);
        bendPoint = new KVector_2(inputPort.owner.pos);
        bendPoint.x_0 = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [originInputPort.owner.pos, originInputPort.pos, originInputPort.anchor])).x_0;
        $add_8(selfLoop.bendPoints, bendPoint);
      }
       else {
        if (node.ports.array.length >= 2) {
          sameOriginPort = true;
          portIterator = new ArrayList$1(node.ports);
          currentPort = castTo($next_8(portIterator), 7);
          while (portIterator.i < portIterator.this$01.array.length) {
            previousPort = currentPort;
            currentPort = castTo($next_8(portIterator), 7);
            if (!equals_Ljava_lang_Object__Z__devirtual$($getProperty(previousPort, ORIGIN), $getProperty(currentPort, ORIGIN))) {
              sameOriginPort = false;
              break;
            }
          }
        }
         else {
          sameOriginPort = false;
        }
        for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
          port = castTo($next_8(port$iterator), 7);
          port.incomingEdges.array.length == 0 || $processInputPort(port, sameOriginPort);
          port.outgoingEdges.array.length == 0 || $processOutputPort(port, sameOriginPort);
        }
      }
      $setLayer_0(node, null);
    }
  }
  $done(monitor);
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_NorthSouthPortPostprocessor_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'NorthSouthPortPostprocessor', 500);
function $createDummyNode_0(layeredGraph, inPort, outPort, dummyNodes){
  var crossingHint, dummy, dummyInputPort, dummyOutputPort, edge, edge$index, edge$max, edgeArray;
  dummy = new LNode(layeredGraph);
  $setType(dummy, ($clinit_LNode$NodeType() , NORTH_SOUTH_PORT));
  $setProperty(dummy, ($clinit_LayoutOptions() , PORT_CONSTRAINTS), ($clinit_PortConstraints() , FIXED_POS));
  crossingHint = 0;
  if (inPort) {
    dummyInputPort = new LPort;
    $setProperty(dummyInputPort, ($clinit_InternalProperties() , ORIGIN), inPort);
    $setProperty(dummy, ORIGIN, inPort.owner);
    $setSide(dummyInputPort, ($clinit_PortSide() , WEST));
    $setNode(dummyInputPort, dummy);
    edgeArray = castTo($toArray_1(inPort.incomingEdges, initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LEdge_2_classLit, $intern_57, 12, inPort.incomingEdges.array.length, 0, 1)), 47);
    for (edge$index = 0 , edge$max = edgeArray.length; edge$index < edge$max; ++edge$index) {
      edge = edgeArray[edge$index];
      $setTarget(edge, dummyInputPort);
    }
    $setProperty(inPort, PORT_DUMMY, dummy);
    ++crossingHint;
  }
  if (outPort) {
    dummyOutputPort = new LPort;
    $setProperty(dummy, ($clinit_InternalProperties() , ORIGIN), outPort.owner);
    $setProperty(dummyOutputPort, ORIGIN, outPort);
    $setSide(dummyOutputPort, ($clinit_PortSide() , EAST));
    $setNode(dummyOutputPort, dummy);
    edgeArray = castTo($toArray_1(outPort.outgoingEdges, initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LEdge_2_classLit, $intern_57, 12, outPort.outgoingEdges.array.length, 0, 1)), 47);
    for (edge$index = 0 , edge$max = edgeArray.length; edge$index < edge$max; ++edge$index) {
      edge = edgeArray[edge$index];
      $setSource(edge, dummyOutputPort);
    }
    $setProperty(outPort, PORT_DUMMY, dummy);
    ++crossingHint;
  }
  $setProperty(dummy, ($clinit_InternalProperties() , CROSSING_HINT), valueOf_0(crossingHint));
  dummyNodes.array[dummyNodes.array.length] = dummy;
  return dummy;
}

function $createDummyNodes(layeredGraph, ports, dummyNodes, opposingSideDummyNodes, barycenterAssociates){
  var edge, edge$iterator, edge$iterator0, edge$iterator1, in_0, inOutPort, inOutPort$iterator, inOutPorts, inPort, inPort$iterator, inPorts, northSouthSelfLoopEdges, out, outPort, outPort$iterator, outPorts, port, port$iterator, port$iterator0, sameSideSelfLoopEdges, dummy, dummyInputPort, dummyOutputPort;
  inPorts = new ArrayList_0(ports.size_0);
  outPorts = new ArrayList_0(ports.size_0);
  inOutPorts = new ArrayList_0(ports.size_0);
  sameSideSelfLoopEdges = new ArrayList_0(ports.size_0);
  northSouthSelfLoopEdges = new ArrayList_0(ports.size_0);
  for (port$iterator0 = $listIterator_2(ports, 0); port$iterator0.currentNode != port$iterator0.this$01.tail;) {
    port = castTo($next_11(port$iterator0), 7);
    for (edge$iterator0 = new ArrayList$1(port.outgoingEdges); edge$iterator0.i < edge$iterator0.this$01.array.length;) {
      edge = castTo($next_8(edge$iterator0), 12);
      if (edge.source.owner == edge.target.owner) {
        if (port.side == edge.target.side) {
          sameSideSelfLoopEdges.array[sameSideSelfLoopEdges.array.length] = edge;
          continue;
        }
         else if (port.side == ($clinit_PortSide() , NORTH) && edge.target.side == SOUTH) {
          northSouthSelfLoopEdges.array[northSouthSelfLoopEdges.array.length] = edge;
          continue;
        }
      }
    }
  }
  for (edge$iterator1 = new ArrayList$1(northSouthSelfLoopEdges); edge$iterator1.i < edge$iterator1.this$01.array.length;) {
    edge = castTo($next_8(edge$iterator1), 12);
    $createNorthSouthSelfLoopDummyNodes(layeredGraph, edge, dummyNodes, opposingSideDummyNodes, ($clinit_PortSide() , EAST));
  }
  for (edge$iterator = new ArrayList$1(sameSideSelfLoopEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
    edge = castTo($next_8(edge$iterator), 12);
    dummy = new LNode(layeredGraph);
    $setType(dummy, ($clinit_LNode$NodeType() , NORTH_SOUTH_PORT));
    $setProperty(dummy, ($clinit_LayoutOptions() , PORT_CONSTRAINTS), ($clinit_PortConstraints() , FIXED_POS));
    $setProperty(dummy, ($clinit_InternalProperties() , ORIGIN), edge);
    dummyInputPort = new LPort;
    $setProperty(dummyInputPort, ORIGIN, edge.target);
    $setSide(dummyInputPort, ($clinit_PortSide() , WEST));
    $setNode(dummyInputPort, dummy);
    dummyOutputPort = new LPort;
    $setProperty(dummyOutputPort, ORIGIN, edge.source);
    $setSide(dummyOutputPort, EAST);
    $setNode(dummyOutputPort, dummy);
    $setProperty(edge.source, PORT_DUMMY, dummy);
    $setProperty(edge.target, PORT_DUMMY, dummy);
    $setSource(edge, null);
    $setTarget(edge, null);
    dummyNodes.array[dummyNodes.array.length] = dummy;
    $setProperty(dummy, CROSSING_HINT, valueOf_0(2));
  }
  for (port$iterator = $listIterator_2(ports, 0); port$iterator.currentNode != port$iterator.this$01.tail;) {
    port = castTo($next_11(port$iterator), 7);
    in_0 = port.incomingEdges.array.length > 0;
    out = port.outgoingEdges.array.length > 0;
    in_0 && out?(inOutPorts.array[inOutPorts.array.length] = port , true):in_0?(inPorts.array[inPorts.array.length] = port , true):out && (outPorts.array[outPorts.array.length] = port , true);
  }
  for (inPort$iterator = new ArrayList$1(inPorts); inPort$iterator.i < inPort$iterator.this$01.array.length;) {
    inPort = castTo($next_8(inPort$iterator), 7);
    $add_11(barycenterAssociates, $createDummyNode_0(layeredGraph, inPort, null, dummyNodes));
  }
  for (outPort$iterator = new ArrayList$1(outPorts); outPort$iterator.i < outPort$iterator.this$01.array.length;) {
    outPort = castTo($next_8(outPort$iterator), 7);
    $add_11(barycenterAssociates, $createDummyNode_0(layeredGraph, null, outPort, dummyNodes));
  }
  for (inOutPort$iterator = new ArrayList$1(inOutPorts); inOutPort$iterator.i < inOutPort$iterator.this$01.array.length;) {
    inOutPort = castTo($next_8(inOutPort$iterator), 7);
    $add_11(barycenterAssociates, $createDummyNode_0(layeredGraph, inOutPort, inOutPort, dummyNodes));
  }
}

function $createNorthSouthSelfLoopDummyNodes(layeredGraph, selfLoop, northDummyNodes, southDummyNodes, portSide){
  var northDummy, northDummyOutputPort, southDummy, southDummyInputPort;
  northDummy = new LNode(layeredGraph);
  $setType(northDummy, ($clinit_LNode$NodeType() , NORTH_SOUTH_PORT));
  $setProperty(northDummy, ($clinit_LayoutOptions() , PORT_CONSTRAINTS), ($clinit_PortConstraints() , FIXED_POS));
  $setProperty(northDummy, ($clinit_InternalProperties() , ORIGIN), selfLoop.source.owner);
  northDummyOutputPort = new LPort;
  $setProperty(northDummyOutputPort, ORIGIN, selfLoop.source);
  $setSide(northDummyOutputPort, portSide);
  $setNode(northDummyOutputPort, northDummy);
  $setProperty(selfLoop.source, PORT_DUMMY, northDummy);
  southDummy = new LNode(layeredGraph);
  $setType(southDummy, NORTH_SOUTH_PORT);
  $setProperty(southDummy, PORT_CONSTRAINTS, FIXED_POS);
  $setProperty(southDummy, ORIGIN, selfLoop.target.owner);
  southDummyInputPort = new LPort;
  $setProperty(southDummyInputPort, ORIGIN, selfLoop.target);
  $setSide(southDummyInputPort, portSide);
  $setNode(southDummyInputPort, southDummy);
  $setProperty(selfLoop.target, PORT_DUMMY, southDummy);
  $setSource(selfLoop, northDummyOutputPort);
  $setTarget(selfLoop, southDummyInputPort);
  checkCriticalPositionIndex(0, northDummyNodes.array.length);
  insertTo(northDummyNodes.array, 0, northDummy);
  southDummyNodes.array[southDummyNodes.array.length] = southDummy;
  $setProperty(northDummy, CROSSING_HINT, valueOf_0(1));
  $setProperty(southDummy, CROSSING_HINT, valueOf_0(1));
}

function $sortPortList(node){
  var inOutPorts, inPorts, incoming, outPorts, outgoing, port, port$iterator, ports;
  ports = node.ports.array.length;
  inPorts = 0;
  inOutPorts = ports;
  outPorts = 2 * ports;
  for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_8(port$iterator), 7);
    switch (port.side.ordinal) {
      case 2:
      case 4:
        port.id_0 = -1;
        break;
      case 1:
      case 3:
        incoming = port.incomingEdges.array.length;
        outgoing = port.outgoingEdges.array.length;
        incoming > 0 && outgoing > 0?(port.id_0 = inOutPorts++):incoming > 0?(port.id_0 = inPorts++):outgoing > 0?(port.id_0 = outPorts++):(port.id_0 = inPorts++);
    }
  }
  sort_1(node.ports, new NorthSouthPortPreprocessor$lambda$0$Type);
}

function NorthSouthPortPreprocessor(){
}

defineClass(501, 1, $intern_56, NorthSouthPortPreprocessor);
_.process = function process_32(layeredGraph, monitor){
  var barycenterAssociates, dummy, dummy$iterator, dummy$iterator0, dummyPort, insertPoint, layer, layer$iterator, node, node$index, node$max, nodeArray, northDummyNodes, originPort, pointer, port, port$iterator, portList, southDummyNodes;
  $begin(monitor, 'Odd port side processing', 1);
  northDummyNodes = new ArrayList;
  southDummyNodes = new ArrayList;
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator), 16);
    pointer = -1;
    nodeArray = castTo($toArray_1(layer.nodes, initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LNode_2_classLit, $intern_49, 9, layer.nodes.array.length, 0, 1)), 51);
    for (node$index = 0 , node$max = nodeArray.length; node$index < node$max; ++node$index) {
      node = nodeArray[node$index];
      ++pointer;
      if (!(node.type_0 == ($clinit_LNode$NodeType() , NORMAL) && $isSideFixed(castTo($getProperty(node, ($clinit_LayoutOptions() , PORT_CONSTRAINTS)), 28)))) {
        continue;
      }
      $isOrderFixed(castTo($getProperty(node, ($clinit_LayoutOptions() , PORT_CONSTRAINTS)), 28)) || $sortPortList(node);
      $setProperty(node, ($clinit_InternalProperties() , IN_LAYER_LAYOUT_UNIT), node);
      northDummyNodes.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
      southDummyNodes.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
      barycenterAssociates = new ArrayList;
      portList = new LinkedList;
      addAll_4(portList, $getPorts_0(node, ($clinit_PortSide() , NORTH)));
      $createDummyNodes(layeredGraph, portList, northDummyNodes, southDummyNodes, barycenterAssociates);
      insertPoint = pointer;
      for (dummy$iterator0 = new ArrayList$1(northDummyNodes); dummy$iterator0.i < dummy$iterator0.this$01.array.length;) {
        dummy = castTo($next_8(dummy$iterator0), 9);
        $setLayer(dummy, insertPoint, layer);
        ++pointer;
        $setProperty(dummy, IN_LAYER_LAYOUT_UNIT, node);
        dummyPort = castTo($get_8(dummy.ports, 0), 7);
        originPort = castTo($getProperty(dummyPort, ORIGIN), 7);
        unsafeCast(checkNotNull_1(castToBoolean($getProperty(originPort, ($clinit_Properties() , NORTH_OR_SOUTH_PORT))))) || castTo($getProperty(dummy, IN_LAYER_SUCCESSOR_CONSTRAINTS), 20).add_1(node);
      }
      $reset_0(portList);
      for (port$iterator = $getPorts_0(node, SOUTH).iterator_0(); port$iterator.hasNext_0();) {
        port = castTo(port$iterator.next_1(), 7);
        $addNode_0(portList, port, portList.header, portList.header.next_0);
      }
      $createDummyNodes(layeredGraph, portList, southDummyNodes, null, barycenterAssociates);
      for (dummy$iterator = new ArrayList$1(southDummyNodes); dummy$iterator.i < dummy$iterator.this$01.array.length;) {
        dummy = castTo($next_8(dummy$iterator), 9);
        $setLayer(dummy, ++pointer, layer);
        $setProperty(dummy, IN_LAYER_LAYOUT_UNIT, node);
        dummyPort = castTo($get_8(dummy.ports, 0), 7);
        originPort = castTo($getProperty(dummyPort, ORIGIN), 7);
        unsafeCast(checkNotNull_1(castToBoolean($getProperty(originPort, ($clinit_Properties() , NORTH_OR_SOUTH_PORT))))) || castTo($getProperty(node, IN_LAYER_SUCCESSOR_CONSTRAINTS), 20).add_1(dummy);
      }
      barycenterAssociates.array.length == 0 || $setProperty(node, BARYCENTER_ASSOCIATES, barycenterAssociates);
    }
  }
  $done(monitor);
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_NorthSouthPortPreprocessor_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'NorthSouthPortPreprocessor', 501);
function NorthSouthPortPreprocessor$lambda$0$Type(){
}

defineClass(502, 1, $intern_9, NorthSouthPortPreprocessor$lambda$0$Type);
_.compare_0 = function compare_21(arg0, arg1){
  var side1, side2;
  return side1 = arg0.side , side2 = arg1.side , side1 != side2?side1.ordinal - side2.ordinal:arg0.id_0 == arg1.id_0?0:side1 == ($clinit_PortSide() , NORTH)?arg0.id_0 - arg1.id_0:arg1.id_0 - arg0.id_0;
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_NorthSouthPortPreprocessor$lambda$0$Type_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'NorthSouthPortPreprocessor/lambda$0$Type', 502);
function PartitionPostprocessor(){
}

defineClass(504, 1, $intern_56, PartitionPostprocessor);
_.process = function process_33(lGraph, monitor){
  var layer, layer$iterator, node, node$iterator, port, ports;
  $begin(monitor, 'Removing partition constraint edges', 1);
  for (layer$iterator = new ArrayList$1(lGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator), 16);
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      ports = new ArrayList$1(node.ports);
      while (ports.i < ports.this$01.array.length) {
        port = castTo($next_8(ports), 7);
        unsafeCast(checkNotNull_1(castToBoolean($getProperty(port, ($clinit_InternalProperties() , PARTITION_DUMMY))))) && $remove_12(ports);
      }
    }
  }
  $done(monitor);
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_PartitionPostprocessor_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'PartitionPostprocessor', 504);
function $retrievePartition(this$static, index_0){
  while (index_0 >= this$static.partitions.array.length) {
    $add_11(this$static.partitions, new LinkedList);
  }
  return castTo($get_8(this$static.partitions, index_0), 20);
}

function PartitionPreprocessor(){
}

defineClass(505, 1, $intern_56, PartitionPreprocessor);
_.process = function process_34(lGraph, monitor){
  var edge, i, index_0, node, node$iterator, node$iterator0, otherNode, otherNode$iterator, sourcePort, targetPort;
  $begin(monitor, 'Adding partition constraint edges', 1);
  this.partitions = new ArrayList;
  for (node$iterator0 = new ArrayList$1(lGraph.layerlessNodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
    node = castTo($next_8(node$iterator0), 9);
    index_0 = castTo($getProperty(node, ($clinit_LayoutOptions() , PARTITION)), 24);
    $retrievePartition(this, index_0.value_0).add_1(node);
  }
  for (i = 0; i < this.partitions.array.length - 1; i++) {
    for (node$iterator = castTo($get_8(this.partitions, i), 20).iterator_0(); node$iterator.hasNext_0();) {
      node = castTo(node$iterator.next_1(), 9);
      sourcePort = new LPort;
      $setNode(sourcePort, node);
      $setSide(sourcePort, ($clinit_PortSide() , EAST));
      $setProperty(sourcePort, ($clinit_InternalProperties() , PARTITION_DUMMY), ($clinit_Boolean() , $clinit_Boolean() , TRUE_0));
      for (otherNode$iterator = castTo($get_8(this.partitions, i + 1), 20).iterator_0(); otherNode$iterator.hasNext_0();) {
        otherNode = castTo(otherNode$iterator.next_1(), 9);
        targetPort = new LPort;
        $setNode(targetPort, otherNode);
        $setSide(targetPort, WEST);
        $setProperty(targetPort, PARTITION_DUMMY, (null , TRUE_0));
        edge = new LEdge;
        $setProperty(edge, PARTITION_DUMMY, (null , TRUE_0));
        $setProperty(edge, ($clinit_LayoutOptions() , PRIORITY), valueOf_0(20));
        $setSource(edge, sourcePort);
        $setTarget(edge, targetPort);
      }
    }
  }
  this.partitions = null;
  $done(monitor);
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_PartitionPreprocessor_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'PartitionPreprocessor', 505);
function $switchPortSides(layer){
  var dummyPort, dummyPorts, node, node$iterator, origin, originalPort;
  for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 9);
    if (node.type_0 == ($clinit_LNode$NodeType() , NORTH_SOUTH_PORT)) {
      origin = castTo($getProperty(node, ($clinit_InternalProperties() , IN_LAYER_LAYOUT_UNIT)), 9);
      dummyPorts = node.ports;
      dummyPort = (checkCriticalElementIndex(0, dummyPorts.array.length) , castTo(dummyPorts.array[0], 7));
      originalPort = castTo($getProperty(dummyPort, ORIGIN), 7);
      originalPort.side == ($clinit_PortSide() , NORTH) && node.id_0 > origin.id_0?$setSide(originalPort, SOUTH):originalPort.side == SOUTH && origin.id_0 > node.id_0 && $setSide(originalPort, NORTH);
    }
  }
}

function PortDistributionProcessor(){
}

defineClass(506, 1, $intern_56, PortDistributionProcessor);
_.process = function process_35(layeredGraph, progressMonitor){
  var graphArray, layer, layer$index, layer$iterator, layer$max, node, node$index, node$max, nodeCount, port, port$iterator, portCount, portDistributor, random;
  $begin(progressMonitor, 'Port distribution', 1);
  graphArray = $toNodeArray(layeredGraph);
  portCount = 0;
  nodeCount = 0;
  for (layer$index = 0 , layer$max = graphArray.length; layer$index < layer$max; ++layer$index) {
    layer = graphArray[layer$index];
    for (node$index = 0 , node$max = layer.length; node$index < node$max; ++node$index) {
      node = layer[node$index];
      node.id_0 = nodeCount++;
      for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
        port = castTo($next_8(port$iterator), 7);
        port.id_0 = portCount++;
      }
    }
  }
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator), 16);
    $switchPortSides(layer);
  }
  random = castTo($getProperty(layeredGraph, ($clinit_InternalProperties() , RANDOM)), 154);
  portDistributor = $nextInternal(random, 1) != 0?new NodeRelativePortDistributor(initUnidimensionalArray(F_classLit, $intern_61, 26, portCount, 12, 1)):new LayerTotalPortDistributor(initUnidimensionalArray(F_classLit, $intern_61, 26, portCount, 12, 1));
  $distributePorts_0(portDistributor, graphArray);
  $done(progressMonitor);
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_PortDistributionProcessor_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'PortDistributionProcessor', 506);
function PortListSorter(){
}

defineClass(507, 1, $intern_56, PortListSorter);
_.process = function process_36(layeredGraph, monitor){
  var layer, layer$iterator, node, node$iterator, portComparator;
  $begin(monitor, 'Port order processing', 1);
  portComparator = new PortListSorter$PortComparator;
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator), 16);
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      $isSideFixed(castTo($getProperty(node, ($clinit_LayoutOptions() , PORT_CONSTRAINTS)), 28)) && sort_1(node.ports, portComparator);
    }
  }
  $done(monitor);
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_PortListSorter_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'PortListSorter', 507);
function $compare_9(port1, port2){
  var index1, index2, indexDifference, ordinalDifference, port1Constraint;
  port1Constraint = castTo($getProperty(port1.owner, ($clinit_LayoutOptions() , PORT_CONSTRAINTS)), 28);
  ordinalDifference = port1.side.ordinal - port2.side.ordinal;
  if (ordinalDifference != 0 || port1Constraint == ($clinit_PortConstraints() , FIXED_SIDE)) {
    return ordinalDifference;
  }
  if (port1Constraint == ($clinit_PortConstraints() , FIXED_ORDER)) {
    index1 = castTo($getProperty(port1, PORT_INDEX), 24);
    index2 = castTo($getProperty(port2, PORT_INDEX), 24);
    if (!!index1 && !!index2) {
      indexDifference = index1.value_0 - index2.value_0;
      if (indexDifference != 0) {
        return indexDifference;
      }
    }
  }
  switch (port1.side.ordinal) {
    case 1:
      return compare_31(port1.pos.x_0, port2.pos.x_0);
    case 2:
      return compare_31(port1.pos.y_0, port2.pos.y_0);
    case 3:
      return compare_31(port2.pos.x_0, port1.pos.x_0);
    case 4:
      return compare_31(port2.pos.y_0, port1.pos.y_0);
    default:throw new IllegalStateException_0('Port side is undefined');
  }
}

function PortListSorter$PortComparator(){
}

defineClass(508, 1, $intern_9, PortListSorter$PortComparator);
_.compare_0 = function compare_22(port1, port2){
  return $compare_9(castTo(port1, 7), castTo(port2, 7));
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_PortListSorter$PortComparator_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'PortListSorter/PortComparator', 508);
function $process_6(node){
  var port, port$iterator;
  if ($isSideFixed(castTo($getProperty(node, ($clinit_LayoutOptions() , PORT_CONSTRAINTS)), 28))) {
    for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_8(port$iterator), 7);
      port.side == ($clinit_PortSide() , UNDEFINED_4) && setPortSide(port);
    }
  }
   else {
    for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_8(port$iterator), 7);
      setPortSide(port);
    }
    $setProperty(node, PORT_CONSTRAINTS, ($clinit_PortConstraints() , FIXED_SIDE));
  }
}

function PortSideProcessor(){
}

function setPortSide(port){
  if (port.incomingEdges.array.length - port.outgoingEdges.array.length < 0) {
    $setSide(port, ($clinit_PortSide() , EAST));
    port.anchor.x_0 = port.size_0.x_0;
  }
   else {
    $setSide(port, ($clinit_PortSide() , WEST));
    port.anchor.x_0 = 0;
  }
}

defineClass(509, 1, $intern_56, PortSideProcessor);
_.process = function process_37(layeredGraph, monitor){
  var layer, layer$iterator, node, node$iterator, node$iterator0;
  $begin(monitor, 'Port side processing', 1);
  for (node$iterator0 = new ArrayList$1(layeredGraph.layerlessNodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
    node = castTo($next_8(node$iterator0), 9);
    $process_6(node);
  }
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator), 16);
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      $process_6(node);
    }
  }
  $done(monitor);
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_PortSideProcessor_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'PortSideProcessor', 509);
function ReversedEdgeRestorer(){
}

defineClass(510, 1, $intern_56, ReversedEdgeRestorer);
_.process = function process_38(layeredGraph, monitor){
  var edge, edge$index, edge$max, edgeArray, layer, layer$iterator, node, node$iterator, port, port$iterator;
  $begin(monitor, 'Restoring reversed edges', 1);
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator), 16);
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
        port = castTo($next_8(port$iterator), 7);
        edgeArray = castTo($toArray_1(port.outgoingEdges, initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LEdge_2_classLit, $intern_57, 12, port.outgoingEdges.array.length, 0, 1)), 47);
        for (edge$index = 0 , edge$max = edgeArray.length; edge$index < edge$max; ++edge$index) {
          edge = edgeArray[edge$index];
          unsafeCast(checkNotNull_1(castToBoolean($getProperty(edge, ($clinit_InternalProperties() , REVERSED))))) && $reverse_0(edge, false);
        }
      }
    }
  }
  $done(monitor);
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_ReversedEdgeRestorer_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'ReversedEdgeRestorer', 510);
function $createWestPortSideDummies_0(layeredGraph, westwardPort, edge, layerNodeList){
  var dummy, dummyEdge, dummyInput, dummyOutput, originalTarget, sourcePort, sourceNode, sourceNodeType, targetPort, targetNode, targetNodeType;
  if (edge.target.owner == westwardPort.owner) {
    return;
  }
  dummy = new LNode(layeredGraph);
  $setType(dummy, ($clinit_LNode$NodeType() , LONG_EDGE));
  $setProperty(dummy, ($clinit_InternalProperties() , ORIGIN), edge);
  $setProperty(dummy, ($clinit_LayoutOptions() , PORT_CONSTRAINTS), ($clinit_PortConstraints() , FIXED_POS));
  layerNodeList.array[layerNodeList.array.length] = dummy;
  dummyInput = new LPort;
  $setNode(dummyInput, dummy);
  $setSide(dummyInput, ($clinit_PortSide() , WEST));
  dummyOutput = new LPort;
  $setNode(dummyOutput, dummy);
  $setSide(dummyOutput, EAST);
  originalTarget = edge.target;
  $setTarget(edge, dummyInput);
  dummyEdge = new LEdge;
  $copyProperties(dummyEdge, edge);
  $setProperty(dummyEdge, JUNCTION_POINTS, null);
  $setSource(dummyEdge, dummyOutput);
  $setTarget(dummyEdge, originalTarget);
  sourcePort = castTo($get_8(dummyInput.incomingEdges, 0), 12).source;
  sourceNode = sourcePort.owner;
  sourceNodeType = sourceNode.type_0;
  targetPort = castTo($get_8(dummyOutput.outgoingEdges, 0), 12).target;
  targetNode = targetPort.owner;
  targetNodeType = targetNode.type_0;
  sourceNodeType == LONG_EDGE?$setProperty(dummy, LONG_EDGE_SOURCE, castTo($getProperty(sourceNode, LONG_EDGE_SOURCE), 7)):$setProperty(dummy, LONG_EDGE_SOURCE, sourcePort);
  targetNodeType == LONG_EDGE?$setProperty(dummy, LONG_EDGE_TARGET, castTo($getProperty(targetNode, LONG_EDGE_TARGET), 7)):$setProperty(dummy, LONG_EDGE_TARGET, targetPort);
}

function $determineMaximalHeight(this$static, graph){
  var l, l$iterator, lH, maxH, n, n$iterator;
  maxH = 0;
  for (l$iterator = new ArrayList$1(graph.layers); l$iterator.i < l$iterator.this$01.array.length;) {
    l = castTo($next_8(l$iterator), 16);
    lH = 0;
    for (n$iterator = new ArrayList$1(l.nodes); n$iterator.i < n$iterator.this$01.array.length;) {
      n = castTo($next_8(n$iterator), 9);
      lH += n.size_0.y_0 + n.margin.bottom + n.margin.top_0 + this$static.inLayerSpacing;
    }
    lH -= this$static.inLayerSpacing;
    maxH = maxH > lH?maxH:lH;
  }
  return maxH;
}

function $determineMaximalWidth(this$static, graph){
  var l, l$iterator, maxW, n, n$iterator, nW;
  maxW = 0;
  for (l$iterator = new ArrayList$1(graph.layers); l$iterator.i < l$iterator.this$01.array.length;) {
    l = castTo($next_8(l$iterator), 16);
    for (n$iterator = new ArrayList$1(l.nodes); n$iterator.i < n$iterator.this$01.array.length;) {
      n = castTo($next_8(n$iterator), 9);
      nW = n.size_0.x_0 + n.margin.right + n.margin.left + this$static.spacing;
      maxW = maxW > nW?maxW:nW;
    }
  }
  return maxW;
}

function $insertDummies(layeredGraph, originalEdge){
  var dummyEdge, dummyInput, dummyNode, dummyOutput, edge, i, nextLayer, portPos, src_0, srcIndex, targetPort, tgt, tgtIndex, thickness;
  edge = originalEdge;
  targetPort = originalEdge.target;
  src_0 = originalEdge.source.owner;
  tgt = originalEdge.target.owner;
  srcIndex = $getIndex_0(src_0.layer);
  tgtIndex = $getIndex_0(tgt.layer);
  for (i = srcIndex; i < tgtIndex; i++) {
    dummyNode = new LNode(layeredGraph);
    $setType(dummyNode, ($clinit_LNode$NodeType() , LONG_EDGE));
    $setProperty(dummyNode, ($clinit_InternalProperties() , ORIGIN), edge);
    $setProperty(dummyNode, ($clinit_LayoutOptions() , PORT_CONSTRAINTS), ($clinit_PortConstraints() , FIXED_POS));
    nextLayer = castTo($get_8(layeredGraph.layers, i + 1), 16);
    $setLayer_0(dummyNode, nextLayer);
    thickness = castTo($getProperty(edge, THICKNESS), 15).value_0;
    if (thickness < 0) {
      thickness = 0;
      $setProperty(edge, THICKNESS, new Float_0(thickness));
    }
    dummyNode.size_0.y_0 = thickness;
    portPos = Math.floor(thickness / 2);
    dummyInput = new LPort;
    $setSide(dummyInput, ($clinit_PortSide() , WEST));
    $setNode(dummyInput, dummyNode);
    dummyInput.pos.y_0 = portPos;
    dummyOutput = new LPort;
    $setSide(dummyOutput, EAST);
    $setNode(dummyOutput, dummyNode);
    dummyOutput.pos.y_0 = portPos;
    $setTarget(edge, dummyInput);
    dummyEdge = new LEdge;
    $copyProperties(dummyEdge, edge);
    $setProperty(dummyEdge, JUNCTION_POINTS, null);
    $setSource(dummyEdge, dummyOutput);
    $setTarget(dummyEdge, targetPort);
    $setDummyProperties(dummyNode, edge, dummyEdge);
    edge = dummyEdge;
  }
}

function $setDummyProperties(dummy, inEdge, outEdge){
  var inEdgeSourceNode;
  inEdgeSourceNode = inEdge.source.owner;
  if (inEdgeSourceNode.type_0 == ($clinit_LNode$NodeType() , LONG_EDGE)) {
    $setProperty(dummy, ($clinit_InternalProperties() , LONG_EDGE_SOURCE), castTo($getProperty(inEdgeSourceNode, LONG_EDGE_SOURCE), 7));
    $setProperty(dummy, LONG_EDGE_TARGET, castTo($getProperty(inEdgeSourceNode, LONG_EDGE_TARGET), 7));
  }
   else {
    $setProperty(dummy, ($clinit_InternalProperties() , LONG_EDGE_SOURCE), inEdge.source);
    $setProperty(dummy, LONG_EDGE_TARGET, outEdge.target);
  }
}

function SausageFolding(){
}

defineClass(511, 1, $intern_56, SausageFolding);
_.process = function process_39(graph, progressMonitor){
  var currentAR, desiredAR, dir_0, dist, e, e$iterator, foo, index_0, it, l, lastDist, longestPath, maxHeight, maxWidth, n, n$iterator, n1, n2, newIndex, newLayer, no, no$iterator, nodesPerRow, reversalAllowed, rows_0, src_0, sumWidth, tgt, tgt$iterator, wannaRevert;
  $begin(progressMonitor, 'Sausage Folding', 1);
  this.spacing = castTo($getProperty(graph, ($clinit_InternalProperties() , SPACING_0)), 15).value_0;
  this.inLayerSpacing = this.spacing * castTo($getProperty(graph, ($clinit_Properties() , OBJ_SPACING_IN_LAYER_FACTOR)), 15).value_0;
  maxHeight = $determineMaximalHeight(this, graph);
  longestPath = graph.layers.array.length;
  maxWidth = $determineMaximalWidth(this, graph);
  sumWidth = longestPath * maxWidth;
  dir_0 = castTo($getProperty(graph, ($clinit_LayoutOptions() , DIRECTION)), 59);
  dir_0 == ($clinit_Direction() , LEFT_0) || dir_0 == RIGHT_0 || dir_0 == UNDEFINED?(desiredAR = castTo($getProperty(graph, ASPECT_RATIO_0), 15).value_0):(desiredAR = 1 / castTo($getProperty(graph, ASPECT_RATIO_0), 15).value_0);
  currentAR = sumWidth / maxHeight;
  if (desiredAR > currentAR) {
    $done(progressMonitor);
    return;
  }
  rows_0 = 0;
  dist = $intern_60;
  do {
    ++rows_0;
    currentAR = sumWidth / rows_0 / (maxHeight * rows_0);
    lastDist = dist;
    dist = currentAR - desiredAR <= 0?0 - (currentAR - desiredAR):currentAR - desiredAR;
  }
   while (currentAR > desiredAR);
  lastDist < dist && --rows_0;
  nodesPerRow = longestPath / (1 > rows_0?1:rows_0) | 0;
  index_0 = nodesPerRow;
  newIndex = nodesPerRow;
  wannaRevert = true;
  while (index_0 < longestPath) {
    l = castTo($get_8(graph.layers, index_0), 16);
    reversalAllowed = true;
    n1 = null;
    n2 = null;
    check: for (tgt$iterator = new ArrayList$1(l.nodes); tgt$iterator.i < tgt$iterator.this$01.array.length;) {
      tgt = castTo($next_8(tgt$iterator), 9);
      for (e$iterator = $iterator($getIncomingEdges_0(tgt)); $hasNext_0(e$iterator);) {
        e = castTo($next_2(e$iterator), 12);
        if (!!n1 && n1 != tgt) {
          reversalAllowed = false;
          break check;
        }
        n1 = tgt;
        src_0 = e.source.owner;
        if (!!n2 && n2 != src_0) {
          reversalAllowed = false;
          break check;
        }
        n2 = src_0;
      }
    }
    if (wannaRevert && reversalAllowed) {
      newIndex = 0;
      wannaRevert = false;
    }
    if (index_0 != newIndex) {
      newLayer = castTo($get_8(graph.layers, newIndex), 16);
      for (n$iterator = new ArrayList$1(newArrayList(l.nodes)); n$iterator.i < n$iterator.this$01.array.length;) {
        n = castTo($next_8(n$iterator), 9);
        $setLayer(n, newLayer.nodes.array.length, newLayer);
        if (newIndex == 0) {
          for (e$iterator = new ArrayList$1(newArrayList($getIncomingEdges_0(n))); e$iterator.i < e$iterator.this$01.array.length;) {
            e = castTo($next_8(e$iterator), 12);
            $reverse_0(e, true);
            $setProperty(graph, CYCLIC, ($clinit_Boolean() , $clinit_Boolean() , TRUE_0));
            $insertDummies(graph, e);
            foo = new ArrayList;
            $createWestPortSideDummies_0(graph, e.source, e, foo);
            for (no$iterator = new ArrayList$1(foo); no$iterator.i < no$iterator.this$01.array.length;) {
              no = castTo($next_8(no$iterator), 9);
              $setLayer(no, newLayer.nodes.array.length - 1, newLayer);
            }
          }
        }
      }
    }
    newIndex >= nodesPerRow && (wannaRevert = true);
    ++newIndex;
    ++index_0;
  }
  it = new AbstractList$ListIteratorImpl(graph.layers, 0);
  while (it.i < it.this$01_0.size_1()) {
    l = (checkCriticalElement(it.i < it.this$01_0.size_1()) , castTo(it.this$01_0.get_2(it.last = it.i++), 16));
    l.nodes.array.length == 0 && $remove_11(it);
  }
  $done(progressMonitor);
}
;
_.inLayerSpacing = 0;
_.spacing = 0;
var Lde_cau_cs_kieler_klay_layered_intermediate_SausageFolding_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'SausageFolding', 511);
function $createDummy_0(layeredGraph, edge, sourcePort, targetPort){
  var dummyEdge, dummyInput, dummyNode, dummyOutput;
  dummyNode = new LNode(layeredGraph);
  $setType(dummyNode, ($clinit_LNode$NodeType() , LONG_EDGE));
  $setProperty(dummyNode, ($clinit_InternalProperties() , ORIGIN), edge);
  $setProperty(dummyNode, ($clinit_LayoutOptions() , PORT_CONSTRAINTS), ($clinit_PortConstraints() , FIXED_POS));
  $setProperty(dummyNode, LONG_EDGE_SOURCE, sourcePort);
  $setProperty(dummyNode, LONG_EDGE_TARGET, targetPort);
  dummyInput = new LPort;
  $setSide(dummyInput, ($clinit_PortSide() , WEST));
  $setNode(dummyInput, dummyNode);
  dummyOutput = new LPort;
  $setSide(dummyOutput, EAST);
  $setNode(dummyOutput, dummyNode);
  $setTarget(edge, dummyInput);
  dummyEdge = new LEdge;
  $copyProperties(dummyEdge, edge);
  $setProperty(dummyEdge, JUNCTION_POINTS, null);
  $setSource(dummyEdge, dummyOutput);
  $setTarget(dummyEdge, targetPort);
  return dummyNode;
}

function SelfLoopProcessor(){
}

defineClass(512, 1, $intern_56, SelfLoopProcessor);
_.process = function process_40(layeredGraph, monitor){
  var createdDummies, dummy, dummy$iterator, edge, edge$index, edge$max, edges, layer, layer$iterator, node, node$iterator, port, port$iterator, sourcePort, sourcePortSide, targetPort, targetPortSide;
  $begin(monitor, 'Self-loop processing', 1);
  createdDummies = new ArrayList;
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator), 16);
    createdDummies.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
        port = castTo($next_8(port$iterator), 7);
        edges = castTo($toArray_1(port.outgoingEdges, initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LEdge_2_classLit, $intern_57, 12, port.outgoingEdges.array.length, 0, 1)), 47);
        for (edge$index = 0 , edge$max = edges.length; edge$index < edge$max; ++edge$index) {
          edge = edges[edge$index];
          if (edge.source.owner != edge.target.owner) {
            continue;
          }
          sourcePort = edge.source;
          targetPort = edge.target;
          sourcePortSide = sourcePort.side;
          targetPortSide = targetPort.side;
          (sourcePortSide == ($clinit_PortSide() , NORTH) || sourcePortSide == SOUTH) && targetPortSide == WEST?$reverse_0(edge, false):sourcePortSide == SOUTH && targetPortSide == NORTH?$reverse_0(edge, false):sourcePortSide == EAST && targetPortSide != EAST && $reverse_0(edge, false);
          sourcePortSide == EAST && targetPortSide == WEST?$add_11(createdDummies, $createDummy_0(layeredGraph, edge, targetPort, sourcePort)):sourcePortSide == WEST && targetPortSide == EAST && $add_11(createdDummies, $createDummy_0(layeredGraph, edge, sourcePort, targetPort));
        }
      }
    }
    for (dummy$iterator = new ArrayList$1(createdDummies); dummy$iterator.i < dummy$iterator.this$01.array.length;) {
      dummy = castTo($next_8(dummy$iterator), 9);
      $setLayer_0(dummy, layer);
    }
  }
  $done(monitor);
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_SelfLoopProcessor_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'SelfLoopProcessor', 512);
function $addComponentWithNonLoopEdges(component){
  var edgeWithHiddenPort, edgeWithHiddenPort$iterator, hiddenPort, hiddenPorts, node, nodePortIter, portOnNode, portWithSide, portsWithSideIter;
  node = component.owner;
  hiddenPorts = newHashSet($getHidablePorts(component));
  portsWithSideIter = $listIterator_2(newLinkedList(component.portsWithNonLoopEdge), 0);
  while (portsWithSideIter.currentNode != portsWithSideIter.this$01.tail) {
    portWithSide = castTo($next_11(portsWithSideIter), 7);
    if (portWithSide.outgoingEdges.array.length == 0) {
      for (edgeWithHiddenPort$iterator = new ArrayList$1(portWithSide.incomingEdges); edgeWithHiddenPort$iterator.i < edgeWithHiddenPort$iterator.this$01.array.length;) {
        edgeWithHiddenPort = castTo($next_8(edgeWithHiddenPort$iterator), 12);
        hiddenPort = edgeWithHiddenPort.source;
        if (hiddenPorts.map_0.containsKey(hiddenPort)) {
          nodePortIter = new AbstractList$ListIteratorImpl(node.ports, 0);
          portOnNode = (checkCriticalElement(nodePortIter.i < nodePortIter.this$01_0.size_1()) , castTo(nodePortIter.this$01_0.get_2(nodePortIter.last = nodePortIter.i++), 7));
          while (portOnNode != portWithSide) {
            portOnNode = (checkCriticalElement(nodePortIter.i < nodePortIter.this$01_0.size_1()) , castTo(nodePortIter.this$01_0.get_2(nodePortIter.last = nodePortIter.i++), 7));
          }
          $add_15(nodePortIter, hiddenPort);
          $add_19(portsWithSideIter, hiddenPort);
          setSideOfPort(hiddenPort, portWithSide.side);
          $previous_2(portsWithSideIter);
          $previous_2(portsWithSideIter);
          hiddenPorts.map_0.remove_0(hiddenPort) != null;
        }
      }
    }
     else {
      for (edgeWithHiddenPort$iterator = new ArrayList$1(portWithSide.outgoingEdges); edgeWithHiddenPort$iterator.i < edgeWithHiddenPort$iterator.this$01.array.length;) {
        edgeWithHiddenPort = castTo($next_8(edgeWithHiddenPort$iterator), 12);
        hiddenPort = edgeWithHiddenPort.target;
        if (hiddenPorts.map_0.containsKey(hiddenPort)) {
          nodePortIter = new AbstractList$ListIteratorImpl(node.ports, 0);
          portOnNode = (checkCriticalElement(nodePortIter.i < nodePortIter.this$01_0.size_1()) , castTo(nodePortIter.this$01_0.get_2(nodePortIter.last = nodePortIter.i++), 7));
          while (portOnNode != portWithSide) {
            portOnNode = (checkCriticalElement(nodePortIter.i < nodePortIter.this$01_0.size_1()) , castTo(nodePortIter.this$01_0.get_2(nodePortIter.last = nodePortIter.i++), 7));
          }
          checkCriticalElement(nodePortIter.i > 0);
          nodePortIter.this$01.get_2(nodePortIter.last = --nodePortIter.i);
          $add_15(nodePortIter, hiddenPort);
          $add_19(portsWithSideIter, hiddenPort);
          setSideOfPort(hiddenPort, portWithSide.side);
          $previous_2(portsWithSideIter);
          $previous_2(portsWithSideIter);
          hiddenPorts.map_0.remove_0(hiddenPort) != null;
        }
      }
    }
  }
}

function $findNextSide(startSide, itr){
  var currentSide;
  currentSide = startSide;
  while (itr.i < itr.this$01_0.size_1() && currentSide == startSide) {
    currentSide = (checkCriticalElement(itr.i < itr.this$01_0.size_1()) , castTo(itr.this$01_0.get_2(itr.last = itr.i++), 7)).side;
  }
  currentSide == startSide || (checkCriticalElement(itr.i > 0) , itr.this$01.get_2(itr.last = --itr.i));
}

function $portLinedPositioning(components){
  var itr, node;
  if (components.isEmpty()) {
    return;
  }
  node = castTo(components.get_2(0), 75).owner;
  new SplineSelfLoopPositioner$PortReadder(components);
  itr = new AbstractList$ListIteratorImpl(node.ports, 0);
  $addSourcePortsReversed(($clinit_LoopSide() , NW), itr);
  $addTargetPorts(SWN, itr);
  $findNextSide(($clinit_PortSide() , NORTH), itr);
  $addInlineTargetsFirst(N, itr);
  $addTargetPorts(SEN, itr);
  $addAllPorts(EN, itr);
  $addSourcePortsReversed(ENW, itr);
  $findNextSide(EAST, itr);
  $addInlineTargetsFirst(E_0, itr);
  $addSourcePortsReversed(ESW, itr);
  $addAllPorts(SE, itr);
  $addSourcePortsReversed(SEN, itr);
  $findNextSide(SOUTH, itr);
  $addInlineTargetsFirst(S, itr);
  $addSourcePortsReversed(SWN, itr);
  $addAllPorts(WS, itr);
  $addTargetPorts(ESW, itr);
  while (itr.i < itr.this$01_0.size_1()) {
    checkCriticalElement(itr.i < itr.this$01_0.size_1());
    itr.this$01_0.get_2(itr.last = itr.i++);
  }
  $addInlineTargetsFirst(W, itr);
  $addTargetPorts(ENW, itr);
  $addTargetPorts(NW, itr);
}

function $portStackedPositioning(components){
  var itr, node;
  if (components.isEmpty()) {
    return;
  }
  node = castTo(components.get_2(0), 75).owner;
  new SplineSelfLoopPositioner$PortReadder(components);
  itr = new AbstractList$ListIteratorImpl(node.ports, 0);
  $addSourcePortsReversed(($clinit_LoopSide() , NW), itr);
  $addTargetPorts(SWN, itr);
  $findNextSide(($clinit_PortSide() , NORTH), itr);
  $addAllPorts(N, itr);
  $addTargetPorts(SEN, itr);
  $addAllPorts(EN, itr);
  $addSourcePortsReversed(ENW, itr);
  $findNextSide(EAST, itr);
  $addAllPorts(E_0, itr);
  $addSourcePortsReversed(ESW, itr);
  $addAllPorts(SE, itr);
  $addSourcePortsReversed(SEN, itr);
  $findNextSide(SOUTH, itr);
  $addAllPorts(S, itr);
  $addSourcePortsReversed(SWN, itr);
  $addAllPorts(WS, itr);
  $addTargetPorts(ESW, itr);
  while (itr.i < itr.this$01_0.size_1()) {
    checkCriticalElement(itr.i < itr.this$01_0.size_1());
    itr.this$01_0.get_2(itr.last = itr.i++);
  }
  $addAllPorts(W, itr);
  $addTargetPorts(ENW, itr);
  $addTargetPorts(NW, itr);
}

function $setPortSideByConstraint(component){
  var all, edge, iter, loopSidesInComponent, side, side0, sourceSide, targetSide;
  iter = cycle(newArrayList(component.edges));
  loopSidesInComponent = (all = castTo($getEnumConstants(Lde_cau_cs_kieler_klay_layered_p5edges_splines_LoopSide_2_classLit), 11) , new EnumSet$EnumSetImpl(all, castTo(createFrom(all, all.length), 11), 0));
  while (iter.iterator.hasNext_0() || iter.val$iterable1.iterator_0().hasNext_0()) {
    edge = castTo($next_0(iter), 12);
    sourceSide = edge.source.side;
    targetSide = edge.target.side;
    if (sourceSide == ($clinit_PortSide() , UNDEFINED_4)) {
      if (targetSide != UNDEFINED_4) {
        side0 = fromPortSides(targetSide);
        $setProperty(edge, ($clinit_InternalProperties() , SPLINE_LOOPSIDE), side0);
        $setSide(edge.source, targetSide);
        $add_17(loopSidesInComponent, side0);
        iter.iterator.remove();
      }
    }
     else {
      if (targetSide == UNDEFINED_4) {
        side0 = fromPortSides(sourceSide);
        $setProperty(edge, ($clinit_InternalProperties() , SPLINE_LOOPSIDE), side0);
        $setSide(edge.target, sourceSide);
        $add_17(loopSidesInComponent, side0);
        iter.iterator.remove();
      }
       else {
        side0 = fromPortSide(sourceSide, targetSide);
        $setProperty(edge, ($clinit_InternalProperties() , SPLINE_LOOPSIDE), side0);
        $add_17(loopSidesInComponent, side0);
        iter.iterator.remove();
      }
    }
  }
  loopSidesInComponent.size_0 == 1?(side = castTo($next_9(new EnumSet$EnumSetImpl$IteratorImpl(loopSidesInComponent)), 60)):(side = ($clinit_LoopSide() , UNDEFINED_6));
  $setLoopSide(component, side, false);
  return side;
}

function SplineSelfLoopPositioner(){
}

function setSideOfPort(port, side){
  switch (side.ordinal) {
    case 2:
      $setSide(port, ($clinit_PortSide() , EAST));
      port.anchor.x_0 = port.size_0.x_0;
      port.anchor.y_0 = port.size_0.y_0 / 2;
      break;
    case 4:
      $setSide(port, ($clinit_PortSide() , WEST));
      port.anchor.x_0 = 0;
      port.anchor.y_0 = port.size_0.y_0 / 2;
      break;
    case 1:
      $setSide(port, ($clinit_PortSide() , NORTH));
      port.anchor.x_0 = port.size_0.x_0 / 2;
      port.anchor.y_0 = 0;
      break;
    case 3:
      $setSide(port, ($clinit_PortSide() , SOUTH));
      port.anchor.x_0 = port.size_0.x_0 / 2;
      port.anchor.y_0 = port.size_0.y_0;
  }
}

function setSideOfPorts(ports, side){
  var port, port$iterator;
  for (port$iterator = new ArrayList$1(ports); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_8(port$iterator), 7);
    setSideOfPort(port, side);
  }
}

defineClass(513, 1, $intern_56, SplineSelfLoopPositioner);
_.process = function process_41(layeredGraph, monitor){
  var component, component$iterator, component$iterator0, component$iterator1, components, componentsToBePlaced, layer, layer$iterator, loopPlacement, node, node$iterator, constrainedPorts, loopSideCalculator;
  $begin(monitor, 'Spline SelfLoop positioning', 1);
  loopPlacement = castTo($getProperty(layeredGraph, ($clinit_Properties() , SPLINE_SELF_LOOP_PLACEMENT)), 153);
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator), 16);
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      components = castTo($getProperty(node, ($clinit_InternalProperties() , SPLINE_SELFLOOP_COMPONENTS)), 20);
      componentsToBePlaced = new ArrayList;
      for (component$iterator0 = components.iterator_0(); component$iterator0.hasNext_0();) {
        component = castTo(component$iterator0.next_1(), 75);
        $unhideEdges(component);
        if ((constrainedPorts = newHashSet(component.portsWithNonLoopEdge) , $addAll(constrainedPorts, component.portsWithPortSide) , constrainedPorts).map_0.size_1() == 0) {
          componentsToBePlaced.array[componentsToBePlaced.array.length] = component;
        }
         else {
          $setPortSideByConstraint(component);
          component.portsWithNonLoopEdge.map_0.size_1() == 0 || $addComponentWithNonLoopEdges(component);
        }
      }
      switch (loopPlacement.ordinal) {
        case 0:
          loopSideCalculator = new SplineSelfLoopPositioner$DistributedLoopSidesCalculator(node);
          $removeOccupiedSides(loopSideCalculator);
          $calculate(loopSideCalculator, componentsToBePlaced);
          break;
        case 2:
          for (component$iterator1 = new ArrayList$1(componentsToBePlaced); component$iterator1.i < component$iterator1.this$01.array.length;) {
            component = castTo($next_8(component$iterator1), 75);
            $setLoopSide(component, ($clinit_LoopSide() , N), true);
          }

          break;
        case 1:
          for (component$iterator = new ArrayList$1(componentsToBePlaced); component$iterator.i < component$iterator.this$01.array.length;) {
            component = castTo($next_8(component$iterator), 75);
            $setLoopSide(component, ($clinit_LoopSide() , N), true);
          }

      }
      switch (loopPlacement.ordinal) {
        case 0:
        case 1:
          $portStackedPositioning(components);
          break;
        case 2:
          $portLinedPositioning(components);
      }
    }
  }
  $done(monitor);
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_SplineSelfLoopPositioner_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'SplineSelfLoopPositioner', 513);
function $assignAcrossSide(this$static, components){
  var component, component$iterator, side;
  for (component$iterator = new ArrayList$1(components); component$iterator.i < component$iterator.this$01.array.length;) {
    component = castTo($next_8(component$iterator), 75);
    side = $getLeastCrowdedHorizontalCrossing(this$static.loopSides);
    $addSize(this$static.loopSides, side, component.textWidth, component.textHeight);
    $setLoopSide(component, side, true);
  }
}

function $assignCornerSide(this$static, components){
  var component, component$iterator, side;
  for (component$iterator = new ArrayList$1(components); component$iterator.i < component$iterator.this$01.array.length;) {
    component = castTo($next_8(component$iterator), 75);
    side = $getLeastCrowdedCorner(this$static.loopSides);
    $addSize(this$static.loopSides, side, component.textWidth, component.textHeight);
    $setLoopSide(component, side, true);
  }
}

function $calculate(this$static, components){
  var availableStraights, center, component, component$iterator, fullSets, i, itrAvailable, itrComponent, itrComponent0, itrSides, number, portSides, remainer, side, tmpSide, withLongText, withShortText, withoutText;
  withLongText = new ArrayList;
  withShortText = new ArrayList;
  withoutText = new ArrayList;
  for (component$iterator = new ArrayList$1(components); component$iterator.i < component$iterator.this$01.array.length;) {
    component = castTo($next_8(component$iterator), 75);
    component.textWidth > 50?(withLongText.array[withLongText.array.length] = component , true):component.textWidth > 0?(withShortText.array[withShortText.array.length] = component , true):(withoutText.array[withoutText.array.length] = component , true);
  }
  if (withShortText.array.length == 1 && withLongText.array.length == 0) {
    $addAll_6(withLongText, withShortText);
    withShortText.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
  }
  withLongText.array.length != 0 && $containsEnum($availableSides(this$static.loopSides), ($clinit_LoopSide() , N)) && $containsEnum($availableSides(this$static.loopSides), ($clinit_LoopSide() , S))?$assignAcrossSide(this$static, withLongText):$addAll_6(withShortText, withLongText);
  withShortText.array.length == 0 || $assignCornerSide(this$static, withShortText);
  if (withoutText.array.length != 0) {
    availableStraights = $availableStraightSides(this$static.loopSides);
    if (availableStraights.size_0 != 0) {
      itrComponent0 = new ArrayList$1(withoutText);
      itrAvailable = (checkNotNull(availableStraights) , cycle((new Iterables$1(availableStraights)).val$iterable1));
      while (itrComponent0.i < itrComponent0.this$01.array.length) {
        component = castTo($next_8(itrComponent0), 75);
        while (itrComponent0.i < itrComponent0.this$01.array.length && component.edges.map_0.size_1() < 2) {
          component = castTo($next_8(itrComponent0), 75);
        }
        if (component.edges.map_0.size_1() > 1) {
          side = castTo($next_0(itrAvailable), 60);
          $setLoopSide(component, side, true);
          $remove_12(itrComponent0);
          $removeSide(this$static.loopSides, side);
        }
      }
    }
    number = withoutText.array.length;
    center = $findCenter(this$static);
    portSides = new ArrayList;
    fullSets = number / $availableNotAcrossSides(this$static.loopSides).size_0 | 0;
    for (i = 0; i < fullSets; i++) {
      $addAll_6(portSides, $availableNotAcrossSides(this$static.loopSides));
    }
    remainer = number % $availableNotAcrossSides(this$static.loopSides).size_0;
    if (remainer > 3) {
      $addAll_6(portSides, ($clinit_LoopSide() , $clinit_LoopSide() , ALL_CORNERS));
      remainer -= 4;
    }
    switch (remainer) {
      case 3:
        $add_11(portSides, $opposite_0(center));
      case 2:
        tmpSide = $left($opposite_0(center));
        do {
          tmpSide = $left(tmpSide);
        }
         while (!$containsEnum($availableSides(this$static.loopSides), tmpSide));
        portSides.array[portSides.array.length] = tmpSide;
        tmpSide = $right($opposite_0(center));
        do {
          tmpSide = $right(tmpSide);
        }
         while (!$containsEnum($availableSides(this$static.loopSides), tmpSide));
        portSides.array[portSides.array.length] = tmpSide;
        break;
      case 1:
        $add_11(portSides, $opposite_0(center));
    }
    itrSides = new ArrayList$1(portSides);
    itrComponent = new ArrayList$1(withoutText);
    while (itrSides.i < itrSides.this$01.array.length && itrComponent.i < itrComponent.this$01.array.length) {
      $setLoopSide(castTo($next_8(itrComponent), 75), castTo($next_8(itrSides), 60), true);
    }
  }
}

function $findCenter(this$static){
  var first, itr, retVal, second;
  switch ($availableStraightSides(this$static.loopSides).size_0) {
    case 4:
      return $clinit_LoopSide() , S;
    case 3:
      return castTo($allRemovedStraightSides(this$static.loopSides).iterator_0().next_1(), 60);
    case 2:
      retVal = $availableStraightSides(this$static.loopSides);
      itr = new EnumSet$EnumSetImpl$IteratorImpl(retVal);
      first = castTo($next_9(itr), 60);
      second = castTo($next_9(itr), 60);
      return $opposite_0(first) == second?$containsEnum(retVal, ($clinit_LoopSide() , S))?E_0:S:$left($left(first)) == second?$left(first):$right(first);
    case 1:
      retVal = $availableStraightSides(this$static.loopSides);
      return $opposite_0(castTo($next_9(new EnumSet$EnumSetImpl$IteratorImpl(retVal)), 60));
    case 0:
      return $clinit_LoopSide() , SE;
    default:return null;
  }
}

function $removeOccupiedSides(this$static){
  var port, port$iterator;
  for (port$iterator = new ArrayList$1(this$static.node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_8(port$iterator), 7);
    $removeSide(this$static.loopSides, fromPortSides(port.side));
  }
}

function SplineSelfLoopPositioner$DistributedLoopSidesCalculator(node){
  this.loopSides = new SplineSelfLoopPositioner$DistributedLoopSidesCalculator$SortedLoopSides;
  this.node = node;
}

defineClass(515, 1, {}, SplineSelfLoopPositioner$DistributedLoopSidesCalculator);
var Lde_cau_cs_kieler_klay_layered_intermediate_SplineSelfLoopPositioner$DistributedLoopSidesCalculator_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'SplineSelfLoopPositioner/DistributedLoopSidesCalculator', 515);
function $addSize(this$static, side, addedWidth, addedHeight){
  var size_0;
  size_0 = castTo($get_15(this$static.sizeMap, side), 116);
  size_0.width_0 += addedWidth;
  size_0.height += addedHeight;
  $put_7(this$static.sizeMap, side, size_0);
  this$static.sideRemovedOrChanged = true;
}

function $allRemovedStraightSides(this$static){
  var retVal;
  retVal = ($clinit_LoopSide() , $clinit_LoopSide() , ALL_STRAIGHTS);
  this$static.sideRemovedOrChanged && $updateAvailableSides(this$static);
  $removeAll_0();
  return retVal;
}

function $availableNotAcrossSides(this$static){
  this$static.sideRemovedOrChanged && $updateAvailableSides(this$static);
  return this$static.availableNotAcrossSides;
}

function $availableSides(this$static){
  this$static.sideRemovedOrChanged && $updateAvailableSides(this$static);
  return this$static.availableSides;
}

function $availableStraightSides(this$static){
  this$static.sideRemovedOrChanged && $updateAvailableSides(this$static);
  return this$static.availableStraightSides;
}

function $getLeastCrowdedCorner(this$static){
  var entry, entry$iterator, height, isLessHigh, isNotHigherAndLessWide, minHeight, minSide, minWidth, width_0;
  minHeight = $intern_60;
  minWidth = $intern_60;
  minSide = null;
  for (entry$iterator = new LinkedHashMap$EntrySet$EntryIterator(new LinkedHashMap$EntrySet(this$static.sizeMap)); entry$iterator.next_0 != entry$iterator.this$11.this$01.head;) {
    entry = $next_10(entry$iterator);
    if (castTo(entry.key, 60).type_0 == 1) {
      height = castTo(entry.value_0, 116).height;
      width_0 = castTo(entry.value_0, 116).width_0;
      isLessHigh = minHeight - height > $intern_62;
      isNotHigherAndLessWide = height - minHeight < $intern_62 && minWidth - width_0 > $intern_62;
      if (isLessHigh || isNotHigherAndLessWide) {
        minWidth = castTo(entry.value_0, 116).width_0;
        minHeight = castTo(entry.value_0, 116).height;
        minSide = castTo(entry.key, 60);
        if (minWidth == 0 && minHeight == 0) {
          return minSide;
        }
      }
    }
  }
  return minSide;
}

function $getLeastCrowdedHorizontalCrossing(this$static){
  var entry, entry$iterator, height, isLessHigh, isNotHigherAndLessWide, minHeight, minSide, minWidth, width_0;
  minHeight = $intern_60;
  minWidth = $intern_60;
  minSide = null;
  for (entry$iterator = new LinkedHashMap$EntrySet$EntryIterator(new LinkedHashMap$EntrySet(this$static.sizeMap)); entry$iterator.next_0 != entry$iterator.this$11.this$01.head;) {
    entry = $next_10(entry$iterator);
    if (maskUndefined(entry.key) === maskUndefined(($clinit_LoopSide() , ENW)) || maskUndefined(entry.key) === maskUndefined(ESW)) {
      height = castTo(entry.value_0, 116).height;
      width_0 = castTo(entry.value_0, 116).width_0;
      isLessHigh = minHeight - height > $intern_62;
      isNotHigherAndLessWide = height - minHeight < $intern_62 && minWidth - width_0 > $intern_62;
      if (isLessHigh || isNotHigherAndLessWide) {
        minWidth = castTo(entry.value_0, 116).width_0;
        minHeight = castTo(entry.value_0, 116).height;
        minSide = castTo(entry.key, 60);
        if (minWidth == 0 && minHeight == 0) {
          return minSide;
        }
      }
    }
  }
  return minSide;
}

function $removeSide(this$static, side){
  var wasRemoved;
  wasRemoved = castTo($remove_20(this$static.sizeMap, side), 116);
  !!wasRemoved && (this$static.sideRemovedOrChanged = true);
}

function $updateAvailableSides(this$static){
  var entry, outerIter, side, side$iterator;
  $clear_0(this$static.availableStraightSides);
  $clear_0(this$static.availableSides);
  $clear_0(this$static.availableNotAcrossSides);
  for (side$iterator = (outerIter = (new AbstractMap$1(this$static.sizeMap)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter)); side$iterator.val$outerIter2.hasNext_0();) {
    side = (entry = castTo(side$iterator.val$outerIter2.next_1(), 21) , castTo(entry.getKey(), 60));
    if (side.type_0 != 2) {
      $add_17(this$static.availableNotAcrossSides, side);
      side.type_0 == 0 && $add_17(this$static.availableStraightSides, side);
    }
    $add_17(this$static.availableSides, side);
  }
  this$static.sideRemovedOrChanged = false;
}

function SplineSelfLoopPositioner$DistributedLoopSidesCalculator$SortedLoopSides(){
  var side, side$iterator, all0, all1, all;
  this.sizeMap = ($clinit_Maps() , new LinkedHashMap);
  this.availableSides = (all0 = castTo($getEnumConstants(Lde_cau_cs_kieler_klay_layered_p5edges_splines_LoopSide_2_classLit), 11) , new EnumSet$EnumSetImpl(all0, castTo(createFrom(all0, all0.length), 11), 0));
  this.availableStraightSides = (all1 = castTo($getEnumConstants(Lde_cau_cs_kieler_klay_layered_p5edges_splines_LoopSide_2_classLit), 11) , new EnumSet$EnumSetImpl(all1, castTo(createFrom(all1, all1.length), 11), 0));
  this.availableNotAcrossSides = (all = castTo($getEnumConstants(Lde_cau_cs_kieler_klay_layered_p5edges_splines_LoopSide_2_classLit), 11) , new EnumSet$EnumSetImpl(all, castTo(createFrom(all, all.length), 11), 0));
  for (side$iterator = ($clinit_LoopSide() , $clinit_LoopSide() , ALL).iterator_0(); side$iterator.hasNext_0();) {
    side = castTo(side$iterator.next_1(), 60);
    $put_7(this.sizeMap, side, new SplineSelfLoopPositioner$DistributedLoopSidesCalculator$SortedLoopSides$SizeOfSide);
  }
}

defineClass(516, 1, {}, SplineSelfLoopPositioner$DistributedLoopSidesCalculator$SortedLoopSides);
_.sideRemovedOrChanged = true;
var Lde_cau_cs_kieler_klay_layered_intermediate_SplineSelfLoopPositioner$DistributedLoopSidesCalculator$SortedLoopSides_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'SplineSelfLoopPositioner/DistributedLoopSidesCalculator/SortedLoopSides', 516);
function SplineSelfLoopPositioner$DistributedLoopSidesCalculator$SortedLoopSides$SizeOfSide(){
  this.width_0 = 0;
  this.height = 0;
}

defineClass(116, 1, {116:1}, SplineSelfLoopPositioner$DistributedLoopSidesCalculator$SortedLoopSides$SizeOfSide);
_.height = 0;
_.width_0 = 0;
var Lde_cau_cs_kieler_klay_layered_intermediate_SplineSelfLoopPositioner$DistributedLoopSidesCalculator$SortedLoopSides$SizeOfSide_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'SplineSelfLoopPositioner/DistributedLoopSidesCalculator/SortedLoopSides/SizeOfSide', 116);
function $clinit_SplineSelfLoopPositioner$PortReadder(){
  $clinit_SplineSelfLoopPositioner$PortReadder = emptyMethod;
  var side, side$array, side$index, side$max;
  LISTS_OF_COMPONENTS = new EnumMap(Lde_cau_cs_kieler_klay_layered_p5edges_splines_LoopSide_2_classLit);
  for (side$array = values_44() , side$index = 0 , side$max = side$array.length; side$index < side$max; ++side$index) {
    side = side$array[side$index];
    $put_4(LISTS_OF_COMPONENTS, side, null);
  }
}

function $addAllPorts(loopSide, itr){
  var component, component$iterator, entry, outerIter, port, port$iterator, port$iterator0, secondPart, secondPartSide;
  secondPart = new ArrayList;
  secondPartSide = null;
  for (component$iterator = castTo($get_11(LISTS_OF_COMPONENTS, loopSide), 20).iterator_0(); component$iterator.hasNext_0();) {
    component = castTo(component$iterator.next_1(), 75);
    for (port$iterator0 = (outerIter = (new AbstractMap$1(component.exclusiveLoopTargetPorts.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter)); port$iterator0.val$outerIter2.hasNext_0();) {
      port = (entry = castTo(port$iterator0.val$outerIter2.next_1(), 21) , castTo(entry.getKey(), 7));
      $add_15(itr, port);
      setSideOfPort(port, loopSide.target);
    }
    $addAll_6(secondPart, component.exclusiveLoopSourcePorts);
    secondPartSide = loopSide.source;
  }
  reverse_3(secondPart);
  setSideOfPorts(secondPart, secondPartSide);
  for (port$iterator = new ArrayList$1(secondPart); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_8(port$iterator), 7);
    $add_15(itr, port);
  }
}

function $addInlineTargetsFirst(loopSide, itr){
  var compItr, component, firstPart, port, port$iterator, port$iterator0, secondPart;
  firstPart = new ArrayList;
  secondPart = new ArrayList;
  compItr = castTo($get_11(LISTS_OF_COMPONENTS, loopSide), 20).iterator_0();
  while (compItr.hasNext_0()) {
    component = castTo(compItr.next_1(), 75);
    $addAll_5(firstPart, component.exclusiveLoopSourcePorts);
    $addAll_5(firstPart, $getTargetLoopPortsReversed(component));
    if (compItr.hasNext_0()) {
      component = castTo(compItr.next_1(), 75);
      $addAll_6(secondPart, $getTargetLoopPortsReversed(component));
      $addAll_6(secondPart, component.exclusiveLoopSourcePorts);
    }
  }
  setSideOfPorts(firstPart, loopSide.target);
  setSideOfPorts(secondPart, loopSide.source);
  for (port$iterator0 = new ArrayList$1(firstPart); port$iterator0.i < port$iterator0.this$01.array.length;) {
    port = castTo($next_8(port$iterator0), 7);
    $add_15(itr, port);
  }
  for (port$iterator = new ArrayList$1(secondPart); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_8(port$iterator), 7);
    $add_15(itr, port);
  }
}

function $addSourcePortsReversed(loopSide, itr){
  var component, component$iterator, port, port$iterator, sourcePorts;
  sourcePorts = new ArrayList;
  for (component$iterator = castTo($get_11(LISTS_OF_COMPONENTS, loopSide), 20).iterator_0(); component$iterator.hasNext_0();) {
    component = castTo(component$iterator.next_1(), 75);
    $addAll_6(sourcePorts, component.exclusiveLoopSourcePorts);
  }
  reverse_3(sourcePorts);
  setSideOfPorts(sourcePorts, loopSide.source);
  for (port$iterator = new ArrayList$1(sourcePorts); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_8(port$iterator), 7);
    $add_15(itr, port);
  }
}

function $addTargetPorts(loopSide, itr){
  var component, component$iterator, entry, outerIter, port, port$iterator, portSide;
  portSide = loopSide.target;
  for (component$iterator = castTo($get_11(LISTS_OF_COMPONENTS, loopSide), 20).iterator_0(); component$iterator.hasNext_0();) {
    component = castTo(component$iterator.next_1(), 75);
    for (port$iterator = (outerIter = (new AbstractMap$1(component.exclusiveLoopTargetPorts.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter)); port$iterator.val$outerIter2.hasNext_0();) {
      port = (entry = castTo(port$iterator.val$outerIter2.next_1(), 21) , castTo(entry.getKey(), 7));
      $add_15(itr, port);
      setSideOfPort(port, portSide);
    }
  }
}

function SplineSelfLoopPositioner$PortReadder(components){
  $clinit_SplineSelfLoopPositioner$PortReadder();
  var component, component$iterator, entry, list, list$iterator, outerIter, side, side$array, side$index, side$max;
  this.loopSorter = new SplineSelfLoopPositioner$TextWidthComparator;
  this.withNonSelfLoop = new ArrayList;
  this.allHiddenPorts = new ArrayList;
  for (side$array = values_44() , side$index = 0 , side$max = side$array.length; side$index < side$max; ++side$index) {
    side = side$array[side$index];
    $put_4(LISTS_OF_COMPONENTS, side, new ArrayList);
  }
  for (component$iterator = components.iterator_0(); component$iterator.hasNext_0();) {
    component = castTo(component$iterator.next_1(), 75);
    $addAll_6(this.allHiddenPorts, $getHidablePorts(component));
    component.portsWithNonLoopEdge.map_0.size_1() == 0?castTo($get_11(LISTS_OF_COMPONENTS, component.loopSide), 20).add_1(component):$add_11(this.withNonSelfLoop, component);
  }
  for (list$iterator = (outerIter = (new AbstractMap$2(LISTS_OF_COMPONENTS)).this$01.entrySet_0().iterator_0() , new AbstractMap$2$1(outerIter)); list$iterator.val$outerIter2.hasNext_0();) {
    list = (entry = castTo(list$iterator.val$outerIter2.next_1(), 21) , castTo(entry.getValue(), 20));
    sort_1(list, this.loopSorter);
  }
  reverse_3(castTo($get_11(LISTS_OF_COMPONENTS, ($clinit_LoopSide() , NW)), 20));
}

defineClass(318, 1, {}, SplineSelfLoopPositioner$PortReadder);
var LISTS_OF_COMPONENTS;
var Lde_cau_cs_kieler_klay_layered_intermediate_SplineSelfLoopPositioner$PortReadder_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'SplineSelfLoopPositioner/PortReadder', 318);
function $compare_10(loop0, loop1){
  return compare_31(loop1.textWidth, loop0.textWidth);
}

function SplineSelfLoopPositioner$TextWidthComparator(){
}

defineClass(514, 1, $intern_9, SplineSelfLoopPositioner$TextWidthComparator);
_.compare_0 = function compare_23(loop0, loop1){
  return $compare_10(castTo(loop0, 75), castTo(loop1, 75));
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_SplineSelfLoopPositioner$TextWidthComparator_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'SplineSelfLoopPositioner/TextWidthComparator', 514);
function $correctPortSideConstraint(node){
  var port, port$iterator;
  if (!$isSideFixed(castTo($getProperty(node, ($clinit_LayoutOptions() , PORT_CONSTRAINTS)), 28))) {
    for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_8(port$iterator), 7);
      $setSide(port, ($clinit_PortSide() , UNDEFINED_4));
    }
  }
}

function SplineSelfLoopPreProcessor(){
}

function findAConnectedComponent(portsToEdges, node, isFixedOrder){
  var allEdgesOnCurrentPort, connectedComponent, currentEdge, currentEdge$iterator, currentPort, edgeToPort, port, port$iterator, portsOfCurrentEdge, portsProcessed, portsToProcess, result;
  edgeToPort = new ArrayListMultimap;
  invertFrom(portsToEdges, edgeToPort);
  connectedComponent = new ConnectedSelfLoopComponent(node);
  portsToProcess = new ArrayList;
  $add_11(portsToProcess, (result = portsToEdges.keys_0 , castTo($next_1($iterator_3(!result?(portsToEdges.keys_0 = new Multimaps$Keys(portsToEdges)):result)), 7)));
  portsProcessed = new ArrayList;
  while (portsToProcess.array.length != 0) {
    currentPort = castTo($next_8(new ArrayList$1(portsToProcess)), 7);
    portsProcessed.array[portsProcessed.array.length] = currentPort;
    allEdgesOnCurrentPort = $removeAll_1(portsToEdges, currentPort);
    for (currentEdge$iterator = new Collections$UnmodifiableCollectionIterator(allEdgesOnCurrentPort.coll.iterator_0()); currentEdge$iterator.it.hasNext_0();) {
      currentEdge = castTo(currentEdge$iterator.it.next_1(), 12);
      if ($tryAddEdge(connectedComponent, currentEdge, isFixedOrder)) {
        portsOfCurrentEdge = castTo($removeAll(edgeToPort, currentEdge), 20);
        for (port$iterator = portsOfCurrentEdge.iterator_0(); port$iterator.hasNext_0();) {
          port = castTo(port$iterator.next_1(), 7);
          $indexOf_0(portsProcessed, port, 0) != -1 || (portsToProcess.array[portsToProcess.array.length] = port , true);
        }
      }
    }
    $remove_7(portsToProcess, currentPort);
  }
  return connectedComponent;
}

function findAllConnectedComponents(loopEdges, node){
  var components, edge, edge$iterator, entry, outerIter, portToEdge;
  components = new ArrayList;
  portToEdge = new LinkedListMultimap;
  for (edge$iterator = (outerIter = (new AbstractMap$1(loopEdges.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter)); edge$iterator.val$outerIter2.hasNext_0();) {
    edge = (entry = castTo(edge$iterator.val$outerIter2.next_1(), 21) , castTo(entry.getKey(), 12));
    $addNode(portToEdge, edge.source, edge, null);
    $addNode(portToEdge, edge.target, edge, null);
  }
  while (portToEdge.head) {
    $add_11(components, findAConnectedComponent(portToEdge, node, $isOrderFixed(castTo($getProperty(node, ($clinit_LayoutOptions() , PORT_CONSTRAINTS)), 28))));
  }
  return components;
}

defineClass(517, 1, $intern_56, SplineSelfLoopPreProcessor);
_.process = function process_42(layeredGraph, monitor){
  var allComponents, component, component$iterator, edge, edge$iterator, edge$iterator0, entry, itr, loopEdges, node, node$iterator, old, outerIter, port, portsToHide, sourcePortSide, targetPortSide;
  $begin(monitor, 'Spline SelfLoop pre-processing.', 1);
  loopEdges = new LinkedHashSet;
  for (node$iterator = new ArrayList$1(layeredGraph.layerlessNodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 9);
    $correctPortSideConstraint(node);
    loopEdges.map_0.clear_0();
    for (edge$iterator0 = $iterator($getOutgoingEdges_0(node)); $hasNext_0(edge$iterator0);) {
      edge = castTo($next_2(edge$iterator0), 12);
      $isSelfLoop(edge) && (old = loopEdges.map_0.put(edge, loopEdges) , old == null);
    }
    for (edge$iterator = (outerIter = (new AbstractMap$1(loopEdges.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter)); edge$iterator.val$outerIter2.hasNext_0();) {
      edge = (entry = castTo(edge$iterator.val$outerIter2.next_1(), 21) , castTo(entry.getKey(), 12));
      sourcePortSide = edge.source.side;
      targetPortSide = edge.target.side;
      (sourcePortSide == ($clinit_PortSide() , NORTH) && (targetPortSide == EAST || targetPortSide == SOUTH) || sourcePortSide == EAST && targetPortSide == SOUTH || sourcePortSide == SOUTH && targetPortSide == WEST || sourcePortSide == WEST && (targetPortSide == NORTH || targetPortSide == EAST)) && $reverse_0(edge, false);
    }
    allComponents = findAllConnectedComponents(loopEdges, node);
    $setProperty(node, ($clinit_InternalProperties() , SPLINE_SELFLOOP_COMPONENTS), allComponents);
    if (!$isOrderFixed(castTo($getProperty(node, ($clinit_LayoutOptions() , PORT_CONSTRAINTS)), 28))) {
      portsToHide = new HashSet;
      for (component$iterator = new ArrayList$1(allComponents); component$iterator.i < component$iterator.this$01.array.length;) {
        component = castTo($next_8(component$iterator), 75);
        $addAll(portsToHide, $getHidablePorts(component));
        $addAll(portsToHide, component.portsWithPortSide);
      }
      itr = new AbstractList$ListIteratorImpl(node.ports, 0);
      while (itr.i < itr.this$01_0.size_1()) {
        port = (checkCriticalElement(itr.i < itr.this$01_0.size_1()) , castTo(itr.this$01_0.get_2(itr.last = itr.i++), 7));
        portsToHide.map_0.containsKey(port) && $remove_11(itr);
      }
    }
  }
  $done(monitor);
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_SplineSelfLoopPreProcessor_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'SplineSelfLoopPreProcessor', 517);
function $calculateAcrossSelfLoop(edge, sourcePadding, middlePadding, targetPadding){
  var edgeMargins, label_0, label$iterator, labelMargins, nubs, textLength;
  textLength = 0;
  for (label$iterator = new ArrayList$1(edge.lEdge.labels); label$iterator.i < label$iterator.this$01.array.length;) {
    label_0 = castTo($next_8(label$iterator), 33);
    textLength = max_1(textLength, label_0.size_0.x_0);
  }
  nubs = createAcrossSelfLoop(edge.lEdge.source, sourcePadding, edge.lEdge.target, targetPadding, $getMiddleSide(edge.loopSide), middlePadding);
  $addAll(edge.lEdge.bendPoints, $getBezierCP(nubs));
  labelMargins = $placeLabels(edge.lEdge.labels, nubs.firstLabelPosition, edge.loopSide);
  edgeMargins = new Rectangle_3((!nubs.outerBox && (nubs.outerBox = new Rectangle_4($getControlPoints(nubs))) , nubs.outerBox));
  $enlarge(edgeMargins);
  return !labelMargins?edgeMargins:union(edgeMargins, labelMargins);
}

function $calculateCornerSelfLoop(edge, sourcePadding, targetPadding){
  var edgeMargins, label_0, label$iterator, labelLength, labelMargins, nubs, side;
  side = edge.loopSide;
  labelLength = 0;
  for (label$iterator = new ArrayList$1(edge.lEdge.labels); label$iterator.i < label$iterator.this$01.array.length;) {
    label_0 = castTo($next_8(label$iterator), 33);
    labelLength = max_1(labelLength, label_0.size_0.x_0);
  }
  nubs = createCornerSelfLoop(edge.lEdge.source, edge.lEdge.target, sourcePadding, targetPadding, labelLength);
  $addAll(edge.lEdge.bendPoints, $getBezierCP(nubs));
  labelMargins = $placeLabels(edge.lEdge.labels, nubs.firstLabelPosition, side);
  edgeMargins = new Rectangle_3((!nubs.outerBox && (nubs.outerBox = new Rectangle_4($getControlPoints(nubs))) , nubs.outerBox));
  $enlarge(edgeMargins);
  return !labelMargins?edgeMargins:union(edgeMargins, labelMargins);
}

function $placeLabel(label_0, rawPosition, side){
  var labelSize, thisLabelPosition;
  thisLabelPosition = new KVector_2(rawPosition);
  labelSize = new KVector_2(label_0.size_0);
  switch (side.ordinal) {
    case 1:
    case 8:
    case 7:
      $add_6(thisLabelPosition, -labelSize.x_0 / 2, -labelSize.y_0);
      $add_6(rawPosition, 0, -(0.5 + labelSize.y_0));
      break;
    case 3:
    case 4:
    case 5:
      $add_6(thisLabelPosition, -labelSize.x_0 / 2, 0);
      $add_6(rawPosition, 0, 0.5 + labelSize.y_0);
      break;
    case 0:
      $add_6(thisLabelPosition, -labelSize.x_0 / 2, -labelSize.y_0);
      $add_6(rawPosition, 0, -(0.5 + -labelSize.y_0));
      break;
    case 10:
    case 2:
      $add_6(thisLabelPosition, 0, -labelSize.y_0 / 2);
      $add_6(rawPosition, 0, -(0.5 + labelSize.y_0));
      break;
    case 6:
      $add_6(thisLabelPosition, -labelSize.x_0, labelSize.y_0 / 2);
      $add_6(rawPosition, 0, -(0.5 + labelSize.y_0));
      break;
    case 9:
      $add_6(thisLabelPosition, -labelSize.x_0 / 2, 0);
      $add_6(rawPosition, 0, -(0.5 + labelSize.y_0));
      break;
    case 11:
      $add_6(thisLabelPosition, -labelSize.x_0, -labelSize.y_0 / 2);
      $add_6(rawPosition, 0, -(0.5 + labelSize.y_0));
  }
  $add_7($reset(label_0.pos), thisLabelPosition);
  return new Rectangle_2(label_0);
}

function $placeLabels(labels, rawPosition, side){
  var allLabels, iter, label_0;
  iter = new ArrayList$1(labels);
  if (iter.i < iter.this$01.array.length) {
    label_0 = castTo($next_8(iter), 33);
    allLabels = $placeLabel(label_0, rawPosition, side);
    while (iter.i < iter.this$01.array.length) {
      label_0 = castTo($next_8(iter), 33);
      $union_0(allLabels, $placeLabel(label_0, rawPosition, side));
    }
    return new Rectangle_3(allLabels);
  }
   else {
    return null;
  }
}

function $processSelfLoop(selfLoop, loopPaddings){
  var itr, loopRectangle, loopSide, middleHeight, pred, relevantPaddings, sidePredicate, sourceHeight, targetHeight, side, nubs, labelMargins, edgeMargins;
  pred = new SplineSelfLoopRouter$LoopPadding$EnclosingPredicate(selfLoop);
  relevantPaddings = newArrayList(filter_0(loopPaddings, pred));
  sort_1(relevantPaddings, new SplineSelfLoopRouter$LoopPadding$MarginComparator);
  loopSide = selfLoop.loopSide;
  switch (loopSide.type_0) {
    case 2:
      sidePredicate = new SplineSelfLoopRouter$LoopPadding$PortSidePredicate(loopSide.source);
      itr = $iterator_0(filter_0(relevantPaddings, sidePredicate));
      $hasNext(itr)?(sourceHeight = castTo($next(itr), 91).padding):(sourceHeight = 15);
      sidePredicate = new SplineSelfLoopRouter$LoopPadding$PortSidePredicate($getMiddleSide(loopSide));
      itr = $iterator_0(filter_0(relevantPaddings, sidePredicate));
      $hasNext(itr)?(middleHeight = castTo($next(itr), 91).padding):(middleHeight = 15);
      sidePredicate = new SplineSelfLoopRouter$LoopPadding$PortSidePredicate(loopSide.target);
      itr = $iterator_0(filter_0(relevantPaddings, sidePredicate));
      $hasNext(itr)?(targetHeight = castTo($next(itr), 91).padding):(targetHeight = 15);
      loopRectangle = $calculateAcrossSelfLoop(selfLoop, sourceHeight, middleHeight, targetHeight);
      $add_18(loopPaddings, new SplineSelfLoopRouter$LoopPadding(loopRectangle, selfLoop.sourceIndex, selfLoop.targetIndex, selfLoop.lEdge.source.owner, loopSide.source));
      $add_18(loopPaddings, new SplineSelfLoopRouter$LoopPadding(loopRectangle, selfLoop.sourceIndex, selfLoop.targetIndex, selfLoop.lEdge.source.owner, $getMiddleSide(loopSide)));
      $add_18(loopPaddings, new SplineSelfLoopRouter$LoopPadding(loopRectangle, selfLoop.sourceIndex, selfLoop.targetIndex, selfLoop.lEdge.source.owner, loopSide.target));
      break;
    case 1:
      sidePredicate = new SplineSelfLoopRouter$LoopPadding$PortSidePredicate(loopSide.source);
      itr = $iterator_0(filter_0(relevantPaddings, sidePredicate));
      $hasNext(itr)?(sourceHeight = castTo($next(itr), 91).padding):(sourceHeight = 15);
      sidePredicate = new SplineSelfLoopRouter$LoopPadding$PortSidePredicate(loopSide.target);
      itr = $iterator_0(filter_0(relevantPaddings, sidePredicate));
      $hasNext(itr)?(targetHeight = castTo($next(itr), 91).padding):(targetHeight = 15);
      loopRectangle = $calculateCornerSelfLoop(selfLoop, sourceHeight, targetHeight);
      $add_18(loopPaddings, new SplineSelfLoopRouter$LoopPadding(loopRectangle, selfLoop.sourceIndex, selfLoop.targetIndex, selfLoop.lEdge.source.owner, loopSide.source));
      $add_18(loopPaddings, new SplineSelfLoopRouter$LoopPadding(loopRectangle, selfLoop.sourceIndex, selfLoop.targetIndex, selfLoop.lEdge.source.owner, loopSide.target));
      break;
    case 0:
      sidePredicate = new SplineSelfLoopRouter$LoopPadding$PortSidePredicate(loopSide.source);
      itr = $iterator_0(filter_0(relevantPaddings, sidePredicate));
      $hasNext(itr)?(sourceHeight = castTo($next(itr), 91).padding):(sourceHeight = 15);
      loopRectangle = (side = selfLoop.loopSide , nubs = createSideSelfLoop(selfLoop.lEdge.source, selfLoop.lEdge.target, sourceHeight) , $addAll(selfLoop.lEdge.bendPoints, $getBezierCP(nubs)) , labelMargins = $placeLabels(selfLoop.lEdge.labels, nubs.firstLabelPosition, side) , edgeMargins = new Rectangle_3((!nubs.outerBox && (nubs.outerBox = new Rectangle_4($getControlPoints(nubs))) , nubs.outerBox)) , $enlarge(edgeMargins) , !labelMargins?edgeMargins:union(edgeMargins, labelMargins));
      $add_18(loopPaddings, new SplineSelfLoopRouter$LoopPadding(loopRectangle, selfLoop.sourceIndex, selfLoop.targetIndex, selfLoop.lEdge.source.owner, loopSide.source));
      break;
    default:throw new IllegalArgumentException_0('The loopside must be defined.');
  }
  return loopRectangle;
}

function SplineSelfLoopRouter(){
}

defineClass(518, 1, $intern_56, SplineSelfLoopRouter);
_.process = function process_43(layeredGraph, monitor){
  var component, component$iterator, currentPort, edge, edge$iterator, entry, found, index_0, iter, layer, layer$iterator, loopEdges, loopIter, loopPaddings, loopRectangle, node, node$iterator, outerIter, ports, selfLoops, side, sourceIndex, sourcePort, stepSize, stepSizeComparator, targetIndex, targetPort, retVal, shapeRectangle;
  $begin(monitor, 'Spline SelfLoop routing', 1);
  stepSizeComparator = new SplineSelfLoopRouter$SelfLoopEdge$StepSizeComparator;
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator), 16);
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      ports = node.ports;
      loopEdges = new LinkedHashSet;
      for (component$iterator = castTo($getProperty(node, ($clinit_InternalProperties() , SPLINE_SELFLOOP_COMPONENTS)), 20).iterator_0(); component$iterator.hasNext_0();) {
        component = castTo(component$iterator.next_1(), 75);
        $addAll(loopEdges, component.edges);
      }
      selfLoops = new ArrayList;
      for (edge$iterator = (outerIter = (new AbstractMap$1(loopEdges.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter)); edge$iterator.val$outerIter2.hasNext_0();) {
        edge = (entry = castTo(edge$iterator.val$outerIter2.next_1(), 21) , castTo(entry.getKey(), 12));
        sourcePort = edge.source;
        targetPort = edge.target;
        iter = new ArrayList$1(edge.source.owner.ports);
        sourceIndex = 0;
        targetIndex = 0;
        found = 0;
        index_0 = 0;
        while (found < 2) {
          currentPort = castTo($next_8(iter), 7);
          if (sourcePort == currentPort) {
            sourceIndex = index_0;
            ++found;
          }
          if (targetPort == currentPort) {
            targetIndex = index_0;
            ++found;
          }
          ++index_0;
        }
        side = castTo($getProperty(edge, SPLINE_LOOPSIDE), 60);
        stepSize = side == ($clinit_LoopSide() , NW) || side == ENW?ports.array.length - (targetIndex - sourceIndex < 0?-(targetIndex - sourceIndex):targetIndex - sourceIndex) + 1:targetIndex - sourceIndex < 0?-(targetIndex - sourceIndex):targetIndex - sourceIndex;
        $add_11(selfLoops, new SplineSelfLoopRouter$SelfLoopEdge(sourceIndex, targetIndex, stepSize, side, edge));
      }
      sort_1(selfLoops, stepSizeComparator);
      loopPaddings = new HashSet;
      loopIter = new ArrayList$1(selfLoops);
      if (loopIter.i < loopIter.this$01.array.length) {
        loopRectangle = $processSelfLoop(castTo($next_8(loopIter), 195), loopPaddings);
        while (loopIter.i < loopIter.this$01.array.length) {
          $union_0(loopRectangle, $processSelfLoop(castTo($next_8(loopIter), 195), loopPaddings));
        }
        $setProperty(node, SPLINE_SELF_LOOP_MARGINS, (retVal = new Spacing$Margins , shapeRectangle = new Rectangle_1(node.size_0.x_0, node.size_0.y_0) , retVal.top_0 = max_1(0, shapeRectangle.top_0 - loopRectangle.top_0) , retVal.left = max_1(0, shapeRectangle.left - loopRectangle.left) , retVal.bottom = max_1(0, loopRectangle.bottom - shapeRectangle.bottom) , retVal.right = max_1(0, loopRectangle.right - shapeRectangle.right) , retVal));
      }
    }
  }
  $done(monitor);
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_SplineSelfLoopRouter_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'SplineSelfLoopRouter', 518);
function SplineSelfLoopRouter$LoopPadding(boundingBox, sourceIndex, targetIndex, shape_0, side){
  this.side = side;
  this.startIndex = sourceIndex;
  this.endIndex = targetIndex;
  switch (side.ordinal) {
    case 4:
      this.padding = abs_0(boundingBox.left);
      break;
    case 1:
      this.padding = abs_0(boundingBox.top_0);
      break;
    case 2:
      this.padding = abs_0(boundingBox.right - shape_0.size_0.x_0);
      break;
    case 3:
      this.padding = abs_0(boundingBox.bottom - shape_0.size_0.y_0);
      break;
    default:this.padding = 0;
  }
}

defineClass(91, 1, {91:1}, SplineSelfLoopRouter$LoopPadding);
_.toString_0 = function toString_56(){
  return this.padding + ': ' + this.startIndex + ' -> ' + this.endIndex + ' ' + $toString_2(this.side);
}
;
_.endIndex = 0;
_.padding = 0;
_.startIndex = 0;
var Lde_cau_cs_kieler_klay_layered_intermediate_SplineSelfLoopRouter$LoopPadding_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'SplineSelfLoopRouter/LoopPadding', 91);
function $apply_8(this$static, margin){
  if (!$getPortSides(this$static.loopSide).contains(margin.side)) {
    return false;
  }
  return $viaNW(this$static.loopSide)?!(isBetween_0(margin.startIndex, this$static.startIndex, this$static.endIndex) && isBetween_0(margin.endIndex, this$static.startIndex, this$static.endIndex)):isBetween_0(margin.startIndex, this$static.startIndex, this$static.endIndex) && isBetween_0(margin.endIndex, this$static.startIndex, this$static.endIndex);
}

function SplineSelfLoopRouter$LoopPadding$EnclosingPredicate(edge){
  this.startIndex = edge.sourceIndex;
  this.endIndex = edge.targetIndex;
  this.loopSide = edge.loopSide;
}

defineClass(521, 1, $intern_52, SplineSelfLoopRouter$LoopPadding$EnclosingPredicate);
_.apply_1 = function apply_43(margin){
  return $apply_8(this, castTo(margin, 91));
}
;
_.endIndex = 0;
_.startIndex = 0;
var Lde_cau_cs_kieler_klay_layered_intermediate_SplineSelfLoopRouter$LoopPadding$EnclosingPredicate_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'SplineSelfLoopRouter/LoopPadding/EnclosingPredicate', 521);
function $compare_11(margin0, margin1){
  return compare_31(margin1.padding, margin0.padding);
}

function SplineSelfLoopRouter$LoopPadding$MarginComparator(){
}

defineClass(520, 1, $intern_9, SplineSelfLoopRouter$LoopPadding$MarginComparator);
_.compare_0 = function compare_24(margin0, margin1){
  return $compare_11(castTo(margin0, 91), castTo(margin1, 91));
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_SplineSelfLoopRouter$LoopPadding$MarginComparator_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'SplineSelfLoopRouter/LoopPadding/MarginComparator', 520);
function SplineSelfLoopRouter$LoopPadding$PortSidePredicate(side){
  this.side = side;
}

defineClass(196, 1, $intern_52, SplineSelfLoopRouter$LoopPadding$PortSidePredicate);
_.apply_1 = function apply_44(margin){
  return castTo(margin, 91).side == this.side;
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_SplineSelfLoopRouter$LoopPadding$PortSidePredicate_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'SplineSelfLoopRouter/LoopPadding/PortSidePredicate', 196);
function SplineSelfLoopRouter$SelfLoopEdge(sourceIndex, targetIndex, stepSize, loopSide, edge){
  this.sourceIndex = sourceIndex;
  this.targetIndex = targetIndex;
  this.stepSize = stepSize;
  this.loopSide = loopSide;
  this.lEdge = edge;
}

defineClass(195, 1, {195:1}, SplineSelfLoopRouter$SelfLoopEdge);
_.sourceIndex = 0;
_.stepSize = 0;
_.targetIndex = 0;
var Lde_cau_cs_kieler_klay_layered_intermediate_SplineSelfLoopRouter$SelfLoopEdge_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'SplineSelfLoopRouter/SelfLoopEdge', 195);
function $compare_12(edge0, edge1){
  return edge0.stepSize - edge1.stepSize;
}

function SplineSelfLoopRouter$SelfLoopEdge$StepSizeComparator(){
}

defineClass(519, 1, $intern_9, SplineSelfLoopRouter$SelfLoopEdge$StepSizeComparator);
_.compare_0 = function compare_25(edge0, edge1){
  return $compare_12(castTo(edge0, 195), castTo(edge1, 195));
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_SplineSelfLoopRouter$SelfLoopEdge$StepSizeComparator_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate', 'SplineSelfLoopRouter/SelfLoopEdge/StepSizeComparator', 519);
function $addSegment(this$static, vSeg){
  var difference, e, e$iterator, entry, inc, newY1, newY2, out, outerIter;
  $addAll_3(this$static.bends, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [vSeg.bend1, vSeg.bend2]));
  $addAll(this$static.juctionPoints, vSeg.junctionPoints);
  this$static.spacingIgnore.up = this$static.spacingIgnore.up | vSeg.blockTopSpacing;
  this$static.spacingIgnore.down = this$static.spacingIgnore.down | vSeg.blockBottomSpacing;
  newY1 = min_1(this$static.hitbox.y_0, vSeg.y1);
  newY2 = max_1(this$static.hitbox.y_0 + this$static.hitbox.height, vSeg.y2);
  $setRect(this$static.hitbox, vSeg.x1, newY1, 0, newY2 - newY1);
  $add_18(this$static.originalLEdges, vSeg.lEdge);
  vSeg.lEdge.source.owner == vSeg.lEdge.target.owner && $set_2(this$static.lock, true, true, true, true);
  inc = new HashSet;
  out = new HashSet;
  for (e$iterator = (outerIter = (new AbstractMap$1(this$static.originalLEdges.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter)); e$iterator.val$outerIter2.hasNext_0();) {
    e = (entry = castTo(e$iterator.val$outerIter2.next_1(), 21) , castTo(entry.getKey(), 12));
    $add_18(inc, e.source);
    $add_18(out, e.target);
  }
  difference = inc.map_0.size_1() - out.map_0.size_1();
  if (difference < 0) {
    $set_1(this$static.lock, true, ($clinit_Direction() , LEFT_0));
    $set_1(this$static.lock, false, RIGHT_0);
  }
   else if (difference > 0) {
    $set_1(this$static.lock, false, ($clinit_Direction() , LEFT_0));
    $set_1(this$static.lock, true, RIGHT_0);
  }
}

function CLEdge(vSeg, layeredGraph){
  CNode.call(this);
  this.originalLEdges = new HashSet;
  this.horizontalSpacing = castTo($getProperty(layeredGraph, ($clinit_InternalProperties() , SPACING_0)), 15).value_0 * castTo($getProperty(layeredGraph, ($clinit_Properties() , EDGE_SPACING_FACTOR)), 15).value_0;
  this.verticalSpacing = this.horizontalSpacing * castTo($getProperty(layeredGraph, OBJ_SPACING_IN_LAYER_FACTOR), 15).value_0;
  this.bends = new KVectorChain;
  this.juctionPoints = new KVectorChain;
  this.hitbox = new Rectangle_0(vSeg.x1, vSeg.y1, 0, vSeg.y2 - vSeg.y1);
  this.parentNode = vSeg.parentNode;
  this.cGroupOffset.x_0 = vSeg.relativePosition;
  $addSegment(this, vSeg);
}

defineClass(82, 25, {25:1, 82:1}, CLEdge);
_.applyElementPosition = function applyElementPosition_0(){
  var b, b$iterator, j, j$iterator;
  for (b$iterator = $listIterator_2(this.bends, 0); b$iterator.currentNode != b$iterator.this$01.tail;) {
    b = castTo($next_11(b$iterator), 10);
    b.x_0 = this.hitbox.x_0;
  }
  for (j$iterator = $listIterator_2(this.juctionPoints, 0); j$iterator.currentNode != j$iterator.this$01.tail;) {
    j = castTo($next_11(j$iterator), 10);
    j.x_0 = this.hitbox.x_0;
  }
}
;
_.getHorizontalSpacing_0 = function getHorizontalSpacing_2(){
  return this.horizontalSpacing;
}
;
_.getVerticalSpacing_0 = function getVerticalSpacing_2(){
  return this.verticalSpacing;
}
;
_.toString_0 = function toString_57(){
  return $toString_5(new AbstractMap$1(this.originalLEdges.map_0));
}
;
_.horizontalSpacing = 0;
_.verticalSpacing = 0;
var Lde_cau_cs_kieler_klay_layered_intermediate_compaction_CLEdge_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate.compaction', 'CLEdge', 82);
function CLNode(lNode, layeredGraph){
  var difference;
  CNode.call(this);
  this.horizontalSpacing = castTo($getProperty(layeredGraph, ($clinit_InternalProperties() , SPACING_0)), 15).value_0;
  this.verticalSpacing = this.horizontalSpacing * castTo($getProperty(layeredGraph, ($clinit_Properties() , OBJ_SPACING_IN_LAYER_FACTOR)), 15).value_0;
  this.lNode = lNode;
  this.hitbox = new Rectangle_0(lNode.pos.x_0 - lNode.margin.left, lNode.pos.y_0 - lNode.margin.top_0, lNode.size_0.x_0 + lNode.margin.left + lNode.margin.right, lNode.size_0.y_0 + lNode.margin.top_0 + lNode.margin.bottom);
  $reset(this.cGroupOffset);
  difference = size_18($getIncomingEdges_0(lNode)) - size_18($getOutgoingEdges_0(lNode));
  difference < 0?$set_1(this.lock, true, ($clinit_Direction() , LEFT_0)):difference > 0 && $set_1(this.lock, true, ($clinit_Direction() , RIGHT_0));
  lNode.type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT) && $set_2(this.lock, false, false, false, false);
}

defineClass(93, 25, {25:1, 93:1}, CLNode);
_.applyElementPosition = function applyElementPosition_1(){
  this.lNode.pos.x_0 = this.hitbox.x_0 + this.lNode.margin.left;
}
;
_.getHorizontalSpacing_0 = function getHorizontalSpacing_3(){
  if (this.lNode.type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
    return 0;
  }
  return this.horizontalSpacing;
}
;
_.getVerticalSpacing_0 = function getVerticalSpacing_3(){
  if (this.lNode.type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
    return 0;
  }
  return this.verticalSpacing;
}
;
_.toString_0 = function toString_58(){
  return toString__Ljava_lang_String___devirtual$($getProperty(this.lNode, ($clinit_InternalProperties() , ORIGIN)));
}
;
_.horizontalSpacing = 0;
_.verticalSpacing = 0;
var Lde_cau_cs_kieler_klay_layered_intermediate_compaction_CLNode_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate.compaction', 'CLNode', 93);
function $clinit_ConstraintCalculationStrategy(){
  $clinit_ConstraintCalculationStrategy = emptyMethod;
  QUADRATIC = new ConstraintCalculationStrategy('QUADRATIC', 0);
  SCANLINE = new ConstraintCalculationStrategy('SCANLINE', 1);
}

function ConstraintCalculationStrategy(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function values_34(){
  $clinit_ConstraintCalculationStrategy();
  return stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_intermediate_compaction_ConstraintCalculationStrategy_2_classLit, 1), $intern_13, 175, 0, [QUADRATIC, SCANLINE]);
}

defineClass(175, 17, {175:1, 3:1, 23:1, 17:1}, ConstraintCalculationStrategy);
var QUADRATIC, SCANLINE;
var Lde_cau_cs_kieler_klay_layered_intermediate_compaction_ConstraintCalculationStrategy_2_classLit = createForEnum('de.cau.cs.kieler.klay.layered.intermediate.compaction', 'ConstraintCalculationStrategy', 175, Ljava_lang_Enum_2_classLit, values_34);
function $clinit_ConstraintCalculationStrategy$Map(){
  $clinit_ConstraintCalculationStrategy$Map = emptyMethod;
  $MAP_13 = createValueOfMap(($clinit_ConstraintCalculationStrategy() , stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_intermediate_compaction_ConstraintCalculationStrategy_2_classLit, 1), $intern_13, 175, 0, [QUADRATIC, SCANLINE])));
}

var $MAP_13;
function $clinit_GraphCompactionStrategy(){
  $clinit_GraphCompactionStrategy = emptyMethod;
  NONE_1 = new GraphCompactionStrategy('NONE', 0);
  LEFT_2 = new GraphCompactionStrategy('LEFT', 1);
  RIGHT_2 = new GraphCompactionStrategy('RIGHT', 2);
  LEFT_RIGHT_CONSTRAINT_LOCKING = new GraphCompactionStrategy('LEFT_RIGHT_CONSTRAINT_LOCKING', 3);
  LEFT_RIGHT_CONNECTION_LOCKING = new GraphCompactionStrategy('LEFT_RIGHT_CONNECTION_LOCKING', 4);
  EDGE_LENGTH = new GraphCompactionStrategy('EDGE_LENGTH', 5);
}

function GraphCompactionStrategy(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function values_35(){
  $clinit_GraphCompactionStrategy();
  return stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_intermediate_compaction_GraphCompactionStrategy_2_classLit, 1), $intern_13, 125, 0, [NONE_1, LEFT_2, RIGHT_2, LEFT_RIGHT_CONSTRAINT_LOCKING, LEFT_RIGHT_CONNECTION_LOCKING, EDGE_LENGTH]);
}

defineClass(125, 17, {125:1, 3:1, 23:1, 17:1}, GraphCompactionStrategy);
var EDGE_LENGTH, LEFT_2, LEFT_RIGHT_CONNECTION_LOCKING, LEFT_RIGHT_CONSTRAINT_LOCKING, NONE_1, RIGHT_2;
var Lde_cau_cs_kieler_klay_layered_intermediate_compaction_GraphCompactionStrategy_2_classLit = createForEnum('de.cau.cs.kieler.klay.layered.intermediate.compaction', 'GraphCompactionStrategy', 125, Ljava_lang_Enum_2_classLit, values_35);
function $clinit_GraphCompactionStrategy$Map(){
  $clinit_GraphCompactionStrategy$Map = emptyMethod;
  $MAP_14 = createValueOfMap(($clinit_GraphCompactionStrategy() , stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_intermediate_compaction_GraphCompactionStrategy_2_classLit, 1), $intern_13, 125, 0, [NONE_1, LEFT_2, RIGHT_2, LEFT_RIGHT_CONSTRAINT_LOCKING, LEFT_RIGHT_CONNECTION_LOCKING, EDGE_LENGTH])));
}

var $MAP_14;
function $clinit_HorizontalGraphCompactor(){
  $clinit_HorizontalGraphCompactor = emptyMethod;
  NETWORK_SIMPLEX_COMPACTION = new NetworkSimplexCompaction;
  EDGE_AWARE_SCANLINE_CONSTRAINTS = new HorizontalGraphCompactor$EdgeAwareScanlineConstraintCalculation;
}

function HorizontalGraphCompactor(){
  $clinit_HorizontalGraphCompactor();
  this.specialSpacingsHandler = new HorizontalGraphCompactor$1(this);
}

defineClass(455, 1, $intern_56, HorizontalGraphCompactor);
_.process = function process_44(layeredGraph, progressMonitor){
  var odc, strategy, transformer;
  strategy = castTo($getProperty(layeredGraph, ($clinit_Properties() , POST_COMPACTION)), 125);
  if (strategy == ($clinit_GraphCompactionStrategy() , NONE_1)) {
    return;
  }
  $begin(progressMonitor, 'Horizontal Compaction', 1);
  this.lGraph = layeredGraph;
  transformer = new LGraphToCGraphTransformer;
  odc = new OneDimensionalCompactor($transform_2(transformer, layeredGraph));
  $setSpacingsHandler(odc, this.specialSpacingsHandler);
  switch (castTo($getProperty(layeredGraph, POST_COMPACTION_COSTRAINTS), 175).ordinal) {
    case 1:
      $setConstraintAlgorithm(odc, EDGE_AWARE_SCANLINE_CONSTRAINTS);
      break;
    default:$setConstraintAlgorithm(odc, ($clinit_OneDimensionalCompactor() , QUADRATIC_CONSTRAINTS));
  }
  switch (strategy.ordinal) {
    case 1:
      $compact_1(odc);
      break;
    case 2:
      $compact_1($changeDirection(odc, ($clinit_Direction() , RIGHT_0)));
      break;
    case 3:
      $compact_1($applyLockingStrategy($changeDirection($compact_1(odc), ($clinit_Direction() , RIGHT_0))));
      break;
    case 4:
      $compact_1($applyLockingStrategy($setLockingStrategy($changeDirection($compact_1(odc), ($clinit_Direction() , RIGHT_0)), new HorizontalGraphCompactor$lambda$0$Type)));
      break;
    case 5:
      $compact_1($setCompactionAlgorithm(odc, NETWORK_SIMPLEX_COMPACTION));
  }
  $changeDirection(odc, ($clinit_Direction() , LEFT_0));
  odc.finished = true;
  $applyLayout_0(transformer);
  $done(progressMonitor);
}
;
var EDGE_AWARE_SCANLINE_CONSTRAINTS, NETWORK_SIMPLEX_COMPACTION;
var Lde_cau_cs_kieler_klay_layered_intermediate_compaction_HorizontalGraphCompactor_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate.compaction', 'HorizontalGraphCompactor', 455);
function HorizontalGraphCompactor$1(this$0){
  this.this$01 = this$0;
}

defineClass(462, 1, {}, HorizontalGraphCompactor$1);
_.getHorizontalSpacing = function getHorizontalSpacing_4(cNode1, cNode2){
  var node1, node2, spacings;
  if (instanceOf(cNode1, 82) && instanceOf(cNode2, 82) && !$isEmpty(intersection(castTo(cNode1, 82).originalLEdges, castTo(cNode2, 82).originalLEdges))) {
    return 0;
  }
  node1 = null;
  instanceOf(cNode1, 93) && (node1 = castTo(cNode1, 93).lNode);
  node2 = null;
  instanceOf(cNode2, 93) && (node2 = castTo(cNode2, 93).lNode);
  if (!!node1 && node1.type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT) || !!node2 && node2.type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
    return 0;
  }
  spacings = castTo($getProperty(this.this$01.lGraph, ($clinit_InternalProperties() , SPACINGS)), 134);
  return $getHorizontalSpacing(spacings, node1?node1.type_0:($clinit_LNode$NodeType() , LONG_EDGE), node2?node2.type_0:($clinit_LNode$NodeType() , LONG_EDGE));
}
;
_.getVerticalSpacing = function getVerticalSpacing_4(cNode1, cNode2){
  if (instanceOf(cNode1, 82) && instanceOf(cNode2, 82) && !$isEmpty(intersection(castTo(cNode1, 82).originalLEdges, castTo(cNode2, 82).originalLEdges))) {
    return 1;
  }
  return min_1(cNode1.getVerticalSpacing_0(), cNode2.getVerticalSpacing_0());
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_compaction_HorizontalGraphCompactor$1_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate.compaction', 'HorizontalGraphCompactor/1', 462);
function $lambda$0(this$static, n_0){
  return $isHorizontal(this$static.compactor.direction)?n_0.getVerticalSpacing_0():n_0.getHorizontalSpacing_0();
}

function HorizontalGraphCompactor$EdgeAwareScanlineConstraintCalculation(){
  ScanlineConstraintCalculator.call(this);
  this.defaultSpacingFun = new HorizontalGraphCompactor$EdgeAwareScanlineConstraintCalculation$lambda$0$Type(this);
}

defineClass(456, 317, {}, HorizontalGraphCompactor$EdgeAwareScanlineConstraintCalculation);
_.calculateConstraints = function calculateConstraints_1(theCompactor){
  var minSpacing, n, n$iterator;
  this.compactor = theCompactor;
  $sweep(this, new HorizontalGraphCompactor$EdgeAwareScanlineConstraintCalculation$lambda$1$Type, this.defaultSpacingFun);
  $sweep(this, new HorizontalGraphCompactor$EdgeAwareScanlineConstraintCalculation$lambda$2$Type, this.defaultSpacingFun);
  minSpacing = $intern_50;
  for (n$iterator = new ArrayList$1(this.compactor.cGraph.cNodes); n$iterator.i < n$iterator.this$01.array.length;) {
    n = castTo($next_8(n$iterator), 25);
    if (instanceOf(n, 93) && castTo(n, 93).lNode.type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
      continue;
    }
    minSpacing = min_1(minSpacing, checkNotNull_1($apply_9(this.defaultSpacingFun, n)));
  }
  minSpacing == $intern_50 && (minSpacing = 0);
  $sweep(this, new HorizontalGraphCompactor$EdgeAwareScanlineConstraintCalculation$lambda$3$Type, new HorizontalGraphCompactor$EdgeAwareScanlineConstraintCalculation$lambda$4$Type(minSpacing));
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_compaction_HorizontalGraphCompactor$EdgeAwareScanlineConstraintCalculation_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate.compaction', 'HorizontalGraphCompactor/EdgeAwareScanlineConstraintCalculation', 456);
function $apply_9(this$static, arg0){
  return $lambda$0(this$static.$$outer_0, arg0);
}

function HorizontalGraphCompactor$EdgeAwareScanlineConstraintCalculation$lambda$0$Type($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(457, 1, $intern_35, HorizontalGraphCompactor$EdgeAwareScanlineConstraintCalculation$lambda$0$Type);
_.apply_0 = function apply_45(arg0){
  return $apply_9(this, arg0);
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_compaction_HorizontalGraphCompactor$EdgeAwareScanlineConstraintCalculation$lambda$0$Type_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate.compaction', 'HorizontalGraphCompactor/EdgeAwareScanlineConstraintCalculation/lambda$0$Type', 457);
function HorizontalGraphCompactor$EdgeAwareScanlineConstraintCalculation$lambda$1$Type(){
}

defineClass(458, 1, $intern_52, HorizontalGraphCompactor$EdgeAwareScanlineConstraintCalculation$lambda$1$Type);
_.apply_1 = function apply_46(arg0){
  return instanceOf(castTo(arg0, 25), 82);
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_compaction_HorizontalGraphCompactor$EdgeAwareScanlineConstraintCalculation$lambda$1$Type_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate.compaction', 'HorizontalGraphCompactor/EdgeAwareScanlineConstraintCalculation/lambda$1$Type', 458);
function HorizontalGraphCompactor$EdgeAwareScanlineConstraintCalculation$lambda$2$Type(){
}

defineClass(459, 1, $intern_52, HorizontalGraphCompactor$EdgeAwareScanlineConstraintCalculation$lambda$2$Type);
_.apply_1 = function apply_47(arg0){
  return instanceOf(castTo(arg0, 25), 93);
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_compaction_HorizontalGraphCompactor$EdgeAwareScanlineConstraintCalculation$lambda$2$Type_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate.compaction', 'HorizontalGraphCompactor/EdgeAwareScanlineConstraintCalculation/lambda$2$Type', 459);
function HorizontalGraphCompactor$EdgeAwareScanlineConstraintCalculation$lambda$3$Type(){
}

defineClass(460, 1, $intern_52, HorizontalGraphCompactor$EdgeAwareScanlineConstraintCalculation$lambda$3$Type);
_.apply_1 = function apply_48(arg0){
  return true;
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_compaction_HorizontalGraphCompactor$EdgeAwareScanlineConstraintCalculation$lambda$3$Type_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate.compaction', 'HorizontalGraphCompactor/EdgeAwareScanlineConstraintCalculation/lambda$3$Type', 460);
function HorizontalGraphCompactor$EdgeAwareScanlineConstraintCalculation$lambda$4$Type(finalMinSpacing_0){
  this.finalMinSpacing_0 = finalMinSpacing_0;
}

defineClass(461, 1, $intern_35, HorizontalGraphCompactor$EdgeAwareScanlineConstraintCalculation$lambda$4$Type);
_.apply_0 = function apply_49(arg0){
  return this.finalMinSpacing_0;
}
;
_.finalMinSpacing_0 = 0;
var Lde_cau_cs_kieler_klay_layered_intermediate_compaction_HorizontalGraphCompactor$EdgeAwareScanlineConstraintCalculation$lambda$4$Type_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate.compaction', 'HorizontalGraphCompactor/EdgeAwareScanlineConstraintCalculation/lambda$4$Type', 461);
function HorizontalGraphCompactor$lambda$0$Type(){
}

defineClass(463, 1, $intern_35, HorizontalGraphCompactor$lambda$0$Type);
_.apply_0 = function apply_50(arg0){
  return $clinit_HorizontalGraphCompactor() , $clinit_Boolean() , $get_7(castTo(castTo(arg0, 27).first, 25).lock, castTo(castTo(arg0, 27).second, 59))?FALSE_0:TRUE_0;
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_compaction_HorizontalGraphCompactor$lambda$0$Type_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate.compaction', 'HorizontalGraphCompactor/lambda$0$Type', 463);
function $applyCommentPositions(this$static){
  var comment, e, e$iterator, offset, other;
  for (e$iterator = new AbstractHashMap$EntrySetIterator((new AbstractHashMap$EntrySet(this$static.commentOffsets)).this$01); e$iterator.hasNext;) {
    e = $next_6(e$iterator);
    comment = castTo(e.getKey(), 9);
    other = castTo(castTo(e.getValue(), 27).first, 9);
    offset = castTo(castTo(e.getValue(), 27).second, 10);
    $add_7($reset(comment.pos), $add_7($clone(other.pos), offset));
  }
}

function $applyExternalPortPositions(this$static, topLeft, bottomRight){
  var borderSpacing, cNode, cNode$iterator, lNode;
  borderSpacing = castTo($getProperty(this$static.layeredGraph, ($clinit_LayoutOptions() , BORDER_SPACING)), 15).value_0;
  for (cNode$iterator = new ArrayList$1(this$static.cGraph.cNodes); cNode$iterator.i < cNode$iterator.this$01.array.length;) {
    cNode = castTo($next_8(cNode$iterator), 25);
    if (instanceOf(cNode, 93)) {
      lNode = castTo(cNode, 93).lNode;
      if (lNode.type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
        switch (castTo($getProperty(lNode, ($clinit_InternalProperties() , EXT_PORT_SIDE)), 32).ordinal) {
          case 4:
            lNode.pos.x_0 = topLeft.x_0 - borderSpacing;
            break;
          case 2:
            lNode.pos.x_0 = bottomRight.x_0 + borderSpacing - (lNode.size_0.x_0 + lNode.margin.right);
            break;
          case 1:
            lNode.pos.y_0 = topLeft.y_0 - borderSpacing;
            break;
          case 3:
            lNode.pos.y_0 = bottomRight.y_0 + borderSpacing - (lNode.size_0.y_0 + lNode.margin.bottom);
        }
      }
    }
  }
}

function $applyLayout_0(this$static){
  var bottomRight, cNode, cNode$iterator, topLeft;
  $applyNodePositions(this$static);
  $applyCommentPositions(this$static);
  topLeft = new KVector_1($intern_50, $intern_50);
  bottomRight = new KVector_1($intern_51, $intern_51);
  for (cNode$iterator = new ArrayList$1(this$static.cGraph.cNodes); cNode$iterator.i < cNode$iterator.this$01.array.length;) {
    cNode = castTo($next_8(cNode$iterator), 25);
    topLeft.x_0 = min_1(topLeft.x_0, cNode.hitbox.x_0);
    topLeft.y_0 = min_1(topLeft.y_0, cNode.hitbox.y_0);
    bottomRight.x_0 = max_1(bottomRight.x_0, cNode.hitbox.x_0 + cNode.hitbox.width_0);
    bottomRight.y_0 = max_1(bottomRight.y_0, cNode.hitbox.y_0 + cNode.hitbox.height);
  }
  $add_7($reset(this$static.layeredGraph.offset), $negate(new KVector_1(topLeft.x_0, topLeft.y_0)));
  $add_7($reset(this$static.layeredGraph.size_0), $sub_0(new KVector_1(bottomRight.x_0, bottomRight.y_0), topLeft));
  $applyExternalPortPositions(this$static, topLeft, bottomRight);
  this$static.cGraph.cGroups.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
  this$static.cGraph.cNodes.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
}

function $applyNodePositions(this$static){
  var cNode, cNode$iterator;
  for (cNode$iterator = new ArrayList$1(this$static.cGraph.cNodes); cNode$iterator.i < cNode$iterator.this$01.array.length;) {
    cNode = castTo($next_8(cNode$iterator), 25);
    cNode.applyElementPosition();
  }
}

function $groupCNodes(this$static){
  var cNode, cNode$iterator, cNode$iterator0, cNode$iterator1;
  this$static.cGraph.cGroups.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
  for (cNode$iterator0 = new ArrayList$1(this$static.cGraph.cNodes); cNode$iterator0.i < cNode$iterator0.this$01.array.length;) {
    cNode = castTo($next_8(cNode$iterator0), 25);
    cNode.cGroup = null;
  }
  for (cNode$iterator1 = new ArrayList$1(this$static.cGraph.cNodes); cNode$iterator1.i < cNode$iterator1.this$01.array.length;) {
    cNode = castTo($next_8(cNode$iterator1), 25);
    !cNode.parentNode && $add_11(this$static.cGraph.cGroups, new CGroup(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_compaction_oned_CNode_2_classLit, 1), $intern_12, 25, 0, [cNode])));
  }
  for (cNode$iterator = new ArrayList$1(this$static.cGraph.cNodes); cNode$iterator.i < cNode$iterator.this$01.array.length;) {
    cNode = castTo($next_8(cNode$iterator), 25);
    !!cNode.parentNode && $addCNode(cNode.parentNode.cGroup, cNode);
  }
}

function $readNodes(this$static){
  var bend1, bend2, bends, c, cNode, cTargetNode, e, edge, edge$iterator, edge$iterator0, first, i, last, lastSegment, layer, layer$iterator, layer$iterator0, node, node$iterator, nodeMap, other, p, verticalSegment, verticalSegments, vs;
  verticalSegments = new ArrayList;
  this$static.cGraph.cNodes.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
  nodeMap = ($clinit_Maps() , new HashMap);
  for (layer$iterator0 = new ArrayList$1(this$static.layeredGraph.layers); layer$iterator0.i < layer$iterator0.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator0), 16);
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      if (unsafeCast(checkNotNull_1(castToBoolean($getProperty(node, ($clinit_LayoutOptions() , COMMENT_BOX)))))) {
        if (!isEmpty_12($getConnectedEdges(node))) {
          e = castTo(get_9($getConnectedEdges(node)), 12);
          other = e.source.owner;
          other == node && (other = e.target.owner);
          p = new Pair(other, $sub_0($clone(node.pos), other.pos));
          $put_2(this$static.commentOffsets, node, p);
          continue;
        }
      }
      cNode = new CLNode(node, this$static.layeredGraph);
      $add_11(this$static.cGraph.cNodes, cNode);
      $put_5(nodeMap.hashCodeMap, node, cNode);
    }
  }
  for (layer$iterator = new ArrayList$1(this$static.layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator), 16);
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      cNode = castTo(getEntryValueOrNull($getEntry(nodeMap.hashCodeMap, node)), 25);
      for (edge$iterator0 = $iterator($getOutgoingEdges_0(node)); $hasNext_0(edge$iterator0);) {
        edge = castTo($next_2(edge$iterator0), 12);
        bends = $listIterator_2(edge.bendPoints, 0);
        first = true;
        lastSegment = null;
        if (bends.currentNode != bends.this$01.tail) {
          bend1 = castTo($next_11(bends), 10);
          if (edge.source.side == ($clinit_PortSide() , NORTH)) {
            vs = new VerticalSegment(bend1, new KVector_1(bend1.x_0, cNode.hitbox.y_0), cNode, edge);
            vs.blockBottomSpacing = true;
            verticalSegments.array[verticalSegments.array.length] = vs;
          }
          if (edge.source.side == SOUTH) {
            vs = new VerticalSegment(bend1, new KVector_1(bend1.x_0, cNode.hitbox.y_0 + cNode.hitbox.height), cNode, edge);
            vs.blockTopSpacing = true;
            verticalSegments.array[verticalSegments.array.length] = vs;
          }
          while (bends.currentNode != bends.this$01.tail) {
            bend2 = castTo($next_11(bends), 10);
            if (!eq(bend1.y_0, bend2.y_0)) {
              lastSegment = new VerticalSegment(bend1, bend2, null, edge);
              verticalSegments.array[verticalSegments.array.length] = lastSegment;
              if (first) {
                first = false;
                if (bend2.y_0 < cNode.hitbox.y_0) {
                  lastSegment.blockBottomSpacing = true;
                }
                 else if (bend2.y_0 > cNode.hitbox.y_0 + cNode.hitbox.height) {
                  lastSegment.blockTopSpacing = true;
                }
                 else {
                  lastSegment.blockTopSpacing = true;
                  lastSegment.blockBottomSpacing = true;
                }
              }
            }
            bends.currentNode != bends.this$01.tail && (bend1 = bend2);
          }
          if (lastSegment) {
            cTargetNode = castTo($get_9(nodeMap, edge.target.owner), 25);
            if (bend1.y_0 < cTargetNode.hitbox.y_0) {
              lastSegment.blockBottomSpacing = true;
            }
             else if (bend1.y_0 > cTargetNode.hitbox.y_0 + cTargetNode.hitbox.height) {
              lastSegment.blockTopSpacing = true;
            }
             else {
              lastSegment.blockTopSpacing = true;
              lastSegment.blockBottomSpacing = true;
            }
          }
        }
      }
      for (edge$iterator = $iterator($getIncomingEdges_0(node)); $hasNext_0(edge$iterator);) {
        edge = castTo($next_2(edge$iterator), 12);
        if (edge.bendPoints.size_0 != 0) {
          bend1 = castTo($getLast(edge.bendPoints), 10);
          if (edge.target.side == ($clinit_PortSide() , NORTH)) {
            vs = new VerticalSegment(bend1, new KVector_1(bend1.x_0, cNode.hitbox.y_0), cNode, edge);
            vs.blockBottomSpacing = true;
            verticalSegments.array[verticalSegments.array.length] = vs;
          }
          if (edge.target.side == SOUTH) {
            vs = new VerticalSegment(bend1, new KVector_1(bend1.x_0, cNode.hitbox.y_0 + cNode.hitbox.height), cNode, edge);
            vs.blockTopSpacing = true;
            verticalSegments.array[verticalSegments.array.length] = vs;
          }
        }
      }
    }
  }
  if (verticalSegments.array.length != 0) {
    $clinit_Collections();
    sort_1(verticalSegments, null);
    last = (checkCriticalElementIndex(0, verticalSegments.array.length) , castTo(verticalSegments.array[0], 142));
    c = new CLEdge(last, this$static.layeredGraph);
    for (i = 1; i < verticalSegments.array.length; i++) {
      verticalSegment = (checkCriticalElementIndex(i, verticalSegments.array.length) , castTo(verticalSegments.array[i], 142));
      if (eq(c.hitbox.x_0, verticalSegment.x1) && !(lt_0(c.hitbox.y_0 + c.hitbox.height, verticalSegment.y1) || lt_0(verticalSegment.y2, c.hitbox.y_0))) {
        $addSegment(c, verticalSegment);
      }
       else {
        $add_11(this$static.cGraph.cNodes, c);
        c = new CLEdge(verticalSegment, this$static.layeredGraph);
      }
    }
    $add_11(this$static.cGraph.cNodes, c);
  }
  verticalSegments.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
  $groupCNodes(this$static);
}

function $transform_2(this$static, inputGraph){
  var l, l$iterator, n, n$iterator, supportedDirections;
  this$static.layeredGraph = inputGraph;
  $reset_3(this$static.commentOffsets);
  this$static.hasEdges = false;
  outer: for (l$iterator = new ArrayList$1(this$static.layeredGraph.layers); l$iterator.i < l$iterator.this$01.array.length;) {
    l = castTo($next_8(l$iterator), 16);
    for (n$iterator = new ArrayList$1(l.nodes); n$iterator.i < n$iterator.this$01.array.length;) {
      n = castTo($next_8(n$iterator), 9);
      if (!isEmpty_12($getConnectedEdges(n))) {
        this$static.hasEdges = true;
        break outer;
      }
    }
  }
  supportedDirections = of_4(($clinit_Direction() , UNDEFINED), stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_kiml_options_Direction_2_classLit, 1), $intern_13, 59, 0, [LEFT_0, RIGHT_0]));
  if (!this$static.hasEdges) {
    $add_17(supportedDirections, UP);
    $add_17(supportedDirections, DOWN);
  }
  this$static.cGraph = new CGraph(supportedDirections);
  $readNodes(this$static);
  return this$static.cGraph;
}

function LGraphToCGraphTransformer(){
  this.commentOffsets = ($clinit_Maps() , new HashMap);
}

defineClass(553, 1, {}, LGraphToCGraphTransformer);
_.hasEdges = false;
var Lde_cau_cs_kieler_klay_layered_intermediate_compaction_LGraphToCGraphTransformer_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate.compaction', 'LGraphToCGraphTransformer', 553);
function $addArtificialSourceNode(this$static){
  var dummySource, n, n$iterator, sources, src_0, src$iterator;
  sources = new LinkedList;
  for (n$iterator = new ArrayList$1(this$static.networkSimplexGraph.nodes); n$iterator.i < n$iterator.this$01.array.length;) {
    n = castTo($next_8(n$iterator), 61);
    n.incomingEdges.array.length == 0 && ($addNode_0(sources, n, sources.tail.prev, sources.tail) , true);
  }
  if (sources.size_0 > 1) {
    dummySource = $create_1($id(new NNode$NNodeBuilder, this$static.index_0++), this$static.networkSimplexGraph);
    for (src$iterator = $listIterator_2(sources, 0); src$iterator.currentNode != src$iterator.this$01.tail;) {
      src_0 = castTo($next_11(src$iterator), 61);
      $create_0($target($source($weight($delta(new NEdge$NEdgeBuilder, 1), 0), dummySource), src_0));
    }
  }
}

function $addEdgeConstraints(this$static){
  var cNode, cNode$iterator, cNode$iterator0, e, e$iterator, entry, lEdge, lEdge$iterator, lEdgeMap, lNode, lNodeMap, n, n$iterator, outerIter, src_0, srcPort, target, tgt, tgtPort;
  lNodeMap = ($clinit_Maps() , new HashMap);
  lEdgeMap = new HashMultimap;
  for (cNode$iterator0 = new ArrayList$1(this$static.compactor.cGraph.cNodes); cNode$iterator0.i < cNode$iterator0.this$01.array.length;) {
    cNode = castTo($next_8(cNode$iterator0), 25);
    if (instanceOf(cNode, 93)) {
      lNode = castTo(cNode, 93).lNode;
      $put_5(lNodeMap.hashCodeMap, lNode, cNode);
    }
     else if (instanceOf(cNode, 82)) {
      for (e$iterator = (outerIter = (new AbstractMap$1(castTo(cNode, 82).originalLEdges.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter)); e$iterator.val$outerIter2.hasNext_0();) {
        e = (entry = castTo(e$iterator.val$outerIter2.next_1(), 21) , castTo(entry.getKey(), 12));
        $put(lEdgeMap, e, cNode);
      }
    }
  }
  for (cNode$iterator = new ArrayList$1(this$static.compactor.cGraph.cNodes); cNode$iterator.i < cNode$iterator.this$01.array.length;) {
    cNode = castTo($next_8(cNode$iterator), 25);
    if (instanceOf(cNode, 93)) {
      lNode = castTo(cNode, 93).lNode;
      for (lEdge$iterator = $iterator($getOutgoingEdges_0(lNode)); $hasNext_0(lEdge$iterator);) {
        lEdge = castTo($next_2(lEdge$iterator), 12);
        if ($isSelfLoop(lEdge)) {
          continue;
        }
        srcPort = lEdge.source;
        tgtPort = lEdge.target;
        if (($clinit_PortSide() , SIDES_NORTH_SOUTH).contains(lEdge.source.side) && SIDES_NORTH_SOUTH.contains(lEdge.target.side)) {
          continue;
        }
        target = castTo($get_9(lNodeMap, lEdge.target.owner), 25);
        $create_0($target($source($weight($delta(new NEdge$NEdgeBuilder, 0), 100), this$static.nNodes[cNode.cGroup.id_0]), this$static.nNodes[target.cGroup.id_0]));
        if (srcPort.side == WEST && $apply_0(($clinit_LPort() , OUTPUT_PREDICATE , srcPort))) {
          for (n$iterator = castTo($get(lEdgeMap, lEdge), 18).iterator_0(); n$iterator.hasNext_0();) {
            n = castTo(n$iterator.next_1(), 25);
            if (n.hitbox.x_0 < cNode.hitbox.x_0) {
              src_0 = this$static.nNodes[n.cGroup.id_0];
              tgt = this$static.nNodes[cNode.cGroup.id_0];
              if (src_0 == tgt) {
                continue;
              }
              $create_0($target($source($weight($delta(new NEdge$NEdgeBuilder, 1), 100), src_0), tgt));
            }
          }
        }
        if (tgtPort.side == EAST && $apply_1(($clinit_LPort() , INPUT_PREDICATE , tgtPort))) {
          for (n$iterator = castTo($get(lEdgeMap, lEdge), 18).iterator_0(); n$iterator.hasNext_0();) {
            n = castTo(n$iterator.next_1(), 25);
            if (n.hitbox.x_0 > cNode.hitbox.x_0) {
              src_0 = this$static.nNodes[cNode.cGroup.id_0];
              tgt = this$static.nNodes[n.cGroup.id_0];
              if (src_0 == tgt) {
                continue;
              }
              $create_0($target($source($weight($delta(new NEdge$NEdgeBuilder, 1), 100), src_0), tgt));
            }
          }
        }
      }
    }
  }
}

function $addSeparationConstraints(this$static){
  var cNode, cNode$iterator, delta, helper, incNode, incNode$iterator, offsetDelta, spacing, weight;
  for (cNode$iterator = new ArrayList$1(this$static.compactor.cGraph.cNodes); cNode$iterator.i < cNode$iterator.this$01.array.length;) {
    cNode = castTo($next_8(cNode$iterator), 25);
    for (incNode$iterator = cNode.constraints.iterator_0(); incNode$iterator.hasNext_0();) {
      incNode = castTo(incNode$iterator.next_1(), 25);
      if (cNode.cGroup == incNode.cGroup) {
        continue;
      }
      $isHorizontal(this$static.compactor.direction)?(spacing = this$static.compactor.spacingsHandler.getHorizontalSpacing(cNode, incNode)):(spacing = this$static.compactor.spacingsHandler.getVerticalSpacing(cNode, incNode));
      delta = cNode.cGroupOffset.x_0 + cNode.hitbox.width_0 + spacing - incNode.cGroupOffset.x_0;
      delta = Math.ceil(delta);
      delta = 0 > delta?0:delta;
      if (!!cNode.parentNode && !!incNode.parentNode && instanceOf(cNode, 82) && instanceOf(incNode, 82) && !$isEmpty(intersection(castTo(cNode, 82).originalLEdges, castTo(incNode, 82).originalLEdges))) {
        helper = $create_1(new NNode$NNodeBuilder, this$static.networkSimplexGraph);
        offsetDelta = round_int(ceil_0(incNode.cGroupOffset.x_0 - cNode.cGroupOffset.x_0));
        $create_0($target($source($weight($delta(new NEdge$NEdgeBuilder, 0 > offsetDelta?0:offsetDelta), 1), helper), this$static.nNodes[cNode.cGroup.id_0]));
        $create_0($target($source($weight($delta(new NEdge$NEdgeBuilder, 0 > -offsetDelta?0:-offsetDelta), 1), helper), this$static.nNodes[incNode.cGroup.id_0]));
      }
       else {
        weight = 1;
        (instanceOf(cNode, 82) && instanceOf(incNode, 93) || instanceOf(incNode, 82) && instanceOf(cNode, 93)) && (weight = 2);
        $create_0($target($source($weight($delta(new NEdge$NEdgeBuilder, round_int(delta)), weight), this$static.nNodes[cNode.cGroup.id_0]), this$static.nNodes[incNode.cGroup.id_0]));
      }
    }
  }
}

function NetworkSimplexCompaction(){
}

defineClass(552, 1, {}, NetworkSimplexCompaction);
_.compact = function compact_0(theCompactor){
  var cGroup, cGroup$iterator, cNode, cNode$iterator, nNode;
  this.compactor = theCompactor;
  this.networkSimplexGraph = new NGraph;
  this.nNodes = initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_networksimplex_NNode_2_classLit, $intern_12, 61, this.compactor.cGraph.cGroups.array.length, 0, 1);
  this.index_0 = 0;
  for (cGroup$iterator = new ArrayList$1(this.compactor.cGraph.cGroups); cGroup$iterator.i < cGroup$iterator.this$01.array.length;) {
    cGroup = castTo($next_8(cGroup$iterator), 78);
    cGroup.id_0 = this.index_0;
    nNode = $create_1($origin($id(new NNode$NNodeBuilder, this.index_0), cGroup), this.networkSimplexGraph);
    this.nNodes[this.index_0] = nNode;
    ++this.index_0;
  }
  $addSeparationConstraints(this);
  $addEdgeConstraints(this);
  $addArtificialSourceNode(this);
  $execute(forGraph(this.networkSimplexGraph), new BasicProgressMonitor);
  for (cNode$iterator = new ArrayList$1(this.compactor.cGraph.cNodes); cNode$iterator.i < cNode$iterator.this$01.array.length;) {
    cNode = castTo($next_8(cNode$iterator), 25);
    cNode.startPos = this.nNodes[cNode.cGroup.id_0].layer + cNode.cGroupOffset.x_0;
    cNode.hitbox.x_0 = cNode.startPos;
  }
}
;
_.index_0 = 0;
var Lde_cau_cs_kieler_klay_layered_intermediate_compaction_NetworkSimplexCompaction_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate.compaction', 'NetworkSimplexCompaction', 552);
function $compareTo_1(this$static, o){
  var d;
  d = compare_31(this$static.x1, o.x1);
  if (d == 0) {
    return compare_31(this$static.y1, o.y1);
  }
  return d;
}

function VerticalSegment(bend1, bend2, cNode, lEdge){
  var inJPs, jp, jp$iterator;
  this.junctionPoints = new KVectorChain;
  this.bend1 = bend1;
  this.bend2 = bend2;
  if (bend1.y_0 < bend2.y_0) {
    this.x1 = bend1.x_0;
    this.y1 = bend1.y_0;
    this.y2 = bend2.y_0;
  }
   else {
    this.x1 = bend2.x_0;
    this.y1 = bend2.y_0;
    this.y2 = bend1.y_0;
  }
  inJPs = castTo($getProperty(lEdge, ($clinit_LayoutOptions() , JUNCTION_POINTS)), 44);
  if (inJPs) {
    for (jp$iterator = $listIterator_2(inJPs, 0); jp$iterator.currentNode != jp$iterator.this$01.tail;) {
      jp = castTo($next_11(jp$iterator), 10);
      eq(jp.x_0, bend1.x_0) && $add_8(this.junctionPoints, jp);
    }
  }
  this.parentNode = cNode;
  !!this.parentNode && (this.relativePosition = this.x1 - cNode.hitbox.x_0);
  this.lEdge = lEdge;
}

defineClass(142, 1, {142:1, 23:1}, VerticalSegment);
_.compareTo = function compareTo_3(o){
  return $compareTo_1(this, castTo(o, 142));
}
;
_.blockBottomSpacing = false;
_.blockTopSpacing = true;
_.relativePosition = 0;
_.x1 = 0;
_.y1 = 0;
_.y2 = 0;
var Lde_cau_cs_kieler_klay_layered_intermediate_compaction_VerticalSegment_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate.compaction', 'VerticalSegment', 142);
function $countAllCrossingsInGraphWithOrder(this$static, currentOrder){
  var easternLayer, layerIndex, totalCrossings, westernLayer;
  totalCrossings = 0;
  for (layerIndex = 0; layerIndex < currentOrder.length; layerIndex++) {
    easternLayer = currentOrder[layerIndex];
    if (layerIndex < currentOrder.length - 1) {
      westernLayer = currentOrder[layerIndex + 1];
      totalCrossings += $countBetweenLayerCrossingsInOrder(this$static, easternLayer, westernLayer);
    }
    totalCrossings += (this$static.northSouthPortCrossingCounter = new NorthSouthEdgeAllCrossingsCounter(easternLayer) , $countCrossings_0(this$static.northSouthPortCrossingCounter));
    totalCrossings += (this$static.inLayerEdgeCrossingsCounter = new InLayerEdgeAllCrossingsCounter(easternLayer) , $countCrossings(this$static.inLayerEdgeCrossingsCounter));
  }
  return totalCrossings;
}

function $countBetweenLayerCrossingsInOrder(this$static, easternLayer, westernLayer){
  if (easternLayer.length == 0 || westernLayer.length == 0) {
    return 0;
  }
  this$static.useHyperedgeCounter?(this$static.inbetweenLayerCounter = new BetweenLayerHyperedgeAllCrossingsCounter(this$static.layeredGraph)):(this$static.inbetweenLayerCounter = new BetweenLayerStraightEdgeAllCrossingsCounter(this$static.layeredGraph));
  return this$static.inbetweenLayerCounter.countCrossings(easternLayer, westernLayer);
}

function AllCrossingsCounter(layeredGraph){
  this.layeredGraph = layeredGraph;
  this.useHyperedgeCounter = false;
}

defineClass(586, 1, {}, AllCrossingsCounter);
_.useHyperedgeCounter = false;
var Lde_cau_cs_kieler_klay_layered_intermediate_greedyswitch_AllCrossingsCounter_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate.greedyswitch', 'AllCrossingsCounter', 586);
function $initialize(this$static, graph){
  var layer, layer$index, layer$max, node, node$index, node$max, port, port$iterator, portCount;
  portCount = 0;
  for (layer$index = 0 , layer$max = graph.length; layer$index < layer$max; ++layer$index) {
    layer = graph[layer$index];
    for (node$index = 0 , node$max = layer.length; node$index < node$max; ++node$index) {
      node = layer[node$index];
      for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
        port = castTo($next_8(port$iterator), 7);
        port.id_0 = portCount++;
      }
    }
  }
  this$static.portPos = initUnidimensionalArray(I_classLit, $intern_37, 26, portCount, 12, 1);
}

function BetweenLayerEdgeAllCrossingsCounter(graph){
  $initialize(this, graph);
}

defineClass(339, 1, {});
var Lde_cau_cs_kieler_klay_layered_intermediate_greedyswitch_BetweenLayerEdgeAllCrossingsCounter_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate.greedyswitch', 'BetweenLayerEdgeAllCrossingsCounter', 339);
function $addEasternCrossings(this$static, upperNode, lowerNode){
  this$static.upperAdjacencies = $getAdjacencyFor(this$static, upperNode, ($clinit_PortSide() , EAST), this$static.easternAdjacencies);
  this$static.lowerAdjacencies = $getAdjacencyFor(this$static, lowerNode, EAST, this$static.easternAdjacencies);
  if (this$static.upperAdjacencies.currentSize == 0 || this$static.lowerAdjacencies.currentSize == 0) {
    return;
  }
  $countCrossingsByMergingAdjacencyLists(this$static);
}

function $addWesternCrossings(this$static, upperNode, lowerNode){
  this$static.upperAdjacencies = $getAdjacencyFor(this$static, upperNode, ($clinit_PortSide() , WEST), this$static.westernAdjacencies);
  this$static.lowerAdjacencies = $getAdjacencyFor(this$static, lowerNode, WEST, this$static.westernAdjacencies);
  if (this$static.upperAdjacencies.currentSize == 0 || this$static.lowerAdjacencies.currentSize == 0) {
    return;
  }
  $countCrossingsByMergingAdjacencyLists(this$static);
}

function $countBothSideCrossings(this$static, upperNode, lowerNode){
  this$static.upperLowerCrossings = 0;
  this$static.lowerUpperCrossings = 0;
  if (upperNode == lowerNode) {
    return;
  }
  $addWesternCrossings(this$static, upperNode, lowerNode);
  $addEasternCrossings(this$static, upperNode, lowerNode);
}

function $countCrossingsByMergingAdjacencyLists(this$static){
  while (this$static.upperAdjacencies.currentSize != 0 && this$static.lowerAdjacencies.currentSize != 0) {
    if ($currentAdjacency(this$static.upperAdjacencies).position > $currentAdjacency(this$static.lowerAdjacencies).position) {
      this$static.upperLowerCrossings += this$static.upperAdjacencies.currentSize;
      $removeFirst_0(this$static.lowerAdjacencies);
    }
     else if ($currentAdjacency(this$static.lowerAdjacencies).position > $currentAdjacency(this$static.upperAdjacencies).position) {
      this$static.lowerUpperCrossings += this$static.lowerAdjacencies.currentSize;
      $removeFirst_0(this$static.upperAdjacencies);
    }
     else {
      this$static.upperLowerCrossings += $countAdjacenciesBelowNodeOfFirstPort(this$static.upperAdjacencies);
      this$static.lowerUpperCrossings += $countAdjacenciesBelowNodeOfFirstPort(this$static.lowerAdjacencies);
      $removeFirst_0(this$static.upperAdjacencies);
      $removeFirst_0(this$static.lowerAdjacencies);
    }
  }
}

function $countEasternEdgeCrossings(this$static, upperNode, lowerNode){
  this$static.upperLowerCrossings = 0;
  this$static.lowerUpperCrossings = 0;
  if (upperNode == lowerNode) {
    return;
  }
  $addEasternCrossings(this$static, upperNode, lowerNode);
}

function $countWesternEdgeCrossings(this$static, upperNode, lowerNode){
  this$static.upperLowerCrossings = 0;
  this$static.lowerUpperCrossings = 0;
  if (upperNode == lowerNode) {
    return;
  }
  $addWesternCrossings(this$static, upperNode, lowerNode);
}

function $getAdjacencyFor(this$static, node, side, adjacencies){
  var aL, n, n$array, n$index, n$max;
  if (adjacencies.hashCodeMap.size_0 + adjacencies.stringMap.size_0 == 0) {
    for (n$array = this$static.currentNodeOrder[this$static.freeLayerIndex] , n$index = 0 , n$max = n$array.length; n$index < n$max; ++n$index) {
      n = n$array[n$index];
      $put_2(adjacencies, n, new BetweenLayerEdgeTwoNodeCrossingsCounter$AdjacencyList(this$static, n, side));
    }
  }
  aL = castTo(getEntryValueOrNull($getEntry(adjacencies.hashCodeMap, node)), 284);
  aL.currentIndex = 0;
  aL.currentSize = aL.size_0;
  aL.currentSize == 0 || $reset_2(castTo($get_8(aL.adjacencyList, aL.currentIndex), 128));
  return aL;
}

function $setPortPositionsForLayer(this$static, layerIndex, portSide){
  var node, node$array, node$index, node$max, port, port$iterator, portId, ports;
  portId = 0;
  for (node$array = this$static.currentNodeOrder[layerIndex] , node$index = 0 , node$max = node$array.length; node$index < node$max; ++node$index) {
    node = node$array[node$index];
    ports = new PortIterable(node, portSide);
    for (port$iterator = $iterator_4(ports); port$iterator.hasNext_0();) {
      port = castTo(port$iterator.next_1(), 7);
      $put_2(this$static.portPositions, port, valueOf_0(portId));
      $isOrderFixed(castTo($getProperty(node, ($clinit_LayoutOptions() , PORT_CONSTRAINTS)), 28)) && ++portId;
    }
    $isOrderFixed(castTo($getProperty(node, ($clinit_LayoutOptions() , PORT_CONSTRAINTS)), 28)) || ++portId;
  }
}

function BetweenLayerEdgeTwoNodeCrossingsCounter(currentNodeOrder, freeLayerIndex){
  this.portPositions = ($clinit_Maps() , new HashMap);
  this.easternAdjacencies = new HashMap;
  this.westernAdjacencies = new HashMap;
  this.currentNodeOrder = currentNodeOrder;
  this.freeLayerIndex = freeLayerIndex;
  this.freeLayerIndex > 0 && $setPortPositionsForLayer(this, this.freeLayerIndex - 1, ($clinit_PortSide() , EAST));
  this.freeLayerIndex < this.currentNodeOrder.length - 1 && $setPortPositionsForLayer(this, this.freeLayerIndex + 1, ($clinit_PortSide() , WEST));
}

defineClass(612, 1, {}, BetweenLayerEdgeTwoNodeCrossingsCounter);
_.freeLayerIndex = 0;
_.lowerUpperCrossings = 0;
_.upperLowerCrossings = 0;
var Lde_cau_cs_kieler_klay_layered_intermediate_greedyswitch_BetweenLayerEdgeTwoNodeCrossingsCounter_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate.greedyswitch', 'BetweenLayerEdgeTwoNodeCrossingsCounter', 612);
function $addAdjacencyOf(this$static, edge){
  var adjacentPort, adjacentPortPosition, lastIndex;
  adjacentPort = $adjacentPortOf(edge, this$static.side);
  adjacentPortPosition = castTo($get_9(this$static.this$01.portPositions, adjacentPort), 24).value_0;
  lastIndex = this$static.adjacencyList.array.length - 1;
  if (this$static.adjacencyList.array.length != 0 && castTo($get_8(this$static.adjacencyList, lastIndex), 128).position == adjacentPortPosition) {
    ++castTo($get_8(this$static.adjacencyList, lastIndex), 128).cardinality;
    ++castTo($get_8(this$static.adjacencyList, lastIndex), 128).currentCardinality;
  }
   else {
    $add_11(this$static.adjacencyList, new BetweenLayerEdgeTwoNodeCrossingsCounter$AdjacencyList$Adjacency(adjacentPortPosition));
  }
}

function $adjacentPortOf(e, s){
  return s == ($clinit_PortSide() , WEST)?e.source:e.target;
}

function $countAdjacenciesBelowNodeOfFirstPort(this$static){
  return this$static.currentSize - castTo($get_8(this$static.adjacencyList, this$static.currentIndex), 128).currentCardinality;
}

function $currentAdjacency(this$static){
  return castTo($get_8(this$static.adjacencyList, this$static.currentIndex), 128);
}

function $iterateTroughEdgesCollectingAdjacencies(this$static){
  var edge, edge$iterator, edges, port, port$iterator, ports;
  ports = new PortIterable(this$static.node, this$static.side);
  for (port$iterator = $iterator_4(ports); port$iterator.hasNext_0();) {
    port = castTo(port$iterator.next_1(), 7);
    edges = this$static.side == ($clinit_PortSide() , WEST)?port.incomingEdges:port.outgoingEdges;
    for (edge$iterator = new ArrayList$1(edges); edge$iterator.i < edge$iterator.this$01.array.length;) {
      edge = castTo($next_8(edge$iterator), 12);
      if (!$isSelfLoop(edge) && edge.source.owner.layer != edge.target.owner.layer) {
        $addAdjacencyOf(this$static, edge);
        ++this$static.size_0;
        ++this$static.currentSize;
      }
    }
  }
}

function $removeFirst_0(this$static){
  var currentEntry;
  if (this$static.currentSize == 0) {
    return;
  }
  currentEntry = castTo($get_8(this$static.adjacencyList, this$static.currentIndex), 128);
  currentEntry.currentCardinality == 1?(++this$static.currentIndex , this$static.currentIndex < this$static.adjacencyList.array.length && $reset_2(castTo($get_8(this$static.adjacencyList, this$static.currentIndex), 128))):--currentEntry.currentCardinality;
  --this$static.currentSize;
}

function BetweenLayerEdgeTwoNodeCrossingsCounter$AdjacencyList(this$0, node, side){
  this.this$01 = this$0;
  this.node = node;
  this.side = side;
  this.adjacencyList = new ArrayList;
  $iterateTroughEdgesCollectingAdjacencies(this);
  $clinit_Collections();
  sort_1(this.adjacencyList, null);
}

defineClass(284, 1, {284:1}, BetweenLayerEdgeTwoNodeCrossingsCounter$AdjacencyList);
_.toString_0 = function toString_59(){
  return 'AdjacencyList [node=' + this.node + ', adjacencies= ' + this.adjacencyList + ']';
}
;
_.currentIndex = 0;
_.currentSize = 0;
_.size_0 = 0;
var Lde_cau_cs_kieler_klay_layered_intermediate_greedyswitch_BetweenLayerEdgeTwoNodeCrossingsCounter$AdjacencyList_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate.greedyswitch', 'BetweenLayerEdgeTwoNodeCrossingsCounter/AdjacencyList', 284);
function $compareTo_2(this$static, o){
  return this$static.position < o.position?-1:this$static.position == o.position?0:1;
}

function $reset_2(this$static){
  this$static.currentCardinality = this$static.cardinality;
}

function BetweenLayerEdgeTwoNodeCrossingsCounter$AdjacencyList$Adjacency(adjacentPortPosition){
  this.position = adjacentPortPosition;
  this.cardinality = 1;
  this.currentCardinality = 1;
}

defineClass(128, 1, {128:1, 23:1}, BetweenLayerEdgeTwoNodeCrossingsCounter$AdjacencyList$Adjacency);
_.compareTo = function compareTo_4(o){
  return $compareTo_2(this, castTo(o, 128));
}
;
_.toString_0 = function toString_60(){
  return 'Adjacency [position=' + this.position + ', cardinality=' + this.cardinality + ', currentCardinality=' + this.currentCardinality + ']';
}
;
_.cardinality = 0;
_.currentCardinality = 0;
_.position = 0;
var Lde_cau_cs_kieler_klay_layered_intermediate_greedyswitch_BetweenLayerEdgeTwoNodeCrossingsCounter$AdjacencyList$Adjacency_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate.greedyswitch', 'BetweenLayerEdgeTwoNodeCrossingsCounter/AdjacencyList/Adjacency', 128);
function BetweenLayerHyperedgeAllCrossingsCounter(graph){
  BetweenLayerEdgeAllCrossingsCounter.call(this, graph);
}

defineClass(609, 339, {}, BetweenLayerHyperedgeAllCrossingsCounter);
_.countCrossings = function countCrossings(leftLayer, rightLayer){
  var compressDeltas, crossings, delta, edge, edge$iterator, element, element$index, element$max, firstIndex, he, he$index, he$max, hyperedge, hyperedgeSet, hyperedges, i, i0, i1, i2, i3, index_0, leftCorner, leftCorner$index, leftCorner$max, leftCorners, leftLayerRef, node, node$index, node$index0, node$index1, node$max, node$max0, node$max1, nodeEdges, northInputPorts, openHyperedges, otherInputPorts, p, p$iterator, port, port$iterator, port2HyperedgeMap, portEdges, portIter, pos, q, rightCorner, rightCorner$index, rightCorner$max, rightCorners, rightLayerRef, sourceCount, sourceHE, sourcePort, sourcePort$iterator, southSequence, targetCount, targetHE, targetPort, tree, treeSize;
  sourceCount = 0;
  for (node$index0 = 0 , node$max0 = leftLayer.length; node$index0 < node$max0; ++node$index0) {
    node = leftLayer[node$index0];
    if ($isOrderFixed(castTo($getProperty(node, ($clinit_LayoutOptions() , PORT_CONSTRAINTS)), 28))) {
      for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
        port = castTo($next_8(port$iterator), 7);
        portEdges = 0;
        for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
          edge = castTo($next_8(edge$iterator), 12);
          node.layer != edge.target.owner.layer && ++portEdges;
        }
        portEdges > 0 && (this.portPos[port.id_0] = sourceCount++);
      }
    }
     else {
      nodeEdges = 0;
      for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
        port = castTo($next_8(port$iterator), 7);
        for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
          edge = castTo($next_8(edge$iterator), 12);
          node.layer != edge.target.owner.layer && ++nodeEdges;
        }
        this.portPos[port.id_0] = sourceCount;
      }
      nodeEdges > 0 && ++sourceCount;
    }
  }
  targetCount = 0;
  for (node$index1 = 0 , node$max1 = rightLayer.length; node$index1 < node$max1; ++node$index1) {
    node = rightLayer[node$index1];
    if ($isOrderFixed(castTo($getProperty(node, ($clinit_LayoutOptions() , PORT_CONSTRAINTS)), 28))) {
      northInputPorts = 0;
      for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
        port = castTo($next_8(port$iterator), 7);
        if (port.side == ($clinit_PortSide() , NORTH)) {
          for (edge$iterator = new ArrayList$1(port.incomingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
            edge = castTo($next_8(edge$iterator), 12);
            if (node.layer != edge.source.owner.layer) {
              ++northInputPorts;
              break;
            }
          }
        }
         else {
          break;
        }
      }
      otherInputPorts = 0;
      portIter = new AbstractList$ListIteratorImpl(node.ports, node.ports.array.length);
      while (portIter.i > 0) {
        port = (checkCriticalElement(portIter.i > 0) , castTo(portIter.this$01.get_2(portIter.last = --portIter.i), 7));
        portEdges = 0;
        for (edge$iterator = new ArrayList$1(port.incomingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
          edge = castTo($next_8(edge$iterator), 12);
          node.layer != edge.source.owner.layer && ++portEdges;
        }
        if (portEdges > 0) {
          if (port.side == ($clinit_PortSide() , NORTH)) {
            this.portPos[port.id_0] = targetCount;
            ++targetCount;
          }
           else {
            this.portPos[port.id_0] = targetCount + northInputPorts + otherInputPorts;
            ++otherInputPorts;
          }
        }
      }
      targetCount += otherInputPorts;
    }
     else {
      nodeEdges = 0;
      for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
        port = castTo($next_8(port$iterator), 7);
        for (edge$iterator = new ArrayList$1(port.incomingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
          edge = castTo($next_8(edge$iterator), 12);
          node.layer != edge.source.owner.layer && ++nodeEdges;
        }
        this.portPos[port.id_0] = targetCount;
      }
      nodeEdges > 0 && ++targetCount;
    }
  }
  port2HyperedgeMap = new HashMap;
  hyperedgeSet = new HashSet;
  for (node$index = 0 , node$max = leftLayer.length; node$index < node$max; ++node$index) {
    node = leftLayer[node$index];
    for (sourcePort$iterator = new ArrayList$1(node.ports); sourcePort$iterator.i < sourcePort$iterator.this$01.array.length;) {
      sourcePort = castTo($next_8(sourcePort$iterator), 7);
      for (edge$iterator = new ArrayList$1(sourcePort.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
        edge = castTo($next_8(edge$iterator), 12);
        targetPort = edge.target;
        if (node.layer != targetPort.owner.layer) {
          sourceHE = castTo(getEntryValueOrNull($getEntry(port2HyperedgeMap.hashCodeMap, sourcePort)), 204);
          targetHE = castTo(getEntryValueOrNull($getEntry(port2HyperedgeMap.hashCodeMap, targetPort)), 204);
          if (!sourceHE && !targetHE) {
            hyperedge = new BetweenLayerHyperedgeAllCrossingsCounter$Hyperedge;
            hyperedgeSet.map_0.put(hyperedge, hyperedgeSet);
            $add_8(hyperedge.edges, edge);
            $add_8(hyperedge.ports, sourcePort);
            $put_5(port2HyperedgeMap.hashCodeMap, sourcePort, hyperedge);
            $add_8(hyperedge.ports, targetPort);
            $put_5(port2HyperedgeMap.hashCodeMap, targetPort, hyperedge);
          }
           else if (!sourceHE) {
            $add_8(targetHE.edges, edge);
            $add_8(targetHE.ports, sourcePort);
            $put_5(port2HyperedgeMap.hashCodeMap, sourcePort, targetHE);
          }
           else if (!targetHE) {
            $add_8(sourceHE.edges, edge);
            $add_8(sourceHE.ports, targetPort);
            $put_5(port2HyperedgeMap.hashCodeMap, targetPort, sourceHE);
          }
           else if (sourceHE == targetHE) {
            $add_8(sourceHE.edges, edge);
          }
           else {
            $add_8(sourceHE.edges, edge);
            for (p$iterator = $listIterator_2(targetHE.ports, 0); p$iterator.currentNode != p$iterator.this$01.tail;) {
              p = castTo($next_11(p$iterator), 7);
              $put_5(port2HyperedgeMap.hashCodeMap, p, sourceHE);
            }
            $addAll(sourceHE.edges, targetHE.edges);
            $addAll(sourceHE.ports, targetHE.ports);
            hyperedgeSet.map_0.remove_0(targetHE) != null;
          }
        }
      }
    }
  }
  hyperedges = castTo($toArray(hyperedgeSet, initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_intermediate_greedyswitch_BetweenLayerHyperedgeAllCrossingsCounter$Hyperedge_2_classLit, {674:1, 3:1, 5:1, 6:1}, 204, hyperedgeSet.map_0.size_1(), 0, 1)), 674);
  leftLayerRef = leftLayer[0].layer;
  rightLayerRef = rightLayer[0].layer;
  for (he$index = 0 , he$max = hyperedges.length; he$index < he$max; ++he$index) {
    he = hyperedges[he$index];
    he.upperLeft = sourceCount;
    he.upperRight = targetCount;
    for (port$iterator = $listIterator_2(he.ports, 0); port$iterator.currentNode != port$iterator.this$01.tail;) {
      port = castTo($next_11(port$iterator), 7);
      pos = this.portPos[port.id_0];
      if (port.owner.layer == leftLayerRef) {
        if (pos < he.upperLeft) {
          he.upperLeft = pos;
          he.hashCode = getObjectIdentityHashCode(port);
        }
        pos > he.lowerLeft && (he.lowerLeft = pos);
      }
       else if (port.owner.layer == rightLayerRef) {
        pos < he.upperRight && (he.upperRight = pos);
        pos > he.lowerRight && (he.lowerRight = pos);
      }
    }
  }
  mergeSort(hyperedges, 0, hyperedges.length, ($clinit_Comparators() , $clinit_Comparators() , NATURAL));
  southSequence = initUnidimensionalArray(I_classLit, $intern_37, 26, hyperedges.length, 12, 1);
  compressDeltas = initUnidimensionalArray(I_classLit, $intern_37, 26, targetCount + 1, 12, 1);
  for (i0 = 0; i0 < hyperedges.length; i0++) {
    southSequence[i0] = hyperedges[i0].upperRight;
    compressDeltas[southSequence[i0]] = 1;
  }
  delta = 0;
  for (i1 = 0; i1 < compressDeltas.length; i1++) {
    compressDeltas[i1] == 1?(compressDeltas[i1] = delta):--delta;
  }
  q = 0;
  for (i2 = 0; i2 < southSequence.length; i2++) {
    southSequence[i2] += compressDeltas[southSequence[i2]];
    q = max_3(q, southSequence[i2] + 1);
  }
  firstIndex = 1;
  while (firstIndex < q) {
    firstIndex *= 2;
  }
  treeSize = 2 * firstIndex - 1;
  firstIndex -= 1;
  tree = initUnidimensionalArray(I_classLit, $intern_37, 26, treeSize, 12, 1);
  crossings = 0;
  for (element$index = 0 , element$max = southSequence.length; element$index < element$max; ++element$index) {
    element = southSequence[element$index];
    index_0 = element + firstIndex;
    ++tree[index_0];
    while (index_0 > 0) {
      index_0 % 2 > 0 && (crossings += tree[index_0 + 1]);
      index_0 = (index_0 - 1) / 2 | 0;
      ++tree[index_0];
    }
  }
  leftCorners = initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_intermediate_greedyswitch_BetweenLayerHyperedgeAllCrossingsCounter$HyperedgeCorner_2_classLit, $intern_12, 158, hyperedges.length * 2, 0, 1);
  for (i3 = 0; i3 < hyperedges.length; i3++) {
    leftCorners[2 * i3] = new BetweenLayerHyperedgeAllCrossingsCounter$HyperedgeCorner(hyperedges[i3], hyperedges[i3].upperLeft, hyperedges[i3].lowerLeft, 0);
    leftCorners[2 * i3 + 1] = new BetweenLayerHyperedgeAllCrossingsCounter$HyperedgeCorner(hyperedges[i3], hyperedges[i3].lowerLeft, hyperedges[i3].upperLeft, 1);
  }
  mergeSort(leftCorners, 0, leftCorners.length, (null , NATURAL));
  openHyperedges = 0;
  for (leftCorner$index = 0 , leftCorner$max = leftCorners.length; leftCorner$index < leftCorner$max; ++leftCorner$index) {
    leftCorner = leftCorners[leftCorner$index];
    switch (leftCorner.type_0) {
      case 0:
        ++openHyperedges;
        break;
      case 1:
        --openHyperedges;
        crossings += openHyperedges;
    }
  }
  rightCorners = initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_intermediate_greedyswitch_BetweenLayerHyperedgeAllCrossingsCounter$HyperedgeCorner_2_classLit, $intern_12, 158, hyperedges.length * 2, 0, 1);
  for (i = 0; i < hyperedges.length; i++) {
    rightCorners[2 * i] = new BetweenLayerHyperedgeAllCrossingsCounter$HyperedgeCorner(hyperedges[i], hyperedges[i].upperRight, hyperedges[i].lowerRight, 0);
    rightCorners[2 * i + 1] = new BetweenLayerHyperedgeAllCrossingsCounter$HyperedgeCorner(hyperedges[i], hyperedges[i].lowerRight, hyperedges[i].upperRight, 1);
  }
  mergeSort(rightCorners, 0, rightCorners.length, (null , NATURAL));
  openHyperedges = 0;
  for (rightCorner$index = 0 , rightCorner$max = rightCorners.length; rightCorner$index < rightCorner$max; ++rightCorner$index) {
    rightCorner = rightCorners[rightCorner$index];
    switch (rightCorner.type_0) {
      case 0:
        ++openHyperedges;
        break;
      case 1:
        --openHyperedges;
        crossings += openHyperedges;
    }
  }
  return crossings;
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_greedyswitch_BetweenLayerHyperedgeAllCrossingsCounter_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate.greedyswitch', 'BetweenLayerHyperedgeAllCrossingsCounter', 609);
function $compareTo_3(this$static, other){
  if (this$static.upperLeft < other.upperLeft) {
    return -1;
  }
   else if (this$static.upperLeft > other.upperLeft) {
    return 1;
  }
   else if (this$static.upperRight < other.upperRight) {
    return -1;
  }
   else if (this$static.upperRight > other.upperRight) {
    return 1;
  }
  return this$static.hashCode - other.hashCode;
}

function BetweenLayerHyperedgeAllCrossingsCounter$Hyperedge(){
  this.edges = new LinkedList;
  this.ports = new LinkedList;
}

defineClass(204, 1, {204:1, 23:1}, BetweenLayerHyperedgeAllCrossingsCounter$Hyperedge);
_.compareTo = function compareTo_5(other){
  return $compareTo_3(this, castTo(other, 204));
}
;
_.hashCode = 0;
_.lowerLeft = 0;
_.lowerRight = 0;
_.upperLeft = 0;
_.upperRight = 0;
var Lde_cau_cs_kieler_klay_layered_intermediate_greedyswitch_BetweenLayerHyperedgeAllCrossingsCounter$Hyperedge_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate.greedyswitch', 'BetweenLayerHyperedgeAllCrossingsCounter/Hyperedge', 204);
function $compareTo_4(this$static, other){
  if (this$static.position < other.position) {
    return -1;
  }
   else if (this$static.position > other.position) {
    return 1;
  }
   else if (this$static.oppositePosition < other.oppositePosition) {
    return -1;
  }
   else if (this$static.oppositePosition > other.oppositePosition) {
    return 1;
  }
   else if (this$static.hyperedge != other.hyperedge) {
    return this$static.hyperedge.hashCode - other.hyperedge.hashCode;
  }
   else if (this$static.type_0 == 0 && other.type_0 == 1) {
    return -1;
  }
   else if (this$static.type_0 == 1 && other.type_0 == 0) {
    return 1;
  }
  return 0;
}

function BetweenLayerHyperedgeAllCrossingsCounter$HyperedgeCorner(hyperedge, position, oppositePosition, type_0){
  this.hyperedge = hyperedge;
  this.position = position;
  this.oppositePosition = oppositePosition;
  this.type_0 = type_0;
}

defineClass(158, 1, {158:1, 23:1}, BetweenLayerHyperedgeAllCrossingsCounter$HyperedgeCorner);
_.compareTo = function compareTo_6(other){
  return $compareTo_4(this, castTo(other, 158));
}
;
_.oppositePosition = 0;
_.position = 0;
_.type_0 = 0;
var Lde_cau_cs_kieler_klay_layered_intermediate_greedyswitch_BetweenLayerHyperedgeAllCrossingsCounter$HyperedgeCorner_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate.greedyswitch', 'BetweenLayerHyperedgeAllCrossingsCounter/HyperedgeCorner', 158);
function $buildAccumulatorTreeAndCountCrossings(targetCount, edgeCount, southSequence){
  var crossCount, firstIndex, index_0, k, tree, treeSize;
  firstIndex = 1;
  while (firstIndex < targetCount) {
    firstIndex *= 2;
  }
  treeSize = 2 * firstIndex - 1;
  firstIndex -= 1;
  tree = initUnidimensionalArray(I_classLit, $intern_37, 26, treeSize, 12, 1);
  crossCount = 0;
  for (k = 0; k < edgeCount; k++) {
    index_0 = southSequence[k] + firstIndex;
    ++tree[index_0];
    while (index_0 > 0) {
      index_0 % 2 > 0 && (crossCount += tree[index_0 + 1]);
      index_0 = (index_0 - 1) / 2 | 0;
      ++tree[index_0];
    }
  }
  return crossCount;
}

function BetweenLayerStraightEdgeAllCrossingsCounter(nodeOrder){
  BetweenLayerEdgeAllCrossingsCounter.call(this, nodeOrder);
}

function binarySearch(array, start_0, end, n){
  var currentEnd, currentStart, index_0;
  currentStart = start_0;
  currentEnd = end - 1;
  while (currentStart <= currentEnd) {
    index_0 = (currentStart + currentEnd) / 2 | 0;
    if (array[index_0] == n) {
      return index_0;
    }
     else 
      array[index_0] < n?(currentStart = index_0 + 1):(currentEnd = index_0 - 1);
  }
  return -currentStart - 1;
}

function insert(array, start_0, end, n){
  var insx, j;
  insx = binarySearch(array, start_0, end, n);
  insx < 0 && (insx = -insx - 1);
  for (j = end - 1; j >= insx; j--) {
    array[j + 1] = array[j];
  }
  array[insx] = n;
}

defineClass(610, 339, {}, BetweenLayerStraightEdgeAllCrossingsCounter);
_.countCrossings = function countCrossings_0(leftLayer, rightLayer){
  var crossCount, edge, edge$iterator, edgeCount, i, leftLayerRef, node, node$index, node$index0, node$max, node$max0, nodeEdges, northInputPorts, otherInputPorts, port, port$iterator, portEdges, portIter, rightLayerRef, southSequence, start_0, target, targetCount;
  targetCount = 0;
  edgeCount = 0;
  leftLayerRef = leftLayer[0].layer;
  rightLayerRef = rightLayer[0].layer;
  for (node$index0 = 0 , node$max0 = rightLayer.length; node$index0 < node$max0; ++node$index0) {
    node = rightLayer[node$index0];
    if ($isOrderFixed(castTo($getProperty(node, ($clinit_LayoutOptions() , PORT_CONSTRAINTS)), 28))) {
      northInputPorts = 0;
      for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
        port = castTo($next_8(port$iterator), 7);
        if (port.side == ($clinit_PortSide() , NORTH)) {
          for (edge$iterator = new ArrayList$1(port.incomingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
            edge = castTo($next_8(edge$iterator), 12);
            if (edge.source.owner.layer == leftLayerRef) {
              ++northInputPorts;
              break;
            }
          }
        }
         else {
          break;
        }
      }
      otherInputPorts = 0;
      portIter = new AbstractList$ListIteratorImpl(node.ports, node.ports.array.length);
      while (portIter.i > 0) {
        port = (checkCriticalElement(portIter.i > 0) , castTo(portIter.this$01.get_2(portIter.last = --portIter.i), 7));
        portEdges = 0;
        for (edge$iterator = new ArrayList$1(port.incomingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
          edge = castTo($next_8(edge$iterator), 12);
          edge.source.owner.layer == leftLayerRef && ++portEdges;
        }
        if (portEdges > 0) {
          if (port.side == ($clinit_PortSide() , NORTH)) {
            this.portPos[port.id_0] = targetCount;
            ++targetCount;
          }
           else {
            this.portPos[port.id_0] = targetCount + northInputPorts + otherInputPorts;
            ++otherInputPorts;
          }
          edgeCount += portEdges;
        }
      }
      targetCount += otherInputPorts;
    }
     else {
      nodeEdges = 0;
      for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
        port = castTo($next_8(port$iterator), 7);
        for (edge$iterator = new ArrayList$1(port.incomingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
          edge = castTo($next_8(edge$iterator), 12);
          edge.source.owner.layer == leftLayerRef && ++nodeEdges;
        }
        this.portPos[port.id_0] = targetCount;
      }
      if (nodeEdges > 0) {
        ++targetCount;
        edgeCount += nodeEdges;
      }
    }
  }
  southSequence = initUnidimensionalArray(I_classLit, $intern_37, 26, edgeCount, 12, 1);
  i = 0;
  for (node$index = 0 , node$max = leftLayer.length; node$index < node$max; ++node$index) {
    node = leftLayer[node$index];
    if ($isOrderFixed(castTo($getProperty(node, ($clinit_LayoutOptions() , PORT_CONSTRAINTS)), 28))) {
      for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
        port = castTo($next_8(port$iterator), 7);
        start_0 = i;
        for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
          edge = castTo($next_8(edge$iterator), 12);
          target = edge.target;
          target.owner.layer == rightLayerRef && insert(southSequence, start_0, i++, this.portPos[target.id_0]);
        }
      }
    }
     else {
      start_0 = i;
      for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
        port = castTo($next_8(port$iterator), 7);
        for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
          edge = castTo($next_8(edge$iterator), 12);
          target = edge.target;
          target.owner.layer == rightLayerRef && insert(southSequence, start_0, i++, this.portPos[target.id_0]);
        }
      }
    }
  }
  crossCount = $buildAccumulatorTreeAndCountCrossings(targetCount, edgeCount, southSequence);
  return crossCount;
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_greedyswitch_BetweenLayerStraightEdgeAllCrossingsCounter_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate.greedyswitch', 'BetweenLayerStraightEdgeAllCrossingsCounter', 610);
function $fillCrossingMatrix(this$static, upperNode, lowerNode){
  if (this$static.oneSided) {
    switch (this$static.direction) {
      case 1:
        $countEasternEdgeCrossings(this$static.inBetweenLayerCrossingCounter, upperNode, lowerNode);
        break;
      case 0:
        $countWesternEdgeCrossings(this$static.inBetweenLayerCrossingCounter, upperNode, lowerNode);
    }
  }
   else {
    $countBothSideCrossings(this$static.inBetweenLayerCrossingCounter, upperNode, lowerNode);
  }
  this$static.crossingMatrix[upperNode.id_0][lowerNode.id_0] = this$static.inBetweenLayerCrossingCounter.upperLowerCrossings;
  this$static.crossingMatrix[lowerNode.id_0][upperNode.id_0] = this$static.inBetweenLayerCrossingCounter.lowerUpperCrossings;
}

function $getCrossingMatrixEntry(this$static, upperNode, lowerNode){
  if (!this$static.isCrossingMatrixFilled[upperNode.id_0][lowerNode.id_0]) {
    $fillCrossingMatrix(this$static, upperNode, lowerNode);
    this$static.isCrossingMatrixFilled[upperNode.id_0][lowerNode.id_0] = true;
    this$static.isCrossingMatrixFilled[lowerNode.id_0][upperNode.id_0] = true;
  }
  return this$static.crossingMatrix[upperNode.id_0][lowerNode.id_0];
}

function CrossingMatrixFiller(greedyType, graph, freeLayerIndex, direction){
  var freeLayer;
  this.direction = direction;
  this.oneSided = greedyType.isOneSided;
  freeLayer = graph[freeLayerIndex];
  this.isCrossingMatrixFilled = initMultidimensionalArray(Z_classLit, [$intern_0, $intern_63], [227, 26], 13, [freeLayer.length, freeLayer.length], 2);
  this.crossingMatrix = initMultidimensionalArray(I_classLit, [$intern_0, $intern_37], [52, 26], 12, [freeLayer.length, freeLayer.length], 2);
  this.inBetweenLayerCrossingCounter = new BetweenLayerEdgeTwoNodeCrossingsCounter(graph, freeLayerIndex);
}

defineClass(338, 1, {}, CrossingMatrixFiller);
_.direction = 0;
_.oneSided = false;
var Lde_cau_cs_kieler_klay_layered_intermediate_greedyswitch_CrossingMatrixFiller_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate.greedyswitch', 'CrossingMatrixFiller', 338);
function $continueSwitchingUntilNoImprovementInLayer(this$static, freeLayerIndex){
  var continueSwitching, improved;
  improved = false;
  do {
    this$static.sweepDownwardInLayer?(continueSwitching = $sweepDownwardInLayer(this$static, freeLayerIndex)):(continueSwitching = $sweepUpwardInLayer(this$static, freeLayerIndex));
    improved = improved | continueSwitching;
  }
   while (continueSwitching);
  return improved;
}

function $copyNodeOrder(this$static){
  var copy, i, length_0, order;
  order = initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LNode_2_classLit, $intern_0, 51, this$static.bestNodeOrder.length, 0, 2);
  for (i = 0; i < order.length; i++) {
    length_0 = this$static.bestNodeOrder[i].length;
    copy = initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LNode_2_classLit, $intern_49, 9, length_0, 0, 1);
    arraycopy(this$static.bestNodeOrder[i], 0, copy, 0, length_0);
    order[i] = copy;
  }
  return order;
}

function $initialize_0(this$static, graph){
  var id_0, layer, layerCount, layerIndex, layerIter, layerNodeCount, node, nodeIter;
  this$static.layeredGraph = graph;
  layerCount = graph.layers.array.length;
  this$static.bestNodeOrder = initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LNode_2_classLit, $intern_0, 51, layerCount, 0, 2);
  this$static.currentNodeOrder = initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LNode_2_classLit, $intern_0, 51, layerCount, 0, 2);
  this$static.originalNodeOrder = initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LNode_2_classLit, $intern_0, 51, layerCount, 0, 2);
  layerIter = new AbstractList$ListIteratorImpl(graph.layers, 0);
  while (layerIter.i < layerIter.this$01_0.size_1()) {
    layer = (checkCriticalElement(layerIter.i < layerIter.this$01_0.size_1()) , castTo(layerIter.this$01_0.get_2(layerIter.last = layerIter.i++), 16));
    layerNodeCount = layer.nodes.array.length;
    layerIndex = layerIter.i - 1;
    this$static.bestNodeOrder[layerIndex] = initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LNode_2_classLit, $intern_49, 9, layerNodeCount, 0, 1);
    this$static.currentNodeOrder[layerIndex] = initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LNode_2_classLit, $intern_49, 9, layerNodeCount, 0, 1);
    this$static.originalNodeOrder[layerIndex] = initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LNode_2_classLit, $intern_49, 9, layerNodeCount, 0, 1);
    nodeIter = new AbstractList$ListIteratorImpl(layer.nodes, 0);
    id_0 = 0;
    while (nodeIter.i < nodeIter.this$01_0.size_1()) {
      node = (checkCriticalElement(nodeIter.i < nodeIter.this$01_0.size_1()) , castTo(nodeIter.this$01_0.get_2(nodeIter.last = nodeIter.i++), 9));
      node.id_0 = id_0++;
      this$static.currentNodeOrder[layerIndex][nodeIter.i - 1] = node;
      this$static.bestNodeOrder[layerIndex][nodeIter.i - 1] = node;
      this$static.originalNodeOrder[layerIndex][nodeIter.i - 1] = node;
    }
  }
  this$static.crossingCounter = new AllCrossingsCounter(this$static.currentNodeOrder);
  this$static.greedySwitchType.useHperedgeCounter && (this$static.crossingCounter.useHyperedgeCounter = true);
}

function $oneSidedLayerSweep(this$static){
  var crossingsInGraph, oldNumberOfCrossings;
  crossingsInGraph = $countAllCrossingsInGraphWithOrder(this$static.crossingCounter, this$static.currentNodeOrder);
  oldNumberOfCrossings = $intern_3;
  while (oldNumberOfCrossings > crossingsInGraph) {
    $setAsBestNodeOrder(this$static, this$static.currentNodeOrder);
    if (crossingsInGraph == 0) {
      oldNumberOfCrossings = 0;
      break;
    }
    $sweepForwardReducingCrossings(this$static);
    $sweepBackwardReducingCrossings(this$static);
    oldNumberOfCrossings = crossingsInGraph;
    crossingsInGraph = $countAllCrossingsInGraphWithOrder(this$static.crossingCounter, this$static.currentNodeOrder);
  }
  this$static.currentCrossings = oldNumberOfCrossings;
}

function $setAsBestNodeOrder(this$static, nodeOrder){
  var i, j;
  for (i = 0; i < this$static.bestNodeOrder.length; i++) {
    for (j = 0; j < this$static.bestNodeOrder[i].length; j++) {
      this$static.bestNodeOrder[i][j] = nodeOrder[i][j];
    }
  }
}

function $setAsGraph(this$static, nodeOrder){
  var layer, layerIter, nodeIter, nodes;
  layerIter = new AbstractList$ListIteratorImpl(this$static.layeredGraph.layers, 0);
  while (layerIter.i < layerIter.this$01_0.size_1()) {
    layer = (checkCriticalElement(layerIter.i < layerIter.this$01_0.size_1()) , castTo(layerIter.this$01_0.get_2(layerIter.last = layerIter.i++), 16));
    nodes = nodeOrder[layerIter.i - 1];
    nodeIter = new AbstractList$ListIteratorImpl(layer.nodes, 0);
    while (nodeIter.i < nodeIter.this$01_0.size_1()) {
      checkCriticalElement(nodeIter.i < nodeIter.this$01_0.size_1());
      nodeIter.this$01_0.get_2(nodeIter.last = nodeIter.i++);
      $set_4(nodeIter, nodes[nodeIter.i - 1]);
    }
  }
}

function $sweepBackwardReducingCrossings(this$static){
  var crossingMatrixFiller, freeLayerIndex, improved;
  improved = false;
  for (freeLayerIndex = this$static.currentNodeOrder.length - 1; freeLayerIndex >= 0; freeLayerIndex--) {
    this$static.switchDecider = (crossingMatrixFiller = new CrossingMatrixFiller(this$static.greedySwitchType, this$static.currentNodeOrder, freeLayerIndex, 1) , new SwitchDecider(freeLayerIndex, this$static.currentNodeOrder, crossingMatrixFiller));
    improved = improved | $continueSwitchingUntilNoImprovementInLayer(this$static, freeLayerIndex);
  }
  return improved;
}

function $sweepDownwardInLayer(this$static, layerIndex){
  var continueSwitching, lengthOfFreeLayer, lowerNodeIndex, upperNodeIndex;
  continueSwitching = false;
  lengthOfFreeLayer = this$static.currentNodeOrder[layerIndex].length;
  for (upperNodeIndex = 0; upperNodeIndex < lengthOfFreeLayer - 1; upperNodeIndex++) {
    lowerNodeIndex = upperNodeIndex + 1;
    continueSwitching = continueSwitching | $switchIfImproves(this$static, layerIndex, upperNodeIndex, lowerNodeIndex);
  }
  return continueSwitching;
}

function $sweepForwardReducingCrossings(this$static){
  var crossingMatrixFiller, freeLayerIndex, improved;
  improved = false;
  for (freeLayerIndex = 0; freeLayerIndex < this$static.currentNodeOrder.length; freeLayerIndex++) {
    this$static.switchDecider = (crossingMatrixFiller = new CrossingMatrixFiller(this$static.greedySwitchType, this$static.currentNodeOrder, freeLayerIndex, 0) , new SwitchDecider(freeLayerIndex, this$static.currentNodeOrder, crossingMatrixFiller));
    improved = improved | $continueSwitchingUntilNoImprovementInLayer(this$static, freeLayerIndex);
  }
  return improved;
}

function $sweepUpwardInLayer(this$static, layerIndex){
  var continueSwitching, lengthOfFreeLayer, lowerNodeIndex, upperNodeIndex;
  continueSwitching = false;
  lengthOfFreeLayer = this$static.currentNodeOrder[layerIndex].length;
  for (lowerNodeIndex = lengthOfFreeLayer - 1; lowerNodeIndex > 0; lowerNodeIndex--) {
    upperNodeIndex = lowerNodeIndex - 1;
    continueSwitching = continueSwitching | $switchIfImproves(this$static, layerIndex, upperNodeIndex, lowerNodeIndex);
  }
  return continueSwitching;
}

function $switchIfImproves(this$static, layerIndex, upperNodeIndex, lowerNodeIndex){
  var continueSwitching, layer, temp;
  continueSwitching = false;
  if ($doesSwitchReduceCrossings(this$static.switchDecider, upperNodeIndex, lowerNodeIndex)) {
    $notifyOfSwitch_0(this$static.switchDecider, this$static.currentNodeOrder[layerIndex][upperNodeIndex], this$static.currentNodeOrder[layerIndex][lowerNodeIndex]);
    layer = this$static.currentNodeOrder[layerIndex];
    temp = layer[lowerNodeIndex];
    layer[lowerNodeIndex] = layer[upperNodeIndex];
    layer[upperNodeIndex] = temp;
    continueSwitching = true;
  }
  return continueSwitching;
}

function $twoSidedlayerSweep(this$static){
  var forward_0, improved;
  forward_0 = true;
  do {
    forward_0?(improved = $sweepForwardReducingCrossings(this$static)):(improved = $sweepBackwardReducingCrossings(this$static));
    forward_0 = !forward_0;
  }
   while (improved);
  $setAsBestNodeOrder(this$static, this$static.currentNodeOrder);
}

function GreedySwitchProcessor(){
}

defineClass(447, 1, $intern_56, GreedySwitchProcessor);
_.process = function process_45(graph, progressMonitor){
  var layerCount, downwardSweepOrder, downwardSweepCrossings, upwardSweepCrossings;
  $begin(progressMonitor, 'Greedy switch crossing reduction', 1);
  this.greedySwitchType = castTo($getProperty(graph, ($clinit_Properties() , GREEDY_SWITCH_TYPE)), 110);
  layerCount = graph.layers.array.length;
  if (layerCount < 2 || this.greedySwitchType == ($clinit_GreedySwitchType() , OFF)) {
    $done(progressMonitor);
    return;
  }
  $initialize_0(this, graph);
  this.greedySwitchType.useBestOfUpOrDown?(this.greedySwitchType.isOneSided?$oneSidedLayerSweep(this):$twoSidedlayerSweep(this) , downwardSweepOrder = $copyNodeOrder(this) , downwardSweepCrossings = this.greedySwitchType.isOneSided?this.currentCrossings:$countAllCrossingsInGraphWithOrder(this.crossingCounter, this.currentNodeOrder) , this.sweepDownwardInLayer = !this.sweepDownwardInLayer , this.currentNodeOrder = this.originalNodeOrder , this.greedySwitchType.isOneSided?$oneSidedLayerSweep(this):$twoSidedlayerSweep(this) , upwardSweepCrossings = this.greedySwitchType.isOneSided?this.currentCrossings:$countAllCrossingsInGraphWithOrder(this.crossingCounter, this.currentNodeOrder) , downwardSweepCrossings <= upwardSweepCrossings && $setAsBestNodeOrder(this, downwardSweepOrder) , undefined):this.greedySwitchType.isOneSided?$oneSidedLayerSweep(this):$twoSidedlayerSweep(this);
  $setAsGraph(this, this.bestNodeOrder);
  $done(progressMonitor);
}
;
_.currentCrossings = 0;
_.sweepDownwardInLayer = true;
var Lde_cau_cs_kieler_klay_layered_intermediate_greedyswitch_GreedySwitchProcessor_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate.greedyswitch', 'GreedySwitchProcessor', 447);
function $countCrossings(this$static){
  var crossings;
  crossings = $iterateEdgesTopDownAndCountCrossingsOnSide(this$static, ($clinit_PortSide() , WEST));
  crossings += $iterateEdgesTopDownAndCountCrossingsOnSide(this$static, EAST);
  return crossings;
}

function $countCrossingsOn(this$static, edge, port){
  var crossings, portsOnNodeWithFreePortOrder;
  crossings = 0;
  if ($isInLayer(edge)) {
    if ($contains_7(this$static.inLayerEdges, edge)) {
      $remove_4(this$static.inLayerPorts, valueOf_0($positionOf(this$static, edge.source)), 1) > 0;
      $remove_4(this$static.inLayerPorts, valueOf_0($positionOf(this$static, edge.target)), 1) > 0;
      $remove_17(this$static.inLayerEdges, edge);
      crossings += $numberOfPortsInBetweenEndsOf(this$static, edge, this$static.inLayerPorts);
    }
     else {
      $add_18(this$static.inLayerEdges, edge);
      $add_4(this$static.inLayerPorts, valueOf_0($positionOf(this$static, edge.source)), 1);
      $add_4(this$static.inLayerPorts, valueOf_0($positionOf(this$static, edge.target)), 1);
    }
  }
   else {
    portsOnNodeWithFreePortOrder = $count(this$static.inLayerPorts, valueOf_0(castTo($get_9(this$static.portPositions, port), 24).value_0));
    crossings += this$static.inLayerEdges.map_0.size_1() - portsOnNodeWithFreePortOrder;
  }
  return crossings;
}

function $initializeLayer(this$static, layer){
  var eastPortId, node, node$index, node$max, westPortId;
  eastPortId = 0;
  westPortId = 0;
  for (node$index = 0 , node$max = layer.length; node$index < node$max; ++node$index) {
    node = layer[node$index];
    eastPortId = $setPortIdsAndNodeCardinality(this$static, eastPortId, node, ($clinit_PortSide() , EAST), this$static.eastNodeCardinalities);
    westPortId = $setPortIdsAndNodeCardinality(this$static, westPortId, node, WEST, this$static.westNodeCardinalities);
  }
}

function $isInLayer(edge){
  var sourceLayer, targetLayer;
  sourceLayer = edge.source.owner.layer;
  targetLayer = edge.target.owner.layer;
  return sourceLayer == targetLayer;
}

function $iterateEdgesTopDownAndCountCrossingsOnSide(this$static, portSide){
  var crossings, edge, edge$iterator, node, node$array, node$index, node$max, port, port$iterator, ports;
  crossings = 0;
  for (node$array = this$static.nodeOrder , node$index = 0 , node$max = node$array.length; node$index < node$max; ++node$index) {
    node = node$array[node$index];
    ports = new PortIterable(node, portSide);
    for (port$iterator = $iterator_4(ports); port$iterator.hasNext_0();) {
      port = castTo(port$iterator.next_1(), 7);
      for (edge$iterator = $iterator(concat(($clinit_ImmutableList() , new RegularImmutableList(nullCheckedList(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [port.incomingEdges, port.outgoingEdges])))))); $hasNext_0(edge$iterator);) {
        edge = castTo($next_2(edge$iterator), 12);
        $isSelfLoop(edge) || (crossings += $countCrossingsOn(this$static, edge, port));
      }
    }
  }
  return crossings;
}

function $notifyOfSwitch(this$static, wasUpperNode, wasLowerNode){
  $updatePortIds(this$static, wasUpperNode, wasLowerNode, ($clinit_PortSide() , EAST), this$static.eastNodeCardinalities);
  $updatePortIds(this$static, wasUpperNode, wasLowerNode, WEST, this$static.westNodeCardinalities);
}

function $numberOfPortsInBetweenEndsOf(this$static, edge, set_0){
  var lowerBound, upperBound;
  lowerBound = min_3($positionOf(this$static, edge.target), $positionOf(this$static, edge.source));
  upperBound = max_3($positionOf(this$static, edge.target), $positionOf(this$static, edge.source));
  return saturatedCast($aggregateForEntries($subMultiset(set_0, valueOf_0(lowerBound), ($clinit_BoundType() , OPEN), valueOf_0(upperBound), OPEN), ($clinit_TreeMultiset$Aggregate() , SIZE)));
}

function $positionOf(this$static, port){
  return castTo($get_9(this$static.portPositions, port), 24).value_0;
}

function $setPortIdsAndNodeCardinality(this$static, portId, node, side, cardinalities){
  var cardinality, currentPortId, hasPorts, port, port$iterator, ports;
  currentPortId = portId;
  cardinality = 0;
  hasPorts = false;
  ports = new PortIterable(node, side);
  for (port$iterator = $iterator_4(ports); port$iterator.hasNext_0();) {
    port = castTo(port$iterator.next_1(), 7);
    hasPorts = true;
    $put_2(this$static.portPositions, port, valueOf_0(currentPortId));
    if ($isOrderFixed(castTo($getProperty(node, ($clinit_LayoutOptions() , PORT_CONSTRAINTS)), 28)) || port.incomingEdges.array.length + port.outgoingEdges.array.length > 1) {
      ++cardinality;
      ++currentPortId;
    }
  }
  if (!$isOrderFixed(castTo($getProperty(node, ($clinit_LayoutOptions() , PORT_CONSTRAINTS)), 28)) && hasPorts) {
    ++cardinality;
    ++currentPortId;
  }
  $put_2(cardinalities, node, valueOf_0(cardinality));
  return currentPortId;
}

function $updatePortIds(this$static, firstNode, secondNode, side, cardinalities){
  var port, port$iterator, port$iterator0, ports;
  ports = new PortIterable(firstNode, side);
  for (port$iterator0 = $iterator_4(ports); port$iterator0.hasNext_0();) {
    port = castTo(port$iterator0.next_1(), 7);
    $put_2(this$static.portPositions, port, valueOf_0(castTo($get_9(this$static.portPositions, port), 24).value_0 + castTo(getEntryValueOrNull($getEntry(cardinalities.hashCodeMap, secondNode)), 24).value_0));
  }
  ports = new PortIterable(secondNode, side);
  for (port$iterator = $iterator_4(ports); port$iterator.hasNext_0();) {
    port = castTo(port$iterator.next_1(), 7);
    $put_2(this$static.portPositions, port, valueOf_0(castTo($get_9(this$static.portPositions, port), 24).value_0 - castTo(getEntryValueOrNull($getEntry(cardinalities.hashCodeMap, firstNode)), 24).value_0));
  }
}

function InLayerEdgeAllCrossingsCounter(nodeOrder){
  this.eastNodeCardinalities = ($clinit_Maps() , new HashMap);
  this.westNodeCardinalities = new HashMap;
  this.portPositions = new HashMap;
  this.inLayerEdges = new HashSet;
  this.inLayerPorts = new TreeMultiset_0(($clinit_NaturalOrdering() , INSTANCE_0));
  this.nodeOrder = nodeOrder;
  $initializeLayer(this, nodeOrder);
}

defineClass(340, 1, {}, InLayerEdgeAllCrossingsCounter);
var Lde_cau_cs_kieler_klay_layered_intermediate_greedyswitch_InLayerEdgeAllCrossingsCounter_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate.greedyswitch', 'InLayerEdgeAllCrossingsCounter', 340);
function $addThisEndOrBothEndsOfEdge(this$static, node, port, edge){
  var otherEnd;
  $add_11(this$static.relevantEdgesAndPorts, new InLayerEdgeTwoNodeCrossingCounter$ComparableEdgeAndPort(this$static, port, edge, castTo($get_9(this$static.portPositions, port), 24).value_0));
  if ($isInLayer(edge) && (node == this$static.upperNode?edge.target.owner != this$static.lowerNode && edge.source.owner != this$static.lowerNode:edge.target.owner != this$static.upperNode && edge.source.owner != this$static.upperNode)) {
    otherEnd = port == edge.source?edge.target:edge.source;
    $add_11(this$static.relevantEdgesAndPorts, new InLayerEdgeTwoNodeCrossingCounter$ComparableEdgeAndPort(this$static, otherEnd, edge, castTo($get_9(this$static.portPositions, otherEnd), 24).value_0));
  }
}

function $countCrossingsBetweenNodes(this$static, upper, lower){
  this$static.upperNode = upper;
  this$static.lowerNode = lower;
  this$static.upperLowerCrossings = $countCrossingsOnSide(this$static, ($clinit_PortSide() , EAST));
  this$static.upperLowerCrossings += $countCrossingsOnSide(this$static, WEST);
  $updatePortIds(this$static, upper, lower, EAST, this$static.eastNodeCardinalities);
  $updatePortIds(this$static, upper, lower, WEST, this$static.westNodeCardinalities);
  this$static.lowerUpperCrossings = $countCrossingsOnSide(this$static, EAST);
  this$static.lowerUpperCrossings += $countCrossingsOnSide(this$static, WEST);
  $updatePortIds(this$static, lower, upper, EAST, this$static.eastNodeCardinalities);
  $updatePortIds(this$static, lower, upper, WEST, this$static.westNodeCardinalities);
}

function $countCrossingsOnSide(this$static, side){
  this$static.relevantEdgesAndPorts.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
  $iterateThroughEdgesAndCollectThem(this$static, this$static.upperNode, side);
  $iterateThroughEdgesAndCollectThem(this$static, this$static.lowerNode, side);
  $clinit_Collections();
  sort_1(this$static.relevantEdgesAndPorts, null);
  return $iterateThroughRelevantEdgesAndPortsAndCountCrossings(this$static);
}

function $iterateThroughEdgesAndCollectThem(this$static, node, side){
  var edge, edge$iterator, port, port$iterator, ports;
  ports = new PortIterable(node, side);
  for (port$iterator = $iterator_4(ports); port$iterator.hasNext_0();) {
    port = castTo(port$iterator.next_1(), 7);
    for (edge$iterator = $iterator(concat(($clinit_ImmutableList() , new RegularImmutableList(nullCheckedList(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [port.incomingEdges, port.outgoingEdges])))))); $hasNext_0(edge$iterator);) {
      edge = castTo($next_2(edge$iterator), 12);
      $isSelfLoop(edge) || $addThisEndOrBothEndsOfEdge(this$static, node, port, edge);
    }
  }
}

function $iterateThroughRelevantEdgesAndPortsAndCountCrossings(this$static){
  var crossings, eP, eP$iterator;
  crossings = 0;
  for (eP$iterator = new ArrayList$1(this$static.relevantEdgesAndPorts); eP$iterator.i < eP$iterator.this$01.array.length;) {
    eP = castTo($next_8(eP$iterator), 226);
    crossings += $countCrossingsOn(this$static, eP.edge, eP.port);
  }
  return crossings;
}

function $otherEndOf(edge, fromPort){
  return fromPort == edge.source?edge.target:edge.source;
}

function InLayerEdgeTwoNodeCrossingCounter(nodeOrder){
  InLayerEdgeAllCrossingsCounter.call(this, nodeOrder);
  this.relevantEdgesAndPorts = new ArrayList;
}

defineClass(613, 340, {}, InLayerEdgeTwoNodeCrossingCounter);
_.lowerUpperCrossings = 0;
_.upperLowerCrossings = 0;
var Lde_cau_cs_kieler_klay_layered_intermediate_greedyswitch_InLayerEdgeTwoNodeCrossingCounter_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate.greedyswitch', 'InLayerEdgeTwoNodeCrossingCounter', 613);
function $compareTo_5(this$static, o){
  return this$static.portPosition < o.portPosition || this$static.portPosition == o.portPosition && $isInLayer(this$static.edge) && $isInLayer(o.edge) && $positionOf(this$static.this$01, $otherEndOf(this$static.edge, this$static.port)) > $positionOf(this$static.this$01, $otherEndOf(o.edge, o.port))?-1:this$static.portPosition == o.portPosition && $otherEndOf(this$static.edge, this$static.port) == $otherEndOf(this$static.edge, this$static.port)?0:1;
}

function InLayerEdgeTwoNodeCrossingCounter$ComparableEdgeAndPort(this$0, port, edge, portPosition){
  this.this$01 = this$0;
  this.port = port;
  this.edge = edge;
  this.portPosition = portPosition;
}

defineClass(226, 1, {226:1, 23:1}, InLayerEdgeTwoNodeCrossingCounter$ComparableEdgeAndPort);
_.compareTo = function compareTo_7(o){
  return $compareTo_5(this, castTo(o, 226));
}
;
_.toString_0 = function toString_61(){
  return 'ComparableEdgeAndPort [port=' + this.port + ', edge=' + this.edge + ', portPosition=' + this.portPosition + ']';
}
;
_.portPosition = 0;
var Lde_cau_cs_kieler_klay_layered_intermediate_greedyswitch_InLayerEdgeTwoNodeCrossingCounter$ComparableEdgeAndPort_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate.greedyswitch', 'InLayerEdgeTwoNodeCrossingCounter/ComparableEdgeAndPort', 226);
function $cardinalityOnSide(this$static, node, side){
  switch (side.ordinal) {
    case 1:
      return castTo($get_9(this$static.northCardinalities, node), 24);
    case 3:
      return castTo($get_9(this$static.southCardinalities, node), 24);
  }
  return valueOf_0(0);
}

function $countCrossings_0(this$static){
  var crossings, node, node$array, node$index, node$max;
  crossings = 0;
  for (node$array = this$static.layer , node$index = 0 , node$max = node$array.length; node$index < node$max; ++node$index) {
    node = node$array[node$index];
    crossings += $getLongEdgeDummyCrossings(this$static, node);
    if ($isOrderFixed(castTo($getProperty(node, ($clinit_LayoutOptions() , PORT_CONSTRAINTS)), 28))) {
      $getPorts_0(node, ($clinit_PortSide() , NORTH)).iterator_0().hasNext_0() && (crossings += $getCrossingsOnSide(this$static, node, NORTH));
      $getPorts_0(node, SOUTH).iterator_0().hasNext_0() && (crossings += $getCrossingsOnSide(this$static, node, SOUTH));
    }
  }
  return crossings;
}

function $getCrossingsOnSide(this$static, node, side){
  var crossings, factor, factor0, northSouthDummy, port, port$iterator, southPorts;
  crossings = 0;
  southPorts = $getPorts_0(node, side);
  for (port$iterator = southPorts.iterator_0(); port$iterator.hasNext_0();) {
    port = castTo(port$iterator.next_1(), 7);
    if (castTo($getProperty(port, ($clinit_InternalProperties() , PORT_DUMMY)), 9)) {
      northSouthDummy = castTo($getProperty(port, PORT_DUMMY), 9);
      $getPorts_0(northSouthDummy, ($clinit_PortSide() , EAST)).iterator_0().hasNext_0() && (crossings += (factor0 = this$static.usesOrthogonalCounter?1:$getDegree(castTo($get_8(northSouthDummy.ports, 0), 7)) , factor0 * min_3($cardinalityOnSide(this$static, node, side).value_0 - 1 - castTo($get_9(this$static.portPositions, port), 24).value_0, $nearnessBetween(this$static, node, northSouthDummy))));
      $getPorts_0(northSouthDummy, WEST).iterator_0().hasNext_0() && (crossings += (factor = this$static.usesOrthogonalCounter?1:$getDegree(castTo($get_8(northSouthDummy.ports, 0), 7)) , factor * min_3(castTo($get_9(this$static.portPositions, port), 24).value_0, $nearnessBetween(this$static, node, northSouthDummy))));
    }
  }
  return crossings;
}

function $getLongEdgeDummyCrossings(this$static, node){
  var crossings;
  crossings = 0;
  if (node.type_0 == ($clinit_LNode$NodeType() , NORTH_SOUTH_PORT)) {
    if ($originPortOf(node).owner != this$static.currentOriginNode) {
      $resetDummyCountAndSetCurrentOriginNodeTo(this$static, $originPortOf(node).owner);
      this$static.northOfCurrentOriginNode = true;
    }
    this$static.northOfCurrentOriginNode?++this$static.numberOfNorthSouthEdges:(crossings += this$static.numberOfLongEdgeDummies);
  }
   else if (node.type_0 == LONG_EDGE) {
    this$static.northOfCurrentOriginNode?(crossings += this$static.numberOfNorthSouthEdges):++this$static.numberOfLongEdgeDummies;
  }
   else if (node.type_0 == NORMAL) {
    $resetDummyCountAndSetCurrentOriginNodeTo(this$static, node);
    this$static.northOfCurrentOriginNode = false;
  }
  return crossings;
}

function $initPositionsAndCardinalities(this$static){
  var element, element$array, element$index, element$max, nodeId;
  nodeId = 0;
  for (element$array = this$static.layer , element$index = 0 , element$max = element$array.length; element$index < element$max; ++element$index) {
    element = element$array[element$index];
    element.type_0 == ($clinit_LNode$NodeType() , LONG_EDGE) || $put_2(this$static.nodePositions, element, valueOf_0(nodeId++));
    $setPortPositionsAndCardinalitiesFor(this$static, element, this$static.northCardinalities, ($clinit_PortSide() , NORTH));
    $setPortPositionsAndCardinalitiesFor(this$static, element, this$static.southCardinalities, SOUTH);
  }
}

function $nearnessBetween(this$static, node, northSouthDummy){
  var cardinality, dummySide;
  dummySide = $originPortOf(northSouthDummy).side;
  cardinality = $cardinalityOnSide(this$static, node, dummySide).value_0;
  return cardinality - abs_1(castTo($get_9(this$static.nodePositions, node), 24).value_0 - castTo($get_9(this$static.nodePositions, northSouthDummy), 24).value_0);
}

function $originPortOf(node){
  var origin, port;
  port = castTo($get_8(node.ports, 0), 7);
  origin = castTo($getProperty(port, ($clinit_InternalProperties() , ORIGIN)), 7);
  return origin;
}

function $resetDummyCountAndSetCurrentOriginNodeTo(this$static, node){
  this$static.currentOriginNode = node;
  this$static.numberOfNorthSouthEdges = 0;
  this$static.numberOfLongEdgeDummies = 0;
}

function $setPortPositionsAndCardinalitiesFor(this$static, node, cardinalities, side){
  var port, port$iterator, portId, ports;
  ports = new PortIterable(node, side);
  portId = 0;
  for (port$iterator = $iterator_4(ports); port$iterator.hasNext_0();) {
    port = castTo(port$iterator.next_1(), 7);
    $put_2(this$static.portPositions, port, valueOf_0(portId++));
  }
  $put_2(cardinalities, node, valueOf_0(portId));
}

function NorthSouthEdgeAllCrossingsCounter(layer){
  this.layer = layer;
  this.nodePositions = ($clinit_Maps() , new HashMap);
  this.portPositions = new HashMap;
  this.northCardinalities = new HashMap;
  this.southCardinalities = new HashMap;
  this.usesOrthogonalCounter = maskUndefined($getProperty($getGraph(layer[0]), ($clinit_LayoutOptions() , EDGE_ROUTING))) === maskUndefined(($clinit_EdgeRouting() , ORTHOGONAL));
  $initPositionsAndCardinalities(this);
}

defineClass(611, 1, {}, NorthSouthEdgeAllCrossingsCounter);
_.northOfCurrentOriginNode = true;
_.numberOfLongEdgeDummies = 0;
_.numberOfNorthSouthEdges = 0;
_.usesOrthogonalCounter = false;
var Lde_cau_cs_kieler_klay_layered_intermediate_greedyswitch_NorthSouthEdgeAllCrossingsCounter_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate.greedyswitch', 'NorthSouthEdgeAllCrossingsCounter', 611);
function $countCrossings_1(this$static, upperNode, lowerNode){
  this$static.upperLowerCrossings = 0;
  this$static.lowerUpperCrossings = 0;
  $processIfTwoNorthSouthNodes(this$static, upperNode, lowerNode);
  upperNode.type_0 == ($clinit_LNode$NodeType() , NORTH_SOUTH_PORT) && lowerNode.type_0 == LONG_EDGE?$originPortOf_0(upperNode).side == ($clinit_PortSide() , NORTH)?(this$static.upperLowerCrossings = 1):(this$static.lowerUpperCrossings = 1):lowerNode.type_0 == NORTH_SOUTH_PORT && upperNode.type_0 == LONG_EDGE && ($originPortOf_0(lowerNode).side == ($clinit_PortSide() , NORTH)?(this$static.lowerUpperCrossings = 1):(this$static.upperLowerCrossings = 1));
  $processIfNormalNodeWithNSPortsAndLongEdgeDummy(this$static, upperNode, lowerNode);
}

function $countCrossingsOfTwoNorthSouthDummies(this$static, furtherFromNormalNode, closerToNormalNode, furtherNodePortSide, closerNodePortSide){
  if (furtherNodePortSide == ($clinit_PortSide() , EAST) && closerNodePortSide == EAST) {
    $originPortPositionOf(this$static, furtherFromNormalNode) > $originPortPositionOf(this$static, closerToNormalNode)?(this$static.upperLowerCrossings = $numberOfEdgesConnectTo(this$static, closerToNormalNode)):(this$static.lowerUpperCrossings = $numberOfEdgesConnectTo(this$static, furtherFromNormalNode));
  }
   else if (furtherNodePortSide == WEST && closerNodePortSide == WEST) {
    $originPortPositionOf(this$static, furtherFromNormalNode) < $originPortPositionOf(this$static, closerToNormalNode)?(this$static.upperLowerCrossings = $numberOfEdgesConnectTo(this$static, closerToNormalNode)):(this$static.lowerUpperCrossings = $numberOfEdgesConnectTo(this$static, furtherFromNormalNode));
  }
   else if (furtherNodePortSide == WEST && closerNodePortSide == EAST) {
    if ($originPortPositionOf(this$static, furtherFromNormalNode) > $originPortPositionOf(this$static, closerToNormalNode)) {
      this$static.upperLowerCrossings = $numberOfEdgesConnectTo(this$static, closerToNormalNode);
      this$static.lowerUpperCrossings = $numberOfEdgesConnectTo(this$static, furtherFromNormalNode);
    }
  }
   else {
    if ($originPortPositionOf(this$static, furtherFromNormalNode) < $originPortPositionOf(this$static, closerToNormalNode)) {
      this$static.upperLowerCrossings = $numberOfEdgesConnectTo(this$static, closerToNormalNode);
      this$static.lowerUpperCrossings = $numberOfEdgesConnectTo(this$static, furtherFromNormalNode);
    }
  }
}

function $hasEdgesInBothDirections(n){
  var east, p, p$iterator, west;
  east = false;
  west = false;
  for (p$iterator = new ArrayList$1(n.ports); p$iterator.i < p$iterator.this$01.array.length;) {
    p = castTo($next_8(p$iterator), 7);
    east = east | p.side == ($clinit_PortSide() , EAST);
    west = west | p.side == WEST;
  }
  return east && west;
}

function $initializePortPositions(this$static){
  var node, node$array, node$index, node$max;
  for (node$array = this$static.layer , node$index = 0 , node$max = node$array.length; node$index < node$max; ++node$index) {
    node = node$array[node$index];
    $setPortIdsOn(this$static, node, ($clinit_PortSide() , SOUTH));
    $setPortIdsOn(this$static, node, NORTH);
  }
}

function $numberOfEdgesConnectTo(this$static, node){
  var n, port, port$iterator;
  if (this$static.usesOrthogonalLayout) {
    return 1;
  }
  n = 0;
  for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_8(port$iterator), 7);
    n += port.incomingEdges.array.length + port.outgoingEdges.array.length;
  }
  return n;
}

function $numberOfNorthSouthEdges(node, side){
  var numberOfEdges, port, port$iterator;
  numberOfEdges = 0;
  for (port$iterator = $getPorts_0(node, side).iterator_0(); port$iterator.hasNext_0();) {
    port = castTo(port$iterator.next_1(), 7);
    numberOfEdges += $getProperty(port, ($clinit_InternalProperties() , PORT_DUMMY)) != null?1:0;
  }
  return numberOfEdges;
}

function $originPortOf_0(node){
  var origin, port;
  port = castTo($get_8(node.ports, 0), 7);
  origin = castTo($getProperty(port, ($clinit_InternalProperties() , ORIGIN)), 7);
  return origin;
}

function $originPortPositionOf(this$static, node){
  var origin;
  origin = $originPortOf_0(node);
  return castTo($get_9(this$static.portPositions, origin), 24).value_0;
}

function $processIfNormalNodeWithNSPortsAndLongEdgeDummy(this$static, upperNode, lowerNode){
  if (upperNode.type_0 == ($clinit_LNode$NodeType() , NORMAL) && lowerNode.type_0 == LONG_EDGE) {
    this$static.upperLowerCrossings = $numberOfNorthSouthEdges(upperNode, ($clinit_PortSide() , SOUTH));
    this$static.lowerUpperCrossings = $numberOfNorthSouthEdges(upperNode, NORTH);
  }
  if (lowerNode.type_0 == NORMAL && upperNode.type_0 == LONG_EDGE) {
    this$static.upperLowerCrossings = $numberOfNorthSouthEdges(lowerNode, ($clinit_PortSide() , NORTH));
    this$static.lowerUpperCrossings = $numberOfNorthSouthEdges(lowerNode, SOUTH);
  }
}

function $processIfTwoNorthSouthNodes(this$static, upperNode, lowerNode){
  var lowerNodePortSide, upperNodePortSide;
  if (upperNode.type_0 == ($clinit_LNode$NodeType() , NORTH_SOUTH_PORT) && lowerNode.type_0 == NORTH_SOUTH_PORT) {
    if (!$isOrderFixed(castTo($getProperty(castTo($getProperty(upperNode, ($clinit_InternalProperties() , ORIGIN)), 9), ($clinit_LayoutOptions() , PORT_CONSTRAINTS)), 28)) || castTo($getProperty(upperNode, ORIGIN), 9) != castTo($getProperty(lowerNode, ORIGIN), 9)) {
      return;
    }
    if ($hasEdgesInBothDirections(upperNode) || $hasEdgesInBothDirections(lowerNode)) {
      this$static.upperLowerCrossings = 1;
      this$static.lowerUpperCrossings = 1;
      return;
    }
    upperNodePortSide = castTo($get_8(upperNode.ports, 0), 7).side;
    lowerNodePortSide = castTo($get_8(lowerNode.ports, 0), 7).side;
    $originPortOf_0(upperNode).side == ($clinit_PortSide() , NORTH)?$countCrossingsOfTwoNorthSouthDummies(this$static, upperNode, lowerNode, upperNodePortSide, lowerNodePortSide):$countCrossingsOfTwoNorthSouthDummies(this$static, lowerNode, upperNode, lowerNodePortSide, upperNodePortSide);
  }
}

function $setPortIdsOn(this$static, node, side){
  var port, port$iterator, portId, ports;
  ports = new PortIterable(node, side);
  portId = 0;
  for (port$iterator = $iterator_4(ports); port$iterator.hasNext_0();) {
    port = castTo(port$iterator.next_1(), 7);
    $put_2(this$static.portPositions, port, valueOf_0(portId++));
  }
}

function NorthSouthEdgeNeighbouringNodeCrossingsCounter(nodes){
  this.usesOrthogonalLayout = maskUndefined($getProperty($getGraph(nodes[0]), ($clinit_LayoutOptions() , EDGE_ROUTING))) === maskUndefined(($clinit_EdgeRouting() , ORTHOGONAL));
  this.layer = nodes;
  this.portPositions = new HashMap;
  $initializePortPositions(this);
}

defineClass(614, 1, {}, NorthSouthEdgeNeighbouringNodeCrossingsCounter);
_.lowerUpperCrossings = 0;
_.upperLowerCrossings = 0;
_.usesOrthogonalLayout = false;
var Lde_cau_cs_kieler_klay_layered_intermediate_greedyswitch_NorthSouthEdgeNeighbouringNodeCrossingsCounter_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate.greedyswitch', 'NorthSouthEdgeNeighbouringNodeCrossingsCounter', 614);
function $getPredicate(this$static){
  switch (this$static.side.ordinal) {
    case 1:
      return $clinit_LPort() , NORTH_PREDICATE;
    case 2:
      return $clinit_LPort() , EAST_PREDICATE;
    case 3:
      return $clinit_LPort() , SOUTH_PREDICATE;
    case 4:
      return $clinit_LPort() , WEST_PREDICATE;
  }
  throw new UnsupportedOperationException_0("Can't filter on undefined side");
}

function $iterator_4(this$static){
  var iterator, iterator0, ports;
  ports = this$static.node.ports;
  switch (this$static.order) {
    case 0:
      return new ArrayList$1(this$static.node.ports);
    case 1:
      return filter_1((iterator0 = new PortIterable$1(ports) , iterator0), $getPredicate(this$static));
    case 2:
      switch (this$static.side.ordinal) {
        case 2:
        case 1:
          return filter_1(new ArrayList$1(ports), $getPredicate(this$static));
        case 3:
        case 4:
          return filter_1((iterator = new PortIterable$1(ports) , iterator), $getPredicate(this$static));
      }

  }
  throw new UnsupportedOperationException_0('PortOrder not implemented.');
}

function PortIterable(node, side){
  this.node = node;
  this.side = side;
  this.order = 2;
}

defineClass(143, 1, $intern_30, PortIterable);
_.iterator_0 = function iterator_48(){
  return $iterator_4(this);
}
;
_.order = 0;
var Lde_cau_cs_kieler_klay_layered_intermediate_greedyswitch_PortIterable_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate.greedyswitch', 'PortIterable', 143);
function PortIterable$1(val$ports){
  this.val$ports2 = val$ports;
  this.listIterator = new AbstractList$ListIteratorImpl(this.val$ports2, this.val$ports2.array.length);
}

defineClass(344, 1, $intern_18, PortIterable$1);
_.next_1 = function next_24(){
  return castTo($previous_1(this.listIterator), 7);
}
;
_.hasNext_0 = function hasNext_23(){
  return this.listIterator.i > 0;
}
;
_.remove = function remove_47(){
  throw new UnsupportedOperationException;
}
;
var Lde_cau_cs_kieler_klay_layered_intermediate_greedyswitch_PortIterable$1_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate.greedyswitch', 'PortIterable/1', 344);
function $doesSwitchReduceCrossings(this$static, upperNodeIndex, lowerNodeIndex){
  var lowerNode, lowerUpperCrossings, upperLowerCrossings, upperNode, upperNode_0, lowerNode_0, constraints, neitherNodeIsLongEdgeDummy, upperLayoutUnit, lowerLayoutUnit, nodesHaveLayoutUnits, areInDifferentLayoutUnits, upperNodeHasNorthernEdges, lowerNodeHasSouthernEdges, hasLayoutUnitConstraint;
  if (upperNode_0 = this$static.freeLayer[upperNodeIndex] , lowerNode_0 = this$static.freeLayer[lowerNodeIndex] , (constraints = castTo($getProperty(upperNode_0, ($clinit_InternalProperties() , IN_LAYER_SUCCESSOR_CONSTRAINTS)), 20) , !!constraints && constraints.size_1() != 0 && constraints.contains(lowerNode_0)) || (neitherNodeIsLongEdgeDummy = upperNode_0.type_0 != ($clinit_LNode$NodeType() , LONG_EDGE) && lowerNode_0.type_0 != LONG_EDGE , upperLayoutUnit = castTo($getProperty(upperNode_0, IN_LAYER_LAYOUT_UNIT), 9) , lowerLayoutUnit = castTo($getProperty(lowerNode_0, IN_LAYER_LAYOUT_UNIT), 9) , nodesHaveLayoutUnits = !!upperLayoutUnit && upperLayoutUnit != upperNode_0 || !!lowerLayoutUnit && lowerLayoutUnit != lowerNode_0 , areInDifferentLayoutUnits = upperLayoutUnit != lowerLayoutUnit , upperNodeHasNorthernEdges = $hasEdgesOnSide(upperNode_0, ($clinit_PortSide() , NORTH)) , lowerNodeHasSouthernEdges = $hasEdgesOnSide(lowerNode_0, SOUTH) , hasLayoutUnitConstraint = nodesHaveLayoutUnits && areInDifferentLayoutUnits || upperNodeHasNorthernEdges || lowerNodeHasSouthernEdges , neitherNodeIsLongEdgeDummy && hasLayoutUnitConstraint) || upperNode_0.type_0 == ($clinit_LNode$NodeType() , NORTH_SOUTH_PORT) && lowerNode_0.type_0 == NORMAL || lowerNode_0.type_0 == ($clinit_LNode$NodeType() , NORTH_SOUTH_PORT) && upperNode_0.type_0 == NORMAL) {
    return false;
  }
  upperNode = this$static.freeLayer[upperNodeIndex];
  lowerNode = this$static.freeLayer[lowerNodeIndex];
  $countCrossingsBetweenNodes(this$static.inLayerCounter, upperNode, lowerNode);
  $countCrossings_1(this$static.northSouthCounter, upperNode, lowerNode);
  upperLowerCrossings = $getCrossingMatrixEntry(this$static.crossingMatrixFiller, upperNode, lowerNode) + this$static.inLayerCounter.upperLowerCrossings + this$static.northSouthCounter.upperLowerCrossings;
  lowerUpperCrossings = $getCrossingMatrixEntry(this$static.crossingMatrixFiller, lowerNode, upperNode) + this$static.inLayerCounter.lowerUpperCrossings + this$static.northSouthCounter.lowerUpperCrossings;
  return upperLowerCrossings > lowerUpperCrossings;
}

function $hasEdgesOnSide(node, side){
  var port, port$iterator, ports;
  ports = $getPorts_0(node, side);
  for (port$iterator = ports.iterator_0(); port$iterator.hasNext_0();) {
    port = castTo(port$iterator.next_1(), 7);
    if ($getProperty(port, ($clinit_InternalProperties() , PORT_DUMMY)) != null || $hasNext_0($iterator(concat(($clinit_ImmutableList() , new RegularImmutableList(nullCheckedList(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [port.incomingEdges, port.outgoingEdges])))))))) {
      return true;
    }
  }
  return false;
}

function $notifyOfSwitch_0(this$static, upperNode, lowerNode){
  $notifyOfSwitch(this$static.inLayerCounter, upperNode, lowerNode);
}

function SwitchDecider(freeLayerIndex, graph, crossingMatrixFiller){
  this.crossingMatrixFiller = crossingMatrixFiller;
  if (freeLayerIndex >= graph.length) {
    throw new IndexOutOfBoundsException_0('Greedy SwitchDecider: Free layer layer not in graph.');
  }
  this.freeLayer = graph[freeLayerIndex];
  this.inLayerCounter = new InLayerEdgeTwoNodeCrossingCounter(this.freeLayer);
  this.northSouthCounter = new NorthSouthEdgeNeighbouringNodeCrossingsCounter(this.freeLayer);
}

defineClass(336, 1, {}, SwitchDecider);
var Lde_cau_cs_kieler_klay_layered_intermediate_greedyswitch_SwitchDecider_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.intermediate.greedyswitch', 'SwitchDecider', 336);
function $getOther(this$static, some_0){
  if (some_0 == this$static.source) {
    return this$static.target;
  }
   else if (some_0 == this$static.target) {
    return this$static.source;
  }
   else {
    throw new IllegalArgumentException_0('Node ' + some_0 + ' not part of edge ' + this$static);
  }
}

function NEdge(){
}

defineClass(88, 1, {88:1}, NEdge);
_.toString_0 = function toString_62(){
  return 'NEdge[id=' + this.id_0 + ' w=' + this.weight + ' d=' + this.delta + ']';
}
;
_.delta = 1;
_.id_0 = 0;
_.treeEdge = false;
_.weight = 0;
var Lde_cau_cs_kieler_klay_layered_networksimplex_NEdge_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.networksimplex', 'NEdge', 88);
function $create_0(this$static){
  if (!this$static.edge.source || !this$static.edge.target) {
    throw new IllegalStateException_0(($ensureNamesAreInitialized(Lde_cau_cs_kieler_klay_layered_networksimplex_NEdge_2_classLit) , Lde_cau_cs_kieler_klay_layered_networksimplex_NEdge_2_classLit.simpleName + ' must have a source and target ' + ($ensureNamesAreInitialized(Lde_cau_cs_kieler_klay_layered_networksimplex_NNode_2_classLit) , Lde_cau_cs_kieler_klay_layered_networksimplex_NNode_2_classLit.simpleName) + ' specified.'));
  }
  if (this$static.edge.source == this$static.edge.target) {
    throw new IllegalStateException_0('Network simplex does not support self-loops: ' + this$static.edge + ' ' + this$static.edge.source + ' ' + this$static.edge.target);
  }
  $add_14(this$static.edge.source.outgoingEdges, this$static.edge);
  $add_14(this$static.edge.target.incomingEdges, this$static.edge);
  return this$static.edge;
}

function $delta(this$static, delta){
  this$static.edge.delta = delta;
  return this$static;
}

function $source(this$static, source){
  this$static.edge.source = source;
  return this$static;
}

function $target(this$static, target){
  this$static.edge.target = target;
  return this$static;
}

function $weight(this$static, weight){
  this$static.edge.weight = weight;
  return this$static;
}

function NEdge$NEdgeBuilder(){
  this.edge = new NEdge;
}

defineClass(157, 1, {}, NEdge$NEdgeBuilder);
var Lde_cau_cs_kieler_klay_layered_networksimplex_NEdge$NEdgeBuilder_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.networksimplex', 'NEdge/NEdgeBuilder', 157);
function NGraph(){
  this.nodes = new ArrayList;
}

defineClass(278, 1, {}, NGraph);
var Lde_cau_cs_kieler_klay_layered_networksimplex_NGraph_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.networksimplex', 'NGraph', 278);
function $getConnectedEdges_0(this$static){
  if (this$static.incomingEdgesModCnt != this$static.incomingEdges.modCount || this$static.outgoingEdgesModCnt != this$static.outgoingEdges.modCount) {
    this$static.allEdges.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
    $addAll_6(this$static.allEdges, this$static.incomingEdges);
    $addAll_6(this$static.allEdges, this$static.outgoingEdges);
    this$static.incomingEdgesModCnt = this$static.incomingEdges.modCount;
    this$static.outgoingEdgesModCnt = this$static.outgoingEdges.modCount;
  }
  return this$static.allEdges;
}

function NNode(){
  this.outgoingEdges = new NNode$ChangeAwareArrayList;
  this.incomingEdges = new NNode$ChangeAwareArrayList;
  this.allEdges = new ArrayList;
  this.unknownCutvalues = new ArrayList;
}

defineClass(61, 1, {61:1}, NNode);
_.id_0 = 0;
_.incomingEdgesModCnt = -1;
_.layer = 0;
_.outgoingEdgesModCnt = -1;
_.treeNode = false;
var Lde_cau_cs_kieler_klay_layered_networksimplex_NNode_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.networksimplex', 'NNode', 61);
function $add_14(this$static, e){
  ++this$static.modCount;
  return this$static.array[this$static.array.length] = e , true;
}

function $remove_8(this$static, o){
  ++this$static.modCount;
  return $remove_7(this$static, o);
}

function NNode$ChangeAwareArrayList(){
  ArrayList.call(this);
}

defineClass(333, 13, $intern_53, NNode$ChangeAwareArrayList);
_.add_2 = function add_25(index_0, element){
  ++this.modCount;
  checkCriticalPositionIndex(index_0, this.array.length);
  insertTo(this.array, index_0, element);
}
;
_.add_1 = function add_26(e){
  return $add_14(this, e);
}
;
_.addAll = function addAll_7(c){
  ++this.modCount;
  return $addAll_6(this, c);
}
;
_.clear_0 = function clear_23(){
  ++this.modCount;
  this.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
}
;
_.remove_2 = function remove_48(index_0){
  ++this.modCount;
  return $remove_6(this, index_0);
}
;
_.remove_1 = function remove_49(o){
  return $remove_8(this, o);
}
;
var Lde_cau_cs_kieler_klay_layered_networksimplex_NNode$ChangeAwareArrayList_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.networksimplex', 'NNode/ChangeAwareArrayList', 333);
function $create_1(this$static, graph){
  $add_11(graph.nodes, this$static.node);
  return this$static.node;
}

function $id(this$static, id_0){
  this$static.node.id_0 = id_0;
  return this$static;
}

function $origin(this$static, origin){
  this$static.node.origin = origin;
  return this$static;
}

function NNode$NNodeBuilder(){
  this.node = new NNode;
}

defineClass(199, 1, {}, NNode$NNodeBuilder);
var Lde_cau_cs_kieler_klay_layered_networksimplex_NNode$NNodeBuilder_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.networksimplex', 'NNode/NNodeBuilder', 199);
function $balance(this$static, filling){
  var i, newLayer, node, node$iterator, range;
  for (node$iterator = new ArrayList$1(this$static.graph.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 61);
    if (node.incomingEdges.array.length == node.outgoingEdges.array.length) {
      newLayer = node.layer;
      range = $minimalSpan(node);
      for (i = node.layer - castTo(range.first, 24).value_0 + 1; i < node.layer + castTo(range.second, 24).value_0; i++) {
        filling[i] < filling[newLayer] && (newLayer = i);
      }
      if (filling[newLayer] < filling[node.layer]) {
        --filling[node.layer];
        ++filling[newLayer];
        node.layer = newLayer;
      }
    }
  }
}

function $cutvalues(this$static){
  var edge, edge$iterator, leafs, node, node$iterator, node$iterator0, source, target, toDetermine, treeEdgeCount;
  leafs = new ArrayList;
  for (node$iterator0 = new ArrayList$1(this$static.graph.nodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
    node = castTo($next_8(node$iterator0), 61);
    treeEdgeCount = 0;
    node.unknownCutvalues.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
    for (edge$iterator = new ArrayList$1($getConnectedEdges_0(node)); edge$iterator.i < edge$iterator.this$01.array.length;) {
      edge = castTo($next_8(edge$iterator), 88);
      if (edge.treeEdge) {
        $add_11(node.unknownCutvalues, edge);
        ++treeEdgeCount;
      }
    }
    treeEdgeCount == 1 && (leafs.array[leafs.array.length] = node , true);
  }
  for (node$iterator = new ArrayList$1(leafs); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 61);
    while (node.unknownCutvalues.array.length == 1) {
      toDetermine = castTo($next_8(new ArrayList$1(node.unknownCutvalues)), 88);
      this$static.cutvalue[toDetermine.id_0] = toDetermine.weight;
      source = toDetermine.source;
      target = toDetermine.target;
      for (edge$iterator = new ArrayList$1($getConnectedEdges_0(node)); edge$iterator.i < edge$iterator.this$01.array.length;) {
        edge = castTo($next_8(edge$iterator), 88);
        edge == toDetermine || (edge.treeEdge?source == edge.source || target == edge.target?(this$static.cutvalue[toDetermine.id_0] -= this$static.cutvalue[edge.id_0] - edge.weight):(this$static.cutvalue[toDetermine.id_0] += this$static.cutvalue[edge.id_0] - edge.weight):node == source?edge.source == node?(this$static.cutvalue[toDetermine.id_0] += edge.weight):(this$static.cutvalue[toDetermine.id_0] -= edge.weight):edge.source == node?(this$static.cutvalue[toDetermine.id_0] -= edge.weight):(this$static.cutvalue[toDetermine.id_0] += edge.weight));
      }
      $remove_7(source.unknownCutvalues, toDetermine);
      $remove_7(target.unknownCutvalues, toDetermine);
      source == node?(node = toDetermine.target):(node = toDetermine.source);
    }
  }
}

function $enterEdge(this$static, leave){
  var edge, edge$iterator, repSlack, replace, slack, source, target;
  if (!leave.treeEdge) {
    throw new IllegalArgumentException_0('The input edge is not a tree edge.');
  }
  replace = null;
  repSlack = $intern_3;
  for (edge$iterator = new ArrayList$1(this$static.edges); edge$iterator.i < edge$iterator.this$01.array.length;) {
    edge = castTo($next_8(edge$iterator), 88);
    source = edge.source;
    target = edge.target;
    if ($isInHead(this$static, source, leave) && !$isInHead(this$static, target, leave)) {
      slack = target.layer - source.layer - edge.delta;
      if (slack < repSlack) {
        repSlack = slack;
        replace = edge;
      }
    }
  }
  return replace;
}

function $exchange(this$static, leave, enter){
  var delta, node, node$iterator;
  if (!leave.treeEdge) {
    throw new IllegalArgumentException_0('Given leave edge is no tree edge.');
  }
  if (enter.treeEdge) {
    throw new IllegalArgumentException_0('Given enter edge is a tree edge already.');
  }
  leave.treeEdge = false;
  $remove_17(this$static.treeEdges, leave);
  enter.treeEdge = true;
  $add_18(this$static.treeEdges, enter);
  delta = enter.target.layer - enter.source.layer - enter.delta;
  $isInHead(this$static, enter.target, leave) || (delta = -delta);
  for (node$iterator = new ArrayList$1(this$static.graph.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 61);
    $isInHead(this$static, node, leave) || (node.layer += delta);
  }
  this$static.postOrder = 1;
  fill_6(this$static.edgeVisited);
  $postorderTraversal(this$static, castTo($next_8(new ArrayList$1(this$static.graph.nodes)), 61));
  $cutvalues(this$static);
}

function $execute(this$static, monitor){
  var e, iter, node, node$iterator, removeSubtrees;
  $begin(monitor, 'Network simplex', 1);
  if (this$static.graph.nodes.array.length < 1) {
    $done(monitor);
    return;
  }
  for (node$iterator = new ArrayList$1(this$static.graph.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 61);
    node.layer = 0;
  }
  removeSubtrees = this$static.graph.nodes.array.length >= 40;
  removeSubtrees && $removeSubtrees(this$static);
  $initialize_1(this$static);
  $feasibleTree(this$static);
  e = $leaveEdge(this$static);
  iter = 0;
  while (!!e && iter < this$static.iterationLimit) {
    $exchange(this$static, e, $enterEdge(this$static, e));
    e = $leaveEdge(this$static);
    ++iter;
  }
  removeSubtrees && $reattachSubtrees(this$static);
  this$static.balance?$balance(this$static, $normalize(this$static)):$normalize(this$static);
  this$static.cutvalue = null;
  this$static.edges = null;
  this$static.treeEdges = null;
  this$static.edgeVisited = null;
  this$static.lowestPoID = null;
  this$static.poID = null;
  this$static.sources = null;
  this$static.subtreeNodes = null;
  $done(monitor);
}

function $feasibleTree(this$static){
  var e, node, node$iterator, slack;
  $layeringTopologicalNumbering(this$static, this$static.sources);
  if (this$static.edges.array.length > 0) {
    fill_6(this$static.edgeVisited);
    while ($tightTreeDFS(this$static, castTo($next_8(new ArrayList$1(this$static.graph.nodes)), 61)) < this$static.graph.nodes.array.length) {
      e = $minimalSlack(this$static);
      slack = e.target.layer - e.source.layer - e.delta;
      e.target.treeNode && (slack = -slack);
      for (node$iterator = new ArrayList$1(this$static.graph.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
        node = castTo($next_8(node$iterator), 61);
        node.treeNode && (node.layer += slack);
      }
      fill_6(this$static.edgeVisited);
    }
    fill_6(this$static.edgeVisited);
    $postorderTraversal(this$static, castTo($next_8(new ArrayList$1(this$static.graph.nodes)), 61));
    $cutvalues(this$static);
  }
}

function $initialize_1(this$static){
  var counter, edge, edge$iterator, index_0, n, n$iterator, node, node$iterator, numEdges, numNodes, theEdges;
  numNodes = this$static.graph.nodes.array.length;
  for (n$iterator = new ArrayList$1(this$static.graph.nodes); n$iterator.i < n$iterator.this$01.array.length;) {
    n = castTo($next_8(n$iterator), 61);
    n.treeNode = false;
  }
  this$static.poID = initUnidimensionalArray(I_classLit, $intern_37, 26, numNodes, 12, 1);
  this$static.lowestPoID = initUnidimensionalArray(I_classLit, $intern_37, 26, numNodes, 12, 1);
  this$static.sources = new ArrayList;
  index_0 = 0;
  theEdges = new ArrayList;
  for (node$iterator = new ArrayList$1(this$static.graph.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 61);
    node.id_0 = index_0++;
    node.incomingEdges.array.length == 0 && $add_11(this$static.sources, node);
    $addAll_6(theEdges, node.outgoingEdges);
  }
  counter = 0;
  for (edge$iterator = new ArrayList$1(theEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
    edge = castTo($next_8(edge$iterator), 88);
    edge.id_0 = counter++;
    edge.treeEdge = false;
  }
  numEdges = theEdges.array.length;
  if (this$static.cutvalue == null || this$static.cutvalue.length < numEdges) {
    this$static.cutvalue = initUnidimensionalArray(D_classLit, $intern_11, 26, numEdges, 12, 1);
    this$static.edgeVisited = initUnidimensionalArray(Z_classLit, $intern_63, 26, numEdges, 13, 1);
  }
   else {
    fill_6(this$static.edgeVisited);
  }
  this$static.edges = theEdges;
  this$static.treeEdges = new LinkedHashSet_0(capacity_0(this$static.edges.array.length));
  this$static.postOrder = 1;
}

function $isInHead(this$static, node, edge){
  var source, target;
  source = edge.source;
  target = edge.target;
  if (this$static.lowestPoID[source.id_0] <= this$static.poID[node.id_0] && this$static.poID[node.id_0] <= this$static.poID[source.id_0] && this$static.lowestPoID[target.id_0] <= this$static.poID[node.id_0] && this$static.poID[node.id_0] <= this$static.poID[target.id_0]) {
    if (this$static.poID[source.id_0] < this$static.poID[target.id_0]) {
      return false;
    }
    return true;
  }
  if (this$static.poID[source.id_0] < this$static.poID[target.id_0]) {
    return true;
  }
  return false;
}

function $layeringTopologicalNumbering(this$static, initialRootNodes){
  var edge, edge$iterator, incident, node, node$iterator, roots, target;
  incident = initUnidimensionalArray(I_classLit, $intern_37, 26, this$static.graph.nodes.array.length, 12, 1);
  for (node$iterator = new ArrayList$1(this$static.graph.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 61);
    incident[node.id_0] += node.incomingEdges.array.length;
  }
  roots = newLinkedList(initialRootNodes);
  while (roots.size_0 != 0) {
    node = castTo(roots.size_0 == 0?null:(checkCriticalElement(roots.size_0 != 0) , $removeNode_0(roots, roots.header.next_0)), 61);
    for (edge$iterator = new ArrayList$1(node.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
      edge = castTo($next_8(edge$iterator), 88);
      target = edge.target;
      target.layer = max_3(target.layer, node.layer + edge.delta);
      --incident[target.id_0];
      incident[target.id_0] == 0 && ($addNode_0(roots, target, roots.tail.prev, roots.tail) , true);
    }
  }
}

function $leaveEdge(this$static){
  var edge, edge$iterator, entry, outerIter;
  for (edge$iterator = (outerIter = (new AbstractMap$1(this$static.treeEdges.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter)); edge$iterator.val$outerIter2.hasNext_0();) {
    edge = (entry = castTo(edge$iterator.val$outerIter2.next_1(), 21) , castTo(entry.getKey(), 88));
    if (edge.treeEdge && this$static.cutvalue[edge.id_0] < 0) {
      return edge;
    }
  }
  return null;
}

function $minimalSlack(this$static){
  var curSlack, edge, edge$iterator, minSlack, minSlackEdge;
  minSlack = $intern_3;
  minSlackEdge = null;
  for (edge$iterator = new ArrayList$1(this$static.edges); edge$iterator.i < edge$iterator.this$01.array.length;) {
    edge = castTo($next_8(edge$iterator), 88);
    if (edge.source.treeNode ^ edge.target.treeNode) {
      curSlack = edge.target.layer - edge.source.layer - edge.delta;
      if (curSlack < minSlack) {
        minSlack = curSlack;
        minSlackEdge = edge;
      }
    }
  }
  return minSlackEdge;
}

function $minimalSpan(node){
  var currentSpan, edge, edge$iterator, minSpanIn, minSpanOut;
  minSpanOut = $intern_3;
  minSpanIn = $intern_3;
  for (edge$iterator = new ArrayList$1($getConnectedEdges_0(node)); edge$iterator.i < edge$iterator.this$01.array.length;) {
    edge = castTo($next_8(edge$iterator), 88);
    currentSpan = edge.target.layer - edge.source.layer;
    edge.target == node && currentSpan < minSpanIn?(minSpanIn = currentSpan):currentSpan < minSpanOut && (minSpanOut = currentSpan);
  }
  minSpanIn == $intern_3 && (minSpanIn = -1);
  minSpanOut == $intern_3 && (minSpanOut = -1);
  return new Pair(valueOf_0(minSpanIn), valueOf_0(minSpanOut));
}

function $normalize(this$static){
  var eLayer, eLayer$iterator, filling, highest, layerID, lowest, node, node$iterator, node$iterator0;
  highest = $intern_8;
  lowest = $intern_3;
  for (node$iterator0 = new ArrayList$1(this$static.graph.nodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
    node = castTo($next_8(node$iterator0), 61);
    lowest = min_3(lowest, node.layer);
    highest = max_3(highest, node.layer);
  }
  layerID = 0;
  filling = initUnidimensionalArray(I_classLit, $intern_37, 26, highest - lowest + 1, 12, 1);
  for (node$iterator = new ArrayList$1(this$static.graph.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 61);
    node.layer -= lowest;
    ++filling[node.layer];
  }
  if (this$static.previousLayering) {
    for (eLayer$iterator = new ArrayList$1(this$static.previousLayering.layers); eLayer$iterator.i < eLayer$iterator.this$01.array.length;) {
      eLayer = castTo($next_8(eLayer$iterator), 16);
      filling[layerID++] += eLayer.nodes.array.length;
      if (filling.length == layerID) {
        break;
      }
    }
  }
  return filling;
}

function $postorderTraversal(this$static, node){
  var edge, edge$iterator, lowest;
  lowest = $intern_3;
  for (edge$iterator = new ArrayList$1($getConnectedEdges_0(node)); edge$iterator.i < edge$iterator.this$01.array.length;) {
    edge = castTo($next_8(edge$iterator), 88);
    if (edge.treeEdge && !this$static.edgeVisited[edge.id_0]) {
      this$static.edgeVisited[edge.id_0] = true;
      lowest = min_3(lowest, $postorderTraversal(this$static, $getOther(edge, node)));
    }
  }
  this$static.poID[node.id_0] = this$static.postOrder;
  this$static.lowestPoID[node.id_0] = min_3(lowest, this$static.postOrder++);
  return this$static.lowestPoID[node.id_0];
}

function $reattachSubtrees(this$static){
  var edge, leafy, node, placed;
  while (this$static.subtreeNodes.arrayList.array.length != 0) {
    leafy = castTo($pop(this$static.subtreeNodes), 27);
    node = castTo(leafy.first, 61);
    edge = castTo(leafy.second, 88);
    placed = $getOther(edge, node);
    if (edge.target == node) {
      $add_14(placed.outgoingEdges, edge);
      node.layer = placed.layer + edge.delta;
    }
     else {
      $add_14(placed.incomingEdges, edge);
      node.layer = placed.layer - edge.delta;
    }
    $add_11(this$static.graph.nodes, node);
  }
}

function $removeSubtrees(this$static){
  var edge, isOutEdge, leafs, leafy, node, node$iterator, other;
  this$static.subtreeNodes = new Stack;
  leafs = new LinkedList;
  for (node$iterator = new ArrayList$1(this$static.graph.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 61);
    $getConnectedEdges_0(node).array.length == 1 && ($addNode_0(leafs, node, leafs.tail.prev, leafs.tail) , true);
  }
  while (leafs.size_0 != 0) {
    node = castTo(leafs.size_0 == 0?null:(checkCriticalElement(leafs.size_0 != 0) , $removeNode_0(leafs, leafs.header.next_0)), 61);
    if ($getConnectedEdges_0(node).array.length == 0) {
      continue;
    }
    edge = castTo($get_8($getConnectedEdges_0(node), 0), 88);
    isOutEdge = node.outgoingEdges.array.length > 0;
    other = $getOther(edge, node);
    isOutEdge?$remove_8(other.incomingEdges, edge):$remove_8(other.outgoingEdges, edge);
    $getConnectedEdges_0(other).array.length == 1 && ($addNode_0(leafs, other, leafs.tail.prev, leafs.tail) , true);
    leafy = new Pair(node, edge);
    $push(this$static.subtreeNodes, leafy);
    $remove_7(this$static.graph.nodes, node);
  }
}

function $tightTreeDFS(this$static, node){
  var edge, edge$iterator, nodeCount, opposite;
  nodeCount = 1;
  node.treeNode = true;
  for (edge$iterator = new ArrayList$1($getConnectedEdges_0(node)); edge$iterator.i < edge$iterator.this$01.array.length;) {
    edge = castTo($next_8(edge$iterator), 88);
    if (!this$static.edgeVisited[edge.id_0]) {
      this$static.edgeVisited[edge.id_0] = true;
      opposite = $getOther(edge, node);
      if (edge.treeEdge) {
        nodeCount += $tightTreeDFS(this$static, opposite);
      }
       else if (!opposite.treeNode && edge.delta == edge.target.layer - edge.source.layer) {
        edge.treeEdge = true;
        $add_18(this$static.treeEdges, edge);
        nodeCount += $tightTreeDFS(this$static, opposite);
      }
    }
  }
  return nodeCount;
}

function $withBalancing(this$static, doBalance){
  this$static.balance = doBalance;
  return this$static;
}

function $withIterationLimit(this$static, limit){
  this$static.iterationLimit = limit;
  return this$static;
}

function $withPreviousLayering(this$static, considerPreviousLayering){
  this$static.previousLayering = considerPreviousLayering;
  return this$static;
}

function NetworkSimplex(){
}

function forGraph(graph){
  var ns;
  ns = new NetworkSimplex;
  ns.graph = graph;
  return ns;
}

defineClass(595, 1, {}, NetworkSimplex);
_.balance = false;
_.iterationLimit = $intern_3;
_.postOrder = 0;
var Lde_cau_cs_kieler_klay_layered_networksimplex_NetworkSimplex_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.networksimplex', 'NetworkSimplex', 595);
function $clinit_CycleBreakingStrategy(){
  $clinit_CycleBreakingStrategy = emptyMethod;
  GREEDY = new CycleBreakingStrategy('GREEDY', 0);
  INTERACTIVE_0 = new CycleBreakingStrategy('INTERACTIVE', 1);
}

function CycleBreakingStrategy(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function values_36(){
  $clinit_CycleBreakingStrategy();
  return stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_p1cycles_CycleBreakingStrategy_2_classLit, 1), $intern_13, 193, 0, [GREEDY, INTERACTIVE_0]);
}

defineClass(193, 17, {180:1, 193:1, 3:1, 23:1, 17:1}, CycleBreakingStrategy);
_.create_0 = function create_1(){
  switch (this.ordinal) {
    case 0:
      return new GreedyCycleBreaker;
    case 1:
      return new InteractiveCycleBreaker;
    default:throw new IllegalArgumentException_0('No implementation is available for the cycle breaker ' + (this.name_0 != null?this.name_0:'' + this.ordinal));
  }
}
;
var GREEDY, INTERACTIVE_0;
var Lde_cau_cs_kieler_klay_layered_p1cycles_CycleBreakingStrategy_2_classLit = createForEnum('de.cau.cs.kieler.klay.layered.p1cycles', 'CycleBreakingStrategy', 193, Ljava_lang_Enum_2_classLit, values_36);
function $clinit_CycleBreakingStrategy$Map(){
  $clinit_CycleBreakingStrategy$Map = emptyMethod;
  $MAP_15 = createValueOfMap(($clinit_CycleBreakingStrategy() , stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_p1cycles_CycleBreakingStrategy_2_classLit, 1), $intern_13, 193, 0, [GREEDY, INTERACTIVE_0])));
}

var $MAP_15;
function $clinit_GreedyCycleBreaker(){
  $clinit_GreedyCycleBreaker = emptyMethod;
  INTERMEDIATE_PROCESSING_CONFIGURATION = $addAfterPhase5(new IntermediateProcessingConfiguration, ($clinit_IntermediateProcessorStrategy() , REVERSED_EDGE_RESTORER));
}

function $updateNeighbors(this$static, node){
  var connectedPort, edge, edge$iterator, endpoint, index_0, port, port$iterator, priority;
  for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_8(port$iterator), 7);
    for (edge$iterator = $iterator(concat(($clinit_ImmutableList() , new RegularImmutableList(nullCheckedList(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [port.incomingEdges, port.outgoingEdges])))))); $hasNext_0(edge$iterator);) {
      edge = castTo($next_2(edge$iterator), 12);
      connectedPort = edge.source == port?edge.target:edge.source;
      endpoint = connectedPort.owner;
      if (node == endpoint) {
        continue;
      }
      priority = castTo($getProperty(edge, ($clinit_InternalProperties() , PRIORITY_0)), 24).value_0;
      priority < 0 && (priority = 0);
      index_0 = endpoint.id_0;
      if (this$static.mark[index_0] == 0) {
        if (edge.target == connectedPort) {
          this$static.indeg[index_0] -= priority + 1;
          this$static.indeg[index_0] <= 0 && this$static.outdeg[index_0] > 0 && $add_8(this$static.sources, endpoint);
        }
         else {
          this$static.outdeg[index_0] -= priority + 1;
          this$static.outdeg[index_0] <= 0 && this$static.indeg[index_0] > 0 && $add_8(this$static.sinks, endpoint);
        }
      }
    }
  }
}

function GreedyCycleBreaker(){
  $clinit_GreedyCycleBreaker();
  this.sources = new LinkedList;
  this.sinks = new LinkedList;
}

defineClass(539, 1, $intern_64, GreedyCycleBreaker);
_.getIntermediateProcessingConfiguration = function getIntermediateProcessingConfiguration(graph){
  return INTERMEDIATE_PROCESSING_CONFIGURATION;
}
;
_.process = function process_46(layeredGraph, monitor){
  var edge, edge$index, edge$iterator, edge$iterator0, edge$max, index_0, maxNode, maxNodes, maxOutflow, nextLeft, nextRight, node, node$iterator, node$iterator0, node$iterator1, nodes, outflow, outgoingEdges, port, port$index, port$iterator, port$max, ports, priority, random, shiftBase, sink, source, targetIx, unprocessedNodeCount;
  $begin(monitor, 'Greedy cycle removal', 1);
  nodes = layeredGraph.layerlessNodes;
  unprocessedNodeCount = nodes.array.length;
  this.indeg = initUnidimensionalArray(I_classLit, $intern_37, 26, unprocessedNodeCount, 12, 1);
  this.outdeg = initUnidimensionalArray(I_classLit, $intern_37, 26, unprocessedNodeCount, 12, 1);
  this.mark = initUnidimensionalArray(I_classLit, $intern_37, 26, unprocessedNodeCount, 12, 1);
  index_0 = 0;
  for (node$iterator0 = new ArrayList$1(nodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
    node = castTo($next_8(node$iterator0), 9);
    node.id_0 = index_0;
    for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_8(port$iterator), 7);
      for (edge$iterator0 = new ArrayList$1(port.incomingEdges); edge$iterator0.i < edge$iterator0.this$01.array.length;) {
        edge = castTo($next_8(edge$iterator0), 12);
        if (edge.source.owner == node) {
          continue;
        }
        priority = castTo($getProperty(edge, ($clinit_InternalProperties() , PRIORITY_0)), 24).value_0;
        this.indeg[index_0] += priority > 0?priority + 1:1;
      }
      for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
        edge = castTo($next_8(edge$iterator), 12);
        if (edge.target.owner == node) {
          continue;
        }
        priority = castTo($getProperty(edge, ($clinit_InternalProperties() , PRIORITY_0)), 24).value_0;
        this.outdeg[index_0] += priority > 0?priority + 1:1;
      }
    }
    this.outdeg[index_0] == 0?$add_8(this.sinks, node):this.indeg[index_0] == 0 && $add_8(this.sources, node);
    ++index_0;
  }
  nextRight = -1;
  nextLeft = 1;
  maxNodes = new ArrayList;
  random = castTo($getProperty(layeredGraph, ($clinit_InternalProperties() , RANDOM)), 154);
  while (unprocessedNodeCount > 0) {
    while (this.sinks.size_0 != 0) {
      sink = castTo($removeFirst(this.sinks), 9);
      this.mark[sink.id_0] = nextRight--;
      $updateNeighbors(this, sink);
      --unprocessedNodeCount;
    }
    while (this.sources.size_0 != 0) {
      source = castTo($removeFirst(this.sources), 9);
      this.mark[source.id_0] = nextLeft++;
      $updateNeighbors(this, source);
      --unprocessedNodeCount;
    }
    if (unprocessedNodeCount > 0) {
      maxOutflow = $intern_8;
      for (node$iterator1 = new ArrayList$1(nodes); node$iterator1.i < node$iterator1.this$01.array.length;) {
        node = castTo($next_8(node$iterator1), 9);
        if (this.mark[node.id_0] == 0) {
          outflow = this.outdeg[node.id_0] - this.indeg[node.id_0];
          if (outflow >= maxOutflow) {
            if (outflow > maxOutflow) {
              maxNodes.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
              maxOutflow = outflow;
            }
            maxNodes.array[maxNodes.array.length] = node;
          }
        }
      }
      maxNode = castTo($get_8(maxNodes, $nextInt(random, maxNodes.array.length)), 9);
      this.mark[maxNode.id_0] = nextLeft++;
      $updateNeighbors(this, maxNode);
      --unprocessedNodeCount;
    }
  }
  shiftBase = nodes.array.length + 1;
  for (index_0 = 0; index_0 < nodes.array.length; index_0++) {
    this.mark[index_0] < 0 && (this.mark[index_0] += shiftBase);
  }
  for (node$iterator = new ArrayList$1(nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 9);
    ports = castTo($toArray_1(node.ports, initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LPort_2_classLit, $intern_59, 7, node.ports.array.length, 0, 1)), 346);
    for (port$index = 0 , port$max = ports.length; port$index < port$max; ++port$index) {
      port = ports[port$index];
      outgoingEdges = castTo($toArray_1(port.outgoingEdges, initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LEdge_2_classLit, $intern_57, 12, port.outgoingEdges.array.length, 0, 1)), 47);
      for (edge$index = 0 , edge$max = outgoingEdges.length; edge$index < edge$max; ++edge$index) {
        edge = outgoingEdges[edge$index];
        targetIx = edge.target.owner.id_0;
        if (this.mark[node.id_0] > this.mark[targetIx]) {
          $reverse_0(edge, true);
          $setProperty(layeredGraph, CYCLIC, ($clinit_Boolean() , $clinit_Boolean() , TRUE_0));
        }
      }
    }
  }
  this.indeg = null;
  this.outdeg = null;
  this.mark = null;
  $reset_0(this.sources);
  $reset_0(this.sinks);
  $done(monitor);
}
;
var INTERMEDIATE_PROCESSING_CONFIGURATION;
var Lde_cau_cs_kieler_klay_layered_p1cycles_GreedyCycleBreaker_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p1cycles', 'GreedyCycleBreaker', 539);
function $clinit_InteractiveCycleBreaker(){
  $clinit_InteractiveCycleBreaker = emptyMethod;
  INTERMEDIATE_PROCESSING_CONFIGURATION_0 = $addAfterPhase5($addBeforePhase1(new IntermediateProcessingConfiguration, ($clinit_IntermediateProcessorStrategy() , INTERACTIVE_EXTERNAL_PORT_POSITIONER)), REVERSED_EDGE_RESTORER);
}

function $findCycles(this$static, node1, revEdges){
  var edge, edge$iterator, node2, port, port$iterator;
  node1.id_0 = -1;
  for (port$iterator = $getPorts_1(node1, ($clinit_PortType() , OUTPUT)).iterator_0(); port$iterator.hasNext_0();) {
    port = castTo(port$iterator.next_1(), 7);
    for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
      edge = castTo($next_8(edge$iterator), 12);
      node2 = edge.target.owner;
      node1 != node2 && (node2.id_0 < 0?revEdges.add_1(edge):node2.id_0 > 0 && $findCycles(this$static, node2, revEdges));
    }
  }
  node1.id_0 = 0;
}

function InteractiveCycleBreaker(){
  $clinit_InteractiveCycleBreaker();
}

defineClass(540, 1, $intern_64, InteractiveCycleBreaker);
_.getIntermediateProcessingConfiguration = function getIntermediateProcessingConfiguration_0(graph){
  return INTERMEDIATE_PROCESSING_CONFIGURATION_0;
}
;
_.process = function process_47(layeredGraph, monitor){
  var edge, edge$iterator, edge$iterator0, edge$iterator1, node, node$iterator, port, port$iterator, revEdges, source, source$iterator, sourcex, target, targetx;
  $begin(monitor, 'Interactive cycle breaking', 1);
  revEdges = new ArrayList;
  for (source$iterator = new ArrayList$1(layeredGraph.layerlessNodes); source$iterator.i < source$iterator.this$01.array.length;) {
    source = castTo($next_8(source$iterator), 9);
    source.id_0 = 1;
    sourcex = $getInteractiveReferencePoint(source).x_0;
    for (port$iterator = $getPorts_1(source, ($clinit_PortType() , OUTPUT)).iterator_0(); port$iterator.hasNext_0();) {
      port = castTo(port$iterator.next_1(), 7);
      for (edge$iterator0 = new ArrayList$1(port.outgoingEdges); edge$iterator0.i < edge$iterator0.this$01.array.length;) {
        edge = castTo($next_8(edge$iterator0), 12);
        target = edge.target.owner;
        if (target != source) {
          targetx = $getInteractiveReferencePoint(target).x_0;
          targetx < sourcex && (revEdges.array[revEdges.array.length] = edge , true);
        }
      }
    }
  }
  for (edge$iterator1 = new ArrayList$1(revEdges); edge$iterator1.i < edge$iterator1.this$01.array.length;) {
    edge = castTo($next_8(edge$iterator1), 12);
    $reverse_0(edge, true);
  }
  revEdges.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
  for (node$iterator = new ArrayList$1(layeredGraph.layerlessNodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 9);
    node.id_0 > 0 && $findCycles(this, node, revEdges);
  }
  for (edge$iterator = new ArrayList$1(revEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
    edge = castTo($next_8(edge$iterator), 12);
    $reverse_0(edge, true);
  }
  revEdges.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
  $done(monitor);
}
;
var INTERMEDIATE_PROCESSING_CONFIGURATION_0;
var Lde_cau_cs_kieler_klay_layered_p1cycles_InteractiveCycleBreaker_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p1cycles', 'InteractiveCycleBreaker', 540);
function $checkNode(this$static, node1, graph){
  var edge, edge$iterator, layer1, layer2, newIndex, newLayer, node2, port, port$iterator;
  node1.id_0 = 1;
  layer1 = node1.layer;
  for (port$iterator = $getPorts_1(node1, ($clinit_PortType() , OUTPUT)).iterator_0(); port$iterator.hasNext_0();) {
    port = castTo(port$iterator.next_1(), 7);
    for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
      edge = castTo($next_8(edge$iterator), 12);
      node2 = edge.target.owner;
      if (node1 != node2) {
        layer2 = node2.layer;
        if (layer2.id_0 <= layer1.id_0) {
          newIndex = layer1.id_0 + 1;
          if (newIndex == graph.layers.array.length) {
            newLayer = new Layer(graph);
            newLayer.id_0 = newIndex;
            $add_11(graph.layers, newLayer);
            $setLayer_0(node2, newLayer);
          }
           else {
            newLayer = castTo($get_8(graph.layers, newIndex), 16);
            $setLayer_0(node2, newLayer);
          }
          $checkNode(this$static, node2, graph);
        }
      }
    }
  }
}

function InteractiveLayerer(){
}

defineClass(543, 1, $intern_64, InteractiveLayerer);
_.getIntermediateProcessingConfiguration = function getIntermediateProcessingConfiguration_1(graph){
  return $addBeforePhase3($addBeforePhase1(new IntermediateProcessingConfiguration, ($clinit_IntermediateProcessorStrategy() , INTERACTIVE_EXTERNAL_PORT_POSITIONER)), LAYER_CONSTRAINT_PROCESSOR);
}
;
_.process = function process_48(layeredGraph, monitor){
  var currentSpans, foundSpan, layer, layers, maxx, minx, nextIndex, node, node$iterator, node$iterator0, node$iterator1, span_0, span$iterator, spanIter;
  $begin(monitor, 'Interactive node layering', 1);
  currentSpans = new ArrayList;
  for (node$iterator0 = new ArrayList$1(layeredGraph.layerlessNodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
    node = castTo($next_8(node$iterator0), 9);
    minx = node.pos.x_0;
    maxx = minx + node.size_0.x_0;
    maxx = minx + 1 > maxx?minx + 1:maxx;
    spanIter = new AbstractList$ListIteratorImpl(currentSpans, 0);
    foundSpan = null;
    while (spanIter.i < spanIter.this$01_0.size_1()) {
      span_0 = (checkCriticalElement(spanIter.i < spanIter.this$01_0.size_1()) , castTo(spanIter.this$01_0.get_2(spanIter.last = spanIter.i++), 239));
      if (span_0.start_0 >= maxx) {
        checkCriticalElement(spanIter.i > 0);
        spanIter.this$01.get_2(spanIter.last = --spanIter.i);
        break;
      }
       else if (span_0.end > minx) {
        if (!foundSpan) {
          $add_11(span_0.nodes, node);
          span_0.start_0 = min_1(span_0.start_0, minx);
          span_0.end = max_1(span_0.end, maxx);
          foundSpan = span_0;
        }
         else {
          $addAll_6(foundSpan.nodes, span_0.nodes);
          foundSpan.end = max_1(foundSpan.end, span_0.end);
          $remove_11(spanIter);
        }
      }
    }
    if (!foundSpan) {
      foundSpan = new InteractiveLayerer$LayerSpan;
      foundSpan.start_0 = minx;
      foundSpan.end = maxx;
      $add_15(spanIter, foundSpan);
      $add_11(foundSpan.nodes, node);
    }
  }
  layers = layeredGraph.layers;
  nextIndex = 0;
  for (span$iterator = new ArrayList$1(currentSpans); span$iterator.i < span$iterator.this$01.array.length;) {
    span_0 = castTo($next_8(span$iterator), 239);
    layer = new Layer(layeredGraph);
    layer.id_0 = nextIndex++;
    layers.array[layers.array.length] = layer;
    for (node$iterator1 = new ArrayList$1(span_0.nodes); node$iterator1.i < node$iterator1.this$01.array.length;) {
      node = castTo($next_8(node$iterator1), 9);
      $setLayer_0(node, layer);
      node.id_0 = 0;
    }
  }
  for (node$iterator = new ArrayList$1(layeredGraph.layerlessNodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 9);
    node.id_0 == 0 && $checkNode(this, node, layeredGraph);
  }
  while ((checkCriticalElementIndex(0, layers.array.length) , castTo(layers.array[0], 16)).nodes.array.length == 0) {
    checkCriticalElementIndex(0, layers.array.length);
    layers.array.splice(0, 1);
  }
  layeredGraph.layerlessNodes.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
  $done(monitor);
}
;
var Lde_cau_cs_kieler_klay_layered_p2layers_InteractiveLayerer_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p2layers', 'InteractiveLayerer', 543);
function InteractiveLayerer$LayerSpan(){
  this.nodes = new ArrayList;
}

defineClass(239, 1, {239:1}, InteractiveLayerer$LayerSpan);
_.end = 0;
_.start_0 = 0;
var Lde_cau_cs_kieler_klay_layered_p2layers_InteractiveLayerer$LayerSpan_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p2layers', 'InteractiveLayerer/LayerSpan', 239);
function $clinit_LayeringStrategy(){
  $clinit_LayeringStrategy = emptyMethod;
  NETWORK_SIMPLEX = new LayeringStrategy('NETWORK_SIMPLEX', 0);
  LONGEST_PATH = new LayeringStrategy('LONGEST_PATH', 1);
  INTERACTIVE_1 = new LayeringStrategy('INTERACTIVE', 2);
}

function LayeringStrategy(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function values_37(){
  $clinit_LayeringStrategy();
  return stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_p2layers_LayeringStrategy_2_classLit, 1), $intern_13, 173, 0, [NETWORK_SIMPLEX, LONGEST_PATH, INTERACTIVE_1]);
}

defineClass(173, 17, {180:1, 173:1, 3:1, 23:1, 17:1}, LayeringStrategy);
_.create_0 = function create_2(){
  switch (this.ordinal) {
    case 0:
      return new NetworkSimplexLayerer;
    case 1:
      return new LongestPathLayerer;
    case 2:
      return new InteractiveLayerer;
    default:throw new IllegalArgumentException_0('No implementation is available for the layerer ' + (this.name_0 != null?this.name_0:'' + this.ordinal));
  }
}
;
var INTERACTIVE_1, LONGEST_PATH, NETWORK_SIMPLEX;
var Lde_cau_cs_kieler_klay_layered_p2layers_LayeringStrategy_2_classLit = createForEnum('de.cau.cs.kieler.klay.layered.p2layers', 'LayeringStrategy', 173, Ljava_lang_Enum_2_classLit, values_37);
function $clinit_LayeringStrategy$Map(){
  $clinit_LayeringStrategy$Map = emptyMethod;
  $MAP_16 = createValueOfMap(($clinit_LayeringStrategy() , stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_p2layers_LayeringStrategy_2_classLit, 1), $intern_13, 173, 0, [NETWORK_SIMPLEX, LONGEST_PATH, INTERACTIVE_1])));
}

var $MAP_16;
function $clinit_LongestPathLayerer(){
  $clinit_LongestPathLayerer = emptyMethod;
  BASELINE_PROCESSING_CONFIGURATION_0 = $addBeforePhase3($addBeforePhase1(new IntermediateProcessingConfiguration, ($clinit_IntermediateProcessorStrategy() , EDGE_AND_LAYER_CONSTRAINT_EDGE_REVERSER)), LAYER_CONSTRAINT_PROCESSOR);
  BIG_NODES_PROCESSING_ADDITIONS_AGGRESSIVE = $addAfterPhase5($addBeforePhase3($addBeforePhase2(new IntermediateProcessingConfiguration, BIG_NODES_PREPROCESSOR), BIG_NODES_INTERMEDIATEPROCESSOR), BIG_NODES_POSTPROCESSOR);
  BIG_NODES_PROCESSING_ADDITIONS_CAREFUL = $addAfterPhase5($addBeforePhase4(new IntermediateProcessingConfiguration, BIG_NODES_SPLITTER), BIG_NODES_POSTPROCESSOR);
}

function $putNode(this$static, node, height){
  var i, layers;
  layers = this$static.layeredGraph.layers;
  for (i = layers.array.length; i < height; i++) {
    $add_10(layers, 0, new Layer(this$static.layeredGraph));
  }
  $setLayer_0(node, castTo($get_8(layers, layers.array.length - height), 16));
  this$static.nodeHeights[node.id_0] = height;
}

function $visit(this$static, node){
  var edge, edge$iterator, height, maxHeight, port, port$iterator, targetHeight, targetNode;
  height = this$static.nodeHeights[node.id_0];
  if (height >= 0) {
    return height;
  }
   else {
    maxHeight = 1;
    for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_8(port$iterator), 7);
      for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
        edge = castTo($next_8(edge$iterator), 12);
        targetNode = edge.target.owner;
        if (node != targetNode) {
          targetHeight = $visit(this$static, targetNode);
          maxHeight = maxHeight > targetHeight + 1?maxHeight:targetHeight + 1;
        }
      }
    }
    $putNode(this$static, node, maxHeight);
    return maxHeight;
  }
}

function LongestPathLayerer(){
  $clinit_LongestPathLayerer();
}

defineClass(542, 1, $intern_64, LongestPathLayerer);
_.getIntermediateProcessingConfiguration = function getIntermediateProcessingConfiguration_2(graph){
  var strategy;
  strategy = fromExisting(BASELINE_PROCESSING_CONFIGURATION_0);
  unsafeCast(checkNotNull_1(castToBoolean($getProperty(graph, ($clinit_Properties() , DISTRIBUTE_NODES))))) || maskUndefined($getProperty(graph, WIDE_NODES_ON_MULTIPLE_LAYERS)) === maskUndefined(($clinit_WideNodesStrategy() , AGGRESSIVE))?$addAll_4(strategy, BIG_NODES_PROCESSING_ADDITIONS_AGGRESSIVE):maskUndefined($getProperty(graph, WIDE_NODES_ON_MULTIPLE_LAYERS)) === maskUndefined(($clinit_WideNodesStrategy() , CAREFUL)) && $addAll_4(strategy, BIG_NODES_PROCESSING_ADDITIONS_CAREFUL);
  unsafeCast(checkNotNull_1(castToBoolean($getProperty(graph, SAUSAGE_FOLDING)))) && $addBeforePhase4(strategy, ($clinit_IntermediateProcessorStrategy() , SAUSAGE_COMPACTION));
  return strategy;
}
;
_.process = function process_49(thelayeredGraph, monitor){
  var index_0, node, node$iterator, node$iterator0, nodes;
  $begin(monitor, 'Longest path layering', 1);
  this.layeredGraph = thelayeredGraph;
  nodes = this.layeredGraph.layerlessNodes;
  this.nodeHeights = initUnidimensionalArray(I_classLit, $intern_37, 26, nodes.array.length, 12, 1);
  index_0 = 0;
  for (node$iterator0 = new ArrayList$1(nodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
    node = castTo($next_8(node$iterator0), 9);
    node.id_0 = index_0;
    this.nodeHeights[index_0] = -1;
    ++index_0;
  }
  for (node$iterator = new ArrayList$1(nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 9);
    $visit(this, node);
  }
  nodes.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
  this.layeredGraph = null;
  this.nodeHeights = null;
  $done(monitor);
}
;
var BASELINE_PROCESSING_CONFIGURATION_0, BIG_NODES_PROCESSING_ADDITIONS_AGGRESSIVE, BIG_NODES_PROCESSING_ADDITIONS_CAREFUL;
var Lde_cau_cs_kieler_klay_layered_p2layers_LongestPathLayerer_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p2layers', 'LongestPathLayerer', 542);
function $clinit_NetworkSimplexLayerer(){
  $clinit_NetworkSimplexLayerer = emptyMethod;
  BASELINE_PROCESSING_CONFIGURATION_1 = $addBeforePhase3($addBeforePhase1(new IntermediateProcessingConfiguration, ($clinit_IntermediateProcessorStrategy() , EDGE_AND_LAYER_CONSTRAINT_EDGE_REVERSER)), LAYER_CONSTRAINT_PROCESSOR);
  BIG_NODES_PROCESSING_ADDITIONS_AGGRESSIVE_0 = $addAfterPhase5($addBeforePhase3($addBeforePhase2(new IntermediateProcessingConfiguration, BIG_NODES_PREPROCESSOR), BIG_NODES_INTERMEDIATEPROCESSOR), BIG_NODES_POSTPROCESSOR);
  BIG_NODES_PROCESSING_ADDITIONS_CAREFUL_0 = $addAfterPhase5($addBeforePhase4(new IntermediateProcessingConfiguration, BIG_NODES_SPLITTER), BIG_NODES_POSTPROCESSOR);
}

function $connectedComponents(this$static, theNodes){
  var components, counter, node, node$iterator, node$iterator0;
  this$static.nodeVisited == null || this$static.nodeVisited.length < theNodes.array.length?(this$static.nodeVisited = initUnidimensionalArray(Z_classLit, $intern_63, 26, theNodes.array.length, 13, 1)):fill_6(this$static.nodeVisited);
  this$static.componentNodes = new ArrayList;
  counter = 0;
  for (node$iterator0 = new ArrayList$1(theNodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
    node = castTo($next_8(node$iterator0), 9);
    node.id_0 = counter++;
  }
  components = new LinkedList;
  for (node$iterator = new ArrayList$1(theNodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 9);
    if (!this$static.nodeVisited[node.id_0]) {
      $connectedComponentsDFS(this$static, node);
      components.size_0 == 0 || (checkCriticalElement(components.size_0 != 0) , castTo(components.header.next_0.value_0, 20)).size_1() < this$static.componentNodes.array.length?$addFirst(components, this$static.componentNodes):$addLast(components, this$static.componentNodes);
      this$static.componentNodes = new ArrayList;
    }
  }
  return components;
}

function $connectedComponentsDFS(this$static, node){
  var edge, edge$iterator, opposite, port, port$iterator;
  this$static.nodeVisited[node.id_0] = true;
  $add_11(this$static.componentNodes, node);
  for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_8(port$iterator), 7);
    for (edge$iterator = $iterator(concat(($clinit_ImmutableList() , new RegularImmutableList(nullCheckedList(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [port.incomingEdges, port.outgoingEdges])))))); $hasNext_0(edge$iterator);) {
      edge = castTo($next_2(edge$iterator), 12);
      opposite = $getOpposite(port, edge).owner;
      this$static.nodeVisited[opposite.id_0] || $connectedComponentsDFS(this$static, opposite);
    }
  }
}

function $getOpposite(port, edge){
  if (edge.source == port) {
    return edge.target;
  }
   else if (edge.target == port) {
    return edge.source;
  }
  throw new IllegalArgumentException_0('Input edge is not connected to the input port.');
}

function $initialize_2(theNodes){
  var counter, graph, lEdge, lEdge$iterator, lNode, lNode$iterator, lNode$iterator0, nNode, nodeMap;
  nodeMap = ($clinit_Maps() , new HashMap);
  counter = 0;
  graph = new NGraph;
  for (lNode$iterator0 = theNodes.iterator_0(); lNode$iterator0.hasNext_0();) {
    lNode = castTo(lNode$iterator0.next_1(), 9);
    nNode = $create_1($origin($id(new NNode$NNodeBuilder, counter++), lNode), graph);
    $put_5(nodeMap.hashCodeMap, lNode, nNode);
  }
  for (lNode$iterator = theNodes.iterator_0(); lNode$iterator.hasNext_0();) {
    lNode = castTo(lNode$iterator.next_1(), 9);
    for (lEdge$iterator = $iterator($getOutgoingEdges_0(lNode)); $hasNext_0(lEdge$iterator);) {
      lEdge = castTo($next_2(lEdge$iterator), 12);
      if ($isSelfLoop(lEdge)) {
        continue;
      }
      $create_0($target($source($delta($weight(new NEdge$NEdgeBuilder, max_3(1, castTo($getProperty(lEdge, ($clinit_InternalProperties() , PRIORITY_0)), 24).value_0)), 1), castTo($get_9(nodeMap, lEdge.source.owner), 61)), castTo($get_9(nodeMap, lEdge.target.owner), 61)));
    }
  }
  return graph;
}

function NetworkSimplexLayerer(){
  $clinit_NetworkSimplexLayerer();
  this.wideNodesStrategy = ($clinit_WideNodesStrategy() , OFF_0);
}

defineClass(541, 1, $intern_64, NetworkSimplexLayerer);
_.getIntermediateProcessingConfiguration = function getIntermediateProcessingConfiguration_3(graph){
  var strategy;
  strategy = fromExisting(BASELINE_PROCESSING_CONFIGURATION_1);
  if (unsafeCast(checkNotNull_1(castToBoolean($getProperty(graph, ($clinit_Properties() , DISTRIBUTE_NODES))))) || maskUndefined($getProperty(graph, WIDE_NODES_ON_MULTIPLE_LAYERS)) === maskUndefined(($clinit_WideNodesStrategy() , AGGRESSIVE))) {
    $addAll_4(strategy, BIG_NODES_PROCESSING_ADDITIONS_AGGRESSIVE_0);
    this.wideNodesStrategy = ($clinit_WideNodesStrategy() , AGGRESSIVE);
  }
   else if (maskUndefined($getProperty(graph, WIDE_NODES_ON_MULTIPLE_LAYERS)) === maskUndefined(($clinit_WideNodesStrategy() , CAREFUL))) {
    $addAll_4(strategy, BIG_NODES_PROCESSING_ADDITIONS_CAREFUL_0);
    this.wideNodesStrategy = CAREFUL;
  }
  return strategy;
}
;
_.process = function process_50(theLayeredGraph, monitor){
  var connComp, connComp$iterator, graph, iterLimit, lNode, layers, nNode, nNode$iterator, theNodes, thoroughness;
  $begin(monitor, 'Network simplex layering', 1);
  this.layeredGraph = theLayeredGraph;
  thoroughness = castTo($getProperty(theLayeredGraph, ($clinit_Properties() , THOROUGHNESS)), 24).value_0 * 4;
  theNodes = this.layeredGraph.layerlessNodes;
  if (theNodes.array.length < 1) {
    $done(monitor);
    return;
  }
  for (connComp$iterator = $listIterator_2($connectedComponents(this, theNodes), 0); connComp$iterator.currentNode != connComp$iterator.this$01.tail;) {
    connComp = castTo($next_11(connComp$iterator), 20);
    iterLimit = thoroughness * round_int(sqrt_0(connComp.size_1()));
    graph = $initialize_2(connComp);
    $execute($withBalancing($withPreviousLayering($withIterationLimit(forGraph(graph), iterLimit), this.layeredGraph), this.wideNodesStrategy == ($clinit_WideNodesStrategy() , AGGRESSIVE)), $subTask(monitor, 1));
    layers = this.layeredGraph.layers;
    for (nNode$iterator = new ArrayList$1(graph.nodes); nNode$iterator.i < nNode$iterator.this$01.array.length;) {
      nNode = castTo($next_8(nNode$iterator), 61);
      while (layers.array.length <= nNode.layer) {
        $add_10(layers, layers.array.length, new Layer(this.layeredGraph));
      }
      lNode = castTo(nNode.origin, 9);
      $setLayer_0(lNode, castTo($get_8(layers, nNode.layer), 16));
    }
  }
  theNodes.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
  this.componentNodes = null;
  this.layeredGraph = null;
  this.nodeVisited = null;
  $done(monitor);
}
;
var BASELINE_PROCESSING_CONFIGURATION_1, BIG_NODES_PROCESSING_ADDITIONS_AGGRESSIVE_0, BIG_NODES_PROCESSING_ADDITIONS_CAREFUL_0;
var Lde_cau_cs_kieler_klay_layered_p2layers_NetworkSimplexLayerer_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p2layers', 'NetworkSimplexLayerer', 541);
function $calculatePortRanks(this$static, layer, portType){
  var consumedRank, nodeIx;
  consumedRank = 0;
  for (nodeIx = 0; nodeIx < layer.length; nodeIx++) {
    consumedRank += this$static.calculatePortRanks(layer[nodeIx], consumedRank, portType);
  }
}

function $distributePorts(this$static, node){
  var absurdlyLargeFloat, barycenter, connectedPort, connectedPort$iterator, inLayerConnections, inLayerPort, inLayerPort$iterator, inLayerPorts, incomingEdge, incomingEdge$iterator, input_0, layerSize, maxBarycenter, minBarycenter, nodeIndexInLayer, northSouthPort, outgoingEdge, outgoingEdge$iterator, output, port, port$iterator, portBarycenter, portDummy, portDummyPort, portDummyPort$iterator, portSide, sum;
  if (!$isOrderFixed(castTo($getProperty(node, ($clinit_LayoutOptions() , PORT_CONSTRAINTS)), 28))) {
    if (node.ports.array.length > 1) {
      portBarycenter = initUnidimensionalArray(Ljava_lang_Float_2_classLit, $intern_0, 15, this$static.portRanks.length, 0, 1);
      inLayerPorts = newArrayListWithCapacity(this$static.portRanks.length);
      minBarycenter = 0;
      maxBarycenter = 0;
      absurdlyLargeFloat = 2 * node.layer.nodes.array.length + 1;
      PortIteration: for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
        port = castTo($next_8(port$iterator), 7);
        northSouthPort = port.side == ($clinit_PortSide() , NORTH) || port.side == SOUTH;
        sum = 0;
        if (northSouthPort) {
          portDummy = castTo($getProperty(port, ($clinit_InternalProperties() , PORT_DUMMY)), 9);
          if (!portDummy) {
            continue;
          }
          input_0 = false;
          output = false;
          for (portDummyPort$iterator = new ArrayList$1(portDummy.ports); portDummyPort$iterator.i < portDummyPort$iterator.this$01.array.length;) {
            portDummyPort = castTo($next_8(portDummyPort$iterator), 7);
            maskUndefined($getProperty(portDummyPort, ORIGIN)) === maskUndefined(port) && (portDummyPort.outgoingEdges.array.length == 0?portDummyPort.incomingEdges.array.length == 0 || (input_0 = true):(output = true));
          }
          input_0 && !output?(sum = port.side == NORTH?-(!portDummy.layer?-1:$indexOf_0(portDummy.layer.nodes, portDummy, 0)):absurdlyLargeFloat - (!portDummy.layer?-1:$indexOf_0(portDummy.layer.nodes, portDummy, 0))):output && !input_0?(sum = (!portDummy.layer?-1:$indexOf_0(portDummy.layer.nodes, portDummy, 0)) + 1):input_0 && output && (sum = port.side == NORTH?0:absurdlyLargeFloat / 2);
        }
         else {
          for (outgoingEdge$iterator = new ArrayList$1(port.outgoingEdges); outgoingEdge$iterator.i < outgoingEdge$iterator.this$01.array.length;) {
            outgoingEdge = castTo($next_8(outgoingEdge$iterator), 12);
            connectedPort = outgoingEdge.target;
            if (connectedPort.owner.layer == node.layer) {
              inLayerPorts.array[inLayerPorts.array.length] = port;
              continue PortIteration;
            }
             else {
              sum += this$static.portRanks[connectedPort.id_0];
            }
          }
          for (incomingEdge$iterator = new ArrayList$1(port.incomingEdges); incomingEdge$iterator.i < incomingEdge$iterator.this$01.array.length;) {
            incomingEdge = castTo($next_8(incomingEdge$iterator), 12);
            connectedPort = incomingEdge.source;
            if (connectedPort.owner.layer == node.layer) {
              inLayerPorts.array[inLayerPorts.array.length] = port;
              continue PortIteration;
            }
             else {
              sum -= this$static.portRanks[connectedPort.id_0];
            }
          }
        }
        if (port.incomingEdges.array.length + port.outgoingEdges.array.length > 0) {
          portBarycenter[port.id_0] = new Float_0(sum / (port.incomingEdges.array.length + port.outgoingEdges.array.length));
          minBarycenter = min_2(minBarycenter, portBarycenter[port.id_0].value_0);
          maxBarycenter = max_2(maxBarycenter, portBarycenter[port.id_0].value_0);
        }
         else 
          northSouthPort && (portBarycenter[port.id_0] = new Float_0(sum));
      }
      nodeIndexInLayer = (!node.layer?-1:$indexOf_0(node.layer.nodes, node, 0)) + 1;
      layerSize = node.layer.nodes.array.length + 1;
      for (inLayerPort$iterator = new ArrayList$1(inLayerPorts); inLayerPort$iterator.i < inLayerPort$iterator.this$01.array.length;) {
        inLayerPort = castTo($next_8(inLayerPort$iterator), 7);
        sum = 0;
        inLayerConnections = 0;
        for (connectedPort$iterator = $iterator(concat(($clinit_ImmutableList() , new RegularImmutableList(nullCheckedList(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [new LPort$7(inLayerPort), new LPort$8(inLayerPort)])))))); $hasNext_0(connectedPort$iterator);) {
          connectedPort = castTo($next_2(connectedPort$iterator), 7);
          if (connectedPort.owner.layer == node.layer) {
            sum += $getIndex(connectedPort.owner) + 1;
            ++inLayerConnections;
          }
        }
        barycenter = sum / inLayerConnections;
        portSide = inLayerPort.side;
        portSide == ($clinit_PortSide() , EAST)?barycenter < nodeIndexInLayer?(portBarycenter[inLayerPort.id_0] = new Float_0(minBarycenter - barycenter)):(portBarycenter[inLayerPort.id_0] = new Float_0(maxBarycenter + (layerSize - barycenter))):portSide == WEST && (barycenter < nodeIndexInLayer?(portBarycenter[inLayerPort.id_0] = new Float_0(maxBarycenter + barycenter)):(portBarycenter[inLayerPort.id_0] = new Float_0(minBarycenter - (layerSize - barycenter))));
      }
      sort_1(node.ports, new AbstractPortDistributor$1(portBarycenter));
    }
    $setProperty(node, PORT_CONSTRAINTS, ($clinit_PortConstraints() , FIXED_ORDER));
  }
}

function $distributePorts_0(this$static, layeredGraph){
  var consumedRank, i, l, layer;
  for (l = 0; l < layeredGraph.length; l++) {
    l + 1 < layeredGraph.length && $calculatePortRanks(this$static, layeredGraph[l + 1], ($clinit_PortType() , INPUT));
    layer = layeredGraph[l];
    consumedRank = 0;
    for (i = 0; i < layer.length; i++) {
      $distributePorts(this$static, layer[i]);
      consumedRank += this$static.calculatePortRanks(layer[i], consumedRank, ($clinit_PortType() , OUTPUT));
    }
  }
}

function AbstractPortDistributor(portRanks){
  this.portRanks = portRanks;
}

defineClass(326, 1, {});
var Lde_cau_cs_kieler_klay_layered_p3order_AbstractPortDistributor_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p3order', 'AbstractPortDistributor', 326);
function $compare_13(this$static, port1, port2){
  var pos1, pos2, side1, side2;
  side1 = port1.side;
  side2 = port2.side;
  if (side1 != side2) {
    return side1.ordinal - side2.ordinal;
  }
   else {
    pos1 = this$static.val$position1[port1.id_0];
    pos2 = this$static.val$position1[port2.id_0];
    return !pos1 && !pos2?0:!pos1?-1:!pos2?1:compare_31(pos1.value_0, pos2.value_0);
  }
}

function AbstractPortDistributor$1(val$position){
  this.val$position1 = val$position;
}

defineClass(558, 1, $intern_9, AbstractPortDistributor$1);
_.compare_0 = function compare_26(port1, port2){
  return $compare_13(this, castTo(port1, 7), castTo(port2, 7));
}
;
var Lde_cau_cs_kieler_klay_layered_p3order_AbstractPortDistributor$1_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p3order', 'AbstractPortDistributor/1', 558);
function $calculateBarycenter(this$static, node, forward_0){
  var associate, associate$iterator, barycenterAssociates, fixedNode, fixedPort, fixedPort$iterator, freePort, freePort$iterator, portIterable;
  if (this$static.barycenterState[node.layer.id_0][node.id_0].visited) {
    return;
  }
   else {
    this$static.barycenterState[node.layer.id_0][node.id_0].visited = true;
  }
  this$static.barycenterState[node.layer.id_0][node.id_0].degree = 0;
  this$static.barycenterState[node.layer.id_0][node.id_0].summedWeight = 0;
  this$static.barycenterState[node.layer.id_0][node.id_0].barycenter = null;
  for (freePort$iterator = new ArrayList$1(node.ports); freePort$iterator.i < freePort$iterator.this$01.array.length;) {
    freePort = castTo($next_8(freePort$iterator), 7);
    portIterable = forward_0?new LPort$7(freePort):new LPort$8(freePort);
    for (fixedPort$iterator = portIterable.iterator_0(); fixedPort$iterator.hasNext_0();) {
      fixedPort = castTo(fixedPort$iterator.next_1(), 7);
      fixedNode = fixedPort.owner;
      if (fixedNode.layer == node.layer) {
        if (fixedNode != node) {
          $calculateBarycenter(this$static, fixedNode, forward_0);
          this$static.barycenterState[node.layer.id_0][node.id_0].degree += this$static.barycenterState[fixedNode.layer.id_0][fixedNode.id_0].degree;
          this$static.barycenterState[node.layer.id_0][node.id_0].summedWeight += this$static.barycenterState[fixedNode.layer.id_0][fixedNode.id_0].summedWeight;
        }
      }
       else {
        this$static.barycenterState[node.layer.id_0][node.id_0].summedWeight += this$static.portRanks[fixedPort.id_0];
        ++this$static.barycenterState[node.layer.id_0][node.id_0].degree;
      }
    }
  }
  barycenterAssociates = castTo($getProperty(node, ($clinit_InternalProperties() , BARYCENTER_ASSOCIATES)), 20);
  if (barycenterAssociates) {
    for (associate$iterator = barycenterAssociates.iterator_0(); associate$iterator.hasNext_0();) {
      associate = castTo(associate$iterator.next_1(), 9);
      if (node.layer == associate.layer) {
        $calculateBarycenter(this$static, associate, forward_0);
        this$static.barycenterState[node.layer.id_0][node.id_0].degree += this$static.barycenterState[associate.layer.id_0][associate.id_0].degree;
        this$static.barycenterState[node.layer.id_0][node.id_0].summedWeight += this$static.barycenterState[associate.layer.id_0][associate.id_0].summedWeight;
      }
    }
  }
  if (this$static.barycenterState[node.layer.id_0][node.id_0].degree > 0) {
    this$static.barycenterState[node.layer.id_0][node.id_0].summedWeight += $nextInternal(this$static.random, 24) * $intern_65 * 0.07000000029802322 - 0.03500000014901161;
    this$static.barycenterState[node.layer.id_0][node.id_0].barycenter = this$static.barycenterState[node.layer.id_0][node.id_0].summedWeight / this$static.barycenterState[node.layer.id_0][node.id_0].degree;
  }
}

function $calculateBarycenters(this$static, nodes, forward_0){
  var node, node$iterator, node$iterator0;
  for (node$iterator0 = new ArrayList$1(nodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
    node = castTo($next_8(node$iterator0), 9);
    this$static.barycenterState[node.layer.id_0][node.id_0].visited = false;
  }
  for (node$iterator = new ArrayList$1(nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 9);
    $calculateBarycenter(this$static, node, forward_0);
  }
}

function $fillInUnknownBarycenters(this$static, nodes, preOrdered){
  var lastValue, maxBary, nextNodeIterator, nextValue, node, node$iterator, node$iterator0, nodesIterator, value_0, x_0;
  if (preOrdered) {
    lastValue = -1;
    nodesIterator = new AbstractList$ListIteratorImpl(nodes, 0);
    while (nodesIterator.i < nodesIterator.this$01_0.size_1()) {
      node = (checkCriticalElement(nodesIterator.i < nodesIterator.this$01_0.size_1()) , castTo(nodesIterator.this$01_0.get_2(nodesIterator.last = nodesIterator.i++), 9));
      value_0 = this$static.barycenterState[node.layer.id_0][node.id_0].barycenter;
      if (value_0 == null) {
        nextValue = lastValue + 1;
        nextNodeIterator = new AbstractList$ListIteratorImpl(nodes, nodesIterator.i);
        while (nextNodeIterator.i < nextNodeIterator.this$01_0.size_1()) {
          x_0 = $stateOf(this$static, (checkCriticalElement(nextNodeIterator.i < nextNodeIterator.this$01_0.size_1()) , castTo(nextNodeIterator.this$01_0.get_2(nextNodeIterator.last = nextNodeIterator.i++), 9))).barycenter;
          if (x_0 != null) {
            nextValue = (checkCriticalNotNull(x_0) , x_0);
            break;
          }
        }
        value_0 = (lastValue + nextValue) / 2;
        this$static.barycenterState[node.layer.id_0][node.id_0].barycenter = value_0;
        this$static.barycenterState[node.layer.id_0][node.id_0].summedWeight = (checkCriticalNotNull(value_0) , value_0);
        this$static.barycenterState[node.layer.id_0][node.id_0].degree = 1;
      }
      lastValue = (checkCriticalNotNull(value_0) , value_0);
    }
  }
   else {
    maxBary = 0;
    for (node$iterator0 = new ArrayList$1(nodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
      node = castTo($next_8(node$iterator0), 9);
      this$static.barycenterState[node.layer.id_0][node.id_0].barycenter != null && (maxBary = max_1(maxBary, checkNotNull_1(this$static.barycenterState[node.layer.id_0][node.id_0].barycenter)));
    }
    maxBary += 2;
    for (node$iterator = new ArrayList$1(nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      if (this$static.barycenterState[node.layer.id_0][node.id_0].barycenter == null) {
        value_0 = $nextInternal(this$static.random, 24) * $intern_65 * maxBary - 1;
        this$static.barycenterState[node.layer.id_0][node.id_0].barycenter = value_0;
        this$static.barycenterState[node.layer.id_0][node.id_0].summedWeight = value_0;
        this$static.barycenterState[node.layer.id_0][node.id_0].degree = 1;
      }
    }
  }
}

function $lambda$0_0(this$static, n1_0, n2_1){
  var s1, s2;
  s1 = this$static.barycenterState[n1_0.layer.id_0][n1_0.id_0];
  s2 = this$static.barycenterState[n2_1.layer.id_0][n2_1.id_0];
  if (s1.barycenter != null && s2.barycenter != null) {
    return $compareTo_12(s1.barycenter, s2.barycenter);
  }
   else if (s1.barycenter != null) {
    return -1;
  }
   else if (s2.barycenter != null) {
    return 1;
  }
  return 0;
}

function $minimizeCrossings(this$static, layer, preOrdered, randomize, forward_0){
  if (randomize) {
    $randomizeBarycenters(this$static, layer);
  }
   else {
    $calculateBarycenters(this$static, layer, forward_0);
    $fillInUnknownBarycenters(this$static, layer, preOrdered);
  }
  if (layer.array.length > 1) {
    sort_1(layer, this$static.barycenterStateComparator);
    $processConstraints(this$static.constraintResolver, layer);
  }
}

function $randomizeBarycenters(this$static, nodes){
  var node, node$iterator;
  for (node$iterator = new ArrayList$1(nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 9);
    this$static.barycenterState[node.layer.id_0][node.id_0].barycenter = $nextDouble(this$static.random);
    this$static.barycenterState[node.layer.id_0][node.id_0].summedWeight = checkNotNull_1(this$static.barycenterState[node.layer.id_0][node.id_0].barycenter);
    this$static.barycenterState[node.layer.id_0][node.id_0].degree = 1;
  }
}

function $stateOf(this$static, node){
  return this$static.barycenterState[node.layer.id_0][node.id_0];
}

function BarycenterHeuristic(barycenterState, constraintResolver, graphRandom, portRanks){
  this.barycenterStateComparator = new BarycenterHeuristic$lambda$0$Type(this);
  this.barycenterState = barycenterState;
  this.constraintResolver = constraintResolver;
  this.random = graphRandom;
  this.portRanks = portRanks;
}

defineClass(564, 1, {}, BarycenterHeuristic);
var Lde_cau_cs_kieler_klay_layered_p3order_BarycenterHeuristic_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p3order', 'BarycenterHeuristic', 564);
function BarycenterHeuristic$BarycenterState(node){
  this.node = node;
}

defineClass(272, 1, {272:1}, BarycenterHeuristic$BarycenterState);
_.degree = 0;
_.summedWeight = 0;
_.visited = false;
var Lde_cau_cs_kieler_klay_layered_p3order_BarycenterHeuristic$BarycenterState_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p3order', 'BarycenterHeuristic/BarycenterState', 272);
function BarycenterHeuristic$lambda$0$Type($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(565, 1, $intern_9, BarycenterHeuristic$lambda$0$Type);
_.compare_0 = function compare_27(arg0, arg1){
  return $lambda$0_0(this.$$outer_0, arg0, arg1);
}
;
var Lde_cau_cs_kieler_klay_layered_p3order_BarycenterHeuristic$lambda$0$Type_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p3order', 'BarycenterHeuristic/lambda$0$Type', 565);
function $clinit_CrossingMinimizationStrategy(){
  $clinit_CrossingMinimizationStrategy = emptyMethod;
  LAYER_SWEEP = new CrossingMinimizationStrategy('LAYER_SWEEP', 0);
  INTERACTIVE_2 = new CrossingMinimizationStrategy('INTERACTIVE', 1);
}

function CrossingMinimizationStrategy(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function values_38(){
  $clinit_CrossingMinimizationStrategy();
  return stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_p3order_CrossingMinimizationStrategy_2_classLit, 1), $intern_13, 192, 0, [LAYER_SWEEP, INTERACTIVE_2]);
}

defineClass(192, 17, {180:1, 192:1, 3:1, 23:1, 17:1}, CrossingMinimizationStrategy);
_.create_0 = function create_3(){
  switch (this.ordinal) {
    case 0:
      return new LayerSweepCrossingMinimizer;
    case 1:
      return new InteractiveCrossingMinimizer;
    default:throw new IllegalArgumentException_0('No implementation is available for the crossing minimizer ' + (this.name_0 != null?this.name_0:'' + this.ordinal));
  }
}
;
var INTERACTIVE_2, LAYER_SWEEP;
var Lde_cau_cs_kieler_klay_layered_p3order_CrossingMinimizationStrategy_2_classLit = createForEnum('de.cau.cs.kieler.klay.layered.p3order', 'CrossingMinimizationStrategy', 192, Ljava_lang_Enum_2_classLit, values_38);
function $clinit_CrossingMinimizationStrategy$Map(){
  $clinit_CrossingMinimizationStrategy$Map = emptyMethod;
  $MAP_17 = createValueOfMap(($clinit_CrossingMinimizationStrategy() , stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_p3order_CrossingMinimizationStrategy_2_classLit, 1), $intern_13, 192, 0, [LAYER_SWEEP, INTERACTIVE_2])));
}

var $MAP_17;
function $clinit_InteractiveCrossingMinimizer(){
  $clinit_InteractiveCrossingMinimizer = emptyMethod;
  INTERMEDIATE_PROCESSING_CONFIGURATION_1 = $addAfterPhase5($addBeforePhase4($addBeforePhase3(new IntermediateProcessingConfiguration, ($clinit_IntermediateProcessorStrategy() , LONG_EDGE_SPLITTER)), IN_LAYER_CONSTRAINT_PROCESSOR), LONG_EDGE_JOINER);
}

function $getPos(node, horizPos){
  var bendpoints, edge, originNode, originPort, point1, point2, pointIter, source, sourcePoint, target, targetPoint;
  switch (node.type_0.ordinal) {
    case 1:
      edge = castTo($getProperty(node, ($clinit_InternalProperties() , ORIGIN)), 12);
      bendpoints = castTo($getProperty(edge, ORIGINAL_BENDPOINTS), 44);
      !bendpoints?(bendpoints = new KVectorChain):unsafeCast(checkNotNull_1(castToBoolean($getProperty(edge, REVERSED)))) && (bendpoints = reverse_1(bendpoints));
      source = castTo($getProperty(node, LONG_EDGE_SOURCE), 7);
      sourcePoint = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [source.owner.pos, source.pos, source.anchor]));
      if (horizPos <= sourcePoint.x_0) {
        return sourcePoint.y_0;
      }

      $addNode_0(bendpoints, sourcePoint, bendpoints.header, bendpoints.header.next_0);
      target = castTo($getProperty(node, LONG_EDGE_TARGET), 7);
      targetPoint = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [target.owner.pos, target.pos, target.anchor]));
      if (targetPoint.x_0 <= horizPos) {
        return targetPoint.y_0;
      }

      $addNode_0(bendpoints, targetPoint, bendpoints.tail.prev, bendpoints.tail);
      pointIter = $listIterator_2(bendpoints, 0);
      point1 = castTo($next_11(pointIter), 10);
      point2 = castTo($next_11(pointIter), 10);
      while (point2.x_0 < horizPos && pointIter.currentNode != pointIter.this$01.tail) {
        point1 = point2;
        point2 = castTo($next_11(pointIter), 10);
      }

      return point1.y_0 + (horizPos - point1.x_0) / (point2.x_0 - point1.x_0) * (point2.y_0 - point1.y_0);
    case 3:
      originPort = castTo($getProperty(castTo($get_8(node.ports, 0), 7), ($clinit_InternalProperties() , ORIGIN)), 7);
      originNode = originPort.owner;
      switch (originPort.side.ordinal) {
        case 1:
          return originNode.pos.y_0;
        case 3:
          return originNode.pos.y_0 + originNode.size_0.y_0;
      }

  }
  return $getInteractiveReferencePoint(node).y_0;
}

function InteractiveCrossingMinimizer(){
  $clinit_InteractiveCrossingMinimizer();
}

defineClass(526, 1, $intern_64, InteractiveCrossingMinimizer);
_.getIntermediateProcessingConfiguration = function getIntermediateProcessingConfiguration_4(graph){
  var configuration;
  configuration = fromExisting(INTERMEDIATE_PROCESSING_CONFIGURATION_1);
  castTo($getProperty(graph, ($clinit_InternalProperties() , GRAPH_PROPERTIES)), 18).contains(($clinit_GraphProperties() , NON_FREE_PORTS)) && $addBeforePhase3(configuration, ($clinit_IntermediateProcessorStrategy() , PORT_LIST_SORTER));
  return configuration;
}
;
_.process = function process_51(layeredGraph, monitor){
  var horizPos, layer, layer$iterator, nextIndex, node, node$iterator, node$iterator0, nodeCount, port, port$iterator, portCount, portDistributor, pos;
  $begin(monitor, 'Interactive crossing minimization', 1);
  portCount = 0;
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator), 16);
    horizPos = 0;
    nodeCount = 0;
    for (node$iterator0 = new ArrayList$1(layer.nodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
      node = castTo($next_8(node$iterator0), 9);
      if (node.pos.x_0 > 0) {
        horizPos += node.pos.x_0 + node.size_0.x_0 / 2;
        ++nodeCount;
      }
      for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
        port = castTo($next_8(port$iterator), 7);
        port.id_0 = portCount++;
      }
    }
    horizPos /= nodeCount;
    pos = initUnidimensionalArray(D_classLit, $intern_11, 26, layer.nodes.array.length, 12, 1);
    nextIndex = 0;
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      node.id_0 = nextIndex++;
      pos[node.id_0] = $getPos(node, horizPos);
      node.type_0 == ($clinit_LNode$NodeType() , LONG_EDGE) && $setProperty(node, ($clinit_InternalProperties() , ORIGINAL_DUMMY_NODE_POSITION), pos[node.id_0]);
    }
    sort_1(layer.nodes, new InteractiveCrossingMinimizer$1(pos));
  }
  portDistributor = new NodeRelativePortDistributor(initUnidimensionalArray(F_classLit, $intern_61, 26, portCount, 12, 1));
  $distributePorts_0(portDistributor, $toNodeArray(layeredGraph));
  $done(monitor);
}
;
var INTERMEDIATE_PROCESSING_CONFIGURATION_1;
var Lde_cau_cs_kieler_klay_layered_p3order_InteractiveCrossingMinimizer_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p3order', 'InteractiveCrossingMinimizer', 526);
function $compare_14(this$static, node1, node2){
  var compare, node1Successors, node2Successors;
  compare = compare_31(this$static.val$pos2[node1.id_0], this$static.val$pos2[node2.id_0]);
  if (compare == 0) {
    node1Successors = castTo($getProperty(node1, ($clinit_InternalProperties() , IN_LAYER_SUCCESSOR_CONSTRAINTS)), 20);
    node2Successors = castTo($getProperty(node2, IN_LAYER_SUCCESSOR_CONSTRAINTS), 20);
    if (node1Successors.contains(node2)) {
      return -1;
    }
     else if (node2Successors.contains(node1)) {
      return 1;
    }
  }
  return compare;
}

function InteractiveCrossingMinimizer$1(val$pos){
  this.val$pos2 = val$pos;
}

defineClass(527, 1, $intern_9, InteractiveCrossingMinimizer$1);
_.compare_0 = function compare_28(node1, node2){
  return $compare_14(this, castTo(node1, 9), castTo(node2, 9));
}
;
var Lde_cau_cs_kieler_klay_layered_p3order_InteractiveCrossingMinimizer$1_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p3order', 'InteractiveCrossingMinimizer/1', 527);
function $clinit_LayerSweepCrossingMinimizer(){
  $clinit_LayerSweepCrossingMinimizer = emptyMethod;
  INTERMEDIATE_PROCESSING_CONFIGURATION_2 = $addAfterPhase5($addBeforePhase4($addBeforePhase4($addBeforePhase4($addBeforePhase3(new IntermediateProcessingConfiguration, ($clinit_IntermediateProcessorStrategy() , LONG_EDGE_SPLITTER)), PORT_DISTRIBUTER), GREEDY_SWITCH), IN_LAYER_CONSTRAINT_PROCESSOR), LONG_EDGE_JOINER);
}

function $initialize_3(this$static, layeredGraph){
  var allLayerCombinationsHaveHyperedges, b, edge, edge$iterator, hasNorthSouthPorts, i, inLayerEdgeCount, layer, layerCount, layerIndex, layerIter, layerNodeCount, layoutUnit, noLayerCombinationHasHyperedges, node, nodeCount, nodeIter, port, port$iterator, portCount, portPos;
  layerCount = layeredGraph.layers.array.length;
  this$static.bestSweep = initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LNode_2_classLit, $intern_0, 51, layerCount, 0, 2);
  this$static.curSweep = initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LNode_2_classLit, $intern_0, 51, layerCount, 0, 2);
  this$static.prevSweep = initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LNode_2_classLit, $intern_0, 51, layerCount, 0, 2);
  inLayerEdgeCount = initUnidimensionalArray(I_classLit, $intern_37, 26, layerCount, 12, 1);
  hasNorthSouthPorts = initUnidimensionalArray(Z_classLit, $intern_63, 26, layerCount, 13, 1);
  this$static.hasHyperedgesEast = initUnidimensionalArray(Z_classLit, $intern_63, 26, layerCount, 13, 1);
  this$static.hasHyperedgesWest = initUnidimensionalArray(Z_classLit, $intern_63, 26, layerCount, 13, 1);
  nodeCount = 0;
  portCount = 0;
  layerIter = new AbstractList$ListIteratorImpl(layeredGraph.layers, 0);
  while (layerIter.i < layerIter.this$01_0.size_1()) {
    layer = (checkCriticalElement(layerIter.i < layerIter.this$01_0.size_1()) , castTo(layerIter.this$01_0.get_2(layerIter.last = layerIter.i++), 16));
    layerIndex = layerIter.i - 1;
    layerNodeCount = layer.nodes.array.length;
    this$static.bestSweep[layerIndex] = initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LNode_2_classLit, $intern_49, 9, layerNodeCount, 0, 1);
    this$static.prevSweep[layerIndex] = initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LNode_2_classLit, $intern_49, 9, layerNodeCount, 0, 1);
    this$static.curSweep[layerIndex] = initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LNode_2_classLit, $intern_49, 9, layerNodeCount, 0, 1);
    inLayerEdgeCount[layerIndex] = 0;
    hasNorthSouthPorts[layerIndex] = false;
    nodeIter = new AbstractList$ListIteratorImpl(layer.nodes, 0);
    while (nodeIter.i < nodeIter.this$01_0.size_1()) {
      node = (checkCriticalElement(nodeIter.i < nodeIter.this$01_0.size_1()) , castTo(nodeIter.this$01_0.get_2(nodeIter.last = nodeIter.i++), 9));
      this$static.curSweep[layerIndex][nodeIter.i - 1] = node;
      node.id_0 = nodeCount++;
      layoutUnit = castTo($getProperty(node, ($clinit_InternalProperties() , IN_LAYER_LAYOUT_UNIT)), 9);
      !!layoutUnit && ($addNode(this$static.layoutUnits, layoutUnit, node, null) , true);
      for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
        port = castTo($next_8(port$iterator), 7);
        port.id_0 = portCount++;
        for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
          edge = castTo($next_8(edge$iterator), 12);
          edge.target.owner.layer == layer && ++inLayerEdgeCount[layerIndex];
        }
        port.side == ($clinit_PortSide() , EAST)?port.outgoingEdges.array.length + port.incomingEdges.array.length > 1 && (this$static.hasHyperedgesEast[layerIndex] = true):port.side == WEST && port.outgoingEdges.array.length + port.incomingEdges.array.length > 1 && (this$static.hasHyperedgesWest[layerIndex] = true);
      }
      if (node.type_0 == ($clinit_LNode$NodeType() , NORTH_SOUTH_PORT)) {
        ++inLayerEdgeCount[layerIndex];
        hasNorthSouthPorts[layerIndex] = true;
      }
    }
  }
  allLayerCombinationsHaveHyperedges = true;
  noLayerCombinationHasHyperedges = true;
  for (i = 0; i < this$static.hasHyperedgesWest.length - 1; i++) {
    b = this$static.hasHyperedgesEast[i] || this$static.hasHyperedgesWest[i + 1];
    allLayerCombinationsHaveHyperedges = allLayerCombinationsHaveHyperedges & b;
    noLayerCombinationHasHyperedges = noLayerCombinationHasHyperedges & !b;
  }
  this$static.portRanks = initUnidimensionalArray(F_classLit, $intern_61, 26, portCount, 12, 1);
  portPos = initUnidimensionalArray(I_classLit, $intern_37, 26, portCount, 12, 1);
  if (!allLayerCombinationsHaveHyperedges) {
    this$static.normalCrossingsCounter = new BarthJuengerMutzelCrossingsCounter(inLayerEdgeCount, hasNorthSouthPorts, portPos);
    this$static.inlayerCrossingsCounter = this$static.normalCrossingsCounter;
  }
  if (!noLayerCombinationHasHyperedges) {
    this$static.hyperedgeCrossingsCounter = new HyperedgeCrossingsCounter(inLayerEdgeCount, hasNorthSouthPorts, portPos);
    this$static.inlayerCrossingsCounter = this$static.hyperedgeCrossingsCounter;
  }
}

function $minimizeCrossings_0(layer, heuristic, forward_0, preOrdered, randomize){
  var index_0, nodeGroup, nodeGroup$iterator, nodes;
  nodes = newArrayList_1(layer);
  $minimizeCrossings(heuristic, nodes, preOrdered, randomize, forward_0);
  index_0 = 0;
  for (nodeGroup$iterator = new ArrayList$1(nodes); nodeGroup$iterator.i < nodeGroup$iterator.this$01.array.length;) {
    nodeGroup = castTo($next_8(nodeGroup$iterator), 9);
    layer[index_0++] = nodeGroup;
  }
}

function LayerSweepCrossingMinimizer(){
  $clinit_LayerSweepCrossingMinimizer();
  this.layoutUnits = new LinkedListMultimap;
}

function copySweep(source, dest){
  var i, j;
  for (i = 0; i < dest.length; i++) {
    for (j = 0; j < dest[i].length; j++) {
      dest[i][j] = source[i][j];
    }
  }
}

defineClass(525, 1, $intern_64, LayerSweepCrossingMinimizer);
_.getIntermediateProcessingConfiguration = function getIntermediateProcessingConfiguration_5(graph){
  var configuration;
  configuration = fromExisting(INTERMEDIATE_PROCESSING_CONFIGURATION_2);
  castTo($getProperty(graph, ($clinit_InternalProperties() , GRAPH_PROPERTIES)), 18).contains(($clinit_GraphProperties() , NON_FREE_PORTS)) && $addBeforePhase3(configuration, ($clinit_IntermediateProcessorStrategy() , PORT_LIST_SORTER));
  return configuration;
}
;
_.process = function process_52(layeredGraph, monitor){
  var barycenterStates, bestSweepCrossings, constraintResolver, crossminHeuristic, curSweepCrossings, firstSweep, fixedLayer, fixedLayerIndex, forward_0, freeLayer, i, j, layer, layer$iterator, layerCount, layerIndex, layerIter, layerTotalPortDistributor, node, node$iterator, nodeIter, nodeRelativePortDistributor, nodes, portDistributor, prevSweepCrossings, random, run, runCount;
  $begin(monitor, 'Layer sweep crossing minimization', 1);
  random = castTo($getProperty(layeredGraph, ($clinit_InternalProperties() , RANDOM)), 154);
  layerCount = layeredGraph.layers.array.length;
  if (layerCount < 2) {
    $done(monitor);
    return;
  }
  $initialize_3(this, layeredGraph);
  bestSweepCrossings = $intern_3;
  runCount = castTo($getProperty(layeredGraph, ($clinit_Properties() , THOROUGHNESS)), 24).value_0;
  barycenterStates = initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_p3order_BarycenterHeuristic$BarycenterState_2_classLit, $intern_0, 670, layeredGraph.layers.array.length, 0, 2);
  i = 0;
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator), 16);
    layer.id_0 = i;
    barycenterStates[i] = initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_p3order_BarycenterHeuristic$BarycenterState_2_classLit, {670:1, 3:1, 5:1, 6:1}, 272, layer.nodes.array.length, 0, 1);
    j = 0;
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      node.id_0 = j;
      barycenterStates[i][j] = new BarycenterHeuristic$BarycenterState(node);
      ++j;
    }
    ++i;
  }
  constraintResolver = new ForsterConstraintResolver(barycenterStates, this.layoutUnits);
  crossminHeuristic = new BarycenterHeuristic(barycenterStates, constraintResolver, random, this.portRanks);
  nodeRelativePortDistributor = new NodeRelativePortDistributor(this.portRanks);
  layerTotalPortDistributor = new LayerTotalPortDistributor(this.portRanks);
  for (run = 0; run < runCount && bestSweepCrossings > 0; run++) {
    forward_0 = $nextInternal(random, 1) != 0;
    fixedLayerIndex = forward_0?0:layerCount - 1;
    fixedLayer = this.curSweep[fixedLayerIndex];
    portDistributor = $nextInternal(random, 1) != 0?nodeRelativePortDistributor:layerTotalPortDistributor;
    $minimizeCrossings_0(fixedLayer, crossminHeuristic, forward_0, false, true);
    curSweepCrossings = $intern_3;
    firstSweep = true;
    do {
      copySweep(this.curSweep, this.prevSweep);
      prevSweepCrossings = curSweepCrossings;
      curSweepCrossings = 0;
      curSweepCrossings += $countCrossings_2(this.inlayerCrossingsCounter, fixedLayer, fixedLayerIndex);
      if (forward_0) {
        for (layerIndex = 1; layerIndex < layerCount; layerIndex++) {
          freeLayer = this.curSweep[layerIndex];
          $calculatePortRanks(portDistributor, fixedLayer, ($clinit_PortType() , OUTPUT));
          $minimizeCrossings_0(freeLayer, crossminHeuristic, true, !firstSweep, false);
          curSweepCrossings += $countCrossings_2(this.inlayerCrossingsCounter, freeLayer, layerIndex);
          this.hasHyperedgesWest[layerIndex] || this.hasHyperedgesEast[layerIndex - 1]?(curSweepCrossings += $countCrossings_4(this.hyperedgeCrossingsCounter, fixedLayer, freeLayer)):(curSweepCrossings += $countCrossings_3(this.normalCrossingsCounter, fixedLayer, freeLayer));
          fixedLayer = freeLayer;
        }
        fixedLayerIndex = layerCount - 1;
      }
       else {
        for (layerIndex = layerCount - 2; layerIndex >= 0; layerIndex--) {
          freeLayer = this.curSweep[layerIndex];
          $calculatePortRanks(portDistributor, fixedLayer, ($clinit_PortType() , INPUT));
          $minimizeCrossings_0(freeLayer, crossminHeuristic, false, !firstSweep, false);
          curSweepCrossings += $countCrossings_2(this.inlayerCrossingsCounter, freeLayer, layerIndex);
          this.hasHyperedgesEast[layerIndex] || this.hasHyperedgesWest[layerIndex + 1]?(curSweepCrossings += $countCrossings_4(this.hyperedgeCrossingsCounter, freeLayer, fixedLayer)):(curSweepCrossings += $countCrossings_3(this.normalCrossingsCounter, freeLayer, fixedLayer));
          fixedLayer = freeLayer;
        }
        fixedLayerIndex = 0;
      }
      firstSweep = false;
      forward_0 = !forward_0;
    }
     while (curSweepCrossings < prevSweepCrossings && curSweepCrossings > 0);
    if (curSweepCrossings < bestSweepCrossings || prevSweepCrossings < bestSweepCrossings) {
      if (curSweepCrossings <= prevSweepCrossings) {
        copySweep(this.curSweep, this.bestSweep);
        bestSweepCrossings = curSweepCrossings;
      }
       else {
        copySweep(this.prevSweep, this.bestSweep);
        bestSweepCrossings = prevSweepCrossings;
      }
    }
  }
  layerIter = new AbstractList$ListIteratorImpl(layeredGraph.layers, 0);
  while (layerIter.i < layerIter.this$01_0.size_1()) {
    layer = (checkCriticalElement(layerIter.i < layerIter.this$01_0.size_1()) , castTo(layerIter.this$01_0.get_2(layerIter.last = layerIter.i++), 16));
    nodes = this.bestSweep[layerIter.i - 1];
    nodeIter = new AbstractList$ListIteratorImpl(layer.nodes, 0);
    while (nodeIter.i < nodeIter.this$01_0.size_1()) {
      checkCriticalElement(nodeIter.i < nodeIter.this$01_0.size_1());
      nodeIter.this$01_0.get_2(nodeIter.last = nodeIter.i++);
      $set_4(nodeIter, nodes[nodeIter.i - 1]);
    }
  }
  this.portRanks = null;
  this.bestSweep = null;
  this.curSweep = null;
  this.prevSweep = null;
  this.normalCrossingsCounter = null;
  this.hyperedgeCrossingsCounter = null;
  this.hasHyperedgesEast = null;
  this.hasHyperedgesWest = null;
  $clear_3(this.layoutUnits);
  $done(monitor);
}
;
var INTERMEDIATE_PROCESSING_CONFIGURATION_2;
var Lde_cau_cs_kieler_klay_layered_p3order_LayerSweepCrossingMinimizer_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p3order', 'LayerSweepCrossingMinimizer', 525);
function LayerTotalPortDistributor(portRanks){
  AbstractPortDistributor.call(this, portRanks);
}

function getPortIncr(type_0, side){
  switch (type_0.ordinal) {
    case 1:
      switch (side.ordinal) {
        case 1:
          return 1;
        case 4:
          return 2;
        case 3:
          return 3;
        case 2:
          return 4;
      }

      break;
    case 2:
      switch (side.ordinal) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 3:
          return 3;
        case 4:
          return 4;
      }

      break;
    default:throw new IllegalArgumentException_0('Port type is undefined');
  }
  return 0;
}

defineClass(327, 326, {}, LayerTotalPortDistributor);
_.calculatePortRanks = function calculatePortRanks(node, rankSum, type_0){
  var incr, inputCount, maxIncr, minIncr, northInputCount, northPos, port, port$iterator, port$iterator0, portRanks, pos, restPos;
  portRanks = this.portRanks;
  if ($isOrderFixed(castTo($getProperty(node, ($clinit_LayoutOptions() , PORT_CONSTRAINTS)), 28))) {
    switch (type_0.ordinal) {
      case 1:
        {
          inputCount = 0;
          northInputCount = 0;
          for (port$iterator0 = new ArrayList$1(node.ports); port$iterator0.i < port$iterator0.this$01.array.length;) {
            port = castTo($next_8(port$iterator0), 7);
            if (port.incomingEdges.array.length != 0) {
              ++inputCount;
              port.side == ($clinit_PortSide() , NORTH) && ++northInputCount;
            }
          }
          northPos = rankSum + northInputCount;
          restPos = rankSum + inputCount;
          for (port$iterator = $getPorts_1(node, ($clinit_PortType() , INPUT)).iterator_0(); port$iterator.hasNext_0();) {
            port = castTo(port$iterator.next_1(), 7);
            if (port.side == ($clinit_PortSide() , NORTH)) {
              portRanks[port.id_0] = northPos;
              --northPos;
            }
             else {
              portRanks[port.id_0] = restPos;
              --restPos;
            }
          }
          return inputCount;
        }

      case 2:
        {
          pos = 0;
          for (port$iterator = $getPorts_1(node, ($clinit_PortType() , OUTPUT)).iterator_0(); port$iterator.hasNext_0();) {
            port = castTo(port$iterator.next_1(), 7);
            ++pos;
            portRanks[port.id_0] = rankSum + pos;
          }
          return pos;
        }

      default:throw new IllegalArgumentException;
    }
  }
   else {
    minIncr = 4;
    maxIncr = 0;
    for (port$iterator0 = $getPorts_1(node, type_0).iterator_0(); port$iterator0.hasNext_0();) {
      port = castTo(port$iterator0.next_1(), 7);
      incr = getPortIncr(type_0, port.side);
      minIncr = minIncr < incr - 1?minIncr:incr - 1;
      maxIncr = maxIncr > incr?maxIncr:incr;
    }
    if (maxIncr > minIncr) {
      for (port$iterator = $getPorts_1(node, type_0).iterator_0(); port$iterator.hasNext_0();) {
        port = castTo(port$iterator.next_1(), 7);
        portRanks[port.id_0] = rankSum + getPortIncr(type_0, port.side) - minIncr;
      }
      return maxIncr - minIncr;
    }
    return 0;
  }
}
;
var Lde_cau_cs_kieler_klay_layered_p3order_LayerTotalPortDistributor_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p3order', 'LayerTotalPortDistributor', 327);
function NodeRelativePortDistributor(portRanks){
  AbstractPortDistributor.call(this, portRanks);
}

function getPortIncr_0(type_0, side){
  switch (type_0.ordinal) {
    case 1:
      switch (side.ordinal) {
        case 1:
          return $intern_66;
        case 4:
          return 0.5;
        case 3:
          return $intern_67;
        case 2:
          return $intern_68;
      }

      break;
    case 2:
      switch (side.ordinal) {
        case 1:
          return $intern_66;
        case 2:
          return 0.5;
        case 3:
          return $intern_67;
        case 4:
          return $intern_68;
      }

      break;
    default:throw new IllegalArgumentException_0('Port type is undefined');
  }
  return 0;
}

defineClass(274, 326, {}, NodeRelativePortDistributor);
_.calculatePortRanks = function calculatePortRanks_0(node, rankSum, type_0){
  var incr, inputCount, northInputCount, northPos, outputCount, port, port$iterator, port$iterator0, portRanks, pos, restPos;
  portRanks = this.portRanks;
  if ($isOrderFixed(castTo($getProperty(node, ($clinit_LayoutOptions() , PORT_CONSTRAINTS)), 28))) {
    switch (type_0.ordinal) {
      case 1:
        {
          inputCount = 0;
          northInputCount = 0;
          for (port$iterator0 = new ArrayList$1(node.ports); port$iterator0.i < port$iterator0.this$01.array.length;) {
            port = castTo($next_8(port$iterator0), 7);
            if (port.incomingEdges.array.length != 0) {
              ++inputCount;
              port.side == ($clinit_PortSide() , NORTH) && ++northInputCount;
            }
          }
          incr = 1 / (inputCount + 1);
          northPos = rankSum + northInputCount * incr;
          restPos = rankSum + 1 - incr;
          for (port$iterator = $getPorts_1(node, ($clinit_PortType() , INPUT)).iterator_0(); port$iterator.hasNext_0();) {
            port = castTo(port$iterator.next_1(), 7);
            if (port.side == ($clinit_PortSide() , NORTH)) {
              portRanks[port.id_0] = northPos;
              northPos -= incr;
            }
             else {
              portRanks[port.id_0] = restPos;
              restPos -= incr;
            }
          }
          break;
        }

      case 2:
        {
          outputCount = 0;
          for (port$iterator0 = new ArrayList$1(node.ports); port$iterator0.i < port$iterator0.this$01.array.length;) {
            port = castTo($next_8(port$iterator0), 7);
            port.outgoingEdges.array.length == 0 || ++outputCount;
          }
          incr = 1 / (outputCount + 1);
          pos = rankSum + incr;
          for (port$iterator = $getPorts_1(node, ($clinit_PortType() , OUTPUT)).iterator_0(); port$iterator.hasNext_0();) {
            port = castTo(port$iterator.next_1(), 7);
            portRanks[port.id_0] = pos;
            pos += incr;
          }
          break;
        }

      default:throw new IllegalArgumentException_0('Port type is undefined');
    }
  }
   else {
    for (port$iterator = $getPorts_1(node, type_0).iterator_0(); port$iterator.hasNext_0();) {
      port = castTo(port$iterator.next_1(), 7);
      portRanks[port.id_0] = rankSum + getPortIncr_0(type_0, port.side);
    }
  }
  return 1;
}
;
var Lde_cau_cs_kieler_klay_layered_p3order_NodeRelativePortDistributor_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p3order', 'NodeRelativePortDistributor', 274);
function $buildConstraintsGraph(this$static, groups){
  var currentUnitNode, currentUnitNode$iterator, group, group$iterator, group$iterator0, lastNonDummyNode, lastUnitNode, lastUnitNode$iterator, node, successor, successor$iterator;
  for (group$iterator0 = new ArrayList$1(groups); group$iterator0.i < group$iterator0.this$01.array.length;) {
    group = castTo($next_8(group$iterator0), 101);
    group.outgoingConstraints = null;
    group.incomingConstraintsCount = 0;
  }
  lastNonDummyNode = null;
  for (group$iterator = new ArrayList$1(groups); group$iterator.i < group$iterator.this$01.array.length;) {
    group = castTo($next_8(group$iterator), 101);
    node = group.nodes[0];
    for (successor$iterator = castTo($getProperty(node, ($clinit_InternalProperties() , IN_LAYER_SUCCESSOR_CONSTRAINTS)), 20).iterator_0(); successor$iterator.hasNext_0();) {
      successor = castTo(successor$iterator.next_1(), 9);
      (!group.outgoingConstraints && (group.outgoingConstraints = new ArrayList) , group.outgoingConstraints).add_1(this$static.constraintGroups[successor.layer.id_0][successor.id_0]);
      ++this$static.constraintGroups[successor.layer.id_0][successor.id_0].incomingConstraintsCount;
    }
    if (node.type_0 == ($clinit_LNode$NodeType() , NORMAL)) {
      if (lastNonDummyNode) {
        for (lastUnitNode$iterator = $listIterator_0(new LinkedListMultimap$1(this$static.layoutUnits, lastNonDummyNode), 0); lastUnitNode$iterator.next_0;) {
          lastUnitNode = castTo($next_4(lastUnitNode$iterator), 9);
          for (currentUnitNode$iterator = $listIterator_0(new LinkedListMultimap$1(this$static.layoutUnits, node), 0); currentUnitNode$iterator.next_0;) {
            currentUnitNode = castTo($next_4(currentUnitNode$iterator), 9);
            $getOutgoingConstraints(this$static.constraintGroups[lastUnitNode.layer.id_0][lastUnitNode.id_0]).add_1(this$static.constraintGroups[currentUnitNode.layer.id_0][currentUnitNode.id_0]);
            ++this$static.constraintGroups[currentUnitNode.layer.id_0][currentUnitNode.id_0].incomingConstraintsCount;
          }
        }
      }
      lastNonDummyNode = node;
    }
  }
}

function $findViolatedConstraint(groups){
  var activeGroups, group, group$iterator, predecessor, predecessor$iterator, successor, successor$iterator, successorIncomingList;
  activeGroups = null;
  for (group$iterator = new ArrayList$1(groups); group$iterator.i < group$iterator.this$01.array.length;) {
    group = castTo($next_8(group$iterator), 101);
    checkNotNull_1($stateOf_0(group.this$01, group.nodes[0]).barycenter);
    group.incomingConstraints = null;
    if (!!group.outgoingConstraints && group.outgoingConstraints.size_1() > 0 && group.incomingConstraintsCount == 0) {
      !activeGroups && (activeGroups = new ArrayList);
      activeGroups.array[activeGroups.array.length] = group;
    }
  }
  if (activeGroups) {
    while (activeGroups.array.length != 0) {
      group = castTo($remove_6(activeGroups, 0), 101);
      if (!!group.incomingConstraints && group.incomingConstraints.array.length > 0) {
        for (predecessor$iterator = (!group.incomingConstraints && (group.incomingConstraints = new ArrayList) , new ArrayList$1(group.incomingConstraints)); predecessor$iterator.i < predecessor$iterator.this$01.array.length;) {
          predecessor = castTo($next_8(predecessor$iterator), 101);
          if (checkNotNull_1($stateOf_0(predecessor.this$01, predecessor.nodes[0]).barycenter) == checkNotNull_1($stateOf_0(group.this$01, group.nodes[0]).barycenter)) {
            if ($indexOf_0(groups, predecessor, 0) > $indexOf_0(groups, group, 0)) {
              return new Pair(predecessor, group);
            }
          }
           else if (checkNotNull_1($stateOf_0(predecessor.this$01, predecessor.nodes[0]).barycenter) > checkNotNull_1($stateOf_0(group.this$01, group.nodes[0]).barycenter)) {
            return new Pair(predecessor, group);
          }
        }
      }
      for (successor$iterator = (!group.outgoingConstraints && (group.outgoingConstraints = new ArrayList) , group.outgoingConstraints).iterator_0(); successor$iterator.hasNext_0();) {
        successor = castTo(successor$iterator.next_1(), 101);
        successorIncomingList = (!successor.incomingConstraints && (successor.incomingConstraints = new ArrayList) , successor.incomingConstraints);
        checkCriticalPositionIndex(0, successorIncomingList.array.length);
        insertTo(successorIncomingList.array, 0, group);
        successor.incomingConstraintsCount == successorIncomingList.array.length && (activeGroups.array[activeGroups.array.length] = successor , true);
      }
    }
  }
  return null;
}

function $handleViolatedConstraint(this$static, firstNodeGroup, secondNodeGroup, nodeGroups){
  var alreadyInserted, firstNodeGroupConstraint, newNodeGroup, nodeGroup, nodeGroupIterator, secondNodeGroupConstraint;
  newNodeGroup = new ForsterConstraintResolver$ConstraintGroup_0(this$static, firstNodeGroup, secondNodeGroup);
  nodeGroupIterator = new AbstractList$ListIteratorImpl(nodeGroups, 0);
  alreadyInserted = false;
  while (nodeGroupIterator.i < nodeGroupIterator.this$01_0.size_1()) {
    nodeGroup = (checkCriticalElement(nodeGroupIterator.i < nodeGroupIterator.this$01_0.size_1()) , castTo(nodeGroupIterator.this$01_0.get_2(nodeGroupIterator.last = nodeGroupIterator.i++), 101));
    if (nodeGroup == firstNodeGroup || nodeGroup == secondNodeGroup) {
      $remove_11(nodeGroupIterator);
    }
     else if (!alreadyInserted && checkNotNull_1($stateOf_0(nodeGroup.this$01, nodeGroup.nodes[0]).barycenter) > checkNotNull_1($stateOf_0(newNodeGroup.this$01, newNodeGroup.nodes[0]).barycenter)) {
      checkCriticalElement(nodeGroupIterator.i > 0);
      nodeGroupIterator.this$01.get_2(nodeGroupIterator.last = --nodeGroupIterator.i);
      $add_15(nodeGroupIterator, newNodeGroup);
      alreadyInserted = true;
    }
     else if (!!nodeGroup.outgoingConstraints && nodeGroup.outgoingConstraints.size_1() > 0) {
      firstNodeGroupConstraint = (!nodeGroup.outgoingConstraints && (nodeGroup.outgoingConstraints = new ArrayList) , nodeGroup.outgoingConstraints).remove_1(firstNodeGroup);
      secondNodeGroupConstraint = (!nodeGroup.outgoingConstraints && (nodeGroup.outgoingConstraints = new ArrayList) , nodeGroup.outgoingConstraints).remove_1(secondNodeGroup);
      if (firstNodeGroupConstraint || secondNodeGroupConstraint) {
        (!nodeGroup.outgoingConstraints && (nodeGroup.outgoingConstraints = new ArrayList) , nodeGroup.outgoingConstraints).add_1(newNodeGroup);
        ++newNodeGroup.incomingConstraintsCount;
      }
    }
  }
  alreadyInserted || (nodeGroups.array[nodeGroups.array.length] = newNodeGroup , true);
}

function $processConstraints(this$static, nodes){
  var group, group$iterator, groups, node, node$array, node$index, node$iterator, node$max, violatedConstraint;
  groups = new ArrayList;
  for (node$iterator = new ArrayList$1(nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 9);
    $add_11(groups, this$static.constraintGroups[node.layer.id_0][node.id_0]);
  }
  $buildConstraintsGraph(this$static, groups);
  while (violatedConstraint = $findViolatedConstraint(groups)) {
    $handleViolatedConstraint(this$static, castTo(violatedConstraint.first, 101), castTo(violatedConstraint.second, 101), groups);
  }
  nodes.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
  for (group$iterator = new ArrayList$1(groups); group$iterator.i < group$iterator.this$01.array.length;) {
    group = castTo($next_8(group$iterator), 101);
    for (node$array = group.nodes , node$index = 0 , node$max = node$array.length; node$index < node$max; ++node$index) {
      node = node$array[node$index];
      nodes.array[nodes.array.length] = node;
      this$static.barycenterState[node.layer.id_0][node.id_0].barycenter = $stateOf_0(group.this$01, group.nodes[0]).barycenter;
    }
  }
}

function $stateOf_0(this$static, node){
  return this$static.barycenterState[node.layer.id_0][node.id_0];
}

function ForsterConstraintResolver(barycenterState, layoutUnits){
  var i, j, length_0;
  this.barycenterState = barycenterState;
  this.layoutUnits = layoutUnits;
  this.constraintGroups = initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_p3order_constraints_ForsterConstraintResolver$ConstraintGroup_2_classLit, $intern_0, 672, barycenterState.length, 0, 2);
  for (i = 0; i < barycenterState.length; ++i) {
    length_0 = barycenterState[i].length;
    this.constraintGroups[i] = initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_p3order_constraints_ForsterConstraintResolver$ConstraintGroup_2_classLit, {672:1, 3:1, 5:1, 6:1}, 101, length_0, 0, 1);
    for (j = 0; j < length_0; ++j) {
      this.constraintGroups[i][j] = new ForsterConstraintResolver$ConstraintGroup(this, barycenterState[i][j].node);
    }
  }
}

defineClass(566, 1, {}, ForsterConstraintResolver);
var Lde_cau_cs_kieler_klay_layered_p3order_constraints_ForsterConstraintResolver_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p3order.constraints', 'ForsterConstraintResolver', 566);
function $getOutgoingConstraints(this$static){
  !this$static.outgoingConstraints && (this$static.outgoingConstraints = new ArrayList);
  return this$static.outgoingConstraints;
}

function $setBarycenter(this$static, barycenter){
  var node, node$array, node$index, node$max;
  for (node$array = this$static.nodes , node$index = 0 , node$max = node$array.length; node$index < node$max; ++node$index) {
    node = node$array[node$index];
    $stateOf_0(this$static.this$01, node).barycenter = barycenter;
  }
}

function ForsterConstraintResolver$ConstraintGroup(this$0, node){
  this.this$01 = this$0;
  this.nodes = stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_graph_LNode_2_classLit, 1), $intern_49, 9, 0, [node]);
}

function ForsterConstraintResolver$ConstraintGroup_0(this$0, nodeGroup1, nodeGroup2){
  var candidate, candidate$iterator, i, i0, length1, length2;
  this.this$01 = this$0;
  length1 = nodeGroup1.nodes.length;
  length2 = nodeGroup2.nodes.length;
  this.nodes = initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LNode_2_classLit, $intern_49, 9, length1 + length2, 0, 1);
  for (i0 = 0; i0 < length1; i0++) {
    this.nodes[i0] = nodeGroup1.nodes[i0];
  }
  for (i = 0; i < length2; i++) {
    this.nodes[length1 + i] = nodeGroup2.nodes[i];
  }
  if (nodeGroup1.outgoingConstraints) {
    this.outgoingConstraints = newLinkedList(nodeGroup1.outgoingConstraints);
    this.outgoingConstraints.remove_1(nodeGroup2);
    if (nodeGroup2.outgoingConstraints) {
      for (candidate$iterator = nodeGroup2.outgoingConstraints.iterator_0(); candidate$iterator.hasNext_0();) {
        candidate = castTo(candidate$iterator.next_1(), 101);
        if (candidate == nodeGroup1) {
          continue;
        }
         else 
          this.outgoingConstraints.contains(candidate)?--candidate.incomingConstraintsCount:this.outgoingConstraints.add_1(candidate);
      }
    }
  }
   else if (nodeGroup2.outgoingConstraints) {
    this.outgoingConstraints = newLinkedList(nodeGroup2.outgoingConstraints);
    this.outgoingConstraints.remove_1(nodeGroup1);
  }
  this.summedWeight = nodeGroup1.summedWeight + nodeGroup2.summedWeight;
  this.degree = nodeGroup1.degree + nodeGroup2.degree;
  this.degree > 0?$setBarycenter(this, this.summedWeight / this.degree):$stateOf_0(nodeGroup1.this$01, nodeGroup1.nodes[0]).barycenter != null && $stateOf_0(nodeGroup2.this$01, nodeGroup2.nodes[0]).barycenter != null?$setBarycenter(this, (checkNotNull_1($stateOf_0(nodeGroup1.this$01, nodeGroup1.nodes[0]).barycenter) + checkNotNull_1($stateOf_0(nodeGroup2.this$01, nodeGroup2.nodes[0]).barycenter)) / 2):$stateOf_0(nodeGroup1.this$01, nodeGroup1.nodes[0]).barycenter != null?$setBarycenter(this, $stateOf_0(nodeGroup1.this$01, nodeGroup1.nodes[0]).barycenter):$stateOf_0(nodeGroup2.this$01, nodeGroup2.nodes[0]).barycenter != null && $setBarycenter(this, $stateOf_0(nodeGroup2.this$01, nodeGroup2.nodes[0]).barycenter);
}

defineClass(101, 1, {101:1}, ForsterConstraintResolver$ConstraintGroup, ForsterConstraintResolver$ConstraintGroup_0);
_.toString_0 = function toString_63(){
  var i, sb;
  sb = new StringBuilder;
  sb.string += '[';
  for (i = 0; i < this.nodes.length; i++) {
    $append_3(sb, $toString_8(this.nodes[i]));
    $stateOf_0(this.this$01, this.nodes[0]).barycenter != null && $append_3($append_3((sb.string += '<' , sb), toString_74(checkNotNull_1($stateOf_0(this.this$01, this.nodes[0]).barycenter))), '>');
    i < this.nodes.length - 1 && (sb.string += ', ' , sb);
  }
  return sb.string += ']' , sb.string;
}
;
_.degree = 0;
_.incomingConstraintsCount = 0;
_.summedWeight = 0;
var Lde_cau_cs_kieler_klay_layered_p3order_constraints_ForsterConstraintResolver$ConstraintGroup_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p3order.constraints', 'ForsterConstraintResolver/ConstraintGroup', 101);
function $countCrossings_2(this$static, layer, index_0){
  var c;
  c = 0;
  this$static.inLayerEdgeCount[index_0] > 0 && (c += $countInLayerEdgeCrossings(layer));
  this$static.hasNorthSouthPorts[index_0] && (c += $countNorthSouthPortCrossings(layer));
  return c;
}

function $countInLayerCrossings(port, portIndices){
  var connectedPortIndex, edge, edge$iterator, maxCrossings, portIndex;
  maxCrossings = 0;
  portIndex = castTo(getEntryValueOrNull($getEntry(portIndices.hashCodeMap, port)), 24);
  if (!portIndex) {
    return 0;
  }
  for (edge$iterator = $iterator(concat(($clinit_ImmutableList() , new RegularImmutableList(nullCheckedList(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [port.incomingEdges, port.outgoingEdges])))))); $hasNext_0(edge$iterator);) {
    edge = castTo($next_2(edge$iterator), 12);
    edge.source == port?(connectedPortIndex = castTo($get_9(portIndices, edge.target), 24)):(connectedPortIndex = castTo($get_9(portIndices, edge.source), 24));
    !!connectedPortIndex && portIndex.value_0 > connectedPortIndex.value_0 && (maxCrossings = max_3(maxCrossings, portIndex.value_0 - connectedPortIndex.value_0 - 1));
  }
  return maxCrossings;
}

function $countInLayerEdgeCrossings(layer){
  var currentNormalNode, dummyCount, dummyIndices, eastWestCrossings, easternPortNumbers, lastDummyIndex, lastDummyNormalNode, layerLayoutUnitsSet, newNormalNode, node, node$index, node$index0, node$max, node$max0, nodeType, northMaxCrossingHint, northSouthCrossingHints, northSouthCrossings, northernSide, port, port$iterator, southMaxCrossingHint, westernPortNumbers;
  eastWestCrossings = 0;
  northSouthCrossings = 0;
  northSouthCrossingHints = ($clinit_Maps() , new HashMap);
  dummyIndices = new HashMap;
  easternPortNumbers = new HashMap;
  westernPortNumbers = new HashMap;
  $numberEastWestPorts(layer, easternPortNumbers, westernPortNumbers);
  currentNormalNode = null;
  northMaxCrossingHint = 0;
  southMaxCrossingHint = 0;
  northernSide = true;
  layerLayoutUnitsSet = true;
  for (node$index0 = 0 , node$max0 = layer.length; node$index0 < node$max0; ++node$index0) {
    node = layer[node$index0];
    for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_8(port$iterator), 7);
      switch (port.side.ordinal) {
        case 2:
          eastWestCrossings += $countInLayerCrossings(port, easternPortNumbers);
          break;
        case 4:
          eastWestCrossings += $countInLayerCrossings(port, westernPortNumbers);
      }
    }
    nodeType = node.type_0;
    if (layerLayoutUnitsSet && (nodeType == ($clinit_LNode$NodeType() , NORMAL) || nodeType == NORTH_SOUTH_PORT)) {
      newNormalNode = castTo($getProperty(node, ($clinit_InternalProperties() , IN_LAYER_LAYOUT_UNIT)), 9);
      if (!newNormalNode) {
        layerLayoutUnitsSet = false;
        continue;
      }
      if (currentNormalNode != newNormalNode) {
        !!currentNormalNode && $put_2(northSouthCrossingHints, currentNormalNode, new Pair(valueOf_0(northMaxCrossingHint), valueOf_0(southMaxCrossingHint)));
        currentNormalNode = newNormalNode;
        northMaxCrossingHint = 0;
        southMaxCrossingHint = 0;
        northernSide = true;
      }
      node == currentNormalNode && (northernSide = false);
      if (northernSide) {
        northMaxCrossingHint += castTo($getProperty(node, CROSSING_HINT), 24).value_0;
        $put_2(dummyIndices, node, valueOf_0(northMaxCrossingHint));
      }
       else {
        southMaxCrossingHint += castTo($getProperty(node, CROSSING_HINT), 24).value_0;
        $put_2(dummyIndices, node, valueOf_0(southMaxCrossingHint));
      }
    }
  }
  !!currentNormalNode && $put_2(northSouthCrossingHints, currentNormalNode, new Pair(valueOf_0(northMaxCrossingHint), valueOf_0(southMaxCrossingHint)));
  if (layerLayoutUnitsSet) {
    lastDummyNormalNode = null;
    lastDummyIndex = 0;
    dummyCount = 0;
    northernSide = true;
    for (node$index = 0 , node$max = layer.length; node$index < node$max; ++node$index) {
      node = layer[node$index];
      nodeType = node.type_0;
      switch (nodeType.ordinal) {
        case 0:
          lastDummyIndex = castTo(getEntryValueOrNull($getEntry(dummyIndices.hashCodeMap, node)), 24).value_0;
          dummyCount = castTo(castTo(getEntryValueOrNull($getEntry(northSouthCrossingHints.hashCodeMap, node)), 27).second, 24).value_0;
          lastDummyNormalNode = node;
          northernSide = false;
          break;
        case 3:
          lastDummyIndex = castTo(getEntryValueOrNull($getEntry(dummyIndices.hashCodeMap, node)), 24).value_0;
          newNormalNode = castTo($getProperty(node, ($clinit_InternalProperties() , IN_LAYER_LAYOUT_UNIT)), 9);
          if (newNormalNode != lastDummyNormalNode) {
            dummyCount = castTo(castTo(getEntryValueOrNull($getEntry(northSouthCrossingHints.hashCodeMap, newNormalNode)), 27).first, 24).value_0;
            lastDummyNormalNode = newNormalNode;
            northernSide = true;
          }

          break;
        default:northSouthCrossings += northernSide?lastDummyIndex:dummyCount - lastDummyIndex;
      }
    }
  }
  return eastWestCrossings + northSouthCrossings;
}

function $countNorthSouthPortCrossings(layer){
  var crossings, currentNormalNode, i, j, node, node2, node2InputPort, node2InputPortCollision, node2OutputPort, node2OutputPortCollision, node2Type, nodeInputPort, nodeInputPortCollision, nodeOutputPort, nodeOutputPortCollision, nodeType, northernSide, port, port$iterator, port2, port2$iterator, recentNormalNode;
  crossings = 0;
  northernSide = true;
  recentNormalNode = null;
  for (i = 0; i < layer.length; i++) {
    node = layer[i];
    nodeType = node.type_0;
    if (nodeType == ($clinit_LNode$NodeType() , NORMAL)) {
      recentNormalNode = node;
      northernSide = false;
    }
     else if (nodeType == NORTH_SOUTH_PORT) {
      if (instanceOf($getProperty(node, ($clinit_InternalProperties() , ORIGIN)), 12)) {
        continue;
      }
      currentNormalNode = castTo($getProperty(node, ORIGIN), 9);
      if (recentNormalNode != currentNormalNode) {
        recentNormalNode = currentNormalNode;
        northernSide = true;
      }
      if (!$isOrderFixed(castTo($getProperty(currentNormalNode, ($clinit_LayoutOptions() , PORT_CONSTRAINTS)), 28))) {
        continue;
      }
      nodeInputPort = null;
      nodeOutputPort = null;
      for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
        port = castTo($next_8(port$iterator), 7);
        port.incomingEdges.array.length == 0?port.outgoingEdges.array.length == 0 || (nodeOutputPort = castTo($getProperty(port, ORIGIN), 7)):(nodeInputPort = castTo($getProperty(port, ORIGIN), 7));
      }
      for (j = i + 1; j < layer.length; j++) {
        node2 = layer[j];
        node2Type = node2.type_0;
        if (node2Type == NORMAL) {
          break;
        }
         else if (node2Type == NORTH_SOUTH_PORT) {
          if (maskUndefined($getProperty(node2, ORIGIN)) !== maskUndefined(currentNormalNode)) {
            break;
          }
          node2InputPort = null;
          node2OutputPort = null;
          for (port2$iterator = new ArrayList$1(node2.ports); port2$iterator.i < port2$iterator.this$01.array.length;) {
            port2 = castTo($next_8(port2$iterator), 7);
            port2.incomingEdges.array.length == 0?port2.outgoingEdges.array.length == 0 || (node2OutputPort = castTo($getProperty(port2, ORIGIN), 7)):(node2InputPort = castTo($getProperty(port2, ORIGIN), 7));
          }
          if (northernSide) {
            nodeInputPortCollision = false;
            nodeOutputPortCollision = false;
            if (!!nodeOutputPort && !!node2InputPort && nodeOutputPort.id_0 < node2InputPort.id_0) {
              ++crossings;
              nodeOutputPortCollision = true;
            }
            if (!!nodeInputPort && !!node2OutputPort && nodeInputPort.id_0 > node2OutputPort.id_0) {
              ++crossings;
              nodeInputPortCollision = true;
            }
            if (!!nodeOutputPort && !!node2OutputPort && nodeOutputPort.id_0 > node2OutputPort.id_0) {
              ++crossings;
              nodeOutputPortCollision = true;
            }
            if (!!nodeInputPort && !!node2InputPort && nodeInputPort.id_0 < node2InputPort.id_0) {
              ++crossings;
              nodeInputPortCollision = true;
            }
            nodeInputPortCollision && nodeOutputPortCollision && nodeInputPort == nodeOutputPort && --crossings;
          }
           else {
            node2InputPortCollision = false;
            node2OutputPortCollision = false;
            if (!!nodeInputPort && !!node2OutputPort && nodeInputPort.id_0 < node2OutputPort.id_0) {
              ++crossings;
              node2OutputPortCollision = true;
            }
            if (!!nodeOutputPort && !!node2InputPort && nodeOutputPort.id_0 > node2InputPort.id_0) {
              ++crossings;
              node2InputPortCollision = true;
            }
            if (!!nodeInputPort && !!node2InputPort && nodeInputPort.id_0 < node2InputPort.id_0) {
              ++crossings;
              node2InputPortCollision = true;
            }
            if (!!nodeOutputPort && !!node2OutputPort && nodeOutputPort.id_0 > node2OutputPort.id_0) {
              ++crossings;
              node2OutputPortCollision = true;
            }
            node2InputPortCollision && node2OutputPortCollision && node2InputPort == node2OutputPort && --crossings;
          }
        }
      }
    }
  }
  return crossings;
}

function $numberEastWestPorts(layer, easternMap, westernMap){
  var currentEasternNumber, currentWesternNumber, easternPort, easternPort$iterator, easternPort$iterator0, node, nodeIndex, nodeIndex0, westernPort, westernPort$iterator, westernPort$iterator0;
  currentEasternNumber = 0;
  currentWesternNumber = 0;
  for (nodeIndex0 = 0; nodeIndex0 < layer.length; nodeIndex0++) {
    node = layer[nodeIndex0];
    if ($isOrderFixed(castTo($getProperty(node, ($clinit_LayoutOptions() , PORT_CONSTRAINTS)), 28))) {
      for (easternPort$iterator = $getPorts_0(node, ($clinit_PortSide() , EAST)).iterator_0(); easternPort$iterator.hasNext_0();) {
        easternPort = castTo(easternPort$iterator.next_1(), 7);
        if (easternPort.incomingEdges.array.length + easternPort.outgoingEdges.array.length > 0) {
          currentEasternNumber += easternPort.incomingEdges.array.length + easternPort.outgoingEdges.array.length;
          $put_2(easternMap, easternPort, valueOf_0(currentEasternNumber));
        }
      }
    }
     else {
      for (easternPort$iterator0 = $getPorts_0(node, ($clinit_PortSide() , EAST)).iterator_0(); easternPort$iterator0.hasNext_0();) {
        easternPort = castTo(easternPort$iterator0.next_1(), 7);
        currentEasternNumber += easternPort.incomingEdges.array.length + easternPort.outgoingEdges.array.length;
      }
      for (easternPort$iterator = $getPorts_0(node, EAST).iterator_0(); easternPort$iterator.hasNext_0();) {
        easternPort = castTo(easternPort$iterator.next_1(), 7);
        easternPort.incomingEdges.array.length + easternPort.outgoingEdges.array.length > 0 && $put_2(easternMap, easternPort, valueOf_0(currentEasternNumber));
      }
    }
  }
  for (nodeIndex = layer.length - 1; nodeIndex >= 0; nodeIndex--) {
    node = layer[nodeIndex];
    if ($isOrderFixed(castTo($getProperty(node, ($clinit_LayoutOptions() , PORT_CONSTRAINTS)), 28))) {
      for (westernPort$iterator = $getPorts_0(node, ($clinit_PortSide() , WEST)).iterator_0(); westernPort$iterator.hasNext_0();) {
        westernPort = castTo(westernPort$iterator.next_1(), 7);
        if (westernPort.incomingEdges.array.length + westernPort.outgoingEdges.array.length > 0) {
          currentWesternNumber += westernPort.incomingEdges.array.length + westernPort.outgoingEdges.array.length;
          $put_2(westernMap, westernPort, valueOf_0(currentWesternNumber));
        }
      }
    }
     else {
      for (westernPort$iterator0 = $getPorts_0(node, ($clinit_PortSide() , WEST)).iterator_0(); westernPort$iterator0.hasNext_0();) {
        westernPort = castTo(westernPort$iterator0.next_1(), 7);
        currentWesternNumber += westernPort.incomingEdges.array.length + westernPort.outgoingEdges.array.length;
      }
      for (westernPort$iterator = $getPorts_0(node, WEST).iterator_0(); westernPort$iterator.hasNext_0();) {
        westernPort = castTo(westernPort$iterator.next_1(), 7);
        westernPort.incomingEdges.array.length + westernPort.outgoingEdges.array.length > 0 && $put_2(westernMap, westernPort, valueOf_0(currentWesternNumber));
      }
    }
  }
}

function AbstractCrossingsCounter(inLayerEdgeCount, hasNorthSouthPorts){
  this.inLayerEdgeCount = inLayerEdgeCount;
  this.hasNorthSouthPorts = hasNorthSouthPorts;
}

defineClass(331, 1, {});
var Lde_cau_cs_kieler_klay_layered_p3order_counting_AbstractCrossingsCounter_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p3order.counting', 'AbstractCrossingsCounter', 331);
function $countCrossings_3(this$static, leftLayer, rightLayer){
  var crossCount, edge, edge$iterator, edgeCount, firstIndex, i, index_0, k, leftLayerRef, node, node$index, node$index0, node$max, node$max0, nodeEdges, northInputPorts, otherInputPorts, port, port$iterator, portEdges, portIter, rightLayerRef, southSequence, start_0, target, targetCount, tree, treeSize;
  targetCount = 0;
  edgeCount = 0;
  leftLayerRef = leftLayer[0].layer;
  rightLayerRef = rightLayer[0].layer;
  for (node$index0 = 0 , node$max0 = rightLayer.length; node$index0 < node$max0; ++node$index0) {
    node = rightLayer[node$index0];
    if ($isOrderFixed(castTo($getProperty(node, ($clinit_LayoutOptions() , PORT_CONSTRAINTS)), 28))) {
      northInputPorts = 0;
      for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
        port = castTo($next_8(port$iterator), 7);
        if (port.side == ($clinit_PortSide() , NORTH)) {
          for (edge$iterator = new ArrayList$1(port.incomingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
            edge = castTo($next_8(edge$iterator), 12);
            if (edge.source.owner.layer == leftLayerRef) {
              ++northInputPorts;
              break;
            }
          }
        }
         else {
          break;
        }
      }
      otherInputPorts = 0;
      portIter = new AbstractList$ListIteratorImpl(node.ports, node.ports.array.length);
      while (portIter.i > 0) {
        port = (checkCriticalElement(portIter.i > 0) , castTo(portIter.this$01.get_2(portIter.last = --portIter.i), 7));
        portEdges = 0;
        for (edge$iterator = new ArrayList$1(port.incomingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
          edge = castTo($next_8(edge$iterator), 12);
          edge.source.owner.layer == leftLayerRef && ++portEdges;
        }
        if (portEdges > 0) {
          if (port.side == ($clinit_PortSide() , NORTH)) {
            this$static.portPos[port.id_0] = targetCount;
            ++targetCount;
          }
           else {
            this$static.portPos[port.id_0] = targetCount + northInputPorts + otherInputPorts;
            ++otherInputPorts;
          }
          edgeCount += portEdges;
        }
      }
      targetCount += otherInputPorts;
    }
     else {
      nodeEdges = 0;
      for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
        port = castTo($next_8(port$iterator), 7);
        for (edge$iterator = new ArrayList$1(port.incomingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
          edge = castTo($next_8(edge$iterator), 12);
          edge.source.owner.layer == leftLayerRef && ++nodeEdges;
        }
        this$static.portPos[port.id_0] = targetCount;
      }
      if (nodeEdges > 0) {
        ++targetCount;
        edgeCount += nodeEdges;
      }
    }
  }
  southSequence = initUnidimensionalArray(I_classLit, $intern_37, 26, edgeCount, 12, 1);
  i = 0;
  for (node$index = 0 , node$max = leftLayer.length; node$index < node$max; ++node$index) {
    node = leftLayer[node$index];
    if ($isOrderFixed(castTo($getProperty(node, ($clinit_LayoutOptions() , PORT_CONSTRAINTS)), 28))) {
      for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
        port = castTo($next_8(port$iterator), 7);
        start_0 = i;
        for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
          edge = castTo($next_8(edge$iterator), 12);
          target = edge.target;
          target.owner.layer == rightLayerRef && insert_0(southSequence, start_0, i++, this$static.portPos[target.id_0]);
        }
      }
    }
     else {
      start_0 = i;
      for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
        port = castTo($next_8(port$iterator), 7);
        for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
          edge = castTo($next_8(edge$iterator), 12);
          target = edge.target;
          target.owner.layer == rightLayerRef && insert_0(southSequence, start_0, i++, this$static.portPos[target.id_0]);
        }
      }
    }
  }
  firstIndex = 1;
  while (firstIndex < targetCount) {
    firstIndex *= 2;
  }
  treeSize = 2 * firstIndex - 1;
  firstIndex -= 1;
  tree = initUnidimensionalArray(I_classLit, $intern_37, 26, treeSize, 12, 1);
  crossCount = 0;
  for (k = 0; k < edgeCount; k++) {
    index_0 = southSequence[k] + firstIndex;
    ++tree[index_0];
    while (index_0 > 0) {
      index_0 % 2 > 0 && (crossCount += tree[index_0 + 1]);
      index_0 = (index_0 - 1) / 2 | 0;
      ++tree[index_0];
    }
  }
  return crossCount;
}

function BarthJuengerMutzelCrossingsCounter(inLayerEdgeCount, hasNorthSouthPorts, portPos){
  AbstractCrossingsCounter.call(this, inLayerEdgeCount, hasNorthSouthPorts);
  this.portPos = portPos;
}

function binarySearch_0(a, fromIndex, toIndex, key){
  var high, low, mid, midVal;
  low = fromIndex;
  high = toIndex - 1;
  while (low <= high) {
    mid = low + high >>> 1;
    midVal = a[mid];
    if (midVal < key) {
      low = mid + 1;
    }
     else if (midVal > key) {
      high = mid - 1;
    }
     else {
      return mid;
    }
  }
  return -(low + 1);
}

function insert_0(array, start_0, end, n){
  var insx, j;
  insx = binarySearch_0(array, start_0, end, n);
  insx < 0 && (insx = -insx - 1);
  for (j = end - 1; j >= insx; j--) {
    array[j + 1] = array[j];
  }
  array[insx] = n;
}

defineClass(568, 331, {}, BarthJuengerMutzelCrossingsCounter);
var Lde_cau_cs_kieler_klay_layered_p3order_counting_BarthJuengerMutzelCrossingsCounter_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p3order.counting', 'BarthJuengerMutzelCrossingsCounter', 568);
function $countCrossings_4(this$static, leftLayer, rightLayer){
  var compressDeltas, crossings, delta, edge, edge$iterator, firstIndex, he, he$index, he$max, hyperedge, hyperedgeSet, hyperedges, i, i0, i1, i2, i3, i4, i5, index_0, k, leftCorners, leftLayerRef, node, node$index, node$index0, node$index1, node$max, node$max0, node$max1, nodeEdges, northInputPorts, openHyperedges, otherInputPorts, p, p$iterator, port, port$iterator, port2HyperedgeMap, portEdges, portIter, pos, q, rightCorners, rightLayerRef, sourceCount, sourceHE, sourcePort, sourcePort$iterator, southSequence, targetCount, targetHE, targetPort, tree, treeSize;
  sourceCount = 0;
  for (node$index0 = 0 , node$max0 = leftLayer.length; node$index0 < node$max0; ++node$index0) {
    node = leftLayer[node$index0];
    if ($isOrderFixed(castTo($getProperty(node, ($clinit_LayoutOptions() , PORT_CONSTRAINTS)), 28))) {
      for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
        port = castTo($next_8(port$iterator), 7);
        portEdges = 0;
        for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
          edge = castTo($next_8(edge$iterator), 12);
          node.layer != edge.target.owner.layer && ++portEdges;
        }
        portEdges > 0 && (this$static.portPos[port.id_0] = sourceCount++);
      }
    }
     else {
      nodeEdges = 0;
      for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
        port = castTo($next_8(port$iterator), 7);
        for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
          edge = castTo($next_8(edge$iterator), 12);
          node.layer != edge.target.owner.layer && ++nodeEdges;
        }
        this$static.portPos[port.id_0] = sourceCount;
      }
      nodeEdges > 0 && ++sourceCount;
    }
  }
  targetCount = 0;
  for (node$index1 = 0 , node$max1 = rightLayer.length; node$index1 < node$max1; ++node$index1) {
    node = rightLayer[node$index1];
    if ($isOrderFixed(castTo($getProperty(node, ($clinit_LayoutOptions() , PORT_CONSTRAINTS)), 28))) {
      northInputPorts = 0;
      for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
        port = castTo($next_8(port$iterator), 7);
        if (port.side == ($clinit_PortSide() , NORTH)) {
          for (edge$iterator = new ArrayList$1(port.incomingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
            edge = castTo($next_8(edge$iterator), 12);
            if (node.layer != edge.source.owner.layer) {
              ++northInputPorts;
              break;
            }
          }
        }
         else {
          break;
        }
      }
      otherInputPorts = 0;
      portIter = new AbstractList$ListIteratorImpl(node.ports, node.ports.array.length);
      while (portIter.i > 0) {
        port = (checkCriticalElement(portIter.i > 0) , castTo(portIter.this$01.get_2(portIter.last = --portIter.i), 7));
        portEdges = 0;
        for (edge$iterator = new ArrayList$1(port.incomingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
          edge = castTo($next_8(edge$iterator), 12);
          node.layer != edge.source.owner.layer && ++portEdges;
        }
        if (portEdges > 0) {
          if (port.side == ($clinit_PortSide() , NORTH)) {
            this$static.portPos[port.id_0] = targetCount;
            ++targetCount;
          }
           else {
            this$static.portPos[port.id_0] = targetCount + northInputPorts + otherInputPorts;
            ++otherInputPorts;
          }
        }
      }
      targetCount += otherInputPorts;
    }
     else {
      nodeEdges = 0;
      for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
        port = castTo($next_8(port$iterator), 7);
        for (edge$iterator = new ArrayList$1(port.incomingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
          edge = castTo($next_8(edge$iterator), 12);
          node.layer != edge.source.owner.layer && ++nodeEdges;
        }
        this$static.portPos[port.id_0] = targetCount;
      }
      nodeEdges > 0 && ++targetCount;
    }
  }
  port2HyperedgeMap = ($clinit_Maps() , new HashMap);
  hyperedgeSet = new LinkedHashSet;
  for (node$index = 0 , node$max = leftLayer.length; node$index < node$max; ++node$index) {
    node = leftLayer[node$index];
    for (sourcePort$iterator = new ArrayList$1(node.ports); sourcePort$iterator.i < sourcePort$iterator.this$01.array.length;) {
      sourcePort = castTo($next_8(sourcePort$iterator), 7);
      for (edge$iterator = new ArrayList$1(sourcePort.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
        edge = castTo($next_8(edge$iterator), 12);
        targetPort = edge.target;
        if (node.layer != targetPort.owner.layer) {
          sourceHE = castTo(getEntryValueOrNull($getEntry(port2HyperedgeMap.hashCodeMap, sourcePort)), 197);
          targetHE = castTo(getEntryValueOrNull($getEntry(port2HyperedgeMap.hashCodeMap, targetPort)), 197);
          if (!sourceHE && !targetHE) {
            hyperedge = new HyperedgeCrossingsCounter$Hyperedge;
            hyperedgeSet.map_0.put(hyperedge, hyperedgeSet);
            $add_11(hyperedge.edges, edge);
            $add_11(hyperedge.ports, sourcePort);
            $put_5(port2HyperedgeMap.hashCodeMap, sourcePort, hyperedge);
            $add_11(hyperedge.ports, targetPort);
            $put_5(port2HyperedgeMap.hashCodeMap, targetPort, hyperedge);
          }
           else if (!sourceHE) {
            $add_11(targetHE.edges, edge);
            $add_11(targetHE.ports, sourcePort);
            $put_5(port2HyperedgeMap.hashCodeMap, sourcePort, targetHE);
          }
           else if (!targetHE) {
            $add_11(sourceHE.edges, edge);
            $add_11(sourceHE.ports, targetPort);
            $put_5(port2HyperedgeMap.hashCodeMap, targetPort, sourceHE);
          }
           else if (sourceHE == targetHE) {
            $add_11(sourceHE.edges, edge);
          }
           else {
            $add_11(sourceHE.edges, edge);
            for (p$iterator = new ArrayList$1(targetHE.ports); p$iterator.i < p$iterator.this$01.array.length;) {
              p = castTo($next_8(p$iterator), 7);
              $put_5(port2HyperedgeMap.hashCodeMap, p, sourceHE);
            }
            $addAll_6(sourceHE.edges, targetHE.edges);
            $addAll_6(sourceHE.ports, targetHE.ports);
            hyperedgeSet.map_0.remove_0(targetHE) != null;
          }
        }
      }
    }
  }
  hyperedges = castTo($toArray(hyperedgeSet, initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_p3order_counting_HyperedgeCrossingsCounter$Hyperedge_2_classLit, {673:1, 3:1, 5:1, 6:1}, 197, hyperedgeSet.map_0.size_1(), 0, 1)), 673);
  leftLayerRef = leftLayer[0].layer;
  rightLayerRef = rightLayer[0].layer;
  for (he$index = 0 , he$max = hyperedges.length; he$index < he$max; ++he$index) {
    he = hyperedges[he$index];
    he.upperLeft = sourceCount;
    he.upperRight = targetCount;
    for (port$iterator = new ArrayList$1(he.ports); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_8(port$iterator), 7);
      pos = this$static.portPos[port.id_0];
      if (port.owner.layer == leftLayerRef) {
        pos < he.upperLeft && (he.upperLeft = pos);
        pos > he.lowerLeft && (he.lowerLeft = pos);
      }
       else if (port.owner.layer == rightLayerRef) {
        pos < he.upperRight && (he.upperRight = pos);
        pos > he.lowerRight && (he.lowerRight = pos);
      }
    }
  }
  mergeSort(hyperedges, 0, hyperedges.length, ($clinit_Comparators() , $clinit_Comparators() , NATURAL));
  southSequence = initUnidimensionalArray(I_classLit, $intern_37, 26, hyperedges.length, 12, 1);
  compressDeltas = initUnidimensionalArray(I_classLit, $intern_37, 26, targetCount + 1, 12, 1);
  for (i0 = 0; i0 < hyperedges.length; i0++) {
    southSequence[i0] = hyperedges[i0].upperRight;
    compressDeltas[southSequence[i0]] = 1;
  }
  delta = 0;
  for (i1 = 0; i1 < compressDeltas.length; i1++) {
    compressDeltas[i1] == 1?(compressDeltas[i1] = delta):--delta;
  }
  q = 0;
  for (i2 = 0; i2 < southSequence.length; i2++) {
    southSequence[i2] += compressDeltas[southSequence[i2]];
    q = max_3(q, southSequence[i2] + 1);
  }
  firstIndex = 1;
  while (firstIndex < q) {
    firstIndex *= 2;
  }
  treeSize = 2 * firstIndex - 1;
  firstIndex -= 1;
  tree = initUnidimensionalArray(I_classLit, $intern_37, 26, treeSize, 12, 1);
  crossings = 0;
  for (k = 0; k < southSequence.length; k++) {
    index_0 = southSequence[k] + firstIndex;
    ++tree[index_0];
    while (index_0 > 0) {
      index_0 % 2 > 0 && (crossings += tree[index_0 + 1]);
      index_0 = (index_0 - 1) / 2 | 0;
      ++tree[index_0];
    }
  }
  leftCorners = initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_p3order_counting_HyperedgeCrossingsCounter$HyperedgeCorner_2_classLit, $intern_12, 156, hyperedges.length * 2, 0, 1);
  for (i3 = 0; i3 < hyperedges.length; i3++) {
    leftCorners[2 * i3] = new HyperedgeCrossingsCounter$HyperedgeCorner(hyperedges[i3], hyperedges[i3].upperLeft, hyperedges[i3].lowerLeft, ($clinit_HyperedgeCrossingsCounter$HyperedgeCorner$Type() , UPPER));
    leftCorners[2 * i3 + 1] = new HyperedgeCrossingsCounter$HyperedgeCorner(hyperedges[i3], hyperedges[i3].lowerLeft, hyperedges[i3].upperLeft, LOWER);
  }
  mergeSort(leftCorners, 0, leftCorners.length, (null , NATURAL));
  openHyperedges = 0;
  for (i4 = 0; i4 < leftCorners.length; i4++) {
    switch (leftCorners[i4].type_0.ordinal) {
      case 0:
        ++openHyperedges;
        break;
      case 1:
        --openHyperedges;
        crossings += openHyperedges;
    }
  }
  rightCorners = initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_p3order_counting_HyperedgeCrossingsCounter$HyperedgeCorner_2_classLit, $intern_12, 156, hyperedges.length * 2, 0, 1);
  for (i5 = 0; i5 < hyperedges.length; i5++) {
    rightCorners[2 * i5] = new HyperedgeCrossingsCounter$HyperedgeCorner(hyperedges[i5], hyperedges[i5].upperRight, hyperedges[i5].lowerRight, ($clinit_HyperedgeCrossingsCounter$HyperedgeCorner$Type() , UPPER));
    rightCorners[2 * i5 + 1] = new HyperedgeCrossingsCounter$HyperedgeCorner(hyperedges[i5], hyperedges[i5].lowerRight, hyperedges[i5].upperRight, LOWER);
  }
  mergeSort(rightCorners, 0, rightCorners.length, (null , NATURAL));
  openHyperedges = 0;
  for (i = 0; i < rightCorners.length; i++) {
    switch (rightCorners[i].type_0.ordinal) {
      case 0:
        ++openHyperedges;
        break;
      case 1:
        --openHyperedges;
        crossings += openHyperedges;
    }
  }
  return crossings;
}

function HyperedgeCrossingsCounter(inLayerEdgeCount, hasNorthSouthPorts, portPos){
  AbstractCrossingsCounter.call(this, inLayerEdgeCount, hasNorthSouthPorts);
  this.portPos = portPos;
}

defineClass(567, 331, {}, HyperedgeCrossingsCounter);
var Lde_cau_cs_kieler_klay_layered_p3order_counting_HyperedgeCrossingsCounter_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p3order.counting', 'HyperedgeCrossingsCounter', 567);
function $compareTo_6(this$static, other){
  if (this$static.upperLeft < other.upperLeft) {
    return -1;
  }
   else if (this$static.upperLeft > other.upperLeft) {
    return 1;
  }
   else if (this$static.upperRight < other.upperRight) {
    return -1;
  }
   else if (this$static.upperRight > other.upperRight) {
    return 1;
  }
  return getObjectIdentityHashCode(this$static) - getObjectIdentityHashCode(other);
}

function HyperedgeCrossingsCounter$Hyperedge(){
  this.edges = new ArrayList;
  this.ports = new ArrayList;
}

defineClass(197, 1, {197:1, 23:1}, HyperedgeCrossingsCounter$Hyperedge);
_.compareTo = function compareTo_8(other){
  return $compareTo_6(this, castTo(other, 197));
}
;
_.lowerLeft = 0;
_.lowerRight = 0;
_.upperLeft = 0;
_.upperRight = 0;
var Lde_cau_cs_kieler_klay_layered_p3order_counting_HyperedgeCrossingsCounter$Hyperedge_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p3order.counting', 'HyperedgeCrossingsCounter/Hyperedge', 197);
function $compareTo_7(this$static, other){
  if (this$static.position < other.position) {
    return -1;
  }
   else if (this$static.position > other.position) {
    return 1;
  }
   else if (this$static.oppositePosition < other.oppositePosition) {
    return -1;
  }
   else if (this$static.oppositePosition > other.oppositePosition) {
    return 1;
  }
   else if (this$static.hyperedge != other.hyperedge) {
    return getObjectIdentityHashCode(this$static.hyperedge) - getObjectIdentityHashCode(other.hyperedge);
  }
   else if (this$static.type_0 == ($clinit_HyperedgeCrossingsCounter$HyperedgeCorner$Type() , UPPER) && other.type_0 == LOWER) {
    return -1;
  }
   else if (this$static.type_0 == LOWER && other.type_0 == UPPER) {
    return 1;
  }
  return 0;
}

function HyperedgeCrossingsCounter$HyperedgeCorner(hyperedge, position, oppositePosition, type_0){
  this.hyperedge = hyperedge;
  this.position = position;
  this.oppositePosition = oppositePosition;
  this.type_0 = type_0;
}

defineClass(156, 1, {156:1, 23:1}, HyperedgeCrossingsCounter$HyperedgeCorner);
_.compareTo = function compareTo_9(other){
  return $compareTo_7(this, castTo(other, 156));
}
;
_.oppositePosition = 0;
_.position = 0;
var Lde_cau_cs_kieler_klay_layered_p3order_counting_HyperedgeCrossingsCounter$HyperedgeCorner_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p3order.counting', 'HyperedgeCrossingsCounter/HyperedgeCorner', 156);
function $clinit_HyperedgeCrossingsCounter$HyperedgeCorner$Type(){
  $clinit_HyperedgeCrossingsCounter$HyperedgeCorner$Type = emptyMethod;
  UPPER = new HyperedgeCrossingsCounter$HyperedgeCorner$Type('UPPER', 0);
  LOWER = new HyperedgeCrossingsCounter$HyperedgeCorner$Type('LOWER', 1);
}

function HyperedgeCrossingsCounter$HyperedgeCorner$Type(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function values_39(){
  $clinit_HyperedgeCrossingsCounter$HyperedgeCorner$Type();
  return stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_p3order_counting_HyperedgeCrossingsCounter$HyperedgeCorner$Type_2_classLit, 1), $intern_13, 242, 0, [UPPER, LOWER]);
}

defineClass(242, 17, {242:1, 3:1, 23:1, 17:1}, HyperedgeCrossingsCounter$HyperedgeCorner$Type);
var LOWER, UPPER;
var Lde_cau_cs_kieler_klay_layered_p3order_counting_HyperedgeCrossingsCounter$HyperedgeCorner$Type_2_classLit = createForEnum('de.cau.cs.kieler.klay.layered.p3order.counting', 'HyperedgeCrossingsCounter/HyperedgeCorner/Type', 242, Ljava_lang_Enum_2_classLit, values_39);
function $clinit_InteractiveNodePlacer(){
  $clinit_InteractiveNodePlacer = emptyMethod;
  HIERARCHY_PROCESSING_ADDITIONS = $addBeforePhase5(new IntermediateProcessingConfiguration, ($clinit_IntermediateProcessorStrategy() , HIERARCHICAL_PORT_POSITION_PROCESSOR));
}

function $placeNodes(this$static, layer){
  var minValidY, node, node$iterator, nodeType, originalYCoordinate, prevNodeType, spacing;
  minValidY = $intern_51;
  prevNodeType = ($clinit_LNode$NodeType() , NORMAL);
  for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 9);
    nodeType = node.type_0;
    if (nodeType != NORMAL) {
      originalYCoordinate = castToDouble($getProperty(node, ($clinit_InternalProperties() , ORIGINAL_DUMMY_NODE_POSITION)));
      if (originalYCoordinate == null) {
        minValidY = minValidY > 0?minValidY:0;
        node.pos.y_0 = minValidY + $getVerticalSpacing(this$static.spacings, nodeType, prevNodeType);
      }
       else {
        node.pos.y_0 = (checkCriticalNotNull(originalYCoordinate) , originalYCoordinate);
      }
    }
    spacing = $getVerticalSpacing(this$static.spacings, nodeType, prevNodeType);
    node.pos.y_0 < minValidY + spacing + node.margin.top_0 && (node.pos.y_0 = minValidY + spacing + node.margin.top_0);
    minValidY = node.pos.y_0 + node.size_0.y_0 + node.margin.bottom;
    prevNodeType = nodeType;
  }
}

function InteractiveNodePlacer(){
  $clinit_InteractiveNodePlacer();
}

defineClass(545, 1, $intern_64, InteractiveNodePlacer);
_.getIntermediateProcessingConfiguration = function getIntermediateProcessingConfiguration_6(graph){
  return castTo($getProperty(graph, ($clinit_InternalProperties() , GRAPH_PROPERTIES)), 18).contains(($clinit_GraphProperties() , EXTERNAL_PORTS))?HIERARCHY_PROCESSING_ADDITIONS:null;
}
;
_.process = function process_53(layeredGraph, monitor){
  var layer, layer$iterator;
  $begin(monitor, 'Interactive node placement', 1);
  this.spacings = castTo($getProperty(layeredGraph, ($clinit_InternalProperties() , SPACINGS)), 134);
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator), 16);
    $placeNodes(this, layer);
  }
  $done(monitor);
}
;
var HIERARCHY_PROCESSING_ADDITIONS;
var Lde_cau_cs_kieler_klay_layered_p4nodes_InteractiveNodePlacer_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p4nodes', 'InteractiveNodePlacer', 545);
function $clinit_LinearSegmentsNodePlacer(){
  $clinit_LinearSegmentsNodePlacer = emptyMethod;
  HIERARCHY_PROCESSING_ADDITIONS_0 = $addBeforePhase5(new IntermediateProcessingConfiguration, ($clinit_IntermediateProcessorStrategy() , HIERARCHICAL_PORT_POSITION_PROCESSOR));
  INPUT_PRIO = new Property_2('linearSegments.inputPrio', valueOf_0(0));
  OUTPUT_PRIO = new Property_2('linearSegments.outputPrio', valueOf_0(0));
}

function $balancePlacement(this$static, layeredGraph){
  var deflection, deflectionDampening, finalIters, incoming, lastTotalDeflection, merged, mode, node, node$iterator, outgoing, pendulumIters, ready, segment, segment$array, segment$array0, segment$index, segment$index0, segment$max, segment$max0, thoroughness, threshold, totalDeflection;
  deflectionDampening = castTo($getProperty(layeredGraph, ($clinit_Properties() , LINEAR_SEGMENTS_DEFLECTION_DAMPENING)), 15).value_0;
  thoroughness = castTo($getProperty(layeredGraph, THOROUGHNESS), 24).value_0;
  pendulumIters = 4;
  finalIters = 3;
  threshold = 20 / thoroughness;
  ready = false;
  mode = 0;
  lastTotalDeflection = $intern_3;
  do {
    incoming = mode != 1;
    outgoing = mode != 0;
    totalDeflection = 0;
    for (segment$array0 = this$static.linearSegments , segment$index0 = 0 , segment$max0 = segment$array0.length; segment$index0 < segment$max0; ++segment$index0) {
      segment = segment$array0[segment$index0];
      segment.refSegment = null;
      $calcDeflection(this$static, segment, incoming, outgoing, deflectionDampening);
      totalDeflection += abs_0(segment.deflection);
    }
    do {
      merged = $mergeRegions(this$static, layeredGraph);
    }
     while (merged);
    for (segment$array = this$static.linearSegments , segment$index = 0 , segment$max = segment$array.length; segment$index < segment$max; ++segment$index) {
      segment = segment$array[segment$index];
      deflection = $region(segment).deflection;
      if (deflection != 0) {
        for (node$iterator = new ArrayList$1(segment.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
          node = castTo($next_8(node$iterator), 9);
          node.pos.y_0 += deflection;
        }
      }
    }
    if (mode == 0 || mode == 1) {
      --pendulumIters;
      if (pendulumIters <= 0 && (totalDeflection < lastTotalDeflection || -pendulumIters > thoroughness)) {
        mode = 2;
        lastTotalDeflection = $intern_3;
      }
       else if (mode == 0) {
        mode = 1;
        lastTotalDeflection = totalDeflection;
      }
       else {
        mode = 0;
        lastTotalDeflection = totalDeflection;
      }
    }
     else {
      ready = totalDeflection >= lastTotalDeflection || lastTotalDeflection - totalDeflection < threshold;
      lastTotalDeflection = totalDeflection;
      ready && --finalIters;
    }
  }
   while (!(ready && finalIters <= 0));
}

function $calcDeflection(this$static, segment, incoming, outgoing, deflectionDampening){
  var edge, edge$iterator, edgeWeightSum, inputPrio, minPrio, node, node$iterator, nodeDeflection, nodeWeightSum, otherNode, otherPort, otherPrio, outputPrio, port, port$iterator, portpos, prio, segmentDeflection;
  segmentDeflection = 0;
  nodeWeightSum = 0;
  for (node$iterator = new ArrayList$1(segment.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 9);
    nodeDeflection = 0;
    edgeWeightSum = 0;
    inputPrio = incoming?castTo($getProperty(node, INPUT_PRIO), 24).value_0:$intern_8;
    outputPrio = outgoing?castTo($getProperty(node, OUTPUT_PRIO), 24).value_0:$intern_8;
    minPrio = inputPrio > outputPrio?inputPrio:outputPrio;
    for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_8(port$iterator), 7);
      portpos = node.pos.y_0 + port.pos.y_0 + port.anchor.y_0;
      if (outgoing) {
        for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
          edge = castTo($next_8(edge$iterator), 12);
          otherPort = edge.target;
          otherNode = otherPort.owner;
          if (segment != this$static.linearSegments[otherNode.id_0]) {
            otherPrio = max_3(castTo($getProperty(otherNode, INPUT_PRIO), 24).value_0, castTo($getProperty(otherNode, OUTPUT_PRIO), 24).value_0);
            prio = castTo($getProperty(edge, ($clinit_InternalProperties() , PRIORITY_0)), 24).value_0;
            if (prio >= minPrio && prio >= otherPrio) {
              nodeDeflection += otherNode.pos.y_0 + otherPort.pos.y_0 + otherPort.anchor.y_0 - portpos;
              ++edgeWeightSum;
            }
          }
        }
      }
      if (incoming) {
        for (edge$iterator = new ArrayList$1(port.incomingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
          edge = castTo($next_8(edge$iterator), 12);
          otherPort = edge.source;
          otherNode = otherPort.owner;
          if (segment != this$static.linearSegments[otherNode.id_0]) {
            otherPrio = max_3(castTo($getProperty(otherNode, INPUT_PRIO), 24).value_0, castTo($getProperty(otherNode, OUTPUT_PRIO), 24).value_0);
            prio = castTo($getProperty(edge, ($clinit_InternalProperties() , PRIORITY_0)), 24).value_0;
            if (prio >= minPrio && prio >= otherPrio) {
              nodeDeflection += otherNode.pos.y_0 + otherPort.pos.y_0 + otherPort.anchor.y_0 - portpos;
              ++edgeWeightSum;
            }
          }
        }
      }
    }
    if (edgeWeightSum > 0) {
      segmentDeflection += nodeDeflection / edgeWeightSum;
      ++nodeWeightSum;
    }
  }
  if (nodeWeightSum > 0) {
    segment.deflection = deflectionDampening * segmentDeflection / nodeWeightSum;
    segment.weight = nodeWeightSum;
  }
   else {
    segment.deflection = 0;
    segment.weight = 0;
  }
}

function $createDependencyGraphEdges(layeredGraph, segmentList, outgoingList, incomingCountList){
  var currentNode, currentSegment, cycleNode, cycleNodesIter, cycleSegment, indexInLayer, layer, layer$iterator, layerIndex, nextLinearSegmentID, nextNode, nextSegment, nodeIter, nodes, previousNode;
  nextLinearSegmentID = segmentList.array.length;
  layerIndex = 0;
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator), 16);
    nodes = layer.nodes;
    if (nodes.array.length == 0) {
      continue;
    }
    nodeIter = new ArrayList$1(nodes);
    indexInLayer = 0;
    previousNode = null;
    currentNode = castTo($next_8(nodeIter), 9);
    while (currentNode) {
      currentSegment = castTo($get_8(segmentList, currentNode.id_0), 111);
      if (currentSegment.indexInLastLayer >= 0) {
        cycleSegment = null;
        cycleNodesIter = new AbstractList$ListIteratorImpl(layer.nodes, indexInLayer + 1);
        while (cycleNodesIter.i < cycleNodesIter.this$01_0.size_1()) {
          cycleNode = (checkCriticalElement(cycleNodesIter.i < cycleNodesIter.this$01_0.size_1()) , castTo(cycleNodesIter.this$01_0.get_2(cycleNodesIter.last = cycleNodesIter.i++), 9));
          cycleSegment = castTo($get_8(segmentList, cycleNode.id_0), 111);
          if (cycleSegment.lastLayer == currentSegment.lastLayer && cycleSegment.indexInLastLayer < currentSegment.indexInLastLayer) {
            break;
          }
           else {
            cycleSegment = null;
          }
        }
        if (cycleSegment) {
          if (previousNode) {
            $set_3(incomingCountList, currentNode.id_0, valueOf_0(castTo($get_8(incomingCountList, currentNode.id_0), 24).value_0 - 1));
            castTo($get_8(outgoingList, previousNode.id_0), 20).remove_1(currentSegment);
          }
          currentSegment = $split_0(currentSegment, currentNode, nextLinearSegmentID++);
          segmentList.array[segmentList.array.length] = currentSegment;
          $add_11(outgoingList, new ArrayList);
          if (previousNode) {
            castTo($get_8(outgoingList, previousNode.id_0), 20).add_1(currentSegment);
            $add_11(incomingCountList, valueOf_0(1));
          }
           else {
            $add_11(incomingCountList, valueOf_0(0));
          }
        }
      }
      nextNode = null;
      if (nodeIter.i < nodeIter.this$01.array.length) {
        nextNode = castTo($next_8(nodeIter), 9);
        nextSegment = castTo($get_8(segmentList, nextNode.id_0), 111);
        castTo($get_8(outgoingList, currentNode.id_0), 20).add_1(nextSegment);
        $set_3(incomingCountList, nextNode.id_0, valueOf_0(castTo($get_8(incomingCountList, nextNode.id_0), 24).value_0 + 1));
      }
      currentSegment.lastLayer = layerIndex;
      currentSegment.indexInLastLayer = indexInLayer++;
      previousNode = currentNode;
      currentNode = nextNode;
    }
    ++layerIndex;
  }
  unsafeCast(checkNotNull_1(castToBoolean($getProperty(layeredGraph, ($clinit_LayoutOptions() , DEBUG_MODE))))) && undefined;
}

function $createUnbalancedPlacement(this$static, layeredGraph){
  var layer, layerIndex, node, node$iterator, node$iterator0, nodeCount, nodeType, recentNodeType, segment, segment$array, segment$index, segment$max, spacing, uppermostPlace;
  nodeCount = initUnidimensionalArray(I_classLit, $intern_37, 26, layeredGraph.layers.array.length, 12, 1);
  recentNodeType = initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LNode$NodeType_2_classLit, $intern_13, 132, layeredGraph.layers.array.length, 0, 1);
  for (segment$array = this$static.linearSegments , segment$index = 0 , segment$max = segment$array.length; segment$index < segment$max; ++segment$index) {
    segment = segment$array[segment$index];
    uppermostPlace = 0;
    for (node$iterator0 = new ArrayList$1(segment.nodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
      node = castTo($next_8(node$iterator0), 9);
      nodeType = node.type_0;
      layerIndex = $getIndex_0(node.layer);
      ++nodeCount[layerIndex];
      spacing = this$static.spacings.edgeEdgeSpacing * this$static.spacings.inLayerSpacingFactor;
      nodeCount[layerIndex] > 0 && !!recentNodeType[layerIndex] && (spacing = $getVerticalSpacing(this$static.spacings, recentNodeType[layerIndex], nodeType));
      uppermostPlace = max_1(uppermostPlace, node.layer.size_0.y_0 + spacing);
    }
    for (node$iterator = new ArrayList$1(segment.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      node.pos.y_0 = uppermostPlace + node.margin.top_0;
      layer = node.layer;
      layer.size_0.y_0 = uppermostPlace + node.margin.top_0 + node.size_0.y_0 + node.margin.bottom;
      recentNodeType[$indexOf_0(layer.owner.layers, layer, 0)] = node.type_0;
    }
  }
}

function $fillSegment(this$static, node, segment){
  var edgesIter, nodeType, sourcePort, sourcePort$iterator, targetNode, targetNodeType, targetPort, targetPort$iterator;
  nodeType = node.type_0;
  unsafeCast(checkNotNull_1(castToBoolean($getProperty(node, ($clinit_InternalProperties() , BIG_NODE_INITIAL))))) && (nodeType = ($clinit_LNode$NodeType() , BIG_NODE));
  if (node.id_0 >= 0) {
    return false;
  }
   else if (!!segment.nodeType && nodeType == ($clinit_LNode$NodeType() , BIG_NODE) && nodeType != segment.nodeType) {
    return false;
  }
   else {
    node.id_0 = segment.id_0;
    $add_11(segment.nodes, node);
  }
  segment.nodeType = nodeType;
  if (nodeType == ($clinit_LNode$NodeType() , LONG_EDGE) || nodeType == NORTH_SOUTH_PORT || nodeType == BIG_NODE) {
    for (sourcePort$iterator = new ArrayList$1(node.ports); sourcePort$iterator.i < sourcePort$iterator.this$01.array.length;) {
      sourcePort = castTo($next_8(sourcePort$iterator), 7);
      for (targetPort$iterator = (edgesIter = new ArrayList$1((new LPort$8(sourcePort)).this$01.outgoingEdges) , new LPort$8$1(edgesIter)); $hasNext_3(targetPort$iterator.val$edgesIter2);) {
        targetPort = castTo($next_8(targetPort$iterator.val$edgesIter2), 12).target;
        targetNode = targetPort.owner;
        targetNodeType = targetNode.type_0;
        if (node.layer != targetNode.layer) {
          if (nodeType == BIG_NODE) {
            if (targetNodeType == BIG_NODE) {
              if ($fillSegment(this$static, targetNode, segment)) {
                return true;
              }
            }
          }
           else {
            if (targetNodeType == LONG_EDGE || targetNodeType == NORTH_SOUTH_PORT) {
              if ($fillSegment(this$static, targetNode, segment)) {
                return true;
              }
            }
          }
        }
      }
    }
  }
  return true;
}

function $mergeRegions(this$static, layeredGraph){
  var changed, layer, layer$iterator, node1, node1Extent, node2, node2Extent, nodeIter, region1, region2, spacing, threshold, weightSum;
  changed = false;
  threshold = $intern_39 * this$static.spacings.nodeSpacing * this$static.spacings.inLayerSpacingFactor;
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator), 16);
    nodeIter = new ArrayList$1(layer.nodes);
    node1 = castTo($next_8(nodeIter), 9);
    region1 = $region(this$static.linearSegments[node1.id_0]);
    while (nodeIter.i < nodeIter.this$01.array.length) {
      node2 = castTo($next_8(nodeIter), 9);
      region2 = $region(this$static.linearSegments[node2.id_0]);
      if (region1 != region2) {
        spacing = $getVerticalSpacing_0(this$static.spacings, node1, node2);
        node1Extent = node1.pos.y_0 + node1.size_0.y_0 + node1.margin.bottom + region1.deflection + spacing;
        node2Extent = node2.pos.y_0 - node2.margin.top_0 + region2.deflection;
        if (node1Extent > node2Extent + threshold) {
          weightSum = region1.weight + region2.weight;
          region2.deflection = (region2.weight * region2.deflection + region1.weight * region1.deflection) / weightSum;
          region2.weight = weightSum;
          region1.refSegment = region2;
          changed = true;
        }
      }
      node1 = node2;
      region1 = region2;
    }
  }
  return changed;
}

function $postProcess(this$static){
  var d, edge, edge$iterator, firstNode, foundPlace, index_0, lastNode, minDisplacement, minRoomAbove, minRoomBelow, neighbor, node, node$iterator, node$iterator0, pos, roomAbove, roomBelow, segment, segment$array, segment$index, segment$max, source, source$iterator, spacing, target, target$iterator;
  for (segment$array = this$static.linearSegments , segment$index = 0 , segment$max = segment$array.length; segment$index < segment$max; ++segment$index) {
    segment = segment$array[segment$index];
    minRoomAbove = $intern_3;
    minRoomBelow = $intern_3;
    for (node$iterator0 = new ArrayList$1(segment.nodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
      node = castTo($next_8(node$iterator0), 9);
      index_0 = !node.layer?-1:$indexOf_0(node.layer.nodes, node, 0);
      if (index_0 > 0) {
        neighbor = castTo($get_8(node.layer.nodes, index_0 - 1), 9);
        spacing = $getVerticalSpacing_0(this$static.spacings, node, neighbor);
        roomAbove = node.pos.y_0 - node.margin.top_0 - (neighbor.pos.y_0 + neighbor.size_0.y_0 + neighbor.margin.bottom + spacing);
      }
       else {
        roomAbove = node.pos.y_0 - node.margin.top_0;
      }
      minRoomAbove = roomAbove < minRoomAbove?roomAbove:minRoomAbove;
      if (index_0 < node.layer.nodes.array.length - 1) {
        neighbor = castTo($get_8(node.layer.nodes, index_0 + 1), 9);
        spacing = $getVerticalSpacing_0(this$static.spacings, node, neighbor);
        roomBelow = neighbor.pos.y_0 - neighbor.margin.top_0 - (node.pos.y_0 + node.size_0.y_0 + node.margin.bottom + spacing);
      }
       else {
        roomBelow = 2 * node.pos.y_0;
      }
      minRoomBelow = roomBelow < minRoomBelow?roomBelow:minRoomBelow;
    }
    minDisplacement = $intern_3;
    foundPlace = false;
    firstNode = castTo($get_8(segment.nodes, 0), 9);
    for (target$iterator = new ArrayList$1(firstNode.ports); target$iterator.i < target$iterator.this$01.array.length;) {
      target = castTo($next_8(target$iterator), 7);
      pos = firstNode.pos.y_0 + target.pos.y_0 + target.anchor.y_0;
      for (edge$iterator = new ArrayList$1(target.incomingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
        edge = castTo($next_8(edge$iterator), 12);
        source = edge.source;
        d = source.owner.pos.y_0 + source.pos.y_0 + source.anchor.y_0 - pos;
        if ((d <= 0?0 - d:d) < (minDisplacement <= 0?0 - minDisplacement:minDisplacement) && (d <= 0?0 - d:d) < (d < 0?minRoomAbove:minRoomBelow)) {
          minDisplacement = d;
          foundPlace = true;
        }
      }
    }
    lastNode = castTo($get_8(segment.nodes, segment.nodes.array.length - 1), 9);
    for (source$iterator = new ArrayList$1(lastNode.ports); source$iterator.i < source$iterator.this$01.array.length;) {
      source = castTo($next_8(source$iterator), 7);
      pos = lastNode.pos.y_0 + source.pos.y_0 + source.anchor.y_0;
      for (edge$iterator = new ArrayList$1(source.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
        edge = castTo($next_8(edge$iterator), 12);
        target = edge.target;
        d = target.owner.pos.y_0 + target.pos.y_0 + target.anchor.y_0 - pos;
        if ((d <= 0?0 - d:d) < (minDisplacement <= 0?0 - minDisplacement:minDisplacement) && (d <= 0?0 - d:d) < (d < 0?minRoomAbove:minRoomBelow)) {
          minDisplacement = d;
          foundPlace = true;
        }
      }
    }
    if (foundPlace && minDisplacement != 0) {
      for (node$iterator = new ArrayList$1(segment.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
        node = castTo($next_8(node$iterator), 9);
        node.pos.y_0 += minDisplacement;
      }
    }
  }
}

function $sortLinearSegments(this$static, layeredGraph){
  var edge, edge$iterator, edge$iterator0, i, i0, i1, i2, incomingCount, incomingCountList, inprio, layer, layer$iterator, layer$iterator0, ls, newRanks, nextLinearSegmentID, nextRank, noIncoming, node, node$iterator, outgoing, outgoingList, outprio, port, port$iterator, prio, rank, segment, segmentList, segments, target;
  segmentList = new ArrayList;
  for (layer$iterator0 = new ArrayList$1(layeredGraph.layers); layer$iterator0.i < layer$iterator0.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator0), 16);
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      node.id_0 = -1;
      inprio = $intern_8;
      outprio = $intern_8;
      for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
        port = castTo($next_8(port$iterator), 7);
        for (edge$iterator0 = new ArrayList$1(port.incomingEdges); edge$iterator0.i < edge$iterator0.this$01.array.length;) {
          edge = castTo($next_8(edge$iterator0), 12);
          prio = castTo($getProperty(edge, ($clinit_InternalProperties() , PRIORITY_0)), 24).value_0;
          inprio = inprio > prio?inprio:prio;
        }
        for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
          edge = castTo($next_8(edge$iterator), 12);
          prio = castTo($getProperty(edge, ($clinit_InternalProperties() , PRIORITY_0)), 24).value_0;
          outprio = outprio > prio?outprio:prio;
        }
      }
      $setProperty(node, INPUT_PRIO, valueOf_0(inprio));
      $setProperty(node, OUTPUT_PRIO, valueOf_0(outprio));
    }
  }
  nextLinearSegmentID = 0;
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator), 16);
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      if (node.id_0 < 0) {
        segment = new LinearSegmentsNodePlacer$LinearSegment;
        segment.id_0 = nextLinearSegmentID++;
        $fillSegment(this$static, node, segment);
        segmentList.array[segmentList.array.length] = segment;
      }
    }
  }
  outgoingList = newArrayListWithCapacity(segmentList.array.length);
  incomingCountList = newArrayListWithCapacity(segmentList.array.length);
  for (i0 = 0; i0 < segmentList.array.length; i0++) {
    $add_11(outgoingList, new ArrayList);
    $add_11(incomingCountList, valueOf_0(0));
  }
  $createDependencyGraphEdges(layeredGraph, segmentList, outgoingList, incomingCountList);
  segments = castTo($toArray_1(segmentList, initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_p4nodes_LinearSegmentsNodePlacer$LinearSegment_2_classLit, $intern_69, 111, segmentList.array.length, 0, 1)), 624);
  outgoing = castTo($toArray_1(outgoingList, initUnidimensionalArray(Ljava_util_List_2_classLit, {3:1, 5:1, 6:1, 671:1}, 20, outgoingList.array.length, 0, 1)), 671);
  incomingCount = initUnidimensionalArray(I_classLit, $intern_37, 26, incomingCountList.array.length, 12, 1);
  for (i1 = 0; i1 < incomingCount.length; i1++) {
    incomingCount[i1] = (checkCriticalElementIndex(i1, incomingCountList.array.length) , castTo(incomingCountList.array[i1], 24)).value_0;
  }
  nextRank = 0;
  noIncoming = new ArrayList;
  for (i2 = 0; i2 < segments.length; i2++) {
    incomingCount[i2] == 0 && $add_11(noIncoming, segments[i2]);
  }
  newRanks = initUnidimensionalArray(I_classLit, $intern_37, 26, segments.length, 12, 1);
  while (noIncoming.array.length != 0) {
    segment = castTo($remove_6(noIncoming, 0), 111);
    newRanks[segment.id_0] = nextRank++;
    while (!outgoing[segment.id_0].isEmpty()) {
      target = castTo(outgoing[segment.id_0].remove_2(0), 111);
      --incomingCount[target.id_0];
      incomingCount[target.id_0] == 0 && (noIncoming.array[noIncoming.array.length] = target , true);
    }
  }
  this$static.linearSegments = initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_p4nodes_LinearSegmentsNodePlacer$LinearSegment_2_classLit, $intern_69, 111, segments.length, 0, 1);
  for (i = 0; i < segments.length; i++) {
    ls = segments[i];
    rank = newRanks[i];
    this$static.linearSegments[rank] = ls;
    ls.id_0 = rank;
    for (node$iterator = new ArrayList$1(ls.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      node.id_0 = rank;
    }
  }
  return this$static.linearSegments;
}

function LinearSegmentsNodePlacer(){
  $clinit_LinearSegmentsNodePlacer();
}

defineClass(546, 1, $intern_64, LinearSegmentsNodePlacer);
_.getIntermediateProcessingConfiguration = function getIntermediateProcessingConfiguration_7(graph){
  return castTo($getProperty(graph, ($clinit_InternalProperties() , GRAPH_PROPERTIES)), 18).contains(($clinit_GraphProperties() , EXTERNAL_PORTS))?HIERARCHY_PROCESSING_ADDITIONS_0:null;
}
;
_.process = function process_54(layeredGraph, monitor){
  $begin(monitor, 'Linear segments node placement', 1);
  this.spacings = castTo($getProperty(layeredGraph, ($clinit_InternalProperties() , SPACINGS)), 134);
  $sortLinearSegments(this, layeredGraph);
  $createUnbalancedPlacement(this, layeredGraph);
  $balancePlacement(this, layeredGraph);
  $postProcess(this);
  this.linearSegments = null;
  this.spacings = null;
  $done(monitor);
}
;
var HIERARCHY_PROCESSING_ADDITIONS_0, INPUT_PRIO, OUTPUT_PRIO;
var Lde_cau_cs_kieler_klay_layered_p4nodes_LinearSegmentsNodePlacer_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p4nodes', 'LinearSegmentsNodePlacer', 546);
function $compareTo_8(this$static, other){
  return this$static.id_0 - other.id_0;
}

function $region(this$static){
  var seg;
  seg = this$static;
  while (seg.refSegment) {
    seg = seg.refSegment;
  }
  return seg;
}

function $split_0(this$static, node, newId){
  var iterator, movedNode, newSegment, nodeIndex;
  nodeIndex = $indexOf_0(this$static.nodes, node, 0);
  newSegment = new LinearSegmentsNodePlacer$LinearSegment;
  newSegment.id_0 = newId;
  iterator = new AbstractList$ListIteratorImpl(this$static.nodes, nodeIndex);
  while (iterator.i < iterator.this$01_0.size_1()) {
    movedNode = (checkCriticalElement(iterator.i < iterator.this$01_0.size_1()) , castTo(iterator.this$01_0.get_2(iterator.last = iterator.i++), 9));
    movedNode.id_0 = newId;
    $add_11(newSegment.nodes, movedNode);
    $remove_11(iterator);
  }
  return newSegment;
}

function LinearSegmentsNodePlacer$LinearSegment(){
  this.nodes = new ArrayList;
}

defineClass(111, 1, {111:1, 23:1}, LinearSegmentsNodePlacer$LinearSegment);
_.compareTo = function compareTo_10(other){
  return $compareTo_8(this, castTo(other, 111));
}
;
_.equals = function equals_36(object){
  var other;
  if (instanceOf(object, 111)) {
    other = castTo(object, 111);
    return this.id_0 == other.id_0;
  }
  return false;
}
;
_.hashCode_0 = function hashCode_36(){
  return this.id_0;
}
;
_.toString_0 = function toString_64(){
  return 'ls' + $toString_5(this.nodes);
}
;
_.deflection = 0;
_.id_0 = 0;
_.indexInLastLayer = -1;
_.lastLayer = -1;
_.weight = 0;
var Lde_cau_cs_kieler_klay_layered_p4nodes_LinearSegmentsNodePlacer$LinearSegment_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p4nodes', 'LinearSegmentsNodePlacer/LinearSegment', 111);
function $clinit_NetworkSimplexPlacer(){
  $clinit_NetworkSimplexPlacer = emptyMethod;
  HIERARCHY_PROCESSING_ADDITIONS_1 = $addBeforePhase5(new IntermediateProcessingConfiguration, ($clinit_IntermediateProcessorStrategy() , HIERARCHICAL_PORT_POSITION_PROCESSOR));
}

function $getEdgeWeight(edge){
  var edgeTypeWeight, priority;
  priority = max_3(1, castTo($getProperty(edge, ($clinit_InternalProperties() , PRIORITY_0)), 24).value_0);
  edge.source.owner.type_0 == ($clinit_LNode$NodeType() , NORMAL) && edge.target.owner.type_0 == NORMAL?(edgeTypeWeight = 1):edge.source.owner.type_0 == NORMAL || edge.target.owner.type_0 == NORMAL?(edgeTypeWeight = 2):(edgeTypeWeight = 8);
  return priority * edgeTypeWeight;
}

function NetworkSimplexPlacer(){
  $clinit_NetworkSimplexPlacer();
}

defineClass(548, 1, $intern_64, NetworkSimplexPlacer);
_.getIntermediateProcessingConfiguration = function getIntermediateProcessingConfiguration_8(graph){
  return castTo($getProperty(graph, ($clinit_InternalProperties() , GRAPH_PROPERTIES)), 18).contains(($clinit_GraphProperties() , EXTERNAL_PORTS))?HIERARCHY_PROCESSING_ADDITIONS_1:null;
}
;
_.process = function process_55(layeredGraph, progressMonitor){
  var delta, dummy, graph, iterLimit, l, l$iterator, l$iterator0, l$iterator1, lEdge, lEdge$iterator, lNode, lNode$iterator, leftEdge, n, n$iterator, nEdge, nNode, nodeCnt, nodeMap, offset, p, p$iterator, portOffset, prev, prevL, rightEdge, sourceY, spacings, targetY, y_0;
  spacings = castTo($getProperty(layeredGraph, ($clinit_InternalProperties() , SPACINGS)), 134);
  nodeMap = ($clinit_Maps() , new HashMap);
  nodeCnt = 0;
  graph = new NGraph;
  for (l$iterator0 = new ArrayList$1(layeredGraph.layers); l$iterator0.i < l$iterator0.this$01.array.length;) {
    l = castTo($next_8(l$iterator0), 16);
    prevL = null;
    prev = null;
    for (lNode$iterator = new ArrayList$1(l.nodes); lNode$iterator.i < lNode$iterator.this$01.array.length;) {
      lNode = castTo($next_8(lNode$iterator), 9);
      ++nodeCnt;
      nNode = $create_1(new NNode$NNodeBuilder, graph);
      nNode.origin = lNode;
      $put_5(nodeMap.hashCodeMap, lNode, nNode);
      lNode.margin.top_0 = ceil_0(lNode.margin.top_0);
      if (prev) {
        nEdge = new NEdge;
        nEdge.weight = 0;
        nEdge.delta = round_int(floor_0(prevL.margin.top_0 + prevL.size_0.y_0 + prevL.margin.bottom + $getVerticalSpacing_0(spacings, castTo(prev.origin, 9), lNode)));
        nEdge.source = prev;
        nEdge.target = nNode;
        $add_14(prev.outgoingEdges, nEdge);
        $add_14(nNode.incomingEdges, nEdge);
      }
      prevL = lNode;
      prev = nNode;
    }
  }
  for (l$iterator1 = new ArrayList$1(layeredGraph.layers); l$iterator1.i < l$iterator1.this$01.array.length;) {
    l = castTo($next_8(l$iterator1), 16);
    for (lNode$iterator = new ArrayList$1(l.nodes); lNode$iterator.i < lNode$iterator.this$01.array.length;) {
      lNode = castTo($next_8(lNode$iterator), 9);
      for (p$iterator = new ArrayList$1(lNode.ports); p$iterator.i < p$iterator.this$01.array.length;) {
        p = castTo($next_8(p$iterator), 7);
        y_0 = p.pos.y_0 + p.anchor.y_0;
        if (y_0 != Math.floor(y_0)) {
          offset = y_0 - toDouble_0(fromDouble_0(Math.round(y_0)));
          p.pos.y_0 -= offset;
        }
      }
    }
  }
  for (l$iterator = new ArrayList$1(layeredGraph.layers); l$iterator.i < l$iterator.this$01.array.length;) {
    l = castTo($next_8(l$iterator), 16);
    for (lNode$iterator = new ArrayList$1(l.nodes); lNode$iterator.i < lNode$iterator.this$01.array.length;) {
      lNode = castTo($next_8(lNode$iterator), 9);
      for (lEdge$iterator = $iterator($getOutgoingEdges_0(lNode)); $hasNext_0(lEdge$iterator);) {
        lEdge = castTo($next_2(lEdge$iterator), 12);
        if ($isSelfLoop(lEdge)) {
          continue;
        }
        if (lEdge.target.owner.layer == l) {
          continue;
        }
        sourceY = lEdge.source.owner.margin.top_0 + lEdge.source.pos.y_0 + lEdge.source.anchor.y_0;
        targetY = lEdge.target.owner.margin.top_0 + lEdge.target.pos.y_0 + lEdge.target.anchor.y_0;
        delta = targetY - sourceY;
        portOffset = round_int(delta);
        dummy = $create_1(new NNode$NNodeBuilder, graph);
        leftEdge = new NEdge;
        leftEdge.weight = $getEdgeWeight(lEdge);
        leftEdge.delta = portOffset > 0?portOffset:0;
        leftEdge.source = dummy;
        leftEdge.target = castTo($get_9(nodeMap, lEdge.source.owner), 61);
        $add_14(leftEdge.source.outgoingEdges, leftEdge);
        $add_14(leftEdge.target.incomingEdges, leftEdge);
        rightEdge = new NEdge;
        rightEdge.weight = $getEdgeWeight(lEdge);
        rightEdge.delta = portOffset < 0?-portOffset:0;
        rightEdge.source = dummy;
        rightEdge.target = castTo($get_9(nodeMap, lEdge.target.owner), 61);
        $add_14(rightEdge.source.outgoingEdges, rightEdge);
        $add_14(rightEdge.target.incomingEdges, rightEdge);
      }
    }
  }
  iterLimit = castTo($getProperty(layeredGraph, ($clinit_Properties() , THOROUGHNESS)), 24).value_0 * round_int(Math.sqrt(nodeCnt));
  $execute($withBalancing($withIterationLimit(forGraph(graph), iterLimit), false), $subTask(progressMonitor, 1));
  for (n$iterator = new ArrayList$1(graph.nodes); n$iterator.i < n$iterator.this$01.array.length;) {
    n = castTo($next_8(n$iterator), 61);
    if (n.origin != null) {
      lNode = castTo(n.origin, 9);
      lNode.pos.y_0 = n.layer + lNode.margin.top_0;
    }
  }
}
;
var HIERARCHY_PROCESSING_ADDITIONS_1;
var Lde_cau_cs_kieler_klay_layered_p4nodes_NetworkSimplexPlacer_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p4nodes', 'NetworkSimplexPlacer', 548);
function $clinit_NodePlacementStrategy(){
  $clinit_NodePlacementStrategy = emptyMethod;
  SIMPLE = new NodePlacementStrategy('SIMPLE', 0);
  INTERACTIVE_3 = new NodePlacementStrategy('INTERACTIVE', 1);
  LINEAR_SEGMENTS = new NodePlacementStrategy('LINEAR_SEGMENTS', 2);
  BRANDES_KOEPF = new NodePlacementStrategy('BRANDES_KOEPF', 3);
  NETWORK_SIMPLEX_0 = new NodePlacementStrategy('NETWORK_SIMPLEX', 4);
}

function NodePlacementStrategy(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function values_40(){
  $clinit_NodePlacementStrategy();
  return stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_p4nodes_NodePlacementStrategy_2_classLit, 1), $intern_13, 141, 0, [SIMPLE, INTERACTIVE_3, LINEAR_SEGMENTS, BRANDES_KOEPF, NETWORK_SIMPLEX_0]);
}

defineClass(141, 17, {180:1, 141:1, 3:1, 23:1, 17:1}, NodePlacementStrategy);
_.create_0 = function create_4(){
  switch (this.ordinal) {
    case 0:
      return new SimpleNodePlacer;
    case 1:
      return new InteractiveNodePlacer;
    case 2:
      return new LinearSegmentsNodePlacer;
    case 3:
      return new BKNodePlacer;
    case 4:
      return new NetworkSimplexPlacer;
    default:throw new IllegalArgumentException_0('No implementation is available for the node placer ' + (this.name_0 != null?this.name_0:'' + this.ordinal));
  }
}
;
var BRANDES_KOEPF, INTERACTIVE_3, LINEAR_SEGMENTS, NETWORK_SIMPLEX_0, SIMPLE;
var Lde_cau_cs_kieler_klay_layered_p4nodes_NodePlacementStrategy_2_classLit = createForEnum('de.cau.cs.kieler.klay.layered.p4nodes', 'NodePlacementStrategy', 141, Ljava_lang_Enum_2_classLit, values_40);
function $clinit_NodePlacementStrategy$Map(){
  $clinit_NodePlacementStrategy$Map = emptyMethod;
  $MAP_18 = createValueOfMap(($clinit_NodePlacementStrategy() , stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_p4nodes_NodePlacementStrategy_2_classLit, 1), $intern_13, 141, 0, [SIMPLE, INTERACTIVE_3, LINEAR_SEGMENTS, BRANDES_KOEPF, NETWORK_SIMPLEX_0])));
}

var $MAP_18;
function $clinit_SimpleNodePlacer(){
  $clinit_SimpleNodePlacer = emptyMethod;
  HIERARCHY_PROCESSING_ADDITIONS_2 = $addBeforePhase5(new IntermediateProcessingConfiguration, ($clinit_IntermediateProcessorStrategy() , HIERARCHICAL_PORT_POSITION_PROCESSOR));
}

function SimpleNodePlacer(){
  $clinit_SimpleNodePlacer();
}

defineClass(544, 1, $intern_64, SimpleNodePlacer);
_.getIntermediateProcessingConfiguration = function getIntermediateProcessingConfiguration_9(graph){
  return castTo($getProperty(graph, ($clinit_InternalProperties() , GRAPH_PROPERTIES)), 18).contains(($clinit_GraphProperties() , EXTERNAL_PORTS))?HIERARCHY_PROCESSING_ADDITIONS_2:null;
}
;
_.process = function process_56(layeredGraph, monitor){
  var lastNode, layer, layer$iterator, layer$iterator0, layerSize, maxHeight, node, node$iterator, pos, spacings;
  $begin(monitor, 'Simple node placement', 1);
  spacings = castTo($getProperty(layeredGraph, ($clinit_InternalProperties() , SPACINGS)), 134);
  maxHeight = 0;
  for (layer$iterator0 = new ArrayList$1(layeredGraph.layers); layer$iterator0.i < layer$iterator0.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator0), 16);
    layerSize = layer.size_0;
    layerSize.y_0 = 0;
    lastNode = null;
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      !!lastNode && (layerSize.y_0 += $getHorizontalSpacing(spacings, node.type_0, lastNode.type_0) * spacings.inLayerSpacingFactor);
      layerSize.y_0 += node.margin.top_0 + node.size_0.y_0 + node.margin.bottom;
      lastNode = node;
    }
    maxHeight = max_1(maxHeight, layerSize.y_0);
  }
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator), 16);
    layerSize = layer.size_0;
    pos = (maxHeight - layerSize.y_0) / 2;
    lastNode = null;
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      !!lastNode && (pos += $getHorizontalSpacing(spacings, node.type_0, lastNode.type_0) * spacings.inLayerSpacingFactor);
      pos += node.margin.top_0;
      node.pos.y_0 = pos;
      pos += node.size_0.y_0 + node.margin.bottom;
      lastNode = node;
    }
  }
  $done(monitor);
}
;
var HIERARCHY_PROCESSING_ADDITIONS_2;
var Lde_cau_cs_kieler_klay_layered_p4nodes_SimpleNodePlacer_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p4nodes', 'SimpleNodePlacer', 544);
function $calculateDelta(this$static, src_0, tgt){
  var srcPos, tgtPos;
  srcPos = checkNotNull_1(this$static.y_0[src_0.owner.id_0]) + checkNotNull_1(this$static.innerShift[src_0.owner.id_0]) + src_0.pos.y_0 + src_0.anchor.y_0;
  tgtPos = checkNotNull_1(this$static.y_0[tgt.owner.id_0]) + checkNotNull_1(this$static.innerShift[tgt.owner.id_0]) + tgt.pos.y_0 + tgt.anchor.y_0;
  return tgtPos - srcPos;
}

function $checkSpaceAbove(this$static, blockRoot, delta){
  var availableSpace, current, maxYNeighbor, minYCurrent, neighbor, rootNode, rootNode0;
  availableSpace = delta;
  current = blockRoot;
  do {
    current = this$static.align_0[current.id_0];
    minYCurrent = (rootNode0 = this$static.root[current.id_0] , checkNotNull_1(this$static.y_0[rootNode0.id_0]) + checkNotNull_1(this$static.innerShift[current.id_0]) - current.margin.top_0);
    neighbor = $getUpperNeighbor(current, !current.layer?-1:$indexOf_0(current.layer.nodes, current, 0));
    if (neighbor) {
      maxYNeighbor = (rootNode = this$static.root[neighbor.id_0] , checkNotNull_1(this$static.y_0[rootNode.id_0]) + checkNotNull_1(this$static.innerShift[neighbor.id_0]) + neighbor.size_0.y_0 + neighbor.margin.bottom);
      availableSpace = min_1(availableSpace, minYCurrent - (maxYNeighbor + $getVerticalSpacing_0(this$static.spacings, current, neighbor)));
    }
  }
   while (blockRoot != current);
  return availableSpace;
}

function $checkSpaceBelow(this$static, blockRoot, delta){
  var availableSpace, current, maxYCurrent, minYNeighbor, neighbor, rootNode, rootNode0;
  availableSpace = delta;
  current = blockRoot;
  do {
    current = this$static.align_0[current.id_0];
    maxYCurrent = (rootNode0 = this$static.root[current.id_0] , checkNotNull_1(this$static.y_0[rootNode0.id_0]) + checkNotNull_1(this$static.innerShift[current.id_0]) + current.size_0.y_0 + current.margin.bottom);
    neighbor = $getLowerNeighbor(current, !current.layer?-1:$indexOf_0(current.layer.nodes, current, 0));
    if (neighbor) {
      minYNeighbor = (rootNode = this$static.root[neighbor.id_0] , checkNotNull_1(this$static.y_0[rootNode.id_0]) + checkNotNull_1(this$static.innerShift[neighbor.id_0]) - neighbor.margin.top_0);
      availableSpace = min_1(availableSpace, minYNeighbor - (maxYCurrent + $getVerticalSpacing_0(this$static.spacings, current, neighbor)));
    }
  }
   while (blockRoot != current);
  return availableSpace;
}

function $getLowerNeighbor(n, layerIndex){
  var l;
  l = n.layer;
  if (layerIndex < l.nodes.array.length - 1) {
    return castTo($get_8(l.nodes, layerIndex + 1), 9);
  }
  return null;
}

function $getUpperNeighbor(n, layerIndex){
  var l;
  l = n.layer;
  if (layerIndex > 0) {
    return castTo($get_8(l.nodes, layerIndex - 1), 9);
  }
  return null;
}

function $layoutSize(this$static){
  var layer, layer$iterator, max_0, min_0, n, n$iterator, yMax, yMin;
  min_0 = $intern_50;
  max_0 = $intern_51;
  for (layer$iterator = new ArrayList$1(this$static.layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator), 16);
    for (n$iterator = new ArrayList$1(layer.nodes); n$iterator.i < n$iterator.this$01.array.length;) {
      n = castTo($next_8(n$iterator), 9);
      yMin = checkNotNull_1(this$static.y_0[n.id_0]);
      yMax = yMin + checkNotNull_1(this$static.blockSize[this$static.root[n.id_0].id_0]);
      min_0 = min_0 < yMin?min_0:yMin;
      max_0 = max_0 > yMax?max_0:yMax;
    }
  }
  return max_0 - min_0;
}

function $shiftBlock(this$static, rootNode, delta){
  var current, newPos;
  current = rootNode;
  do {
    newPos = checkNotNull_1(this$static.y_0[current.id_0]) + delta;
    this$static.y_0[current.id_0] = newPos;
    current = this$static.align_0[current.id_0];
  }
   while (current != rootNode);
}

function BKAlignedLayout(layeredGraph, nodeCount, vdir, hdir){
  this.layeredGraph = layeredGraph;
  this.spacings = castTo($getProperty(layeredGraph, ($clinit_InternalProperties() , SPACINGS)), 134);
  this.root = initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LNode_2_classLit, $intern_49, 9, nodeCount, 0, 1);
  this.blockSize = initUnidimensionalArray(Ljava_lang_Double_2_classLit, $intern_0, 184, nodeCount, 6, 1);
  this.align_0 = initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LNode_2_classLit, $intern_49, 9, nodeCount, 0, 1);
  this.innerShift = initUnidimensionalArray(Ljava_lang_Double_2_classLit, $intern_0, 184, nodeCount, 6, 1);
  this.sink = initUnidimensionalArray(Lde_cau_cs_kieler_klay_layered_graph_LNode_2_classLit, $intern_49, 9, nodeCount, 0, 1);
  this.shift_0 = initUnidimensionalArray(Ljava_lang_Double_2_classLit, $intern_0, 184, nodeCount, 6, 1);
  this.y_0 = initUnidimensionalArray(Ljava_lang_Double_2_classLit, $intern_0, 184, nodeCount, 6, 1);
  this.vdir = vdir;
  this.hdir = hdir;
}

defineClass(81, 1, {81:1}, BKAlignedLayout);
_.toString_0 = function toString_65(){
  var result;
  result = '';
  this.hdir == ($clinit_BKAlignedLayout$HDirection() , RIGHT_3)?(result += 'RIGHT'):this.hdir == LEFT_3 && (result += 'LEFT');
  this.vdir == ($clinit_BKAlignedLayout$VDirection() , DOWN_0)?(result += 'DOWN'):this.vdir == UP_0?(result += 'UP'):(result += 'BALANCED');
  return result;
}
;
var Lde_cau_cs_kieler_klay_layered_p4nodes_bk_BKAlignedLayout_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p4nodes.bk', 'BKAlignedLayout', 81);
function $clinit_BKAlignedLayout$HDirection(){
  $clinit_BKAlignedLayout$HDirection = emptyMethod;
  RIGHT_3 = new BKAlignedLayout$HDirection('RIGHT', 0);
  LEFT_3 = new BKAlignedLayout$HDirection('LEFT', 1);
}

function BKAlignedLayout$HDirection(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function values_41(){
  $clinit_BKAlignedLayout$HDirection();
  return stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_p4nodes_bk_BKAlignedLayout$HDirection_2_classLit, 1), $intern_13, 248, 0, [RIGHT_3, LEFT_3]);
}

defineClass(248, 17, {248:1, 3:1, 23:1, 17:1}, BKAlignedLayout$HDirection);
var LEFT_3, RIGHT_3;
var Lde_cau_cs_kieler_klay_layered_p4nodes_bk_BKAlignedLayout$HDirection_2_classLit = createForEnum('de.cau.cs.kieler.klay.layered.p4nodes.bk', 'BKAlignedLayout/HDirection', 248, Ljava_lang_Enum_2_classLit, values_41);
function $clinit_BKAlignedLayout$VDirection(){
  $clinit_BKAlignedLayout$VDirection = emptyMethod;
  DOWN_0 = new BKAlignedLayout$VDirection('DOWN', 0);
  UP_0 = new BKAlignedLayout$VDirection('UP', 1);
}

function BKAlignedLayout$VDirection(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function values_42(){
  $clinit_BKAlignedLayout$VDirection();
  return stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_p4nodes_bk_BKAlignedLayout$VDirection_2_classLit, 1), $intern_13, 247, 0, [DOWN_0, UP_0]);
}

defineClass(247, 17, {247:1, 3:1, 23:1, 17:1}, BKAlignedLayout$VDirection);
var DOWN_0, UP_0;
var Lde_cau_cs_kieler_klay_layered_p4nodes_bk_BKAlignedLayout$VDirection_2_classLit = createForEnum('de.cau.cs.kieler.klay.layered.p4nodes.bk', 'BKAlignedLayout/VDirection', 247, Ljava_lang_Enum_2_classLit, values_42);
function $insideBlockShift(bal){
  var blocks, current, edge, entry, next, nextInnerShift, outerIter, portPosDiff, root, root$iterator, spaceAbove, spaceBelow;
  blocks = getBlocks(bal);
  for (root$iterator = (outerIter = (new AbstractMap$1(blocks)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter)); root$iterator.val$outerIter2.hasNext_0();) {
    root = (entry = castTo(root$iterator.val$outerIter2.next_1(), 21) , castTo(entry.getKey(), 9));
    spaceAbove = root.margin.top_0;
    spaceBelow = root.size_0.y_0 + root.margin.bottom;
    bal.innerShift[root.id_0] = 0;
    current = root;
    while ((next = bal.align_0[current.id_0]) != root) {
      edge = getEdge(current, next);
      bal.hdir == ($clinit_BKAlignedLayout$HDirection() , LEFT_3)?(portPosDiff = edge.target.pos.y_0 + edge.target.anchor.y_0 - edge.source.pos.y_0 - edge.source.anchor.y_0):(portPosDiff = edge.source.pos.y_0 + edge.source.anchor.y_0 - edge.target.pos.y_0 - edge.target.anchor.y_0);
      nextInnerShift = checkNotNull_1(bal.innerShift[current.id_0]) + portPosDiff;
      bal.innerShift[next.id_0] = nextInnerShift;
      spaceAbove = max_1(spaceAbove, next.margin.top_0 - nextInnerShift);
      spaceBelow = max_1(spaceBelow, nextInnerShift + next.size_0.y_0 + next.margin.bottom);
      current = next;
    }
    current = root;
    do {
      bal.innerShift[current.id_0] = checkNotNull_1(bal.innerShift[current.id_0]) + spaceAbove;
      current = bal.align_0[current.id_0];
    }
     while (current != root);
    bal.blockSize[root.id_0] = spaceAbove + spaceBelow;
  }
}

function $verticalAlignment(this$static, bal, markedEdges){
  var d, high, layer, layer$iterator, layer$iterator0, layers, low, m, neighbors, nodes, r, u_m, u_m_pair, um, um_pair, v, v$iterator, v_i_k, v_i_k$iterator;
  for (layer$iterator0 = new ArrayList$1(this$static.layeredGraph.layers); layer$iterator0.i < layer$iterator0.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator0), 16);
    for (v$iterator = new ArrayList$1(layer.nodes); v$iterator.i < v$iterator.this$01.array.length;) {
      v = castTo($next_8(v$iterator), 9);
      bal.root[v.id_0] = v;
      bal.align_0[v.id_0] = v;
      bal.innerShift[v.id_0] = 0;
    }
  }
  layers = this$static.layeredGraph.layers;
  bal.hdir == ($clinit_BKAlignedLayout$HDirection() , LEFT_3) && (layers = instanceOf(layers, 89)?$reverse(castTo(layers, 89)):instanceOf(layers, 87)?castTo(layers, 87).forwardList:instanceOf(layers, 67)?new Lists$RandomAccessReverseList(layers):new Lists$ReverseList(layers));
  for (layer$iterator = layers.iterator_0(); layer$iterator.hasNext_0();) {
    layer = castTo(layer$iterator.next_1(), 16);
    r = -1;
    nodes = layer.nodes;
    if (bal.vdir == ($clinit_BKAlignedLayout$VDirection() , UP_0)) {
      r = $intern_3;
      nodes = instanceOf(nodes, 89)?$reverse(castTo(nodes, 89)):instanceOf(nodes, 87)?castTo(nodes, 87).forwardList:instanceOf(nodes, 67)?new Lists$RandomAccessReverseList(nodes):new Lists$ReverseList(nodes);
    }
    for (v_i_k$iterator = nodes.iterator_0(); v_i_k$iterator.hasNext_0();) {
      v_i_k = castTo(v_i_k$iterator.next_1(), 9);
      bal.hdir == LEFT_3?(neighbors = castTo($get_8(this$static.ni.rightNeighbors, v_i_k.id_0), 20)):(neighbors = castTo($get_8(this$static.ni.leftNeighbors, v_i_k.id_0), 20));
      if (neighbors.size_1() > 0) {
        d = neighbors.size_1();
        low = round_int(Math.floor((d + 1) / 2)) - 1;
        high = round_int(Math.ceil((d + 1) / 2)) - 1;
        if (bal.vdir == UP_0) {
          for (m = high; m >= low; m--) {
            if (bal.align_0[v_i_k.id_0] == v_i_k) {
              u_m_pair = castTo(neighbors.get_2(m), 27);
              u_m = castTo(u_m_pair.first, 9);
              if (!$contains_7(markedEdges, u_m_pair.second) && r > this$static.ni.nodeIndex[u_m.id_0]) {
                bal.align_0[u_m.id_0] = v_i_k;
                bal.root[v_i_k.id_0] = bal.root[u_m.id_0];
                bal.align_0[v_i_k.id_0] = bal.root[v_i_k.id_0];
                r = this$static.ni.nodeIndex[u_m.id_0];
              }
            }
          }
        }
         else {
          for (m = low; m <= high; m++) {
            if (bal.align_0[v_i_k.id_0] == v_i_k) {
              um_pair = castTo(neighbors.get_2(m), 27);
              um = castTo(um_pair.first, 9);
              if (!$contains_7(markedEdges, um_pair.second) && r < this$static.ni.nodeIndex[um.id_0]) {
                bal.align_0[um.id_0] = v_i_k;
                bal.root[v_i_k.id_0] = bal.root[um.id_0];
                bal.align_0[v_i_k.id_0] = bal.root[v_i_k.id_0];
                r = this$static.ni.nodeIndex[um.id_0];
              }
            }
          }
        }
      }
    }
  }
}

function BKAligner(layeredGraph, ni){
  this.layeredGraph = layeredGraph;
  this.ni = ni;
}

defineClass(596, 1, {}, BKAligner);
var Lde_cau_cs_kieler_klay_layered_p4nodes_bk_BKAligner_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p4nodes.bk', 'BKAligner', 596);
function $getOrCreateClassNode(this$static, sinkNode){
  var node;
  node = castTo($get_9(this$static.sinkNodes, sinkNode), 200);
  if (!node) {
    node = new BKCompactor$ClassNode;
    node.node = sinkNode;
    $put_2(this$static.sinkNodes, node.node, node);
  }
  return node;
}

function $horizontalCompaction(this$static, bal){
  var layer, layer$iterator, layer$iterator0, layer$iterator1, layers, node, node$iterator, nodes, sinkShift, v, v$iterator;
  for (layer$iterator0 = new ArrayList$1(this$static.layeredGraph.layers); layer$iterator0.i < layer$iterator0.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator0), 16);
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      bal.sink[node.id_0] = node;
      bal.shift_0[node.id_0] = bal.vdir == ($clinit_BKAlignedLayout$VDirection() , UP_0)?$intern_51:$intern_50;
    }
  }
  layers = this$static.layeredGraph.layers;
  bal.hdir == ($clinit_BKAlignedLayout$HDirection() , LEFT_3) && (layers = instanceOf(layers, 89)?$reverse(castTo(layers, 89)):instanceOf(layers, 87)?castTo(layers, 87).forwardList:instanceOf(layers, 67)?new Lists$RandomAccessReverseList(layers):new Lists$ReverseList(layers));
  $init(this$static.threshStrategy, bal, this$static.ni);
  fill_4(bal.y_0);
  for (layer$iterator1 = layers.iterator_0(); layer$iterator1.hasNext_0();) {
    layer = castTo(layer$iterator1.next_1(), 16);
    nodes = layer.nodes;
    bal.vdir == ($clinit_BKAlignedLayout$VDirection() , UP_0) && (nodes = instanceOf(nodes, 89)?$reverse(castTo(nodes, 89)):instanceOf(nodes, 87)?castTo(nodes, 87).forwardList:instanceOf(nodes, 67)?new Lists$RandomAccessReverseList(nodes):new Lists$ReverseList(nodes));
    for (v$iterator = nodes.iterator_0(); v$iterator.hasNext_0();) {
      v = castTo(v$iterator.next_1(), 9);
      bal.root[v.id_0] == v && $placeBlock(this$static, v, bal);
    }
  }
  $placeClasses(this$static, bal);
  for (layer$iterator = layers.iterator_0(); layer$iterator.hasNext_0();) {
    layer = castTo(layer$iterator.next_1(), 16);
    for (v$iterator = new ArrayList$1(layer.nodes); v$iterator.i < v$iterator.this$01.array.length;) {
      v = castTo($next_8(v$iterator), 9);
      bal.y_0[v.id_0] = bal.y_0[bal.root[v.id_0].id_0];
      if (v == bal.root[v.id_0]) {
        sinkShift = checkNotNull_1(bal.shift_0[bal.sink[v.id_0].id_0]);
        (bal.vdir == ($clinit_BKAlignedLayout$VDirection() , UP_0) && sinkShift > $intern_51 || bal.vdir == DOWN_0 && sinkShift < $intern_50) && (bal.y_0[v.id_0] = checkNotNull_1(bal.y_0[v.id_0]) + sinkShift);
      }
    }
  }
  this$static.threshStrategy.postProcess();
}

function $placeBlock(this$static, root, bal){
  var currentBlockPosition, currentIndexInLayer, currentLayerSize, currentNode, currentNodeType, isInitialAssignment, neighbor, neighborNodeType, neighborRoot, neighborSink, newPosition, requiredSpace, sinkNode, spacing, thresh;
  if (bal.y_0[root.id_0] != null) {
    return;
  }
  isInitialAssignment = true;
  bal.y_0[root.id_0] = 0;
  currentNode = root;
  thresh = bal.vdir == ($clinit_BKAlignedLayout$VDirection() , DOWN_0)?$intern_51:$intern_50;
  do {
    currentIndexInLayer = this$static.ni.nodeIndex[currentNode.id_0];
    currentLayerSize = currentNode.layer.nodes.array.length;
    currentNodeType = currentNode.type_0;
    if (bal.vdir == DOWN_0 && currentIndexInLayer > 0 || bal.vdir == UP_0 && currentIndexInLayer < currentLayerSize - 1) {
      bal.vdir == UP_0?(neighbor = castTo($get_8(currentNode.layer.nodes, currentIndexInLayer + 1), 9)):(neighbor = castTo($get_8(currentNode.layer.nodes, currentIndexInLayer - 1), 9));
      neighborRoot = bal.root[neighbor.id_0];
      neighborNodeType = neighbor.type_0;
      $placeBlock(this$static, neighborRoot, bal);
      thresh = this$static.threshStrategy.calculateThreshold(thresh, root, currentNode);
      bal.sink[root.id_0] == root && (bal.sink[root.id_0] = bal.sink[neighborRoot.id_0]);
      if (bal.sink[root.id_0] == bal.sink[neighborRoot.id_0]) {
        spacing = $getVerticalSpacing(this$static.spacings, currentNodeType, neighborNodeType);
        if (bal.vdir == UP_0) {
          currentBlockPosition = checkNotNull_1(bal.y_0[root.id_0]);
          newPosition = checkNotNull_1(bal.y_0[neighborRoot.id_0]) + checkNotNull_1(bal.innerShift[neighbor.id_0]) - neighbor.margin.top_0 - spacing - currentNode.margin.bottom - currentNode.size_0.y_0 - checkNotNull_1(bal.innerShift[currentNode.id_0]);
          if (isInitialAssignment) {
            isInitialAssignment = false;
            bal.y_0[root.id_0] = newPosition < thresh?newPosition:thresh;
          }
           else {
            bal.y_0[root.id_0] = currentBlockPosition < (newPosition < thresh?newPosition:thresh)?currentBlockPosition:newPosition < thresh?newPosition:thresh;
          }
        }
         else {
          currentBlockPosition = checkNotNull_1(bal.y_0[root.id_0]);
          newPosition = checkNotNull_1(bal.y_0[neighborRoot.id_0]) + checkNotNull_1(bal.innerShift[neighbor.id_0]) + neighbor.size_0.y_0 + neighbor.margin.bottom + spacing + currentNode.margin.top_0 - checkNotNull_1(bal.innerShift[currentNode.id_0]);
          if (isInitialAssignment) {
            isInitialAssignment = false;
            bal.y_0[root.id_0] = newPosition > thresh?newPosition:thresh;
          }
           else {
            bal.y_0[root.id_0] = currentBlockPosition > (newPosition > thresh?newPosition:thresh)?currentBlockPosition:newPosition > thresh?newPosition:thresh;
          }
        }
      }
       else {
        spacing = this$static.spacings.nodeSpacing;
        sinkNode = $getOrCreateClassNode(this$static, bal.sink[root.id_0]);
        neighborSink = $getOrCreateClassNode(this$static, bal.sink[neighborRoot.id_0]);
        if (bal.vdir == UP_0) {
          requiredSpace = checkNotNull_1(bal.y_0[root.id_0]) + checkNotNull_1(bal.innerShift[currentNode.id_0]) + currentNode.size_0.y_0 + currentNode.margin.bottom + spacing - (checkNotNull_1(bal.y_0[neighborRoot.id_0]) + checkNotNull_1(bal.innerShift[neighbor.id_0]) - neighbor.margin.top_0);
          $addEdge(sinkNode, neighborSink, requiredSpace);
        }
         else {
          requiredSpace = checkNotNull_1(bal.y_0[root.id_0]) + checkNotNull_1(bal.innerShift[currentNode.id_0]) - currentNode.margin.top_0 - checkNotNull_1(bal.y_0[neighborRoot.id_0]) - checkNotNull_1(bal.innerShift[neighbor.id_0]) - neighbor.size_0.y_0 - neighbor.margin.bottom - spacing;
          $addEdge(sinkNode, neighborSink, requiredSpace);
        }
      }
    }
     else {
      thresh = this$static.threshStrategy.calculateThreshold(thresh, root, currentNode);
    }
    currentNode = bal.align_0[currentNode.id_0];
  }
   while (currentNode != root);
  $finishBlock(this$static.threshStrategy, root);
}

function $placeClasses(this$static, bal){
  var e, e$iterator, entry, n, n$iterator, n$iterator0, outerIter, outerIter0, sinks;
  sinks = new LinkedList;
  for (n$iterator0 = (outerIter0 = (new AbstractMap$2(this$static.sinkNodes)).this$01.entrySet_0().iterator_0() , new AbstractMap$2$1(outerIter0)); n$iterator0.val$outerIter2.hasNext_0();) {
    n = (entry = castTo(n$iterator0.val$outerIter2.next_1(), 21) , castTo(entry.getValue(), 200));
    n.indegree == 0 && ($addNode_0(sinks, n, sinks.tail.prev, sinks.tail) , true);
  }
  while (sinks.size_0 != 0) {
    n = castTo(sinks.size_0 == 0?null:(checkCriticalElement(sinks.size_0 != 0) , $removeNode_0(sinks, sinks.header.next_0)), 200);
    for (e$iterator = new ArrayList$1(n.outgoing); e$iterator.i < e$iterator.this$01.array.length;) {
      e = castTo($next_8(e$iterator), 279);
      bal.vdir == ($clinit_BKAlignedLayout$VDirection() , DOWN_0)?(e.target.classShift = min_1(e.target.classShift, n.classShift + e.separation)):(e.target.classShift = max_1(e.target.classShift, n.classShift + e.separation));
      --e.target.indegree;
      e.target.indegree == 0 && $add_8(sinks, e.target);
    }
  }
  for (n$iterator = (outerIter = (new AbstractMap$2(this$static.sinkNodes)).this$01.entrySet_0().iterator_0() , new AbstractMap$2$1(outerIter)); n$iterator.val$outerIter2.hasNext_0();) {
    n = (entry = castTo(n$iterator.val$outerIter2.next_1(), 21) , castTo(entry.getValue(), 200));
    bal.shift_0[n.node.id_0] = n.classShift;
  }
}

function BKCompactor(layeredGraph, ni){
  this.sinkNodes = ($clinit_Maps() , new HashMap);
  this.layeredGraph = layeredGraph;
  this.ni = ni;
  this.spacings = castTo($getProperty(layeredGraph, ($clinit_InternalProperties() , SPACINGS)), 134);
  maskUndefined($getProperty(layeredGraph, ($clinit_Properties() , COMPACTION_STRATEGY))) === maskUndefined(($clinit_CompactionStrategy() , IMPROVE_STRAIGHTNESS))?(this.threshStrategy = new ThresholdStrategy$SimpleThresholdStrategy):(this.threshStrategy = new ThresholdStrategy$NullThresholdStrategy);
}

defineClass(599, 1, {}, BKCompactor);
var Lde_cau_cs_kieler_klay_layered_p4nodes_bk_BKCompactor_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p4nodes.bk', 'BKCompactor', 599);
function BKCompactor$ClassEdge(){
}

defineClass(279, 1, {279:1}, BKCompactor$ClassEdge);
_.separation = 0;
var Lde_cau_cs_kieler_klay_layered_p4nodes_bk_BKCompactor$ClassEdge_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p4nodes.bk', 'BKCompactor/ClassEdge', 279);
function $addEdge(this$static, target, separation){
  var se;
  se = new BKCompactor$ClassEdge;
  se.target = target;
  se.separation = separation;
  ++target.indegree;
  $add_11(this$static.outgoing, se);
}

function BKCompactor$ClassNode(){
  this.outgoing = new ArrayList;
}

defineClass(200, 1, {200:1}, BKCompactor$ClassNode);
_.classShift = 0;
_.indegree = 0;
var Lde_cau_cs_kieler_klay_layered_p4nodes_bk_BKCompactor$ClassNode_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p4nodes.bk', 'BKCompactor/ClassNode', 200);
function $clinit_BKNodePlacer(){
  $clinit_BKNodePlacer = emptyMethod;
  HIERARCHY_PROCESSING_ADDITIONS_3 = $addBeforePhase5(new IntermediateProcessingConfiguration, ($clinit_IntermediateProcessorStrategy() , HIERARCHICAL_PORT_POSITION_PROCESSOR));
}

function $checkOrderConstraint(this$static, layeredGraph, bal){
  var bottom, feasible, layer, layer$iterator, node, node$iterator, pos, top_0;
  feasible = true;
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator), 16);
    pos = $intern_51;
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      top_0 = checkNotNull_1(bal.y_0[node.id_0]) + checkNotNull_1(bal.innerShift[node.id_0]) - node.margin.top_0;
      bottom = checkNotNull_1(bal.y_0[node.id_0]) + checkNotNull_1(bal.innerShift[node.id_0]) + node.size_0.y_0 + node.margin.bottom;
      if (top_0 > pos && bottom > pos) {
        pos = checkNotNull_1(bal.y_0[node.id_0]) + checkNotNull_1(bal.innerShift[node.id_0]) + node.size_0.y_0 + node.margin.bottom;
      }
       else {
        feasible = false;
        this$static.debugMode && ($clinit_System() , out_0);
        break;
      }
    }
    if (!feasible) {
      break;
    }
  }
  this$static.debugMode && ($clinit_System() , out_0);
  return feasible;
}

function $createBalancedLayout(this$static, layouts, nodeCount){
  var bal, balanced, calculatedYs, i, i0, i1, i2, l, l$iterator, layer, layer$iterator, max_0, min_0, minWidthLayout, n, n$iterator, noOfLayouts, node, node$iterator, nodePosY, shift_0, width_0;
  noOfLayouts = layouts.array.length;
  balanced = new BKAlignedLayout(this$static.lGraph, nodeCount, null, null);
  width_0 = initUnidimensionalArray(D_classLit, $intern_11, 26, noOfLayouts, 12, 1);
  min_0 = initUnidimensionalArray(D_classLit, $intern_11, 26, noOfLayouts, 12, 1);
  max_0 = initUnidimensionalArray(D_classLit, $intern_11, 26, noOfLayouts, 12, 1);
  minWidthLayout = 0;
  for (i0 = 0; i0 < noOfLayouts; i0++) {
    min_0[i0] = $intern_3;
    max_0[i0] = $intern_8;
  }
  for (i1 = 0; i1 < noOfLayouts; i1++) {
    bal = (checkCriticalElementIndex(i1, layouts.array.length) , castTo(layouts.array[i1], 81));
    width_0[i1] = $layoutSize(bal);
    width_0[minWidthLayout] > width_0[i1] && (minWidthLayout = i1);
    for (l$iterator = new ArrayList$1(this$static.lGraph.layers); l$iterator.i < l$iterator.this$01.array.length;) {
      l = castTo($next_8(l$iterator), 16);
      for (n$iterator = new ArrayList$1(l.nodes); n$iterator.i < n$iterator.this$01.array.length;) {
        n = castTo($next_8(n$iterator), 9);
        nodePosY = checkNotNull_1(bal.y_0[n.id_0]) + checkNotNull_1(bal.innerShift[n.id_0]);
        min_0[i1] = min_0[i1] < nodePosY?min_0[i1]:nodePosY;
        max_0[i1] = max_1(max_0[i1], nodePosY + n.size_0.y_0);
      }
    }
  }
  shift_0 = initUnidimensionalArray(D_classLit, $intern_11, 26, noOfLayouts, 12, 1);
  for (i2 = 0; i2 < noOfLayouts; i2++) {
    (checkCriticalElementIndex(i2, layouts.array.length) , castTo(layouts.array[i2], 81)).vdir == ($clinit_BKAlignedLayout$VDirection() , DOWN_0)?(shift_0[i2] = min_0[minWidthLayout] - min_0[i2]):(shift_0[i2] = max_0[minWidthLayout] - max_0[i2]);
  }
  calculatedYs = initUnidimensionalArray(D_classLit, $intern_11, 26, noOfLayouts, 12, 1);
  for (layer$iterator = new ArrayList$1(this$static.lGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator), 16);
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      for (i = 0; i < noOfLayouts; i++) {
        calculatedYs[i] = checkNotNull_1((checkCriticalElementIndex(i, layouts.array.length) , castTo(layouts.array[i], 81)).y_0[node.id_0]) + checkNotNull_1((checkCriticalElementIndex(i, layouts.array.length) , castTo(layouts.array[i], 81)).innerShift[node.id_0]) + shift_0[i];
      }
      nativeNumberSort(calculatedYs);
      balanced.y_0[node.id_0] = (calculatedYs[1] + calculatedYs[2]) / 2;
      balanced.innerShift[node.id_0] = 0;
    }
  }
  return balanced;
}

function $incidentToInnerSegment(this$static, node, layer1, layer2){
  var edge, edge$iterator, source, sourceNodeType;
  if (node.type_0 == ($clinit_LNode$NodeType() , BIG_NODE)) {
    for (edge$iterator = $iterator($getIncomingEdges_0(node)); $hasNext_0(edge$iterator);) {
      edge = castTo($next_2(edge$iterator), 12);
      source = edge.source.owner;
      if ((source.type_0 == BIG_NODE || unsafeCast(checkNotNull_1(castToBoolean($getProperty(source, ($clinit_InternalProperties() , BIG_NODE_INITIAL)))))) && this$static.ni.layerIndex[edge.source.owner.layer.id_0] == layer2 && this$static.ni.layerIndex[node.layer.id_0] == layer1) {
        return true;
      }
    }
  }
  if (node.type_0 == LONG_EDGE) {
    for (edge$iterator = $iterator($getIncomingEdges_0(node)); $hasNext_0(edge$iterator);) {
      edge = castTo($next_2(edge$iterator), 12);
      sourceNodeType = edge.source.owner.type_0;
      if (sourceNodeType == LONG_EDGE && this$static.ni.layerIndex[edge.source.owner.layer.id_0] == layer2 && this$static.ni.layerIndex[node.layer.id_0] == layer1) {
        return true;
      }
    }
  }
  return false;
}

function $markConflicts(this$static, layeredGraph){
  var currentLayer, i, k, k_0, k_1, l, l_1, layer, layer$iterator, layerIndex, layerIterator, layerSize, nodeIterator, numberOfLayers, upperNeighbor, upperNeighbor$iterator, v_l, v_l_i;
  numberOfLayers = layeredGraph.layers.array.length;
  if (numberOfLayers < 3) {
    return;
  }
  layerSize = initUnidimensionalArray(I_classLit, $intern_37, 26, numberOfLayers, 12, 1);
  layerIndex = 0;
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator), 16);
    layerSize[layerIndex++] = layer.nodes.array.length;
  }
  layerIterator = new AbstractList$ListIteratorImpl(layeredGraph.layers, 2);
  for (i = 1; i < numberOfLayers - 1; i++) {
    currentLayer = (checkCriticalElement(layerIterator.i < layerIterator.this$01_0.size_1()) , castTo(layerIterator.this$01_0.get_2(layerIterator.last = layerIterator.i++), 16));
    nodeIterator = new ArrayList$1(currentLayer.nodes);
    k_0 = 0;
    l = 0;
    for (l_1 = 0; l_1 < layerSize[i + 1]; l_1++) {
      v_l_i = castTo($next_8(nodeIterator), 9);
      if (l_1 == layerSize[i + 1] - 1 || $incidentToInnerSegment(this$static, v_l_i, i + 1, i)) {
        k_1 = layerSize[i] - 1;
        $incidentToInnerSegment(this$static, v_l_i, i + 1, i) && (k_1 = this$static.ni.nodeIndex[castTo(castTo(castTo($get_8(this$static.ni.leftNeighbors, v_l_i.id_0), 20).get_2(0), 27).first, 9).id_0]);
        while (l <= l_1) {
          v_l = castTo($get_8(currentLayer.nodes, l), 9);
          if (!$incidentToInnerSegment(this$static, v_l, i + 1, i)) {
            for (upperNeighbor$iterator = castTo($get_8(this$static.ni.leftNeighbors, v_l.id_0), 20).iterator_0(); upperNeighbor$iterator.hasNext_0();) {
              upperNeighbor = castTo(upperNeighbor$iterator.next_1(), 27);
              k = this$static.ni.nodeIndex[castTo(upperNeighbor.first, 9).id_0];
              (k < k_0 || k > k_1) && $add_18(this$static.markedEdges, castTo(upperNeighbor.second, 12));
            }
          }
          ++l;
        }
        k_0 = k_1;
      }
    }
  }
}

function BKNodePlacer(){
  $clinit_BKNodePlacer();
  this.markedEdges = new HashSet;
}

function getBlocks(bal){
  $clinit_BKNodePlacer();
  var blockContents, blocks, layer, layer$iterator, node, node$iterator, root;
  blocks = ($clinit_Maps() , new LinkedHashMap);
  for (layer$iterator = new ArrayList$1(bal.layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator), 16);
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      root = bal.root[node.id_0];
      blockContents = castTo($get_15(blocks, root), 20);
      if (!blockContents) {
        blockContents = new ArrayList;
        $put_7(blocks, root, blockContents);
      }
      blockContents.add_1(node);
    }
  }
  return blocks;
}

function getClasses(bal){
  var classContents, classes, entry, outerIter, root, root$iterator, roots, sink;
  classes = ($clinit_Maps() , new LinkedHashMap);
  roots = new LinkedHashSet_1(($clinit_Collections2() , new Arrays$ArrayList(bal.root)));
  for (root$iterator = (outerIter = (new AbstractMap$1(roots.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter)); root$iterator.val$outerIter2.hasNext_0();) {
    root = (entry = castTo(root$iterator.val$outerIter2.next_1(), 21) , castTo(entry.getKey(), 9));
    if (!root) {
      $clinit_System();
      break;
    }
    sink = bal.sink[root.id_0];
    classContents = castTo($get_15(classes, sink), 20);
    if (!classContents) {
      classContents = new ArrayList;
      $put_7(classes, sink, classContents);
    }
    classContents.add_1(root);
  }
  return classes;
}

function getEdge(source, target){
  $clinit_BKNodePlacer();
  var edge, edge$iterator;
  for (edge$iterator = $iterator($getConnectedEdges(source)); $hasNext_0(edge$iterator);) {
    edge = castTo($next_2(edge$iterator), 12);
    if (edge.target.owner == target || edge.source.owner == target) {
      return edge;
    }
  }
  return null;
}

defineClass(547, 1, $intern_64, BKNodePlacer);
_.getIntermediateProcessingConfiguration = function getIntermediateProcessingConfiguration_10(graph){
  return castTo($getProperty(graph, ($clinit_InternalProperties() , GRAPH_PROPERTIES)), 18).contains(($clinit_GraphProperties() , EXTERNAL_PORTS))?HIERARCHY_PROCESSING_ADDITIONS_3:null;
}
;
_.process = function process_57(layeredGraph, monitor){
  var aligner, bal, bal$iterator, bal$iterator0, bal$iterator1, bal$iterator2, balanced, chosenLayout, compacter, layer, layer$iterator, layouts, leftdown, leftup, node, node$iterator, rightdown, rightup;
  $begin(monitor, 'Brandes & Koepf node placement', 1);
  this.lGraph = layeredGraph;
  this.ni = buildFor(layeredGraph);
  this.debugMode = unsafeCast(checkNotNull_1(castToBoolean($getProperty(layeredGraph, ($clinit_Properties() , DEBUG_MODE_0)))));
  this.produceBalancedLayout = maskUndefined($getProperty(layeredGraph, FIXED_ALIGNMENT)) === maskUndefined(($clinit_FixedAlignment() , BALANCED));
  $markConflicts(this, layeredGraph);
  layouts = (checkNonnegative(4, 'initialArraySize') , new ArrayList_0(4));
  switch (castTo($getProperty(layeredGraph, FIXED_ALIGNMENT), 124).ordinal) {
    case 3:
      leftdown = new BKAlignedLayout(layeredGraph, this.ni.nodeCount, ($clinit_BKAlignedLayout$VDirection() , DOWN_0), ($clinit_BKAlignedLayout$HDirection() , LEFT_3));
      layouts.array[layouts.array.length] = leftdown;
      break;
    case 1:
      leftup = new BKAlignedLayout(layeredGraph, this.ni.nodeCount, ($clinit_BKAlignedLayout$VDirection() , UP_0), ($clinit_BKAlignedLayout$HDirection() , LEFT_3));
      layouts.array[layouts.array.length] = leftup;
      break;
    case 4:
      rightdown = new BKAlignedLayout(layeredGraph, this.ni.nodeCount, ($clinit_BKAlignedLayout$VDirection() , DOWN_0), ($clinit_BKAlignedLayout$HDirection() , RIGHT_3));
      layouts.array[layouts.array.length] = rightdown;
      break;
    case 2:
      rightup = new BKAlignedLayout(layeredGraph, this.ni.nodeCount, ($clinit_BKAlignedLayout$VDirection() , UP_0), ($clinit_BKAlignedLayout$HDirection() , RIGHT_3));
      layouts.array[layouts.array.length] = rightup;
      break;
    default:leftdown = new BKAlignedLayout(layeredGraph, this.ni.nodeCount, ($clinit_BKAlignedLayout$VDirection() , DOWN_0), ($clinit_BKAlignedLayout$HDirection() , LEFT_3));
      leftup = new BKAlignedLayout(layeredGraph, this.ni.nodeCount, UP_0, LEFT_3);
      rightdown = new BKAlignedLayout(layeredGraph, this.ni.nodeCount, DOWN_0, RIGHT_3);
      rightup = new BKAlignedLayout(layeredGraph, this.ni.nodeCount, UP_0, RIGHT_3);
      layouts.array[layouts.array.length] = rightdown;
      layouts.array[layouts.array.length] = rightup;
      layouts.array[layouts.array.length] = leftdown;
      layouts.array[layouts.array.length] = leftup;
  }
  aligner = new BKAligner(layeredGraph, this.ni);
  for (bal$iterator0 = new ArrayList$1(layouts); bal$iterator0.i < bal$iterator0.this$01.array.length;) {
    bal = castTo($next_8(bal$iterator0), 81);
    $verticalAlignment(aligner, bal, this.markedEdges);
    $insideBlockShift(bal);
  }
  compacter = new BKCompactor(layeredGraph, this.ni);
  for (bal$iterator1 = new ArrayList$1(layouts); bal$iterator1.i < bal$iterator1.this$01.array.length;) {
    bal = castTo($next_8(bal$iterator1), 81);
    $horizontalCompaction(compacter, bal);
  }
  if (this.debugMode) {
    for (bal$iterator2 = new ArrayList$1(layouts); bal$iterator2.i < bal$iterator2.this$01.array.length;) {
      bal = castTo($next_8(bal$iterator2), 81);
      $clinit_System();
      bal + ' size is ' + $layoutSize(bal);
    }
  }
  chosenLayout = null;
  if (this.produceBalancedLayout) {
    balanced = $createBalancedLayout(this, layouts, this.ni.nodeCount);
    $checkOrderConstraint(this, layeredGraph, balanced) && (chosenLayout = balanced);
  }
  if (!chosenLayout) {
    for (bal$iterator2 = new ArrayList$1(layouts); bal$iterator2.i < bal$iterator2.this$01.array.length;) {
      bal = castTo($next_8(bal$iterator2), 81);
      $checkOrderConstraint(this, layeredGraph, bal) && (!chosenLayout || $layoutSize(chosenLayout) > $layoutSize(bal)) && (chosenLayout = bal);
    }
  }
  !chosenLayout && (chosenLayout = (checkCriticalElementIndex(0, layouts.array.length) , castTo(layouts.array[0], 81)));
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator), 16);
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      node.pos.y_0 = checkNotNull_1(chosenLayout.y_0[node.id_0]) + checkNotNull_1(chosenLayout.innerShift[node.id_0]);
    }
  }
  if (this.debugMode) {
    $clinit_System();
    'Blocks: ' + getBlocks(chosenLayout);
    'Classes: ' + getClasses(chosenLayout);
  }
  for (bal$iterator = new ArrayList$1(layouts); bal$iterator.i < bal$iterator.this$01.array.length;) {
    bal = castTo($next_8(bal$iterator), 81);
    bal.root = null;
    bal.blockSize = null;
    bal.align_0 = null;
    bal.innerShift = null;
    bal.sink = null;
    bal.shift_0 = null;
    bal.y_0 = null;
  }
  $cleanup(this.ni);
  this.markedEdges.map_0.clear_0();
  $done(monitor);
}
;
_.debugMode = false;
_.produceBalancedLayout = false;
var HIERARCHY_PROCESSING_ADDITIONS_3;
var Lde_cau_cs_kieler_klay_layered_p4nodes_bk_BKNodePlacer_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p4nodes.bk', 'BKNodePlacer', 547);
function $clinit_CompactionStrategy(){
  $clinit_CompactionStrategy = emptyMethod;
  CLASSIC = new CompactionStrategy('CLASSIC', 0);
  IMPROVE_STRAIGHTNESS = new CompactionStrategy('IMPROVE_STRAIGHTNESS', 1);
}

function CompactionStrategy(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function values_43(){
  $clinit_CompactionStrategy();
  return stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_p4nodes_bk_CompactionStrategy_2_classLit, 1), $intern_13, 194, 0, [CLASSIC, IMPROVE_STRAIGHTNESS]);
}

defineClass(194, 17, {194:1, 3:1, 23:1, 17:1}, CompactionStrategy);
var CLASSIC, IMPROVE_STRAIGHTNESS;
var Lde_cau_cs_kieler_klay_layered_p4nodes_bk_CompactionStrategy_2_classLit = createForEnum('de.cau.cs.kieler.klay.layered.p4nodes.bk', 'CompactionStrategy', 194, Ljava_lang_Enum_2_classLit, values_43);
function $clinit_CompactionStrategy$Map(){
  $clinit_CompactionStrategy$Map = emptyMethod;
  $MAP_19 = createValueOfMap(($clinit_CompactionStrategy() , stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_p4nodes_bk_CompactionStrategy_2_classLit, 1), $intern_13, 194, 0, [CLASSIC, IMPROVE_STRAIGHTNESS])));
}

var $MAP_19;
function $cleanup(this$static){
  this$static.layerIndex = null;
  this$static.nodeIndex = null;
  this$static.leftNeighbors.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
  this$static.rightNeighbors.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
  this$static.neighborComparator = null;
}

function NeighborhoodInformation(){
}

function buildFor(graph){
  var l, l$iterator, lId, lIndex, layer, layer$iterator, n, n$iterator, nId, nIndex, ni;
  ni = new NeighborhoodInformation;
  ni.nodeCount = 0;
  for (layer$iterator = new ArrayList$1(graph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_8(layer$iterator), 16);
    ni.nodeCount += layer.nodes.array.length;
  }
  lId = 0;
  lIndex = 0;
  ni.layerIndex = initUnidimensionalArray(I_classLit, $intern_37, 26, graph.layers.array.length, 12, 1);
  nId = 0;
  ni.nodeIndex = initUnidimensionalArray(I_classLit, $intern_37, 26, ni.nodeCount, 12, 1);
  for (l$iterator = new ArrayList$1(graph.layers); l$iterator.i < l$iterator.this$01.array.length;) {
    l = castTo($next_8(l$iterator), 16);
    l.id_0 = lId++;
    ni.layerIndex[l.id_0] = lIndex++;
    nIndex = 0;
    for (n$iterator = new ArrayList$1(l.nodes); n$iterator.i < n$iterator.this$01.array.length;) {
      n = castTo($next_8(n$iterator), 9);
      n.id_0 = nId++;
      ni.nodeIndex[n.id_0] = nIndex++;
    }
  }
  ni.neighborComparator = new NeighborhoodInformation$NeighborComparator(ni);
  ni.leftNeighbors = newArrayListWithCapacity(ni.nodeCount);
  determineAllLeftNeighbors(ni, graph);
  ni.rightNeighbors = newArrayListWithCapacity(ni.nodeCount);
  determineAllRightNeighbors(ni, graph);
  return ni;
}

function determineAllLeftNeighbors(ni, graph){
  var edge, edge$iterator, edge$iterator0, l, l$iterator, maxPriority, n, n$iterator, result;
  for (l$iterator = new ArrayList$1(graph.layers); l$iterator.i < l$iterator.this$01.array.length;) {
    l = castTo($next_8(l$iterator), 16);
    for (n$iterator = new ArrayList$1(l.nodes); n$iterator.i < n$iterator.this$01.array.length;) {
      n = castTo($next_8(n$iterator), 9);
      result = new ArrayList;
      maxPriority = 0;
      for (edge$iterator0 = $iterator($getIncomingEdges_0(n)); $hasNext_0(edge$iterator0);) {
        edge = castTo($next_2(edge$iterator0), 12);
        castTo($getProperty(edge, ($clinit_InternalProperties() , PRIORITY_0)), 24).value_0 > maxPriority && (maxPriority = castTo($getProperty(edge, PRIORITY_0), 24).value_0);
      }
      for (edge$iterator = $iterator($getIncomingEdges_0(n)); $hasNext_0(edge$iterator);) {
        edge = castTo($next_2(edge$iterator), 12);
        n.layer != edge.source.owner.layer && castTo($getProperty(edge, ($clinit_InternalProperties() , PRIORITY_0)), 24).value_0 == maxPriority && $add_11(result, new Pair(edge.source.owner, edge));
      }
      sort_1(result, ni.neighborComparator);
      $add_10(ni.leftNeighbors, n.id_0, result);
    }
  }
}

function determineAllRightNeighbors(ni, graph){
  var edge, edge$iterator, edge$iterator0, l, l$iterator, maxPriority, n, n$iterator, result;
  for (l$iterator = new ArrayList$1(graph.layers); l$iterator.i < l$iterator.this$01.array.length;) {
    l = castTo($next_8(l$iterator), 16);
    for (n$iterator = new ArrayList$1(l.nodes); n$iterator.i < n$iterator.this$01.array.length;) {
      n = castTo($next_8(n$iterator), 9);
      result = new ArrayList;
      maxPriority = 0;
      for (edge$iterator0 = $iterator($getOutgoingEdges_0(n)); $hasNext_0(edge$iterator0);) {
        edge = castTo($next_2(edge$iterator0), 12);
        castTo($getProperty(edge, ($clinit_InternalProperties() , PRIORITY_0)), 24).value_0 > maxPriority && (maxPriority = castTo($getProperty(edge, PRIORITY_0), 24).value_0);
      }
      for (edge$iterator = $iterator($getOutgoingEdges_0(n)); $hasNext_0(edge$iterator);) {
        edge = castTo($next_2(edge$iterator), 12);
        n.layer != edge.target.owner.layer && castTo($getProperty(edge, ($clinit_InternalProperties() , PRIORITY_0)), 24).value_0 == maxPriority && $add_11(result, new Pair(edge.target.owner, edge));
      }
      sort_1(result, ni.neighborComparator);
      $add_10(ni.rightNeighbors, n.id_0, result);
    }
  }
}

defineClass(597, 1, {}, NeighborhoodInformation);
_.nodeCount = 0;
var Lde_cau_cs_kieler_klay_layered_p4nodes_bk_NeighborhoodInformation_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p4nodes.bk', 'NeighborhoodInformation', 597);
function $compare_15(this$static, o1, o2){
  var cmp;
  cmp = this$static.this$01.nodeIndex[castTo(o1.first, 9).id_0] - this$static.this$01.nodeIndex[castTo(o2.first, 9).id_0];
  return round_int(cmp > 0?1:cmp < 0?-1:0);
}

function NeighborhoodInformation$NeighborComparator(this$0){
  this.this$01 = this$0;
}

defineClass(598, 1, $intern_9, NeighborhoodInformation$NeighborComparator);
_.compare_0 = function compare_29(o1, o2){
  return $compare_15(this, castTo(o1, 27), castTo(o2, 27));
}
;
var Lde_cau_cs_kieler_klay_layered_p4nodes_bk_NeighborhoodInformation$NeighborComparator_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p4nodes.bk', 'NeighborhoodInformation/NeighborComparator', 598);
function $finishBlock(this$static, n){
  $add_18(this$static.blockFinished, n);
}

function $getOther_0(edge, n){
  if (edge.source.owner == n) {
    return edge.target.owner;
  }
   else if (edge.target.owner == n) {
    return edge.source.owner;
  }
   else {
    throw new IllegalArgumentException_0('Node ' + n + ' is neither source nor target of edge ' + edge);
  }
}

function $init(this$static, theBal, theNi){
  this$static.bal = theBal;
  this$static.ni = theNi;
  this$static.blockFinished.map_0.clear_0();
  $reset_0(this$static.postProcessablesQueue);
  this$static.postProcessablesStack.arrayList.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
}

function ThresholdStrategy(){
  this.blockFinished = new HashSet;
  this.postProcessablesQueue = new LinkedList;
  this.postProcessablesStack = new Stack;
}

defineClass(334, 1, {});
var Lde_cau_cs_kieler_klay_layered_p4nodes_bk_ThresholdStrategy_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p4nodes.bk', 'ThresholdStrategy', 334);
function ThresholdStrategy$NullThresholdStrategy(){
  ThresholdStrategy.call(this);
}

defineClass(602, 334, {}, ThresholdStrategy$NullThresholdStrategy);
_.calculateThreshold = function calculateThreshold(oldThresh, blockRoot, currentNode){
  return this.bal.vdir == ($clinit_BKAlignedLayout$VDirection() , UP_0)?$intern_50:$intern_51;
}
;
_.postProcess = function postProcess_0(){
}
;
var Lde_cau_cs_kieler_klay_layered_p4nodes_bk_ThresholdStrategy$NullThresholdStrategy_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p4nodes.bk', 'ThresholdStrategy/NullThresholdStrategy', 602);
function ThresholdStrategy$Postprocessable(free, isRoot){
  this.free = free;
  this.isRoot = isRoot;
}

defineClass(249, 1, {249:1}, ThresholdStrategy$Postprocessable);
_.hasEdges = false;
_.isRoot = false;
var Lde_cau_cs_kieler_klay_layered_p4nodes_bk_ThresholdStrategy$Postprocessable_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p4nodes.bk', 'ThresholdStrategy/Postprocessable', 249);
function $getBound(this$static, blockNode, isRoot){
  var invalid, left, otherPort, otherRoot, pick, right, rootPort, threshold;
  invalid = this$static.bal.vdir == ($clinit_BKAlignedLayout$VDirection() , UP_0)?$intern_50:$intern_51;
  pick = $pickEdge(this$static, new ThresholdStrategy$Postprocessable(blockNode, isRoot));
  if (!pick.edge && pick.hasEdges) {
    $add_8(this$static.postProcessablesQueue, pick);
    return invalid;
  }
   else if (pick.edge) {
    left = pick.edge.source;
    right = pick.edge.target;
    if (isRoot) {
      rootPort = this$static.bal.hdir == ($clinit_BKAlignedLayout$HDirection() , RIGHT_3)?right:left;
      otherPort = this$static.bal.hdir == RIGHT_3?left:right;
      otherRoot = this$static.bal.root[otherPort.owner.id_0];
      threshold = checkNotNull_1(this$static.bal.y_0[otherRoot.id_0]) + checkNotNull_1(this$static.bal.innerShift[otherPort.owner.id_0]) + otherPort.pos.y_0 + otherPort.anchor.y_0 - checkNotNull_1(this$static.bal.innerShift[rootPort.owner.id_0]) - rootPort.pos.y_0 - rootPort.anchor.y_0;
    }
     else {
      rootPort = this$static.bal.hdir == ($clinit_BKAlignedLayout$HDirection() , LEFT_3)?right:left;
      otherPort = this$static.bal.hdir == LEFT_3?left:right;
      threshold = checkNotNull_1(this$static.bal.y_0[this$static.bal.root[otherPort.owner.id_0].id_0]) + checkNotNull_1(this$static.bal.innerShift[otherPort.owner.id_0]) + otherPort.pos.y_0 + otherPort.anchor.y_0 - checkNotNull_1(this$static.bal.innerShift[rootPort.owner.id_0]) - rootPort.pos.y_0 - rootPort.anchor.y_0;
    }
    return threshold;
  }
  return invalid;
}

function $pickEdge(this$static, pp){
  var e, e$iterator, edges, hasEdges;
  pp.isRoot?(edges = this$static.bal.hdir == ($clinit_BKAlignedLayout$HDirection() , RIGHT_3)?$getIncomingEdges_0(pp.free):$getOutgoingEdges_0(pp.free)):(edges = this$static.bal.hdir == ($clinit_BKAlignedLayout$HDirection() , LEFT_3)?$getIncomingEdges_0(pp.free):$getOutgoingEdges_0(pp.free));
  hasEdges = false;
  for (e$iterator = ($clinit_Iterators() , new Iterators$ConcatenatedIterator($iterator_1(transform_1(edges.val$inputs1, new Iterables$12)))); $hasNext_0(e$iterator);) {
    e = castTo($next_2(e$iterator), 12);
    if (this$static.ni.layerIndex[e.source.owner.layer.id_0] === this$static.ni.layerIndex[e.target.owner.layer.id_0]) {
      continue;
    }
    hasEdges = true;
    if ($contains_7(this$static.blockFinished, this$static.bal.root[$getOther_0(e, pp.free).id_0])) {
      pp.hasEdges = true;
      pp.edge = e;
      return pp;
    }
  }
  pp.hasEdges = hasEdges;
  pp.edge = null;
  return pp;
}

function $process_7(this$static, pp){
  var availableSpace, block, delta, edge, fix;
  edge = pp.edge;
  edge.source.owner == pp.free?(fix = edge.target):(fix = edge.source);
  edge.source.owner == pp.free?(block = edge.source):(block = edge.target);
  delta = $calculateDelta(this$static.bal, fix, block);
  if (delta > 0 && delta < $intern_60) {
    availableSpace = $checkSpaceAbove(this$static.bal, block.owner, delta);
    $shiftBlock(this$static.bal, block.owner, -availableSpace);
    return availableSpace > 0;
  }
   else if (delta < 0 && -delta < $intern_60) {
    availableSpace = $checkSpaceBelow(this$static.bal, block.owner, -delta);
    $shiftBlock(this$static.bal, block.owner, availableSpace);
    return availableSpace > 0;
  }
  return false;
}

function ThresholdStrategy$SimpleThresholdStrategy(){
  ThresholdStrategy.call(this);
}

defineClass(603, 334, {}, ThresholdStrategy$SimpleThresholdStrategy);
_.calculateThreshold = function calculateThreshold_0(oldThresh, blockRoot, currentNode){
  var isLast, isRoot, t;
  isRoot = blockRoot == currentNode;
  isLast = this.bal.align_0[currentNode.id_0] == blockRoot;
  if (!(isRoot || isLast)) {
    return oldThresh;
  }
  t = oldThresh;
  if (this.bal.hdir == ($clinit_BKAlignedLayout$HDirection() , RIGHT_3)) {
    isRoot && (t = $getBound(this, blockRoot, true));
    (t == Infinity || t == -Infinity) && isLast && (t = $getBound(this, currentNode, false));
  }
   else {
    isRoot && (t = $getBound(this, blockRoot, true));
    (t == Infinity || t == -Infinity) && isLast && (t = $getBound(this, currentNode, false));
  }
  return t;
}
;
_.postProcess = function postProcess_1(){
  var edge, moved, pick, pp;
  while (this.postProcessablesQueue.size_0 != 0) {
    pp = castTo($poll(this.postProcessablesQueue), 249);
    pick = $pickEdge(this, pp);
    if (!pick.edge) {
      continue;
    }
    edge = pick.edge;
    if (this.ni.layerIndex[edge.source.owner.layer.id_0] === this.ni.layerIndex[edge.target.owner.layer.id_0]) {
      continue;
    }
    moved = $process_7(this, pp);
    moved || $push(this.postProcessablesStack, pp);
  }
  while (this.postProcessablesStack.arrayList.array.length != 0) {
    $process_7(this, castTo($pop(this.postProcessablesStack), 249));
  }
}
;
var Lde_cau_cs_kieler_klay_layered_p4nodes_bk_ThresholdStrategy$SimpleThresholdStrategy_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p4nodes.bk', 'ThresholdStrategy/SimpleThresholdStrategy', 603);
function EdgeRouterFactory(){
}

function factoryFor(edgeRoutingStrategy){
  var factory;
  factory = new EdgeRouterFactory;
  factory.edgeRoutingStrategy = edgeRoutingStrategy;
  return factory;
}

defineClass(423, 1, {180:1}, EdgeRouterFactory);
_.create_0 = function create_5(){
  switch (this.edgeRoutingStrategy.ordinal) {
    case 1:
      return new PolylineEdgeRouter;
    case 3:
      return new SplineEdgeRouter;
    default:return new OrthogonalEdgeRouter;
  }
}
;
var Lde_cau_cs_kieler_klay_layered_p5edges_EdgeRouterFactory_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p5edges', 'EdgeRouterFactory', 423);
function $clinit_OrthogonalEdgeRouter(){
  $clinit_OrthogonalEdgeRouter = emptyMethod;
  HYPEREDGE_PROCESSING_ADDITIONS = $addBeforePhase4(new IntermediateProcessingConfiguration, ($clinit_IntermediateProcessorStrategy() , HYPEREDGE_DUMMY_MERGER));
  INVERTED_PORT_PROCESSING_ADDITIONS = $addBeforePhase3(new IntermediateProcessingConfiguration, INVERTED_PORT_PROCESSOR);
  NORTH_SOUTH_PORT_PROCESSING_ADDITIONS = $addAfterPhase5($addBeforePhase3(new IntermediateProcessingConfiguration, NORTH_SOUTH_PORT_PREPROCESSOR), NORTH_SOUTH_PORT_POSTPROCESSOR);
  HIERARCHICAL_PORT_PROCESSING_ADDITIONS = $addAfterPhase5($addBeforePhase4($addBeforePhase3(new IntermediateProcessingConfiguration, HIERARCHICAL_PORT_CONSTRAINT_PROCESSOR), HIERARCHICAL_PORT_DUMMY_SIZE_PROCESSOR), HIERARCHICAL_PORT_ORTHOGONAL_EDGE_ROUTER);
  SELF_LOOP_PROCESSING_ADDITIONS = $addBeforePhase3(new IntermediateProcessingConfiguration, SELF_LOOP_PROCESSOR);
  HYPERNODE_PROCESSING_ADDITIONS = $addAfterPhase5(new IntermediateProcessingConfiguration, HYPERNODE_PROCESSOR);
  CENTER_EDGE_LABEL_PROCESSING_ADDITIONS = $addAfterPhase5($addBeforePhase4($addBeforePhase3($addBeforePhase2(new IntermediateProcessingConfiguration, LABEL_DUMMY_INSERTER), LABEL_DUMMY_SWITCHER), LABEL_SIDE_SELECTOR), LABEL_DUMMY_REMOVER);
  END_EDGE_LABEL_PROCESSING_ADDITIONS = $addAfterPhase5($addBeforePhase4(new IntermediateProcessingConfiguration, LABEL_SIDE_SELECTOR), END_LABEL_PROCESSOR);
}

function OrthogonalEdgeRouter(){
  $clinit_OrthogonalEdgeRouter();
}

defineClass(538, 1, $intern_64, OrthogonalEdgeRouter);
_.getIntermediateProcessingConfiguration = function getIntermediateProcessingConfiguration_11(graph){
  var configuration, graphProperties;
  graphProperties = castTo($getProperty(graph, ($clinit_InternalProperties() , GRAPH_PROPERTIES)), 18);
  configuration = new IntermediateProcessingConfiguration;
  if (graphProperties.contains(($clinit_GraphProperties() , HYPEREDGES))) {
    $addAll_4(configuration, HYPEREDGE_PROCESSING_ADDITIONS);
    $addAll_4(configuration, INVERTED_PORT_PROCESSING_ADDITIONS);
  }
  if (graphProperties.contains(NON_FREE_PORTS) || unsafeCast(checkNotNull_1(castToBoolean($getProperty(graph, ($clinit_Properties() , FEEDBACK_EDGES)))))) {
    $addAll_4(configuration, INVERTED_PORT_PROCESSING_ADDITIONS);
    graphProperties.contains(NORTH_SOUTH_PORTS) && $addAll_4(configuration, NORTH_SOUTH_PORT_PROCESSING_ADDITIONS);
  }
  graphProperties.contains(EXTERNAL_PORTS) && $addAll_4(configuration, HIERARCHICAL_PORT_PROCESSING_ADDITIONS);
  graphProperties.contains(SELF_LOOPS) && $addAll_4(configuration, SELF_LOOP_PROCESSING_ADDITIONS);
  graphProperties.contains(HYPERNODES) && $addAll_4(configuration, HYPERNODE_PROCESSING_ADDITIONS);
  graphProperties.contains(CENTER_LABELS) && $addAll_4(configuration, CENTER_EDGE_LABEL_PROCESSING_ADDITIONS);
  graphProperties.contains(END_LABELS) && $addAll_4(configuration, END_EDGE_LABEL_PROCESSING_ADDITIONS);
  return configuration;
}
;
_.process = function process_58(layeredGraph, monitor){
  var increment, isLeftLayerExternal, isRightLayerExternal, layerIter, leftLayer, leftLayerNodes, rightLayer, rightLayerNodes, routingGenerator, slotsCount, spacings, startPos, xpos;
  $begin(monitor, 'Orthogonal edge routing', 1);
  spacings = castTo($getProperty(layeredGraph, ($clinit_InternalProperties() , SPACINGS)), 134);
  unsafeCast(checkNotNull_1(castToBoolean($getProperty(layeredGraph, ($clinit_LayoutOptions() , DEBUG_MODE)))));
  routingGenerator = new OrthogonalRoutingGenerator(0, spacings.edgeEdgeSpacing);
  xpos = 0;
  layerIter = new AbstractList$ListIteratorImpl(layeredGraph.layers, 0);
  leftLayer = null;
  leftLayerNodes = null;
  do {
    rightLayer = layerIter.i < layerIter.this$01_0.size_1()?(checkCriticalElement(layerIter.i < layerIter.this$01_0.size_1()) , castTo(layerIter.this$01_0.get_2(layerIter.last = layerIter.i++), 16)):null;
    rightLayerNodes = !rightLayer?null:rightLayer.nodes;
    if (leftLayer) {
      placeNodesHorizontally(leftLayer, xpos);
      xpos += leftLayer.size_0.x_0;
    }
    startPos = !leftLayer?xpos:xpos + spacings.edgeNodeSpacing;
    slotsCount = $routeEdges_0(routingGenerator, layeredGraph, leftLayerNodes, rightLayerNodes, startPos);
    isLeftLayerExternal = !leftLayer || all_0(leftLayerNodes, ($clinit_PolylineEdgeRouter() , PRED_EXTERNAL_WEST_OR_EAST_PORT));
    isRightLayerExternal = !rightLayer || all_0(rightLayerNodes, ($clinit_PolylineEdgeRouter() , PRED_EXTERNAL_WEST_OR_EAST_PORT));
    if (slotsCount > 0) {
      increment = spacings.edgeNodeSpacing + (slotsCount - 1) * spacings.edgeEdgeSpacing;
      !!rightLayer && (increment += spacings.edgeNodeSpacing);
      increment < spacings.nodeSpacing && !isLeftLayerExternal && !isRightLayerExternal && (increment = spacings.nodeSpacing);
      xpos += increment;
    }
     else 
      !isLeftLayerExternal && !isRightLayerExternal && (xpos += spacings.nodeSpacing);
    leftLayer = rightLayer;
    leftLayerNodes = rightLayerNodes;
  }
   while (rightLayer);
  layeredGraph.size_0.x_0 = xpos;
  $done(monitor);
}
;
var CENTER_EDGE_LABEL_PROCESSING_ADDITIONS, END_EDGE_LABEL_PROCESSING_ADDITIONS, HIERARCHICAL_PORT_PROCESSING_ADDITIONS, HYPEREDGE_PROCESSING_ADDITIONS, HYPERNODE_PROCESSING_ADDITIONS, INVERTED_PORT_PROCESSING_ADDITIONS, NORTH_SOUTH_PORT_PROCESSING_ADDITIONS, SELF_LOOP_PROCESSING_ADDITIONS;
var Lde_cau_cs_kieler_klay_layered_p5edges_OrthogonalEdgeRouter_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p5edges', 'OrthogonalEdgeRouter', 538);
function $addJunctionPointIfNecessary(this$static, edge, hyperNode, pos, vertical){
  var jpoint, junctionPoints, p;
  p = vertical?pos.y_0:pos.x_0;
  if (p > hyperNode.start_0 && p < hyperNode.end || hyperNode.sourcePosis.size_0 != 0 && hyperNode.targetPosis.size_0 != 0 && (abs_0(p - checkNotNull_1(castToDouble($getFirst(hyperNode.sourcePosis)))) < $intern_55 && abs_0(p - checkNotNull_1(castToDouble($getFirst(hyperNode.targetPosis)))) < $intern_55 || abs_0(p - checkNotNull_1(castToDouble($getLast(hyperNode.sourcePosis)))) < $intern_55 && abs_0(p - checkNotNull_1(castToDouble($getLast(hyperNode.targetPosis)))) < $intern_55)) {
    if (!$contains_7(this$static.createdJunctionPoints, pos)) {
      junctionPoints = castTo($getProperty(edge, ($clinit_LayoutOptions() , JUNCTION_POINTS)), 44);
      if (!junctionPoints) {
        junctionPoints = new KVectorChain;
        $setProperty(edge, JUNCTION_POINTS, junctionPoints);
      }
      jpoint = new KVector_2(pos);
      $addNode_0(junctionPoints, jpoint, junctionPoints.tail.prev, junctionPoints.tail);
      $add_18(this$static.createdJunctionPoints, jpoint);
    }
  }
}

function $createHyperNodes(this$static, nodes, portSide, hyperNodes, portToHyperNodeMap){
  var hyperNode, node, node$iterator, port, port$iterator;
  if (nodes) {
    for (node$iterator = nodes.iterator_0(); node$iterator.hasNext_0();) {
      node = castTo(node$iterator.next_1(), 9);
      for (port$iterator = $getPorts_2(node, ($clinit_PortType() , OUTPUT), portSide).iterator_0(); port$iterator.hasNext_0();) {
        port = castTo(port$iterator.next_1(), 7);
        hyperNode = castTo(getEntryValueOrNull($getEntry(portToHyperNodeMap.hashCodeMap, port)), 80);
        if (!hyperNode) {
          hyperNode = new OrthogonalRoutingGenerator$HyperNode(this$static);
          hyperNodes.array[hyperNodes.array.length] = hyperNode;
          $addPortPositions(hyperNode, port, portToHyperNodeMap);
        }
      }
    }
  }
}

function $routeEdges_0(this$static, layeredGraph, sourceLayerNodes, targetLayerNodes, startPos){
  var hyperNode1, hyperNode2, hyperNodes, iter1, iter2, node, node$iterator, portToHyperNodeMap, rankCount;
  portToHyperNodeMap = ($clinit_Maps() , new HashMap);
  hyperNodes = new ArrayList;
  $createHyperNodes(this$static, sourceLayerNodes, this$static.routingStrategy.getSourcePortSide(), hyperNodes, portToHyperNodeMap);
  $createHyperNodes(this$static, targetLayerNodes, this$static.routingStrategy.getTargetPortSide(), hyperNodes, portToHyperNodeMap);
  iter1 = new AbstractList$ListIteratorImpl(hyperNodes, 0);
  while (iter1.i < iter1.this$01_0.size_1()) {
    hyperNode1 = (checkCriticalElement(iter1.i < iter1.this$01_0.size_1()) , castTo(iter1.this$01_0.get_2(iter1.last = iter1.i++), 80));
    iter2 = new AbstractList$ListIteratorImpl(hyperNodes, iter1.i);
    while (iter2.i < iter2.this$01_0.size_1()) {
      hyperNode2 = (checkCriticalElement(iter2.i < iter2.this$01_0.size_1()) , castTo(iter2.this$01_0.get_2(iter2.last = iter2.i++), 80));
      createDependency(hyperNode1, hyperNode2, this$static.conflictThreshold);
    }
  }
  breakCycles(hyperNodes, castTo($getProperty(layeredGraph, ($clinit_InternalProperties() , RANDOM)), 154));
  topologicalNumbering(hyperNodes);
  rankCount = -1;
  for (node$iterator = new ArrayList$1(hyperNodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 80);
    if (abs_0(node.start_0 - node.end) < $intern_55) {
      continue;
    }
    rankCount = max_3(rankCount, node.rank);
    this$static.routingStrategy.calculateBendPoints(node, startPos);
  }
  this$static.createdJunctionPoints.map_0.clear_0();
  return rankCount + 1;
}

function OrthogonalRoutingGenerator(direction, edgeSpacing){
  this.createdJunctionPoints = new HashSet;
  switch (direction) {
    case 0:
      this.routingStrategy = new OrthogonalRoutingGenerator$WestToEastRoutingStrategy(this);
      break;
    case 1:
      this.routingStrategy = new OrthogonalRoutingGenerator$NorthToSouthRoutingStrategy(this);
      break;
    case 2:
      this.routingStrategy = new OrthogonalRoutingGenerator$SouthToNorthRoutingStrategy(this);
      break;
    default:throw new IllegalArgumentException;
  }
  this.edgeSpacing = edgeSpacing;
  this.conflictThreshold = 0.2 * edgeSpacing;
}

function breakCycles(nodes, random){
  var depIter, dependency, dependency$iterator, dependency$iterator0, entry, entryIterator, inweight, markBase, maxNode, maxNodes, maxOutflow, nextLeft, nextMark, nextRight, node, node$iterator, node$iterator0, node$iterator1, outflow, outweight, shiftBase, sink, sinks, source, source$iterator, sources, target, unprocessed, set_0;
  sources = new LinkedList;
  sinks = new LinkedList;
  nextMark = -1;
  for (node$iterator0 = new ArrayList$1(nodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
    node = castTo($next_8(node$iterator0), 80);
    node.mark = nextMark--;
    inweight = 0;
    outweight = 0;
    for (dependency$iterator0 = new ArrayList$1(node.outgoing); dependency$iterator0.i < dependency$iterator0.this$01.array.length;) {
      dependency = castTo($next_8(dependency$iterator0), 118);
      outweight += dependency.weight;
    }
    for (dependency$iterator = new ArrayList$1(node.incoming); dependency$iterator.i < dependency$iterator.this$01.array.length;) {
      dependency = castTo($next_8(dependency$iterator), 118);
      inweight += dependency.weight;
    }
    node.inweight = inweight;
    node.outweight = outweight;
    outweight == 0?($addNode_0(sinks, node, sinks.tail.prev, sinks.tail) , true):inweight == 0 && ($addNode_0(sources, node, sources.tail.prev, sources.tail) , true);
  }
  unprocessed = (set_0 = new TreeSet , addAll_4(set_0, nodes) , set_0);
  markBase = nodes.array.length;
  nextRight = markBase - 1;
  nextLeft = markBase + 1;
  maxNodes = new ArrayList;
  while (unprocessed.map_0.size_0 != 0) {
    while (sinks.size_0 != 0) {
      sink = (checkCriticalElement(sinks.size_0 != 0) , castTo($removeNode_0(sinks, sinks.header.next_0), 80));
      $remove_23(unprocessed.map_0, sink) != null;
      sink.mark = nextRight--;
      updateNeighbors(sink, sources, sinks);
    }
    while (sources.size_0 != 0) {
      source = (checkCriticalElement(sources.size_0 != 0) , castTo($removeNode_0(sources, sources.header.next_0), 80));
      $remove_23(unprocessed.map_0, source) != null;
      source.mark = nextLeft++;
      updateNeighbors(source, sources, sinks);
    }
    maxOutflow = $intern_8;
    for (node$iterator1 = (entryIterator = new TreeMap$EntryIterator((new TreeMap$EntrySet((new AbstractNavigableMap$NavigableKeySet(unprocessed.map_0)).map_0)).this$01_0) , new AbstractNavigableMap$NavigableKeySet$1(entryIterator)); $hasNext_2(node$iterator1.val$entryIterator2.iter);) {
      node = (entry = $next_12(node$iterator1.val$entryIterator2) , castTo(entry.getKey(), 80));
      outflow = node.outweight - node.inweight;
      if (outflow >= maxOutflow) {
        if (outflow > maxOutflow) {
          maxNodes.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
          maxOutflow = outflow;
        }
        maxNodes.array[maxNodes.array.length] = node;
      }
    }
    if (maxNodes.array.length != 0) {
      maxNode = castTo($get_8(maxNodes, $nextInt(random, maxNodes.array.length)), 80);
      $remove_23(unprocessed.map_0, maxNode) != null;
      maxNode.mark = nextLeft++;
      updateNeighbors(maxNode, sources, sinks);
      maxNodes.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
    }
  }
  shiftBase = nodes.array.length + 1;
  for (node$iterator = new ArrayList$1(nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 80);
    node.mark < markBase && (node.mark += shiftBase);
  }
  for (source$iterator = new ArrayList$1(nodes); source$iterator.i < source$iterator.this$01.array.length;) {
    source = castTo($next_8(source$iterator), 80);
    depIter = new AbstractList$ListIteratorImpl(source.outgoing, 0);
    while (depIter.i < depIter.this$01_0.size_1()) {
      dependency = (checkCriticalElement(depIter.i < depIter.this$01_0.size_1()) , castTo(depIter.this$01_0.get_2(depIter.last = depIter.i++), 118));
      target = dependency.target;
      if (source.mark > target.mark) {
        $remove_11(depIter);
        $remove_7(target.incoming, dependency);
        if (dependency.weight > 0) {
          dependency.source = target;
          $add_11(target.outgoing, dependency);
          dependency.target = source;
          $add_11(source.incoming, dependency);
        }
      }
    }
  }
}

function countConflicts(posis1, posis2, minDiff){
  var conflicts, hasMore, iter1, iter2, pos1, pos2;
  conflicts = 0;
  if (posis1.size_0 != 0 && posis2.size_0 != 0) {
    iter1 = $listIterator_2(posis1, 0);
    iter2 = $listIterator_2(posis2, 0);
    pos1 = checkNotNull_1(castToDouble($next_11(iter1)));
    pos2 = checkNotNull_1(castToDouble($next_11(iter2)));
    hasMore = true;
    do {
      pos1 > pos2 - minDiff && pos1 < pos2 + minDiff && ++conflicts;
      pos1 <= pos2 && iter1.currentNode != iter1.this$01.tail?(pos1 = checkNotNull_1(castToDouble($next_11(iter1)))):pos2 <= pos1 && iter2.currentNode != iter2.this$01.tail?(pos2 = checkNotNull_1(castToDouble($next_11(iter2)))):(hasMore = false);
    }
     while (hasMore);
  }
  return conflicts;
}

function countCrossings_1(posis, start_0, end){
  var crossings, pos, pos$iterator;
  crossings = 0;
  for (pos$iterator = $listIterator_2(posis, 0); pos$iterator.currentNode != pos$iterator.this$01.tail;) {
    pos = checkNotNull_1(castToDouble($next_11(pos$iterator)));
    if (pos > end) {
      break;
    }
     else 
      pos >= start_0 && ++crossings;
  }
  return crossings;
}

function createDependency(hn1, hn2, minDiff){
  var conflicts1, conflicts2, crossings1, crossings2, depValue1, depValue2;
  if (abs_0(hn1.start_0 - hn1.end) < $intern_55 || abs_0(hn2.start_0 - hn2.end) < $intern_55) {
    return;
  }
  conflicts1 = countConflicts(hn1.targetPosis, hn2.sourcePosis, minDiff);
  conflicts2 = countConflicts(hn2.targetPosis, hn1.sourcePosis, minDiff);
  crossings1 = countCrossings_1(hn1.targetPosis, hn2.start_0, hn2.end) + countCrossings_1(hn2.sourcePosis, hn1.start_0, hn1.end);
  crossings2 = countCrossings_1(hn2.targetPosis, hn1.start_0, hn1.end) + countCrossings_1(hn1.sourcePosis, hn2.start_0, hn2.end);
  depValue1 = 16 * conflicts1 + crossings1;
  depValue2 = 16 * conflicts2 + crossings2;
  if (depValue1 < depValue2) {
    new OrthogonalRoutingGenerator$Dependency(hn1, hn2, depValue2 - depValue1);
  }
   else if (depValue1 > depValue2) {
    new OrthogonalRoutingGenerator$Dependency(hn2, hn1, depValue1 - depValue2);
  }
   else if (depValue1 > 0 && depValue2 > 0) {
    new OrthogonalRoutingGenerator$Dependency(hn1, hn2, 0);
    new OrthogonalRoutingGenerator$Dependency(hn2, hn1, 0);
  }
}

function insertSorted(list, value_0){
  var listIter, next;
  listIter = $listIterator_2(list, 0);
  while (listIter.currentNode != listIter.this$01.tail) {
    next = checkNotNull_1(castToDouble($next_11(listIter)));
    if (next == value_0) {
      return;
    }
     else if (next > value_0) {
      $previous_2(listIter);
      break;
    }
  }
  $add_19(listIter, value_0);
}

function topologicalNumbering(nodes){
  var dep, dep$iterator, maxRank, node, node$iterator, node$iterator0, rightwardTargets, source, sources, target;
  sources = new ArrayList;
  rightwardTargets = new ArrayList;
  for (node$iterator0 = new ArrayList$1(nodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
    node = castTo($next_8(node$iterator0), 80);
    node.inweight = node.incoming.array.length;
    node.outweight = node.outgoing.array.length;
    node.inweight == 0 && (sources.array[sources.array.length] = node , true);
    node.outweight == 0 && node.sourcePosis.size_0 == 0 && (rightwardTargets.array[rightwardTargets.array.length] = node , true);
  }
  maxRank = -1;
  while (sources.array.length != 0) {
    node = castTo($remove_6(sources, 0), 80);
    for (dep$iterator = new ArrayList$1(node.outgoing); dep$iterator.i < dep$iterator.this$01.array.length;) {
      dep = castTo($next_8(dep$iterator), 118);
      target = dep.target;
      target.rank = max_3(target.rank, node.rank + 1);
      maxRank = max_3(maxRank, target.rank);
      --target.inweight;
      target.inweight == 0 && (sources.array[sources.array.length] = target , true);
    }
  }
  if (maxRank > -1) {
    for (node$iterator = new ArrayList$1(rightwardTargets); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 80);
      node.rank = maxRank;
    }
    while (rightwardTargets.array.length != 0) {
      node = castTo($remove_6(rightwardTargets, 0), 80);
      for (dep$iterator = new ArrayList$1(node.incoming); dep$iterator.i < dep$iterator.this$01.array.length;) {
        dep = castTo($next_8(dep$iterator), 118);
        source = dep.source;
        if (source.sourcePosis.size_0 > 0) {
          continue;
        }
        source.rank = min_3(source.rank, node.rank - 1);
        --source.outweight;
        source.outweight == 0 && (rightwardTargets.array[rightwardTargets.array.length] = source , true);
      }
    }
  }
}

function updateNeighbors(node, sources, sinks){
  var dep, dep$iterator, dep$iterator0;
  for (dep$iterator0 = new ArrayList$1(node.outgoing); dep$iterator0.i < dep$iterator0.this$01.array.length;) {
    dep = castTo($next_8(dep$iterator0), 118);
    if (dep.target.mark < 0 && dep.weight > 0) {
      dep.target.inweight -= dep.weight;
      dep.target.inweight <= 0 && dep.target.outweight > 0 && $add_8(sources, dep.target);
    }
  }
  for (dep$iterator = new ArrayList$1(node.incoming); dep$iterator.i < dep$iterator.this$01.array.length;) {
    dep = castTo($next_8(dep$iterator), 118);
    if (dep.source.mark < 0 && dep.weight > 0) {
      dep.source.outweight -= dep.weight;
      dep.source.outweight <= 0 && dep.source.inweight > 0 && $add_8(sinks, dep.source);
    }
  }
}

defineClass(277, 1, {}, OrthogonalRoutingGenerator);
_.conflictThreshold = 0;
_.edgeSpacing = 0;
var Lde_cau_cs_kieler_klay_layered_p5edges_OrthogonalRoutingGenerator_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p5edges', 'OrthogonalRoutingGenerator', 277);
function OrthogonalRoutingGenerator$Dependency(thesource, thetarget, theweight){
  this.target = thetarget;
  this.source = thesource;
  this.weight = theweight;
  $add_11(this.source.outgoing, this);
  $add_11(this.target.incoming, this);
}

defineClass(118, 1, {118:1}, OrthogonalRoutingGenerator$Dependency);
_.toString_0 = function toString_66(){
  return this.source + '->' + this.target;
}
;
_.weight = 0;
var Lde_cau_cs_kieler_klay_layered_p5edges_OrthogonalRoutingGenerator$Dependency_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p5edges', 'OrthogonalRoutingGenerator/Dependency', 118);
function $addPortPositions(this$static, port, hyperNodeMap){
  var otherPort, otherPort$iterator, pos;
  hyperNodeMap.put(port, this$static);
  $add_11(this$static.ports, port);
  pos = this$static.this$01.routingStrategy.getPortPositionOnHyperNode(port);
  isNaN_0(this$static.start_0)?(this$static.start_0 = pos):(this$static.start_0 = min_1(this$static.start_0, pos));
  isNaN_0(this$static.end)?(this$static.end = pos):(this$static.end = max_1(this$static.end, pos));
  port.side == this$static.this$01.routingStrategy.getSourcePortSide()?insertSorted(this$static.sourcePosis, pos):insertSorted(this$static.targetPosis, pos);
  for (otherPort$iterator = $iterator(concat(($clinit_ImmutableList() , new RegularImmutableList(nullCheckedList(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [new LPort$7(port), new LPort$8(port)])))))); $hasNext_0(otherPort$iterator);) {
    otherPort = castTo($next_2(otherPort$iterator), 7);
    hyperNodeMap.containsKey(otherPort) || $addPortPositions(this$static, otherPort, hyperNodeMap);
  }
}

function $compareTo_9(this$static, other){
  return this$static.mark - other.mark;
}

function OrthogonalRoutingGenerator$HyperNode(this$0){
  this.this$01 = this$0;
  this.ports = new ArrayList;
  this.sourcePosis = new LinkedList;
  this.targetPosis = new LinkedList;
  this.outgoing = new ArrayList;
  this.incoming = new ArrayList;
}

defineClass(80, 1, {80:1, 23:1}, OrthogonalRoutingGenerator$HyperNode);
_.compareTo = function compareTo_11(other){
  return $compareTo_9(this, castTo(other, 80));
}
;
_.equals = function equals_37(object){
  var other;
  if (instanceOf(object, 80)) {
    other = castTo(object, 80);
    return this.mark == other.mark;
  }
  return false;
}
;
_.hashCode_0 = function hashCode_37(){
  return this.mark;
}
;
_.toString_0 = function toString_67(){
  var builder, name_0, port, portIter;
  builder = new StringBuilder_1('{');
  portIter = new ArrayList$1(this.ports);
  while (portIter.i < portIter.this$01.array.length) {
    port = castTo($next_8(portIter), 7);
    name_0 = $getName(port.owner);
    name_0 == null && (name_0 = 'n' + $getIndex(port.owner));
    builder.string += '' + name_0;
    portIter.i < portIter.this$01.array.length && (builder.string += ',' , builder);
  }
  builder.string += '}';
  return builder.string;
}
;
_.end = NaN;
_.inweight = 0;
_.mark = 0;
_.outweight = 0;
_.rank = 0;
_.start_0 = NaN;
var Lde_cau_cs_kieler_klay_layered_p5edges_OrthogonalRoutingGenerator$HyperNode_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p5edges', 'OrthogonalRoutingGenerator/HyperNode', 80);
function OrthogonalRoutingGenerator$NorthToSouthRoutingStrategy(this$0){
  this.this$01 = this$0;
}

defineClass(580, 1, {}, OrthogonalRoutingGenerator$NorthToSouthRoutingStrategy);
_.calculateBendPoints = function calculateBendPoints(hyperNode, startPos){
  var edge, edge$iterator, point1, point2, port, port$iterator, sourcex, target, targetx, y_0;
  y_0 = startPos + hyperNode.rank * this.this$01.edgeSpacing;
  for (port$iterator = new ArrayList$1(hyperNode.ports); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_8(port$iterator), 7);
    sourcex = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [port.owner.pos, port.pos, port.anchor])).x_0;
    for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
      edge = castTo($next_8(edge$iterator), 12);
      target = edge.target;
      targetx = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [target.owner.pos, target.pos, target.anchor])).x_0;
      if ((sourcex - targetx <= 0?0 - (sourcex - targetx):sourcex - targetx) > $intern_55) {
        point1 = new KVector_1(sourcex, y_0);
        $add_8(edge.bendPoints, point1);
        $addJunctionPointIfNecessary(this.this$01, edge, hyperNode, point1, false);
        point2 = new KVector_1(targetx, y_0);
        $add_8(edge.bendPoints, point2);
        $addJunctionPointIfNecessary(this.this$01, edge, hyperNode, point2, false);
      }
    }
  }
}
;
_.getPortPositionOnHyperNode = function getPortPositionOnHyperNode(port){
  return port.owner.pos.x_0 + port.pos.x_0 + port.anchor.x_0;
}
;
_.getSourcePortSide = function getSourcePortSide(){
  return $clinit_PortSide() , SOUTH;
}
;
_.getTargetPortSide = function getTargetPortSide(){
  return $clinit_PortSide() , NORTH;
}
;
var Lde_cau_cs_kieler_klay_layered_p5edges_OrthogonalRoutingGenerator$NorthToSouthRoutingStrategy_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p5edges', 'OrthogonalRoutingGenerator/NorthToSouthRoutingStrategy', 580);
function OrthogonalRoutingGenerator$SouthToNorthRoutingStrategy(this$0){
  this.this$01 = this$0;
}

defineClass(581, 1, {}, OrthogonalRoutingGenerator$SouthToNorthRoutingStrategy);
_.calculateBendPoints = function calculateBendPoints_0(hyperNode, startPos){
  var edge, edge$iterator, point1, point2, port, port$iterator, sourcex, target, targetx, y_0;
  y_0 = startPos - hyperNode.rank * this.this$01.edgeSpacing;
  for (port$iterator = new ArrayList$1(hyperNode.ports); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_8(port$iterator), 7);
    sourcex = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [port.owner.pos, port.pos, port.anchor])).x_0;
    for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
      edge = castTo($next_8(edge$iterator), 12);
      target = edge.target;
      targetx = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [target.owner.pos, target.pos, target.anchor])).x_0;
      if ((sourcex - targetx <= 0?0 - (sourcex - targetx):sourcex - targetx) > $intern_55) {
        point1 = new KVector_1(sourcex, y_0);
        $add_8(edge.bendPoints, point1);
        $addJunctionPointIfNecessary(this.this$01, edge, hyperNode, point1, false);
        point2 = new KVector_1(targetx, y_0);
        $add_8(edge.bendPoints, point2);
        $addJunctionPointIfNecessary(this.this$01, edge, hyperNode, point2, false);
      }
    }
  }
}
;
_.getPortPositionOnHyperNode = function getPortPositionOnHyperNode_0(port){
  return port.owner.pos.x_0 + port.pos.x_0 + port.anchor.x_0;
}
;
_.getSourcePortSide = function getSourcePortSide_0(){
  return $clinit_PortSide() , NORTH;
}
;
_.getTargetPortSide = function getTargetPortSide_0(){
  return $clinit_PortSide() , SOUTH;
}
;
var Lde_cau_cs_kieler_klay_layered_p5edges_OrthogonalRoutingGenerator$SouthToNorthRoutingStrategy_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p5edges', 'OrthogonalRoutingGenerator/SouthToNorthRoutingStrategy', 581);
function OrthogonalRoutingGenerator$WestToEastRoutingStrategy(this$0){
  this.this$01 = this$0;
}

defineClass(579, 1, {}, OrthogonalRoutingGenerator$WestToEastRoutingStrategy);
_.calculateBendPoints = function calculateBendPoints_1(hyperNode, startPos){
  var edge, edge$iterator, point1, point2, port, port$iterator, sourcey, target, targety, x_0;
  x_0 = startPos + hyperNode.rank * this.this$01.edgeSpacing;
  for (port$iterator = new ArrayList$1(hyperNode.ports); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_8(port$iterator), 7);
    sourcey = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [port.owner.pos, port.pos, port.anchor])).y_0;
    for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
      edge = castTo($next_8(edge$iterator), 12);
      target = edge.target;
      targety = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [target.owner.pos, target.pos, target.anchor])).y_0;
      if ((sourcey - targety <= 0?0 - (sourcey - targety):sourcey - targety) > $intern_55) {
        point1 = new KVector_1(x_0, sourcey);
        $add_8(edge.bendPoints, point1);
        $addJunctionPointIfNecessary(this.this$01, edge, hyperNode, point1, true);
        point2 = new KVector_1(x_0, targety);
        $add_8(edge.bendPoints, point2);
        $addJunctionPointIfNecessary(this.this$01, edge, hyperNode, point2, true);
      }
    }
  }
}
;
_.getPortPositionOnHyperNode = function getPortPositionOnHyperNode_1(port){
  return port.owner.pos.y_0 + port.pos.y_0 + port.anchor.y_0;
}
;
_.getSourcePortSide = function getSourcePortSide_1(){
  return $clinit_PortSide() , EAST;
}
;
_.getTargetPortSide = function getTargetPortSide_1(){
  return $clinit_PortSide() , WEST;
}
;
var Lde_cau_cs_kieler_klay_layered_p5edges_OrthogonalRoutingGenerator$WestToEastRoutingStrategy_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p5edges', 'OrthogonalRoutingGenerator/WestToEastRoutingStrategy', 579);
function $clinit_PolylineEdgeRouter(){
  $clinit_PolylineEdgeRouter = emptyMethod;
  PRED_EXTERNAL_WEST_OR_EAST_PORT = new PolylineEdgeRouter$1;
  INVERTED_PORT_PROCESSING_ADDITIONS_0 = $addBeforePhase3(new IntermediateProcessingConfiguration, ($clinit_IntermediateProcessorStrategy() , INVERTED_PORT_PROCESSOR));
  NORTH_SOUTH_PORT_PROCESSING_ADDITIONS_0 = $addAfterPhase5($addBeforePhase3(new IntermediateProcessingConfiguration, NORTH_SOUTH_PORT_PREPROCESSOR), NORTH_SOUTH_PORT_POSTPROCESSOR);
  CENTER_EDGE_LABEL_PROCESSING_ADDITIONS_0 = $addAfterPhase5($addBeforePhase4($addBeforePhase3($addBeforePhase2(new IntermediateProcessingConfiguration, LABEL_DUMMY_INSERTER), LABEL_DUMMY_SWITCHER), LABEL_SIDE_SELECTOR), LABEL_DUMMY_REMOVER);
  END_EDGE_LABEL_PROCESSING_ADDITIONS_0 = $addAfterPhase5($addBeforePhase4(new IntermediateProcessingConfiguration, LABEL_SIDE_SELECTOR), END_LABEL_PROCESSOR);
}

function $addBendPoint(this$static, edge, bendPoint, addJunctionPoint, currPort){
  var jpoint, junctionPoints;
  if (!$equals_3(sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [currPort.owner.pos, currPort.pos, currPort.anchor])), bendPoint)) {
    edge.source == currPort?$add_2(edge.bendPoints, 0, new KVector_2(bendPoint)):$add_8(edge.bendPoints, new KVector_2(bendPoint));
    if (addJunctionPoint && !$contains_7(this$static.createdJunctionPoints, bendPoint)) {
      junctionPoints = castTo($getProperty(edge, ($clinit_LayoutOptions() , JUNCTION_POINTS)), 44);
      if (!junctionPoints) {
        junctionPoints = new KVectorChain;
        $setProperty(edge, JUNCTION_POINTS, junctionPoints);
      }
      jpoint = new KVector_2(bendPoint);
      $addNode_0(junctionPoints, jpoint, junctionPoints.tail.prev, junctionPoints.tail);
      $add_18(this$static.createdJunctionPoints, jpoint);
    }
  }
}

function $calculateWestInLayerEdgeYDiff(layer){
  var maxYDiff, node, node$iterator, outgoingEdge, outgoingEdge$iterator, sourcePos, targetPos;
  maxYDiff = 0;
  for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_8(node$iterator), 9);
    for (outgoingEdge$iterator = $iterator($getOutgoingEdges_0(node)); $hasNext_0(outgoingEdge$iterator);) {
      outgoingEdge = castTo($next_2(outgoingEdge$iterator), 12);
      if (layer == outgoingEdge.target.owner.layer && outgoingEdge.source.side == ($clinit_PortSide() , WEST)) {
        sourcePos = $getAbsoluteAnchor(outgoingEdge.source).y_0;
        targetPos = $getAbsoluteAnchor(outgoingEdge.target).y_0;
        maxYDiff = maxYDiff > (targetPos - sourcePos <= 0?0 - (targetPos - sourcePos):targetPos - sourcePos)?maxYDiff:targetPos - sourcePos <= 0?0 - (targetPos - sourcePos):targetPos - sourcePos;
      }
    }
  }
  return maxYDiff;
}

function $processNode_0(this$static, node, layerLeftXPos){
  var absolutePortAnchor, addJunctionPoint, bendPoint, e, e$iterator, layerRightXPos, otherPort, port, port$iterator;
  layerRightXPos = layerLeftXPos + node.layer.size_0.x_0;
  for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_8(port$iterator), 7);
    absolutePortAnchor = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [port.owner.pos, port.pos, port.anchor]));
    bendPoint = new KVector_1(0, absolutePortAnchor.y_0);
    if (port.side == ($clinit_PortSide() , EAST)) {
      bendPoint.x_0 = layerRightXPos;
    }
     else if (port.side == WEST) {
      bendPoint.x_0 = layerLeftXPos;
    }
     else {
      continue;
    }
    if (absolutePortAnchor.x_0 == bendPoint.x_0) {
      continue;
    }
    addJunctionPoint = port.outgoingEdges.array.length + port.incomingEdges.array.length > 1;
    for (e$iterator = $iterator(concat(($clinit_ImmutableList() , new RegularImmutableList(nullCheckedList(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [port.incomingEdges, port.outgoingEdges])))))); $hasNext_0(e$iterator);) {
      e = castTo($next_2(e$iterator), 12);
      otherPort = e.source == port?e.target:e.source;
      abs_0(sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [otherPort.owner.pos, otherPort.pos, otherPort.anchor])).y_0 - bendPoint.y_0) > 1 && $addBendPoint(this$static, e, bendPoint, addJunctionPoint, port);
    }
  }
}

function PolylineEdgeRouter(){
  $clinit_PolylineEdgeRouter();
  this.createdJunctionPoints = new HashSet;
}

defineClass(535, 1, $intern_64, PolylineEdgeRouter);
_.getIntermediateProcessingConfiguration = function getIntermediateProcessingConfiguration_12(graph){
  var configuration, graphProperties;
  graphProperties = castTo($getProperty(graph, ($clinit_InternalProperties() , GRAPH_PROPERTIES)), 18);
  configuration = new IntermediateProcessingConfiguration;
  if (graphProperties.contains(($clinit_GraphProperties() , NON_FREE_PORTS)) || unsafeCast(checkNotNull_1(castToBoolean($getProperty(graph, ($clinit_Properties() , FEEDBACK_EDGES)))))) {
    $addAll_4(configuration, INVERTED_PORT_PROCESSING_ADDITIONS_0);
    graphProperties.contains(NORTH_SOUTH_PORTS) && $addAll_4(configuration, NORTH_SOUTH_PORT_PROCESSING_ADDITIONS_0);
  }
  graphProperties.contains(CENTER_LABELS) && $addAll_4(configuration, CENTER_EDGE_LABEL_PROCESSING_ADDITIONS_0);
  graphProperties.contains(END_LABELS) && $addAll_4(configuration, END_EDGE_LABEL_PROCESSING_ADDITIONS_0);
  return configuration;
}
;
_.process = function process_59(layeredGraph, monitor){
  var edgeSpaceFac, externalLayer, layer, layerIter, layerSpacing, maxCurrOutputYDiff, maxVertDiff, node, node$iterator, nodeSpacing, outgoingEdge, outgoingEdge$iterator, sourcePos, targetPos, xpos, yDiff, sourcePort, targetPort, midY, bendPoint;
  $begin(monitor, 'Polyline edge routing', 1);
  nodeSpacing = castTo($getProperty(layeredGraph, ($clinit_InternalProperties() , SPACING_0)), 15).value_0;
  edgeSpaceFac = castTo($getProperty(layeredGraph, ($clinit_Properties() , EDGE_SPACING_FACTOR)), 15).value_0;
  xpos = 0;
  if (layeredGraph.layers.array.length != 0) {
    yDiff = $calculateWestInLayerEdgeYDiff(castTo($get_8(layeredGraph.layers, 0), 16));
    xpos = 0.4 * edgeSpaceFac * yDiff;
  }
  layerIter = new AbstractList$ListIteratorImpl(layeredGraph.layers, 0);
  while (layerIter.i < layerIter.this$01_0.size_1()) {
    layer = (checkCriticalElement(layerIter.i < layerIter.this$01_0.size_1()) , castTo(layerIter.this$01_0.get_2(layerIter.last = layerIter.i++), 16));
    externalLayer = all_0(layer, PRED_EXTERNAL_WEST_OR_EAST_PORT);
    externalLayer && xpos > 0 && (xpos -= nodeSpacing);
    placeNodesHorizontally(layer, xpos);
    maxVertDiff = 0;
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      maxCurrOutputYDiff = 0;
      for (outgoingEdge$iterator = $iterator($getOutgoingEdges_0(node)); $hasNext_0(outgoingEdge$iterator);) {
        outgoingEdge = castTo($next_2(outgoingEdge$iterator), 12);
        sourcePos = $getAbsoluteAnchor(outgoingEdge.source).y_0;
        targetPos = $getAbsoluteAnchor(outgoingEdge.target).y_0;
        if (layer == outgoingEdge.target.owner.layer) {
          sourcePort = outgoingEdge.source;
          targetPort = outgoingEdge.target;
          midY = (sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [sourcePort.owner.pos, sourcePort.pos, sourcePort.anchor])).y_0 + sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [targetPort.owner.pos, targetPort.pos, targetPort.anchor])).y_0) / 2;
          sourcePort.side == ($clinit_PortSide() , EAST)?(bendPoint = new KVector_1(xpos + sourcePort.owner.layer.size_0.x_0 + 0.4 * edgeSpaceFac * (sourcePos - targetPos <= 0?0 - (sourcePos - targetPos):sourcePos - targetPos), midY)):(bendPoint = new KVector_1(xpos - 0.4 * edgeSpaceFac * (sourcePos - targetPos <= 0?0 - (sourcePos - targetPos):sourcePos - targetPos), midY));
          $add_2(outgoingEdge.bendPoints, 0, bendPoint);
          if (outgoingEdge.source.side == WEST) {
            sourcePos = 0;
            targetPos = 0;
          }
        }
        maxCurrOutputYDiff = maxCurrOutputYDiff > (targetPos - sourcePos <= 0?0 - (targetPos - sourcePos):targetPos - sourcePos)?maxCurrOutputYDiff:targetPos - sourcePos <= 0?0 - (targetPos - sourcePos):targetPos - sourcePos;
      }
      switch (node.type_0.ordinal) {
        case 0:
        case 4:
        case 1:
        case 3:
          $processNode_0(this, node, xpos);
      }
      maxVertDiff = maxVertDiff > maxCurrOutputYDiff?maxVertDiff:maxCurrOutputYDiff;
    }
    if (layerIter.i < layerIter.this$01_0.size_1()) {
      yDiff = $calculateWestInLayerEdgeYDiff((checkCriticalElement(layerIter.i < layerIter.this$01_0.size_1()) , castTo(layerIter.this$01_0.get_2(layerIter.last = layerIter.i++), 16)));
      maxVertDiff = maxVertDiff > yDiff?maxVertDiff:yDiff;
      checkCriticalElement(layerIter.i > 0);
      layerIter.this$01.get_2(layerIter.last = --layerIter.i);
    }
    layerSpacing = 0.4 * edgeSpaceFac * maxVertDiff;
    !externalLayer && layerIter.i < layerIter.this$01_0.size_1() && (layerSpacing += nodeSpacing);
    xpos += layer.size_0.x_0 + layerSpacing;
  }
  this.createdJunctionPoints.map_0.clear_0();
  layeredGraph.size_0.x_0 = xpos;
  $done(monitor);
}
;
var CENTER_EDGE_LABEL_PROCESSING_ADDITIONS_0, END_EDGE_LABEL_PROCESSING_ADDITIONS_0, INVERTED_PORT_PROCESSING_ADDITIONS_0, NORTH_SOUTH_PORT_PROCESSING_ADDITIONS_0, PRED_EXTERNAL_WEST_OR_EAST_PORT;
var Lde_cau_cs_kieler_klay_layered_p5edges_PolylineEdgeRouter_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p5edges', 'PolylineEdgeRouter', 535);
function $apply_10(node){
  var extPortSide;
  extPortSide = castTo($getProperty(node, ($clinit_InternalProperties() , EXT_PORT_SIDE)), 32);
  return node.type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT) && (extPortSide == ($clinit_PortSide() , WEST) || extPortSide == EAST);
}

function PolylineEdgeRouter$1(){
}

defineClass(536, 1, $intern_52, PolylineEdgeRouter$1);
_.apply_1 = function apply_51(node){
  return $apply_10(castTo(node, 9));
}
;
var Lde_cau_cs_kieler_klay_layered_p5edges_PolylineEdgeRouter$1_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p5edges', 'PolylineEdgeRouter/1', 536);
function $addPort(this$static, port){
  if ($hasNonLoopEdge(this$static, port)) {
    $add_18(this$static.portsWithNonLoopEdge, port);
    return true;
  }
  port.side != ($clinit_PortSide() , UNDEFINED_4) && $add_18(this$static.portsWithPortSide, port);
  port.outgoingEdges.array.length == 0?$add_18(this$static.exclusiveLoopTargetPorts, port):$add_18(this$static.exclusiveLoopSourcePorts, port);
  return false;
}

function $calculateNewTextSize(this$static, edge){
  var edgeMaxTextWidth, edgeTextHeight, label_0, label$iterator;
  edgeMaxTextWidth = 0;
  edgeTextHeight = 0;
  for (label$iterator = new ArrayList$1(edge.labels); label$iterator.i < label$iterator.this$01.array.length;) {
    label_0 = castTo($next_8(label$iterator), 33);
    edgeMaxTextWidth = max_1(edgeMaxTextWidth, label_0.size_0.x_0);
    edgeTextHeight += label_0.size_0.y_0;
  }
  $setProperty(edge, ($clinit_InternalProperties() , SPLINE_LABEL_SIZE), new KVector_1(edgeMaxTextWidth, edgeTextHeight));
  this$static.textWidth < edgeMaxTextWidth && (this$static.textWidth = edgeMaxTextWidth);
  this$static.textHeight += edgeTextHeight;
}

function $getHidablePorts(this$static){
  var allPorts;
  allPorts = newLinkedList(this$static.exclusiveLoopSourcePorts);
  $addAll(allPorts, this$static.exclusiveLoopTargetPorts);
  $addAll(allPorts, this$static.portsWithPortSide);
  return allPorts;
}

function $getTargetLoopPortsReversed(this$static){
  var list, port, port$iterator, retVal;
  retVal = new LinkedHashSet;
  list = new ArrayList_1(this$static.exclusiveLoopTargetPorts);
  reverse_3(list);
  for (port$iterator = new ArrayList$1(list); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_8(port$iterator), 7);
    retVal.map_0.put(port, retVal);
  }
  return retVal;
}

function $hasNonLoopEdge(this$static, port){
  var edge, edge$iterator, edge$iterator0;
  for (edge$iterator0 = new ArrayList$1(port.outgoingEdges); edge$iterator0.i < edge$iterator0.this$01.array.length;) {
    edge = castTo($next_8(edge$iterator0), 12);
    if (edge.target.owner != this$static.owner) {
      return true;
    }
  }
  for (edge$iterator = new ArrayList$1(port.incomingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
    edge = castTo($next_8(edge$iterator), 12);
    if (edge.source.owner != this$static.owner) {
      return true;
    }
  }
  return false;
}

function $setLoopSide(this$static, side, alsoForEdges){
  var edge, edge$iterator, entry, outerIter;
  this$static.loopSide = side;
  if (alsoForEdges) {
    for (edge$iterator = (outerIter = (new AbstractMap$1(this$static.edges.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter)); edge$iterator.val$outerIter2.hasNext_0();) {
      edge = (entry = castTo(edge$iterator.val$outerIter2.next_1(), 21) , castTo(entry.getKey(), 12));
      $setProperty(edge, ($clinit_InternalProperties() , SPLINE_LOOPSIDE), this$static.loopSide);
      $setSide(edge.source, side.source);
      $setSide(edge.target, side.target);
    }
  }
}

function $tryAddEdge(this$static, edge, isFixedOrder){
  var edgeMustBeHidden, source, target;
  source = edge.source;
  target = edge.target;
  edgeMustBeHidden = isFixedOrder;
  if ($add_18(this$static.edges, edge)) {
    $addPort(this$static, source) && (edgeMustBeHidden = true);
    $addPort(this$static, target) && (edgeMustBeHidden = true);
    if (edgeMustBeHidden) {
      $remove_7(edge.source.outgoingEdges, edge);
      $remove_7(edge.target.incomingEdges, edge);
      $add_18(this$static.hiddenEdges, edge);
    }
    $calculateNewTextSize(this$static, edge);
    return true;
  }
  return false;
}

function $unhideEdges(this$static){
  var edge, edge$iterator, entry, outerIter;
  for (edge$iterator = (outerIter = (new AbstractMap$1(this$static.hiddenEdges.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter)); edge$iterator.val$outerIter2.hasNext_0();) {
    edge = (entry = castTo(edge$iterator.val$outerIter2.next_1(), 21) , castTo(entry.getKey(), 12));
    $add_11(edge.source.outgoingEdges, edge);
    $add_11(edge.target.incomingEdges, edge);
  }
}

function ConnectedSelfLoopComponent(node){
  this.edges = new LinkedHashSet;
  this.hiddenEdges = new LinkedHashSet;
  this.exclusiveLoopSourcePorts = new LinkedHashSet;
  this.exclusiveLoopTargetPorts = new LinkedHashSet;
  this.portsWithNonLoopEdge = new LinkedHashSet;
  this.portsWithPortSide = new LinkedHashSet;
  this.owner = node;
}

defineClass(75, 1, {75:1}, ConnectedSelfLoopComponent);
_.toString_0 = function toString_68(){
  var port, port$iterator, retVal, text_0;
  retVal = new StringBuilder;
  !!this.loopSide && $append_3($append_3(retVal, $toString_2(this.loopSide)), ': ');
  for (port$iterator = $listIterator_2($getHidablePorts(this), 0); port$iterator.currentNode != port$iterator.this$01.tail;) {
    port = castTo($next_11(port$iterator), 7);
    $append_3($append_3($append($append_3(retVal, (text_0 = $getName_0(port) , text_0 == null?'p_' + port.id_0:'p_' + text_0)), 32), $toString_2(port.side)), ' / ');
  }
  return $substring(retVal, length_1(retVal.string) - 2 - 1);
}
;
_.textHeight = 0;
_.textWidth = 0;
var Lde_cau_cs_kieler_klay_layered_p5edges_splines_ConnectedSelfLoopComponent_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p5edges.splines', 'ConnectedSelfLoopComponent', 75);
function $clinit_LoopSide(){
  $clinit_LoopSide = emptyMethod;
  N = new LoopSide('N', 0, ($clinit_PortSide() , NORTH), NORTH, 0);
  EN = new LoopSide('EN', 1, EAST, NORTH, 1);
  E_0 = new LoopSide('E', 2, EAST, EAST, 0);
  SE = new LoopSide('SE', 3, SOUTH, EAST, 1);
  S = new LoopSide('S', 4, SOUTH, SOUTH, 0);
  WS = new LoopSide('WS', 5, WEST, SOUTH, 1);
  W = new LoopSide('W', 6, WEST, WEST, 0);
  NW = new LoopSide('NW', 7, NORTH, WEST, 1);
  ENW = new LoopSide('ENW', 8, EAST, WEST, 2);
  ESW = new LoopSide('ESW', 9, EAST, WEST, 2);
  SEN = new LoopSide('SEN', 10, SOUTH, NORTH, 2);
  SWN = new LoopSide('SWN', 11, SOUTH, NORTH, 2);
  UNDEFINED_6 = new LoopSide('UNDEFINED', 12, UNDEFINED_4, UNDEFINED_4, 3);
  ALL = of_0(N, EN, E_0, SE, S, WS, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_p5edges_splines_LoopSide_2_classLit, 1), $intern_13, 60, 0, [W, NW, ENW, ESW, SEN, SWN]));
  ALL_STRAIGHTS = ($clinit_ImmutableCollection() , create(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [N, E_0, S, W])));
  ALL_CORNERS = create(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [EN, SE, WS, NW]));
  SIDES_N = new SingletonImmutableSet(NORTH);
  SIDES_EN = create(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [EAST, NORTH]));
  SIDES_E = new SingletonImmutableSet(EAST);
  SIDES_SE = create(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [SOUTH, EAST]));
  SIDES_S = new SingletonImmutableSet(SOUTH);
  SIDES_WS = create(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [WEST, SOUTH]));
  SIDES_W = new SingletonImmutableSet(WEST);
  SIDES_NW = create(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [NORTH, WEST]));
  SIDES_ENW = create(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [EAST, NORTH, WEST]));
  SIDES_ESW = create(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [EAST, SOUTH, WEST]));
  SIDES_SWN = create(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [SOUTH, WEST, NORTH]));
  SIDES_SEN = create(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [SOUTH, EAST, NORTH]));
  SIDES_UNDEF = ($clinit_RegularImmutableSet() , EMPTY_1);
}

function $getMiddleSide(this$static){
  switch (this$static.ordinal) {
    case 8:
      return $clinit_PortSide() , NORTH;
    case 9:
      return $clinit_PortSide() , SOUTH;
    case 10:
      return $clinit_PortSide() , EAST;
    case 11:
      return $clinit_PortSide() , WEST;
    default:return $clinit_PortSide() , UNDEFINED_4;
  }
}

function $getPortSides(this$static){
  switch (this$static.ordinal) {
    case 0:
      return SIDES_N;
    case 1:
      return SIDES_EN;
    case 2:
      return SIDES_E;
    case 3:
      return SIDES_SE;
    case 4:
      return SIDES_S;
    case 5:
      return SIDES_WS;
    case 6:
      return SIDES_W;
    case 7:
      return SIDES_NW;
    case 8:
      return SIDES_ENW;
    case 9:
      return SIDES_ESW;
    case 11:
      return SIDES_SWN;
    case 10:
      return SIDES_SEN;
    default:return SIDES_UNDEF;
  }
}

function $left(this$static){
  switch (this$static.ordinal) {
    case 0:
      return NW;
    case 1:
      return N;
    case 2:
      return EN;
    case 3:
      return E_0;
    case 4:
      return SE;
    case 5:
      return S;
    case 6:
      return WS;
    case 7:
      return W;
    case 8:
      return ESW;
    case 9:
      return ENW;
    case 10:
      return SWN;
    case 11:
      return SEN;
    default:return UNDEFINED_6;
  }
}

function $opposite_0(this$static){
  switch (this$static.ordinal) {
    case 0:
      return S;
    case 1:
      return WS;
    case 2:
      return W;
    case 3:
      return NW;
    case 4:
      return N;
    case 5:
      return EN;
    case 6:
      return E_0;
    case 7:
      return SE;
    case 8:
      return ESW;
    case 9:
      return ENW;
    case 10:
      return SWN;
    case 11:
      return SEN;
    default:return UNDEFINED_6;
  }
}

function $right(this$static){
  switch (this$static.ordinal) {
    case 0:
      return EN;
    case 1:
      return E_0;
    case 2:
      return SE;
    case 3:
      return S;
    case 4:
      return WS;
    case 5:
      return W;
    case 6:
      return NW;
    case 7:
      return N;
    case 8:
      return ESW;
    case 9:
      return ENW;
    case 10:
      return SWN;
    case 11:
      return SEN;
    default:return UNDEFINED_6;
  }
}

function $viaNW(this$static){
  if (this$static == NW || this$static == ENW) {
    return true;
  }
  return false;
}

function LoopSide(enum$name, enum$ordinal, source, target, type_0){
  Enum.call(this, enum$name, enum$ordinal);
  this.source = source;
  this.target = target;
  this.type_0 = type_0;
}

function fromPortSide(side0, side1){
  $clinit_LoopSide();
  if (side0 == side1) {
    return fromPortSides(side0);
  }
  switch (side0.ordinal) {
    case 1:
      switch (side1.ordinal) {
        case 4:
          return NW;
        case 1:
          return N;
        case 2:
          return EN;
        case 3:
          return SEN;
      }

    case 2:
      switch (side1.ordinal) {
        case 1:
          return EN;
        case 2:
          return E_0;
        case 3:
          return SE;
        case 4:
          return ENW;
      }

    case 3:
      switch (side1.ordinal) {
        case 2:
          return SE;
        case 3:
          return S;
        case 4:
          return WS;
        case 1:
          return SEN;
      }

    case 4:
      switch (side1.ordinal) {
        case 3:
          return WS;
        case 4:
          return W;
        case 1:
          return NW;
        case 2:
          return ENW;
      }

  }
  return UNDEFINED_6;
}

function fromPortSides(side){
  $clinit_LoopSide();
  switch (side.ordinal) {
    case 1:
      return N;
    case 2:
      return E_0;
    case 3:
      return S;
    case 4:
      return W;
    default:return UNDEFINED_6;
  }
}

function values_44(){
  $clinit_LoopSide();
  return stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_p5edges_splines_LoopSide_2_classLit, 1), $intern_13, 60, 0, [N, EN, E_0, SE, S, WS, W, NW, ENW, ESW, SEN, SWN, UNDEFINED_6]);
}

defineClass(60, 17, {60:1, 3:1, 23:1, 17:1}, LoopSide);
_.type_0 = 0;
var ALL, ALL_CORNERS, ALL_STRAIGHTS, E_0, EN, ENW, ESW, N, NW, S, SE, SEN, SIDES_E, SIDES_EN, SIDES_ENW, SIDES_ESW, SIDES_N, SIDES_NW, SIDES_S, SIDES_SE, SIDES_SEN, SIDES_SWN, SIDES_UNDEF, SIDES_W, SIDES_WS, SWN, UNDEFINED_6, W, WS;
var Lde_cau_cs_kieler_klay_layered_p5edges_splines_LoopSide_2_classLit = createForEnum('de.cau.cs.kieler.klay.layered.p5edges.splines', 'LoopSide', 60, Ljava_lang_Enum_2_classLit, values_44);
function $$init_5(this$static){
  this$static.knotVector = new ArrayList;
  this$static.controlPoints = new ArrayList;
}

function $createUniformKnotVector(this$static, size_0){
  var i, i0, i1, mySize;
  if (size_0 < 2 * this$static.dimNUBS) {
    throw new IllegalArgumentException_0('The knot vector must have at least two time the dimension elements.');
  }
  this$static.minKnot = 0;
  this$static.maxKnot = 1;
  for (i0 = 0; i0 < this$static.dimNUBS; i0++) {
    this$static.knotVector.add_1(0);
  }
  mySize = size_0 + 1 - 2 * this$static.dimNUBS;
  for (i1 = 1; i1 < mySize; i1++) {
    this$static.knotVector.add_1(i1 / mySize);
  }
  if (this$static.isClamped) {
    for (i = 0; i < this$static.dimNUBS; i++) {
      this$static.knotVector.add_1(1);
    }
  }
}

function $getBezierCP(this$static){
  var iter, retVal;
  this$static.isBezier || $toBezier(this$static);
  retVal = new KVectorChain;
  iter = this$static.controlPoints.iterator_0();
  iter.next_1();
  while (iter.hasNext_0()) {
    $add_8(retVal, castTo(iter.next_1(), 92).cp);
  }
  checkCriticalElement(retVal.size_0 != 0);
  $removeNode_0(retVal, retVal.tail.prev);
  return retVal;
}

function $getControlPoint(this$static, i){
  return castTo(this$static.controlPoints.get_2(i), 92).cp;
}

function $getControlPoints(this$static){
  var polarCP, polarCP$iterator, retVal;
  retVal = new KVectorChain;
  for (polarCP$iterator = this$static.controlPoints.iterator_0(); polarCP$iterator.hasNext_0();) {
    polarCP = castTo(polarCP$iterator.next_1(), 92);
    $add_8(retVal, polarCP.cp);
  }
  return retVal;
}

function $getIndexInKnotVector(this$static, knot){
  var currentKnot, diff, iter;
  iter = this$static.knotVector.listIterator_0();
  while (iter.hasNext_0()) {
    currentKnot = checkNotNull_1(castToDouble(iter.next_1()));
    diff = currentKnot - knot <= 0?0 - (currentKnot - knot):currentKnot - knot;
    if (diff < $intern_70) {
      return iter.nextIndex_0() - 1;
    }
  }
  return this$static.knotVector.size_1();
}

function $getMultiplicity(this$static, knotToCheck){
  var count, currentKnot, diff, iter;
  iter = this$static.knotVector.listIterator_0();
  count = 0;
  while (iter.hasNext_0()) {
    currentKnot = checkNotNull_1(castToDouble(iter.next_1()));
    diff = currentKnot - knotToCheck;
    if (diff > $intern_70) {
      return count;
    }
     else 
      diff > $intern_71 && ++count;
  }
  return count;
}

function $getPointOnCurve(this$static, t, modify){
  var copy, multiplicity;
  multiplicity = $getMultiplicity(this$static, t);
  if (multiplicity == this$static.dimNUBS) {
    return $getControlPoint(this$static, $getIndexInKnotVector(this$static, t));
  }
  if (modify) {
    $insertKnot(this$static, t, this$static.dimNUBS - multiplicity);
    return $getControlPoint(this$static, $getIndexInKnotVector(this$static, t));
  }
   else {
    copy = new NubSpline(this$static);
    $insertKnot(copy, t, this$static.dimNUBS - multiplicity);
    return $getControlPoint(copy, $getIndexInKnotVector(copy, t));
  }
}

function $insertKnot(this$static, knotToInsert, insertions){
  var currentKnot, i, iterCP, iterKnot;
  iterKnot = this$static.knotVector.listIterator_0();
  if (this$static.isClamped) {
    for (i = 0; i < this$static.dimNUBS; i++) {
      iterKnot.next_1();
    }
  }
   else {
    for (i = 0; i < this$static.dimNUBS - 1; i++) {
      iterKnot.next_1();
    }
  }
  iterCP = this$static.controlPoints.listIterator_0();
  currentKnot = checkNotNull_1(castToDouble(iterKnot.next_1()));
  while (currentKnot - knotToInsert < $intern_70) {
    currentKnot = checkNotNull_1(castToDouble(iterKnot.next_1()));
    iterCP.next_1();
  }
  iterKnot.previous_0();
  $insertKnotAtCurrentPosition(this$static, insertions, knotToInsert, iterCP, iterKnot);
}

function $insertKnotAtCurrentPosition(this$static, insertions, knotToInsert, iterCP, iterKnot){
  var cp, cp$iterator, firstCP, i, j, j0, j1, multiplicity, newCPs, secondCP;
  multiplicity = $getMultiplicity(this$static, knotToInsert);
  for (i = 0; i < insertions; i++) {
    iterKnot.add_0(knotToInsert);
    newCPs = new ArrayList;
    secondCP = castTo(iterCP.next_1(), 92);
    for (j0 = multiplicity + i; j0 < this$static.dimNUBS; j0++) {
      firstCP = secondCP;
      secondCP = castTo(iterCP.next_1(), 92);
      $add_11(newCPs, new NubSpline$PolarCP_0(firstCP, secondCP, knotToInsert));
    }
    for (j1 = multiplicity + i; j1 < this$static.dimNUBS; j1++) {
      iterCP.previous_0();
      j1 > multiplicity + i && iterCP.remove();
    }
    for (cp$iterator = new ArrayList$1(newCPs); cp$iterator.i < cp$iterator.this$01.array.length;) {
      cp = castTo($next_8(cp$iterator), 92);
      iterCP.add_0(cp);
    }
    if (i < insertions - 1) {
      for (j = multiplicity + i; j < this$static.dimNUBS; j++) {
        iterCP.previous_0();
      }
    }
  }
}

function $setOuterBox(this$static, outerRectange){
  this$static.outerBox = outerRectange;
}

function $toBezier(this$static){
  var currentKnot, i, iterCP, iterKnot, knotToCount, occurrence;
  iterKnot = this$static.knotVector.listIterator_0();
  iterCP = this$static.controlPoints.listIterator_0();
  if (this$static.isClamped) {
    for (i = 0; i < this$static.dimNUBS; i++) {
      iterKnot.next_1();
    }
  }
   else {
    for (i = 0; i < this$static.dimNUBS - 1; i++) {
      iterKnot.next_1();
      iterKnot.remove();
    }
  }
  currentKnot = checkNotNull_1(castToDouble(iterKnot.next_1()));
  while (this$static.maxKnot - currentKnot > $intern_70) {
    knotToCount = currentKnot;
    occurrence = 0;
    while ((currentKnot - knotToCount <= 0?0 - (currentKnot - knotToCount):currentKnot - knotToCount) < $intern_70) {
      ++occurrence;
      currentKnot = checkNotNull_1(castToDouble(iterKnot.next_1()));
      iterCP.next_1();
    }
    if (occurrence < this$static.dimNUBS) {
      iterKnot.previous_0();
      $insertKnotAtCurrentPosition(this$static, this$static.dimNUBS - occurrence, knotToCount, iterCP, iterKnot);
      iterKnot.next_1();
    }
    iterCP.previous_0();
  }
  if (!this$static.isClamped) {
    for (i = 0; i < this$static.dimNUBS - 1; i++) {
      iterKnot.next_1();
      iterKnot.remove();
    }
  }
  this$static.isClamped = true;
  this$static.isBezier = true;
}

function NubSpline(nubSpline){
  $$init_5(this);
  this.dimNUBS = nubSpline.dimNUBS;
  this.isUniform = nubSpline.isUniform;
  this.isClamped = nubSpline.isClamped;
  this.outerBox = nubSpline.outerBox;
  this.isBezier = nubSpline.isBezier;
  this.knotVector = newLinkedList(nubSpline.knotVector);
  this.minKnot = nubSpline.minKnot;
  this.maxKnot = nubSpline.maxKnot;
  this.controlPoints = newLinkedList(nubSpline.controlPoints);
}

function NubSpline_0(kVectors){
  var i, i0, kVector, kVector$iterator, knotIter, polarCoordinate;
  $$init_5(this);
  for (i0 = kVectors.size_1() - 1; i0 < 3; i0++) {
    kVectors.add_2(0, castTo(kVectors.get_2(0), 10));
  }
  if (kVectors.size_1() < 4) {
    throw new IllegalArgumentException_0('At (least dimension + 1) control points are necessary!');
  }
   else {
    this.dimNUBS = 3;
    this.isClamped = true;
    this.isUniform = true;
    this.isBezier = false;
    $createUniformKnotVector(this, kVectors.size_1() + this.dimNUBS - 1);
    polarCoordinate = new ArrayList;
    knotIter = this.knotVector.iterator_0();
    for (i = 0; i < this.dimNUBS - 1; i++) {
      $add_11(polarCoordinate, castToDouble(knotIter.next_1()));
    }
    for (kVector$iterator = kVectors.iterator_0(); kVector$iterator.hasNext_0();) {
      kVector = castTo(kVector$iterator.next_1(), 10);
      $add_11(polarCoordinate, castToDouble(knotIter.next_1()));
      this.controlPoints.add_1(new NubSpline$PolarCP(kVector, polarCoordinate));
      checkCriticalElementIndex(0, polarCoordinate.array.length);
      polarCoordinate.array.splice(0, 1);
    }
  }
}

function NubSpline_1(clamped, uniform, bezier, dim, knotVec, polarVectors){
  $$init_5(this);
  this.isClamped = clamped;
  this.isUniform = uniform;
  this.isBezier = bezier;
  this.dimNUBS = dim;
  this.knotVector = knotVec;
  this.controlPoints = polarVectors;
  this.minKnot = checkNotNull_1(castToDouble(knotVec.iterator_0().next_1()));
  this.maxKnot = checkNotNull_1(castToDouble(getLast(knotVec)));
}

function generateDerivedNUBS(nubSpline){
  var i, i0, kVector, kVector$iterator, knotIter, newBezier, newCP, newClamped, newControlPoints, newDim, newKnotVector, newPolarVectors, newUniform, oldDim, oldKnotVector, polarCoordinate;
  newClamped = nubSpline.isClamped;
  newUniform = nubSpline.isUniform;
  newBezier = nubSpline.isBezier;
  oldDim = nubSpline.dimNUBS;
  newDim = oldDim - 1;
  oldKnotVector = nubSpline.knotVector;
  newKnotVector = newLinkedList(nubSpline.knotVector.subList(1, nubSpline.knotVector.size_1() - 1));
  newControlPoints = new ArrayList;
  for (i0 = 0; i0 < nubSpline.controlPoints.size_1() - 1; i0++) {
    newCP = $scale($sub_0($clone(castTo(nubSpline.controlPoints.get_2(i0 + 1), 92).cp), castTo(nubSpline.controlPoints.get_2(i0), 92).cp), oldDim / (checkNotNull_1(castToDouble(oldKnotVector.get_2(i0 + oldDim))) - checkNotNull_1(castToDouble(oldKnotVector.get_2(i0)))));
    newControlPoints.array[newControlPoints.array.length] = newCP;
  }
  polarCoordinate = new ArrayList;
  knotIter = $listIterator_2(newKnotVector, 0);
  newPolarVectors = new ArrayList;
  for (i = 0; i < newDim - 1; i++) {
    $add_11(polarCoordinate, castToDouble($next_11(knotIter)));
  }
  for (kVector$iterator = new ArrayList$1(newControlPoints); kVector$iterator.i < kVector$iterator.this$01.array.length;) {
    kVector = castTo($next_8(kVector$iterator), 10);
    $add_11(polarCoordinate, castToDouble($next_11(knotIter)));
    $add_11(newPolarVectors, new NubSpline$PolarCP(kVector, polarCoordinate));
    checkCriticalElementIndex(0, polarCoordinate.array.length);
    polarCoordinate.array.splice(0, 1);
  }
  return new NubSpline_1(newClamped, newUniform, newBezier, newDim, newKnotVector, newPolarVectors);
}

function generateInvertedNUBS(nubSpline){
  var i, kVector, kVector$iterator, knotIter, maxVector, newControlPoints, newKnotVector, newPolarVectors, polarCoordinate, vector, vector$iterator;
  newKnotVector = new ArrayList;
  maxVector = checkNotNull_1(castToDouble(nubSpline.knotVector.get_2(nubSpline.knotVector.size_1() - 1)));
  for (vector$iterator = nubSpline.knotVector.iterator_0(); vector$iterator.hasNext_0();) {
    vector = castToDouble(vector$iterator.next_1());
    $add_10(newKnotVector, 0, maxVector - (checkCriticalNotNull(vector) , vector));
  }
  newControlPoints = reverse_1($getControlPoints(nubSpline));
  polarCoordinate = new ArrayList;
  knotIter = new ArrayList$1(newKnotVector);
  newPolarVectors = new ArrayList;
  for (i = 0; i < nubSpline.dimNUBS - 1; i++) {
    $add_11(polarCoordinate, castToDouble($next_8(knotIter)));
  }
  for (kVector$iterator = $listIterator_2(newControlPoints, 0); kVector$iterator.currentNode != kVector$iterator.this$01.tail;) {
    kVector = castTo($next_11(kVector$iterator), 10);
    $add_11(polarCoordinate, castToDouble($next_8(knotIter)));
    $add_11(newPolarVectors, new NubSpline$PolarCP(kVector, polarCoordinate));
    checkCriticalElementIndex(0, polarCoordinate.array.length);
    polarCoordinate.array.splice(0, 1);
  }
  return new NubSpline_1(nubSpline.isClamped, nubSpline.isUniform, nubSpline.isBezier, nubSpline.dimNUBS, newKnotVector, newPolarVectors);
}

function getFirstHorizontalPoint(nubSpline){
  var currentAccuracy, currentVector, firstDerive, knot, loopCount;
  firstDerive = generateDerivedNUBS(nubSpline);
  currentAccuracy = $intern_60;
  loopCount = 0;
  knot = 0;
  while (currentAccuracy > 0.5 && loopCount < 50) {
    knot = getZeroYOfControlPoligon(firstDerive);
    currentVector = $getPointOnCurve(firstDerive, knot, true);
    currentAccuracy = abs_0(currentVector.y_0);
    ++loopCount;
  }
  return $getPointOnCurve(nubSpline, knot, false);
}

function getFirstVerticalPoint(nubSpline){
  var currentAccuracy, currentVector, firstDerive, knot, loopCount;
  firstDerive = generateDerivedNUBS(nubSpline);
  currentAccuracy = $intern_60;
  loopCount = 0;
  knot = 0;
  while (currentAccuracy > 0.5 && loopCount < 50) {
    knot = getZeroXOfControlPoligon(firstDerive);
    currentVector = $getPointOnCurve(firstDerive, knot, true);
    currentAccuracy = abs_0(currentVector.x_0);
    ++loopCount;
  }
  return $getPointOnCurve(nubSpline, knot, false);
}

function getLastHorizontalPoint(nubSpline){
  var currentAccuracy, currentVector, firstDerive, knot, loopCount, maxVal;
  firstDerive = generateInvertedNUBS(generateDerivedNUBS(nubSpline));
  currentAccuracy = $intern_60;
  loopCount = 0;
  knot = 0;
  while (currentAccuracy > 0.5 && loopCount < 50) {
    knot = getZeroYOfControlPoligon(firstDerive);
    currentVector = $getPointOnCurve(firstDerive, knot, true);
    currentAccuracy = abs_0(currentVector.y_0);
    ++loopCount;
  }
  maxVal = castToDouble($get_4(newLinkedList(nubSpline.knotVector), newLinkedList(nubSpline.knotVector).size_0 - 1));
  return $getPointOnCurve(nubSpline, (checkCriticalNotNull(maxVal) , maxVal) - knot, false);
}

function getLastVerticalPoint(nubSpline){
  var currentAccuracy, currentVector, firstDerive, knot, loopCount, maxVal;
  firstDerive = generateInvertedNUBS(generateDerivedNUBS(nubSpline));
  currentAccuracy = $intern_60;
  loopCount = 0;
  knot = 0;
  while (currentAccuracy > 0.5 && loopCount < 50) {
    knot = getZeroXOfControlPoligon(firstDerive);
    currentVector = $getPointOnCurve(firstDerive, knot, true);
    currentAccuracy = abs_0(currentVector.x_0);
    ++loopCount;
  }
  maxVal = castToDouble($get_4(newLinkedList(nubSpline.knotVector), newLinkedList(nubSpline.knotVector).size_0 - 1));
  return $getPointOnCurve(nubSpline, (checkCriticalNotNull(maxVal) , maxVal) - knot, false);
}

function getTFromPolar(polar){
  var sum, val, val$iterator;
  sum = 0;
  for (val$iterator = polar.iterator_0(); val$iterator.hasNext_0();) {
    val = castToDouble(val$iterator.next_1());
    sum += (checkCriticalNotNull(val) , val);
  }
  return sum / polar.size_1();
}

function getZeroXOfControlPoligon(nubSpline){
  var factor, firstCP, firstIsNegative, firstIsPositive, firstX, iter, secondCP, secondIsNegative, secondIsPositive, secondX, t1, t2;
  iter = nubSpline.controlPoints.iterator_0();
  secondCP = castTo(iter.next_1(), 92);
  secondX = secondCP.cp.x_0;
  secondIsPositive = secondX > $intern_70;
  secondIsNegative = secondX < $intern_71;
  while (iter.hasNext_0()) {
    firstCP = secondCP;
    firstX = secondX;
    firstIsPositive = secondIsPositive;
    firstIsNegative = secondIsNegative;
    secondCP = castTo(iter.next_1(), 92);
    secondX = secondCP.cp.x_0;
    secondIsPositive = secondX > $intern_70;
    secondIsNegative = secondX < $intern_71;
    if (!(secondIsPositive || secondIsNegative)) {
      return getTFromPolar(secondCP.polarCoordinate);
    }
    if (firstIsPositive && secondIsNegative || firstIsNegative && secondIsPositive) {
      factor = firstX / (firstX - secondX);
      t1 = getTFromPolar(firstCP.polarCoordinate);
      t2 = getTFromPolar(secondCP.polarCoordinate);
      return factor * t1 + (1 - factor) * t2;
    }
  }
  return 0;
}

function getZeroYOfControlPoligon(nubSpline){
  var factor, firstCP, firstIsNegative, firstIsPositive, firstY, iter, secondCP, secondIsNegative, secondIsPositive, secondY, t1, t2;
  iter = nubSpline.controlPoints.iterator_0();
  secondCP = castTo(iter.next_1(), 92);
  secondY = secondCP.cp.y_0;
  secondIsPositive = secondY > $intern_70;
  secondIsNegative = secondY < $intern_71;
  while (iter.hasNext_0()) {
    firstCP = secondCP;
    firstY = secondY;
    firstIsPositive = secondIsPositive;
    firstIsNegative = secondIsNegative;
    secondCP = castTo(iter.next_1(), 92);
    secondY = secondCP.cp.y_0;
    secondIsPositive = secondY > $intern_70;
    secondIsNegative = secondY < $intern_71;
    if (!(secondIsPositive || secondIsNegative)) {
      return getTFromPolar(secondCP.polarCoordinate);
    }
    if (firstIsPositive && secondIsNegative || firstIsNegative && secondIsPositive) {
      factor = firstY / (firstY - secondY);
      t1 = getTFromPolar(firstCP.polarCoordinate);
      t2 = getTFromPolar(secondCP.polarCoordinate);
      return factor * t1 + (1 - factor) * t2;
    }
  }
  return 0;
}

defineClass(203, 1, {}, NubSpline, NubSpline_0, NubSpline_1);
_.toString_0 = function toString_69(){
  return this.controlPoints.toString_0();
}
;
_.dimNUBS = 0;
_.isBezier = false;
_.isClamped = false;
_.isUniform = false;
_.maxKnot = 0;
_.minKnot = 0;
var Lde_cau_cs_kieler_klay_layered_p5edges_splines_NubSpline_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p5edges.splines', 'NubSpline', 203);
function $setCp(this$static, cp){
  this$static.cp = cp;
}

function $setPolarCoordinate(this$static, polarCoordinate){
  this$static.polarCoordinate = polarCoordinate;
}

function NubSpline$PolarCP(controlPoint, polarCoordinate){
  $setCp(this, new KVector_1(controlPoint.x_0, controlPoint.y_0));
  $setPolarCoordinate(this, newLinkedList(polarCoordinate));
}

function NubSpline$PolarCP_0(firstCP, secondCP, newKnot){
  var aScaled, bScaled, firstFactor, iter, needsToBeAdded, nextKnot, secondFactor, total;
  firstFactor = checkNotNull_1(castToDouble(firstCP.polarCoordinate.iterator_0().next_1()));
  secondFactor = checkNotNull_1(castToDouble(getLast(secondCP.polarCoordinate)));
  aScaled = $scale($clone(firstCP.cp), secondFactor - newKnot);
  bScaled = $scale($clone(secondCP.cp), newKnot - firstFactor);
  total = $add_7(aScaled, bScaled);
  $scale(total, 1 / (secondFactor - firstFactor));
  this.cp = total;
  this.polarCoordinate = new ArrayList;
  needsToBeAdded = true;
  iter = firstCP.polarCoordinate.iterator_0();
  iter.next_1();
  while (iter.hasNext_0()) {
    nextKnot = checkNotNull_1(castToDouble(iter.next_1()));
    if (needsToBeAdded && nextKnot - newKnot > $intern_70) {
      this.polarCoordinate.add_1(newKnot);
      needsToBeAdded = false;
    }
    this.polarCoordinate.add_1(nextKnot);
  }
  needsToBeAdded && this.polarCoordinate.add_1(newKnot);
}

defineClass(92, 1, {92:1}, NubSpline$PolarCP, NubSpline$PolarCP_0);
var Lde_cau_cs_kieler_klay_layered_p5edges_splines_NubSpline$PolarCP_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p5edges.splines', 'NubSpline/PolarCP', 92);
function NubsSelfLoop(kVectors){
  NubSpline_0.call(this, new Arrays$ArrayList(kVectors));
  this.firstLabelPosition = new KVector;
}

function createAcrossSelfLoop(source, sourceHeight, target, targetHeight, intermediateSide, middleHeight){
  var firstCP, fourthCP, horizontal, loopHeight, middleCP, nubs, secondCP, sourceDir, sourcePos, targetDir, targetPos, thirdCP, thirdExtremum, vertical;
  sourceDir = portSideToDirection(source.side);
  targetDir = portSideToDirection(target.side);
  sourcePos = $add_7($clone(source.pos), source.anchor);
  targetPos = $add_7($clone(target.pos), target.anchor);
  firstCP = $add_7(new KVector_2(sourcePos), $scale(new KVector_0(sourceDir), sourceHeight));
  fourthCP = $add_7(new KVector_2(targetPos), $scale(new KVector_0(targetDir), targetHeight));
  loopHeight = distPortToNodeEdge(source, intermediateSide);
  intermediateSide == ($clinit_PortSide() , SOUTH) || intermediateSide == EAST?(loopHeight += middleHeight):(loopHeight -= middleHeight);
  secondCP = new KVector;
  thirdCP = new KVector;
  switch (intermediateSide.ordinal) {
    case 1:
    case 3:
      secondCP.x_0 = firstCP.x_0;
      secondCP.y_0 = sourcePos.y_0 + loopHeight;
      thirdCP.x_0 = fourthCP.x_0;
      thirdCP.y_0 = secondCP.y_0;
      break;
    case 2:
    case 4:
      secondCP.x_0 = sourcePos.x_0 + loopHeight;
      secondCP.y_0 = firstCP.y_0;
      thirdCP.x_0 = secondCP.x_0;
      thirdCP.y_0 = fourthCP.y_0;
      break;
    default:return null;
  }
  middleCP = $scale($add_7(new KVector_1(secondCP.x_0, secondCP.y_0), thirdCP), 0.5);
  nubs = new NubsSelfLoop(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [sourcePos, firstCP, secondCP, middleCP, thirdCP, fourthCP, targetPos]));
  horizontal = getFirstHorizontalPoint(nubs);
  vertical = getFirstVerticalPoint(nubs);
  switch (intermediateSide.ordinal) {
    case 1:
    case 3:
      nubs.firstLabelPosition = horizontal;
      thirdExtremum = getLastVerticalPoint(nubs);
      break;
    case 2:
    case 4:
      nubs.firstLabelPosition = vertical;
      thirdExtremum = getLastHorizontalPoint(nubs);
      break;
    default:return null;
  }
  $setOuterBox(nubs, new Rectangle_5(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [horizontal, vertical, thirdExtremum, sourcePos, targetPos])));
  return nubs;
}

function createCornerSelfLoop(source, target, sourceHeight, targetHeight, textLength){
  var cornerX, cornerY, dist, firstCP, horizontal, nubs, secondCP, sourceDir, sourcePos, targetDir, targetPos, thirdCP, vertical;
  sourceDir = portSideToDirection(source.side);
  targetDir = portSideToDirection(target.side);
  sourcePos = $add_7($clone(source.pos), source.anchor);
  targetPos = $add_7($clone(target.pos), target.anchor);
  firstCP = $add_7(new KVector_1(sourcePos.x_0, sourcePos.y_0), $scale(new KVector_0(sourceDir), 1.3 * sourceHeight));
  thirdCP = $add_7(new KVector_1(targetPos.x_0, targetPos.y_0), $scale(new KVector_0(targetDir), 1.3 * targetHeight));
  dist = abs_0(firstCP.x_0 - thirdCP.x_0);
  dist < textLength && (source.side == ($clinit_PortSide() , WEST) || source.side == EAST?firstCP.x_0 < thirdCP.x_0?(firstCP.x_0 = thirdCP.x_0 - textLength):(firstCP.x_0 = thirdCP.x_0 + textLength):firstCP.x_0 < thirdCP.x_0?(thirdCP.x_0 = firstCP.x_0 + textLength):(thirdCP.x_0 = firstCP.x_0 - textLength));
  cornerX = 0;
  cornerY = 0;
  switch (source.side.ordinal) {
    case 4:
      cornerX = 2 * (sourcePos.x_0 - sourceHeight) - 0.5 * (firstCP.x_0 + thirdCP.x_0);
      break;
    case 2:
      cornerX = 2 * (sourcePos.x_0 + sourceHeight) - 0.5 * (firstCP.x_0 + thirdCP.x_0);
      break;
    case 1:
      cornerY = 2 * (sourcePos.y_0 - sourceHeight) - 0.5 * (firstCP.y_0 + thirdCP.y_0);
      break;
    case 3:
      cornerY = 2 * (sourcePos.y_0 + sourceHeight) - 0.5 * (firstCP.y_0 + thirdCP.y_0);
  }
  switch (target.side.ordinal) {
    case 4:
      cornerX = 2 * (targetPos.x_0 - targetHeight) - 0.5 * (thirdCP.x_0 + firstCP.x_0);
      break;
    case 2:
      cornerX = 2 * (targetPos.x_0 + targetHeight) - 0.5 * (thirdCP.x_0 + firstCP.x_0);
      break;
    case 1:
      cornerY = 2 * (targetPos.y_0 - targetHeight) - 0.5 * (thirdCP.y_0 + firstCP.y_0);
      break;
    case 3:
      cornerY = 2 * (targetPos.y_0 + targetHeight) - 0.5 * (thirdCP.y_0 + firstCP.y_0);
  }
  secondCP = new KVector_1(cornerX, cornerY);
  nubs = new NubsSelfLoop(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [sourcePos, firstCP, secondCP, thirdCP, targetPos]));
  horizontal = getFirstHorizontalPoint(nubs);
  vertical = getFirstVerticalPoint(nubs);
  nubs.firstLabelPosition = horizontal;
  $setOuterBox(nubs, new Rectangle_5(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [horizontal, vertical, sourcePos, targetPos])));
  return nubs;
}

function createSideSelfLoop(source, target, length_0){
  var direction, firstCP, labelPos, mid, nubs, secondCP, sourcePos, targetPos, thirdCP;
  direction = portSideToDirection(source.side);
  sourcePos = $add_7($clone(source.pos), source.anchor);
  targetPos = $add_7($clone(target.pos), target.anchor);
  firstCP = $add_7(new KVector_2(sourcePos), $scale(new KVector_0(direction), length_0));
  thirdCP = $add_7(new KVector_2(targetPos), $scale(new KVector_0(direction), length_0));
  mid = $scale($sub_0(new KVector_2(firstCP), thirdCP), 0.5);
  secondCP = $add_7($add_7(new KVector_2(thirdCP), mid), $scale(new KVector_0(direction), sqrt_0(mid.x_0 * mid.x_0 + mid.y_0 * mid.y_0)));
  nubs = new NubsSelfLoop(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [sourcePos, firstCP, secondCP, thirdCP, targetPos]));
  labelPos = $getPointOnCurve(nubs, 0.5, false);
  nubs.firstLabelPosition = labelPos;
  $setOuterBox(nubs, new Rectangle_5(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [labelPos, sourcePos, targetPos])));
  return nubs;
}

defineClass(281, 203, {}, NubsSelfLoop);
var Lde_cau_cs_kieler_klay_layered_p5edges_splines_NubsSelfLoop_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p5edges.splines', 'NubsSelfLoop', 281);
function $$init_6(this$static){
}

function $enlarge(this$static){
  this$static.top_0 = this$static.top_0 - 15;
  this$static.left = this$static.left - 15;
  this$static.right = this$static.right + 15;
  this$static.bottom = this$static.bottom + 15;
}

function $union_0(this$static, rectangle){
  this$static.top_0 = min_1(this$static.top_0, rectangle.top_0);
  this$static.right = max_1(this$static.right, rectangle.right);
  this$static.bottom = max_1(this$static.bottom, rectangle.bottom);
  this$static.left = min_1(this$static.left, rectangle.left);
}

function Rectangle_1(right, bottom){
  $$init_6(this);
  if (0 > bottom) {
    throw new IllegalArgumentException_0('Top must be smaller or equal to bottom.');
  }
   else if (0 > right) {
    throw new IllegalArgumentException_0('Left must be smaller or equal to right.');
  }
  this.top_0 = 0;
  this.right = right;
  this.bottom = bottom;
  this.left = 0;
}

function Rectangle_2(shape_0){
  var extend, position;
  $$init_6(this);
  position = shape_0.pos;
  extend = $add_7(new KVector_1(position.x_0, position.y_0), shape_0.size_0);
  this.top_0 = min_1(position.y_0, extend.y_0);
  this.bottom = max_1(position.y_0, extend.y_0);
  this.left = min_1(position.x_0, extend.x_0);
  this.right = max_1(position.x_0, extend.x_0);
}

function Rectangle_3(rectangle){
  $$init_6(this);
  this.top_0 = rectangle.top_0;
  this.right = rectangle.right;
  this.bottom = rectangle.bottom;
  this.left = rectangle.left;
}

function Rectangle_4(vectors){
  var vector, vector$iterator;
  if (isEmpty_12(vectors)) {
    throw new IllegalArgumentException_0('The list of vectors may not be empty.');
  }
  for (vector$iterator = $listIterator_2(vectors, 0); vector$iterator.currentNode != vector$iterator.this$01.tail;) {
    vector = castTo($next_11(vector$iterator), 10);
    this.top_0 = min_1(this.top_0, vector.y_0);
    this.right = max_1(this.right, vector.x_0);
    this.bottom = max_1(this.bottom, vector.y_0);
    this.left = min_1(this.left, vector.x_0);
  }
}

function Rectangle_5(vectors){
  var vector, vector$index, vector$max;
  $$init_6(this);
  if (vectors.length == 0) {
    throw new IllegalArgumentException_0('The list of vectors may not be empty.');
  }
  for (vector$index = 0 , vector$max = vectors.length; vector$index < vector$max; ++vector$index) {
    vector = vectors[vector$index];
    this.top_0 = min_1(this.top_0, vector.y_0);
    this.right = max_1(this.right, vector.x_0);
    this.bottom = max_1(this.bottom, vector.y_0);
    this.left = min_1(this.left, vector.x_0);
  }
}

function union(rectangle1, rectangle2){
  var retVal;
  retVal = new Rectangle_3(rectangle1);
  $union_0(retVal, rectangle2);
  return retVal;
}

defineClass(112, 1, {}, Rectangle_1, Rectangle_2, Rectangle_3, Rectangle_4, Rectangle_5);
_.bottom = $intern_45;
_.left = $intern_60;
_.right = $intern_45;
_.top_0 = $intern_60;
var Lde_cau_cs_kieler_klay_layered_p5edges_splines_Rectangle_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p5edges.splines', 'Rectangle', 112);
function $clinit_SplineEdgeRouter(){
  $clinit_SplineEdgeRouter = emptyMethod;
  SELF_LOOP_PROCESSING_ADDITIONS_0 = $addBeforePhase4($addBeforePhase4($addBeforePhase1(new IntermediateProcessingConfiguration, ($clinit_IntermediateProcessorStrategy() , SPLINE_SELF_LOOP_PREPROCESSOR)), SPLINE_SELF_LOOP_POSITIONER), SPLINE_SELF_LOOP_ROUTER);
  CENTER_EDGE_LABEL_PROCESSING_ADDITIONS_1 = $addAfterPhase5($addBeforePhase4($addBeforePhase3($addBeforePhase2(new IntermediateProcessingConfiguration, LABEL_DUMMY_INSERTER), LABEL_DUMMY_SWITCHER), LABEL_SIDE_SELECTOR), LABEL_DUMMY_REMOVER);
  INVERTED_PORT_PROCESSING_ADDITIONS_1 = $addBeforePhase3(new IntermediateProcessingConfiguration, INVERTED_PORT_PROCESSOR);
  NORTH_SOUTH_PORT_PROCESSING_ADDITIONS_1 = $addAfterPhase5($addBeforePhase3(new IntermediateProcessingConfiguration, NORTH_SOUTH_PORT_PREPROCESSOR), NORTH_SOUTH_PORT_POSTPROCESSOR);
  END_EDGE_LABEL_PROCESSING_ADDITIONS_1 = $addAfterPhase5($addBeforePhase4(new IntermediateProcessingConfiguration, LABEL_SIDE_SELECTOR), END_LABEL_PROCESSOR);
}

function $calculateBezierBendPoints(edge, succeedingEdge){
  var addMidPoint, allCP, currentBendPoints, currentEdge, gap, lastCP, lastEdge, northSouthBendPoint, nubSpline, offsetOfStraightening, originPort, sourceNodeType, sourcePort, targetPort;
  allCP = new KVectorChain;
  northSouthBendPoint = null;
  sourcePort = edge.source;
  sourceNodeType = sourcePort.owner.type_0;
  if (sourceNodeType != ($clinit_LNode$NodeType() , NORMAL) && sourceNodeType != NORTH_SOUTH_PORT) {
    throw new IllegalArgumentException_0('The target node of the edge must be a normal node or a northSouthPort.');
  }
  if (sourceNodeType == NORTH_SOUTH_PORT) {
    originPort = castTo($getProperty(sourcePort, ($clinit_InternalProperties() , ORIGIN)), 7);
    northSouthBendPoint = new KVector_1(sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [originPort.owner.pos, originPort.pos, originPort.anchor])).x_0, sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [sourcePort.owner.pos, sourcePort.pos, sourcePort.anchor])).y_0);
    sourcePort = originPort;
  }
  $addLast(allCP, sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [sourcePort.owner.pos, sourcePort.pos, sourcePort.anchor])));
  gap = max_1(5, getMarginOnPortSide(sourcePort.owner, sourcePort.side));
  offsetOfStraightening = new KVector_0(portSideToDirection(sourcePort.side));
  offsetOfStraightening.x_0 *= gap;
  offsetOfStraightening.y_0 *= gap;
  $add_8(allCP, $add_7(offsetOfStraightening, sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [sourcePort.owner.pos, sourcePort.pos, sourcePort.anchor]))));
  !!northSouthBendPoint && $addNode_0(allCP, northSouthBendPoint, allCP.tail.prev, allCP.tail);
  currentEdge = edge;
  lastEdge = edge;
  lastCP = null;
  addMidPoint = false;
  while (currentEdge) {
    currentBendPoints = currentEdge.bendPoints;
    if (currentBendPoints.size_0 != 0) {
      if (addMidPoint) {
        $add_8(allCP, $scale($add_7(lastCP, (checkCriticalElement(currentBendPoints.size_0 != 0) , castTo(currentBendPoints.header.next_0.value_0, 10))), 0.5));
        addMidPoint = false;
      }
       else {
        addMidPoint = true;
      }
      lastCP = $clone((checkCriticalElement(currentBendPoints.size_0 != 0) , castTo(currentBendPoints.tail.prev.value_0, 10)));
      $addAll(allCP, currentBendPoints);
      $reset_0(currentBendPoints);
    }
    lastEdge = currentEdge;
    currentEdge = castTo(getEntryValueOrNull($getEntry(succeedingEdge.hashCodeMap, currentEdge)), 12);
  }
  targetPort = lastEdge.target;
  if (targetPort.owner.type_0 == NORTH_SOUTH_PORT) {
    originPort = castTo($getProperty(targetPort, ($clinit_InternalProperties() , ORIGIN)), 7);
    $add_8(allCP, new KVector_1(sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [originPort.owner.pos, originPort.pos, originPort.anchor])).x_0, sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [targetPort.owner.pos, targetPort.pos, targetPort.anchor])).y_0));
    targetPort = originPort;
  }
  gap = max_1(5, getMarginOnPortSide(targetPort.owner, targetPort.side));
  offsetOfStraightening = new KVector_0(portSideToDirection(targetPort.side));
  $scale(offsetOfStraightening, gap);
  $add_8(allCP, $add_7(offsetOfStraightening, sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [targetPort.owner.pos, targetPort.pos, targetPort.anchor]))));
  $addLast(allCP, sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [targetPort.owner.pos, targetPort.pos, targetPort.anchor])));
  nubSpline = new NubSpline_0(allCP);
  $addAll(edge.bendPoints, $getBezierCP(nubSpline));
}

function $calculateNUBSBendPointStraight(hyperEdge, startPos){
  var edges, entry, outerIter;
  edges = hyperEdge.edges;
  if (edges.map_0.size_1() > 1) {
    throw new IllegalArgumentException_0('In straight hyperEdges there may be only one edge.');
  }
  $add_8((outerIter = (new AbstractMap$1(edges.map_0)).this$01.entrySet_0().iterator_0() , entry = castTo((new AbstractMap$1$1(outerIter)).val$outerIter2.next_1(), 21) , castTo(entry.getKey(), 12)).bendPoints, new KVector_1(startPos, hyperEdge.centerYPos));
}

function $calculateNUBSBendPoints(this$static, hyperEdge, startXPos, endXPos){
  var center, centerXPos, centerYPos, edge, edge$iterator, entry, outerIter, sourceAnchor, sourceStraightCP, sourceVerticalCP, targetAnchor, targetStraightCP, targetVerticalCP;
  centerXPos = startXPos + (hyperEdge.rank + 1) * this$static.edgeSpacing;
  centerYPos = hyperEdge.centerYPos;
  center = new KVector_1(centerXPos, centerYPos);
  for (edge$iterator = (outerIter = (new AbstractMap$1(hyperEdge.edges.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter)); edge$iterator.val$outerIter2.hasNext_0();) {
    edge = (entry = castTo(edge$iterator.val$outerIter2.next_1(), 21) , castTo(entry.getKey(), 12));
    targetAnchor = $getAbsoluteAnchor(edge.target);
    sourceAnchor = $getAbsoluteAnchor(edge.source);
    sourceVerticalCP = new KVector_1(centerXPos, sourceAnchor.y_0);
    targetVerticalCP = new KVector_1(centerXPos, targetAnchor.y_0);
    sourceStraightCP = new KVector_1(startXPos - 10, sourceAnchor.y_0);
    targetStraightCP = new KVector_1(endXPos, targetAnchor.y_0);
    targetAnchor.x_0 >= endXPos && sourceAnchor.x_0 >= endXPos && (sourceStraightCP.x_0 = endXPos);
    targetAnchor.x_0 <= startXPos && sourceAnchor.x_0 <= startXPos && (targetStraightCP.x_0 = startXPos - 10);
    hyperEdge.edges.map_0.size_1() == 1?$addAll_3(edge.bendPoints, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [sourceStraightCP, sourceVerticalCP, targetVerticalCP, targetStraightCP])):$addAll_3(edge.bendPoints, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [sourceStraightCP, sourceVerticalCP, center, targetVerticalCP, targetStraightCP]));
  }
}

function $createDependency(edge0, edge1){
  var edge0Counter, edge1Counter, entry, outerIter, outerIter0, outerIter1, outerIter2, port, port$iterator, port$iterator0, port$iterator1, port$iterator2;
  if (edge0.topYPos > edge1.bottomYPos || edge1.topYPos > edge0.bottomYPos) {
    return;
  }
  edge0Counter = 0;
  edge1Counter = 0;
  for (port$iterator0 = (outerIter0 = (new AbstractMap$1(edge0.rightPorts.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter0)); port$iterator0.val$outerIter2.hasNext_0();) {
    port = (entry = castTo(port$iterator0.val$outerIter2.next_1(), 21) , castTo(entry.getKey(), 7));
    isBetween(sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [port.owner.pos, port.pos, port.anchor])).y_0, edge1.topYPos, edge1.bottomYPos) && ++edge0Counter;
  }
  for (port$iterator1 = (outerIter1 = (new AbstractMap$1(edge0.leftPorts.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter1)); port$iterator1.val$outerIter2.hasNext_0();) {
    port = (entry = castTo(port$iterator1.val$outerIter2.next_1(), 21) , castTo(entry.getKey(), 7));
    isBetween(sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [port.owner.pos, port.pos, port.anchor])).y_0, edge1.topYPos, edge1.bottomYPos) && --edge0Counter;
  }
  for (port$iterator2 = (outerIter2 = (new AbstractMap$1(edge1.rightPorts.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter2)); port$iterator2.val$outerIter2.hasNext_0();) {
    port = (entry = castTo(port$iterator2.val$outerIter2.next_1(), 21) , castTo(entry.getKey(), 7));
    isBetween(sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [port.owner.pos, port.pos, port.anchor])).y_0, edge0.topYPos, edge0.bottomYPos) && ++edge1Counter;
  }
  for (port$iterator = (outerIter = (new AbstractMap$1(edge1.leftPorts.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter)); port$iterator.val$outerIter2.hasNext_0();) {
    port = (entry = castTo(port$iterator.val$outerIter2.next_1(), 21) , castTo(entry.getKey(), 7));
    isBetween(sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [port.owner.pos, port.pos, port.anchor])).y_0, edge0.topYPos, edge0.bottomYPos) && --edge1Counter;
  }
  if (edge0Counter < edge1Counter) {
    new SplineEdgeRouter$Dependency(edge0, edge1, edge1Counter - edge0Counter);
  }
   else if (edge1Counter < edge0Counter) {
    new SplineEdgeRouter$Dependency(edge1, edge0, edge0Counter - edge1Counter);
  }
   else {
    new SplineEdgeRouter$Dependency(edge1, edge0, 0);
    new SplineEdgeRouter$Dependency(edge0, edge1, 0);
  }
}

function $createHyperEdges(edges, leftPorts, rightPorts, hyperEdges){
  var edge, edge$iterator, sourcePort, sourceSide, targetPort, targetSide;
  for (edge$iterator = new ArrayList$1(edges); edge$iterator.i < edge$iterator.this$01.array.length;) {
    edge = castTo($next_8(edge$iterator), 12);
    sourcePort = edge.source;
    if (leftPorts.map_0.containsKey(sourcePort)) {
      sourceSide = ($clinit_SplineEdgeRouter$SideToProcess() , LEFT_4);
    }
     else if (rightPorts.map_0.containsKey(sourcePort)) {
      sourceSide = ($clinit_SplineEdgeRouter$SideToProcess() , RIGHT_4);
    }
     else {
      throw new IllegalArgumentException_0('Source port must be in one of the port sets.');
    }
    targetPort = edge.target;
    if (leftPorts.map_0.containsKey(targetPort)) {
      targetSide = ($clinit_SplineEdgeRouter$SideToProcess() , LEFT_4);
    }
     else if (rightPorts.map_0.containsKey(targetPort)) {
      targetSide = ($clinit_SplineEdgeRouter$SideToProcess() , RIGHT_4);
    }
     else {
      throw new IllegalArgumentException_0('Target port must be in one of the port sets.');
    }
    $add_11(hyperEdges, new SplineEdgeRouter$SplineHyperEdge(edge, sourceSide, targetSide));
  }
}

function $createHyperEdges_0(leftPorts, rightPorts, sideToProcess, reversed, edgesRemaining, hyperEdges){
  var downEdges, edge, edge$iterator, entry, entry0, outerIter, outerIter0, pair, pair$iterator, portsToProcess, singlePort, singlePort$iterator, singlePortPosition, targetPort, targetPortPosition, upEdges;
  portsToProcess = null;
  sideToProcess == ($clinit_SplineEdgeRouter$SideToProcess() , LEFT_4)?(portsToProcess = leftPorts):sideToProcess == RIGHT_4 && (portsToProcess = rightPorts);
  for (singlePort$iterator = (outerIter0 = (new AbstractMap$1(portsToProcess.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter0)); singlePort$iterator.val$outerIter2.hasNext_0();) {
    singlePort = (entry0 = castTo(singlePort$iterator.val$outerIter2.next_1(), 21) , castTo(entry0.getKey(), 7));
    singlePortPosition = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [singlePort.owner.pos, singlePort.pos, singlePort.anchor])).y_0;
    upEdges = new HashSet;
    downEdges = new HashSet;
    for (edge$iterator = $iterator(concat(($clinit_ImmutableList() , new RegularImmutableList(nullCheckedList(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [singlePort.incomingEdges, singlePort.outgoingEdges])))))); $hasNext_0(edge$iterator);) {
      edge = castTo($next_2(edge$iterator), 12);
      if (unsafeCast(checkNotNull_1(castToBoolean($getProperty(edge, ($clinit_InternalProperties() , REVERSED))))) != reversed) {
        continue;
      }
      if ($indexOf_0(edgesRemaining, edge, 0) != -1) {
        edge.target == singlePort?(targetPort = edge.source):(targetPort = edge.target);
        targetPortPosition = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [targetPort.owner.pos, targetPort.pos, targetPort.anchor])).y_0;
        if ((targetPortPosition - singlePortPosition <= 0?0 - (targetPortPosition - singlePortPosition):targetPortPosition - singlePortPosition) < 0.2) {
          continue;
        }
        targetPortPosition < singlePortPosition?leftPorts.map_0.containsKey(targetPort)?$add_18(upEdges, new Pair(LEFT_4, edge)):$add_18(upEdges, new Pair(RIGHT_4, edge)):leftPorts.map_0.containsKey(targetPort)?$add_18(downEdges, new Pair(LEFT_4, edge)):$add_18(downEdges, new Pair(RIGHT_4, edge));
      }
    }
    if (upEdges.map_0.size_1() > 1) {
      $add_11(hyperEdges, new SplineEdgeRouter$SplineHyperEdge_0(singlePort, upEdges, sideToProcess));
      for (pair$iterator = (outerIter = (new AbstractMap$1(upEdges.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter)); pair$iterator.val$outerIter2.hasNext_0();) {
        pair = (entry = castTo(pair$iterator.val$outerIter2.next_1(), 21) , castTo(entry.getKey(), 27));
        $remove_7(edgesRemaining, pair.second);
      }
    }
    if (downEdges.map_0.size_1() > 1) {
      $add_11(hyperEdges, new SplineEdgeRouter$SplineHyperEdge_0(singlePort, downEdges, sideToProcess));
      for (pair$iterator = (outerIter = (new AbstractMap$1(downEdges.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter)); pair$iterator.val$outerIter2.hasNext_0();) {
        pair = (entry = castTo(pair$iterator.val$outerIter2.next_1(), 21) , castTo(entry.getKey(), 27));
        $remove_7(edgesRemaining, pair.second);
      }
    }
  }
}

function $fillMappings(leftRightLayer, leftRightPorts, allEdges, succeedingEdge, startingEdges, selfLoops){
  var edge, edge$iterator, leftLayer, leftPorts, node, node$iterator, old, port, port$iterator, rightLayer, rightPorts, sourceNodeType, sourcePort, sourcePort$iterator, targetLayer, targetPort;
  leftLayer = castTo(leftRightLayer.first, 16);
  rightLayer = castTo(leftRightLayer.second, 16);
  leftPorts = castTo(leftRightPorts.first, 18);
  rightPorts = castTo(leftRightPorts.second, 18);
  if (leftLayer) {
    for (node$iterator = new ArrayList$1(leftLayer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      for (sourcePort$iterator = $getPorts_0(node, ($clinit_PortSide() , EAST)).iterator_0(); sourcePort$iterator.hasNext_0();) {
        sourcePort = castTo(sourcePort$iterator.next_1(), 7);
        leftPorts.add_1(sourcePort);
        for (edge$iterator = new ArrayList$1(sourcePort.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
          edge = castTo($next_8(edge$iterator), 12);
          if ($isSelfLoop(edge)) {
            continue;
          }
          allEdges.array[allEdges.array.length] = edge;
          $findAndAddSuccessor(edge, succeedingEdge);
          sourceNodeType = edge.source.owner.type_0;
          (sourceNodeType == ($clinit_LNode$NodeType() , NORMAL) || sourceNodeType == NORTH_SOUTH_PORT) && (startingEdges.array[startingEdges.array.length] = edge , true);
          targetPort = edge.target;
          targetLayer = targetPort.owner.layer;
          targetLayer == rightLayer?rightPorts.add_1(targetPort):targetLayer == leftLayer?leftPorts.add_1(targetPort):$remove_7(allEdges, edge);
        }
      }
    }
  }
  if (rightLayer) {
    for (node$iterator = new ArrayList$1(rightLayer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_8(node$iterator), 9);
      for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
        port = castTo($next_8(port$iterator), 7);
        for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
          edge = castTo($next_8(edge$iterator), 12);
          $isSelfLoop(edge) && (old = selfLoops.map_0.put(edge, selfLoops) , old == null);
        }
      }
      for (sourcePort$iterator = $getPorts_0(node, ($clinit_PortSide() , WEST)).iterator_0(); sourcePort$iterator.hasNext_0();) {
        sourcePort = castTo(sourcePort$iterator.next_1(), 7);
        rightPorts.add_1(sourcePort);
        for (edge$iterator = new ArrayList$1(sourcePort.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
          edge = castTo($next_8(edge$iterator), 12);
          if ($isSelfLoop(edge)) {
            continue;
          }
          allEdges.array[allEdges.array.length] = edge;
          $findAndAddSuccessor(edge, succeedingEdge);
          sourceNodeType = edge.source.owner.type_0;
          (sourceNodeType == ($clinit_LNode$NodeType() , NORMAL) || sourceNodeType == NORTH_SOUTH_PORT) && (startingEdges.array[startingEdges.array.length] = edge , true);
          targetPort = edge.target;
          targetLayer = targetPort.owner.layer;
          targetLayer == rightLayer?rightPorts.add_1(targetPort):targetLayer == leftLayer?leftPorts.add_1(targetPort):$remove_7(allEdges, edge);
        }
      }
    }
  }
}

function $findAndAddSuccessor(edge, succeedingEdge){
  var iter, targetNode;
  targetNode = edge.target.owner;
  if (targetNode.type_0 == ($clinit_LNode$NodeType() , NORMAL)) {
    return;
  }
  iter = $iterator($getOutgoingEdges_0(targetNode));
  $hasNext_0(iter) && $put_2(succeedingEdge, edge, castTo($next_2(iter), 12));
}

function $layerOnlyContainsDummies(layer){
  var n, n$iterator;
  for (n$iterator = new ArrayList$1(layer.nodes); n$iterator.i < n$iterator.this$01.array.length;) {
    n = castTo($next_8(n$iterator), 9);
    if (n.type_0 == ($clinit_LNode$NodeType() , NORMAL) || n.type_0 == BIG_NODE) {
      return false;
    }
  }
  return true;
}

function SplineEdgeRouter(){
  $clinit_SplineEdgeRouter();
}

function breakCycles_0(edges, random){
  var depIter, dependency, dependency$iterator, dependency$iterator0, edge, edge$iterator, edge$iterator0, edge$iterator1, entry, inweight, markBase, maxEdge, maxEdges, maxOutflow, nextLeft, nextMark, nextRight, outerIter, outflow, outweight, shiftBase, sink, sinks, source, source$iterator, sources, target, unprocessed;
  sources = new LinkedList;
  sinks = new LinkedList;
  nextMark = -1;
  for (edge$iterator0 = new ArrayList$1(edges); edge$iterator0.i < edge$iterator0.this$01.array.length;) {
    edge = castTo($next_8(edge$iterator0), 77);
    edge.mark = nextMark--;
    inweight = 0;
    outweight = 0;
    for (dependency$iterator0 = new ArrayList$1(edge.outgoing); dependency$iterator0.i < dependency$iterator0.this$01.array.length;) {
      dependency = castTo($next_8(dependency$iterator0), 117);
      outweight += dependency.weight;
    }
    for (dependency$iterator = new ArrayList$1(edge.incoming); dependency$iterator.i < dependency$iterator.this$01.array.length;) {
      dependency = castTo($next_8(dependency$iterator), 117);
      inweight += dependency.weight;
    }
    edge.inweight = inweight;
    edge.outweight = outweight;
    outweight == 0?($addNode_0(sinks, edge, sinks.tail.prev, sinks.tail) , true):inweight == 0 && ($addNode_0(sources, edge, sources.tail.prev, sources.tail) , true);
  }
  unprocessed = new LinkedHashSet_1(($clinit_Collections2() , edges));
  markBase = edges.array.length;
  nextLeft = markBase + 1;
  nextRight = markBase - 1;
  maxEdges = new ArrayList;
  while (unprocessed.map_0.size_1() != 0) {
    while (sinks.size_0 != 0) {
      sink = (checkCriticalElement(sinks.size_0 != 0) , castTo($removeNode_0(sinks, sinks.header.next_0), 77));
      unprocessed.map_0.remove_0(sink) != null;
      sink.mark = nextRight--;
      updateNeighbors_0(sink, sources, sinks);
    }
    while (sources.size_0 != 0) {
      source = (checkCriticalElement(sources.size_0 != 0) , castTo($removeNode_0(sources, sources.header.next_0), 77));
      unprocessed.map_0.remove_0(source) != null;
      source.mark = nextLeft++;
      updateNeighbors_0(source, sources, sinks);
    }
    maxOutflow = $intern_8;
    for (edge$iterator1 = (outerIter = (new AbstractMap$1(unprocessed.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter)); edge$iterator1.val$outerIter2.hasNext_0();) {
      edge = (entry = castTo(edge$iterator1.val$outerIter2.next_1(), 21) , castTo(entry.getKey(), 77));
      outflow = edge.outweight - edge.inweight;
      if (outflow >= maxOutflow) {
        if (outflow > maxOutflow) {
          maxEdges.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
          maxOutflow = outflow;
        }
        maxEdges.array[maxEdges.array.length] = edge;
      }
    }
    if (maxEdges.array.length != 0) {
      maxEdge = castTo($get_8(maxEdges, $nextInt(random, maxEdges.array.length)), 77);
      unprocessed.map_0.remove_0(maxEdge) != null;
      maxEdge.mark = nextLeft++;
      updateNeighbors_0(maxEdge, sources, sinks);
      maxEdges.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
    }
  }
  shiftBase = edges.array.length + 1;
  for (edge$iterator = new ArrayList$1(edges); edge$iterator.i < edge$iterator.this$01.array.length;) {
    edge = castTo($next_8(edge$iterator), 77);
    edge.mark < markBase && (edge.mark += shiftBase);
  }
  for (source$iterator = new ArrayList$1(edges); source$iterator.i < source$iterator.this$01.array.length;) {
    source = castTo($next_8(source$iterator), 77);
    depIter = new AbstractList$ListIteratorImpl(source.outgoing, 0);
    while (depIter.i < depIter.this$01_0.size_1()) {
      dependency = (checkCriticalElement(depIter.i < depIter.this$01_0.size_1()) , castTo(depIter.this$01_0.get_2(depIter.last = depIter.i++), 117));
      target = dependency.target;
      if (source.mark > target.mark) {
        $remove_11(depIter);
        $remove_7(target.incoming, dependency);
        if (dependency.weight > 0) {
          dependency.source = target;
          $add_11(target.outgoing, dependency);
          dependency.target = source;
          $add_11(source.incoming, dependency);
        }
      }
    }
  }
}

function isStraight(firstY, secondY){
  $clinit_SplineEdgeRouter();
  return (firstY - secondY <= 0?0 - (firstY - secondY):firstY - secondY) < 0.2;
}

function topologicalNumbering_0(edges){
  var dep, dep$iterator, edge, edge$iterator, edge$iterator0, maxRank, rightwardTargets, source, sources, target;
  sources = new LinkedList;
  rightwardTargets = new LinkedList;
  for (edge$iterator0 = new ArrayList$1(edges); edge$iterator0.i < edge$iterator0.this$01.array.length;) {
    edge = castTo($next_8(edge$iterator0), 77);
    edge.inweight = edge.incoming.array.length;
    edge.outweight = edge.outgoing.array.length;
    edge.inweight == 0 && ($addNode_0(sources, edge, sources.tail.prev, sources.tail) , true);
    edge.outweight == 0 && edge.leftPorts.map_0.size_1() == 0 && ($addNode_0(rightwardTargets, edge, rightwardTargets.tail.prev, rightwardTargets.tail) , true);
  }
  maxRank = -1;
  while (sources.size_0 != 0) {
    edge = castTo($remove_3(sources, 0), 77);
    for (dep$iterator = new ArrayList$1(edge.outgoing); dep$iterator.i < dep$iterator.this$01.array.length;) {
      dep = castTo($next_8(dep$iterator), 117);
      target = dep.target;
      target.rank = max_3(target.rank, edge.rank + 1);
      maxRank = max_3(maxRank, target.rank);
      --target.inweight;
      target.inweight == 0 && ($addNode_0(sources, target, sources.tail.prev, sources.tail) , true);
    }
  }
  if (maxRank > -1) {
    for (edge$iterator = $listIterator_2(rightwardTargets, 0); edge$iterator.currentNode != edge$iterator.this$01.tail;) {
      edge = castTo($next_11(edge$iterator), 77);
      edge.rank = maxRank;
    }
    while (rightwardTargets.size_0 != 0) {
      edge = castTo($remove_3(rightwardTargets, 0), 77);
      for (dep$iterator = new ArrayList$1(edge.incoming); dep$iterator.i < dep$iterator.this$01.array.length;) {
        dep = castTo($next_8(dep$iterator), 117);
        source = dep.source;
        if (source.leftPorts.map_0.size_1() != 0) {
          continue;
        }
        source.rank = min_3(source.rank, edge.rank - 1);
        --source.outweight;
        source.outweight == 0 && ($addNode_0(rightwardTargets, source, rightwardTargets.tail.prev, rightwardTargets.tail) , true);
      }
    }
  }
}

function updateNeighbors_0(edge, sources, sinks){
  var dep, dep$iterator, dep$iterator0;
  for (dep$iterator0 = new ArrayList$1(edge.outgoing); dep$iterator0.i < dep$iterator0.this$01.array.length;) {
    dep = castTo($next_8(dep$iterator0), 117);
    if (dep.target.mark < 0 && dep.weight > 0) {
      dep.target.inweight -= dep.weight;
      dep.target.inweight <= 0 && dep.target.outweight > 0 && $add_8(sources, dep.target);
    }
  }
  for (dep$iterator = new ArrayList$1(edge.incoming); dep$iterator.i < dep$iterator.this$01.array.length;) {
    dep = castTo($next_8(dep$iterator), 117);
    if (dep.source.mark < 0 && dep.weight > 0) {
      dep.source.outweight -= dep.weight;
      dep.source.outweight <= 0 && dep.source.inweight > 0 && $add_8(sinks, dep.source);
    }
  }
}

defineClass(537, 1, $intern_64, SplineEdgeRouter);
_.getIntermediateProcessingConfiguration = function getIntermediateProcessingConfiguration_13(graph){
  var configuration, graphProperties;
  configuration = new IntermediateProcessingConfiguration;
  graphProperties = castTo($getProperty(graph, ($clinit_InternalProperties() , GRAPH_PROPERTIES)), 18);
  graphProperties.contains(($clinit_GraphProperties() , SELF_LOOPS)) && $addAll_4(configuration, SELF_LOOP_PROCESSING_ADDITIONS_0);
  graphProperties.contains(CENTER_LABELS) && $addAll_4(configuration, CENTER_EDGE_LABEL_PROCESSING_ADDITIONS_1);
  if (graphProperties.contains(NON_FREE_PORTS) || unsafeCast(checkNotNull_1(castToBoolean($getProperty(graph, ($clinit_Properties() , FEEDBACK_EDGES)))))) {
    $addAll_4(configuration, INVERTED_PORT_PROCESSING_ADDITIONS_1);
    graphProperties.contains(NORTH_SOUTH_PORTS) && $addAll_4(configuration, NORTH_SOUTH_PORT_PROCESSING_ADDITIONS_1);
  }
  graphProperties.contains(END_LABELS) && $addAll_4(configuration, END_EDGE_LABEL_PROCESSING_ADDITIONS_1);
  return configuration;
}
;
_.process = function process_60(layeredGraph, monitor){
  var edge, edge$iterator, edge$iterator0, edge$iterator1, edgesRemaining, entry, externalLeftLayer, externalRightLayer, hyperEdge1, hyperEdge2, hyperEdges, increment, label_0, label$iterator, layerIterator, leftLayer, leftPorts, maxRank, nodeSpacing, offset, outerIter, rightLayer, rightLayersPosition, rightPorts, selfLoop, selfLoop$iterator, selfLoops, sourceIter, startEdges, successingEdge, targetIter, xpos;
  $begin(monitor, 'Spline edge routing', 1);
  nodeSpacing = castTo($getProperty(layeredGraph, ($clinit_InternalProperties() , SPACING_0)), 15).value_0;
  this.edgeSpacing = nodeSpacing * castTo($getProperty(layeredGraph, ($clinit_Properties() , EDGE_SPACING_FACTOR)), 15).value_0;
  xpos = 0;
  layerIterator = new ArrayList$1(layeredGraph.layers);
  leftLayer = null;
  successingEdge = ($clinit_Maps() , new HashMap);
  startEdges = new ArrayList;
  externalLeftLayer = true;
  externalRightLayer = true;
  do {
    rightLayer = layerIterator.i < layerIterator.this$01.array.length?castTo($next_8(layerIterator), 16):null;
    hyperEdges = new ArrayList;
    edgesRemaining = new ArrayList;
    leftPorts = new LinkedHashSet;
    rightPorts = new LinkedHashSet;
    selfLoops = new LinkedHashSet;
    $fillMappings(new Pair(leftLayer, rightLayer), new Pair(leftPorts, rightPorts), edgesRemaining, successingEdge, startEdges, selfLoops);
    $createHyperEdges_0(leftPorts, rightPorts, ($clinit_SplineEdgeRouter$SideToProcess() , LEFT_4), true, edgesRemaining, hyperEdges);
    $createHyperEdges_0(leftPorts, rightPorts, LEFT_4, false, edgesRemaining, hyperEdges);
    $createHyperEdges_0(leftPorts, rightPorts, RIGHT_4, true, edgesRemaining, hyperEdges);
    $createHyperEdges_0(leftPorts, rightPorts, RIGHT_4, false, edgesRemaining, hyperEdges);
    $createHyperEdges(edgesRemaining, leftPorts, rightPorts, hyperEdges);
    sourceIter = new AbstractList$ListIteratorImpl(hyperEdges, 0);
    while (sourceIter.i < sourceIter.this$01_0.size_1()) {
      hyperEdge1 = (checkCriticalElement(sourceIter.i < sourceIter.this$01_0.size_1()) , castTo(sourceIter.this$01_0.get_2(sourceIter.last = sourceIter.i++), 77));
      targetIter = new AbstractList$ListIteratorImpl(hyperEdges, sourceIter.i);
      while (targetIter.i < targetIter.this$01_0.size_1()) {
        hyperEdge2 = (checkCriticalElement(targetIter.i < targetIter.this$01_0.size_1()) , castTo(targetIter.this$01_0.get_2(targetIter.last = targetIter.i++), 77));
        $createDependency(hyperEdge1, hyperEdge2);
      }
    }
    breakCycles_0(hyperEdges, castTo($getProperty(layeredGraph, RANDOM), 154));
    topologicalNumbering_0(hyperEdges);
    rightLayersPosition = xpos + 10;
    if (rightLayer) {
      externalRightLayer = !rightLayer || all_0(rightLayer.nodes, ($clinit_PolylineEdgeRouter() , PRED_EXTERNAL_WEST_OR_EAST_PORT));
      maxRank = -1;
      for (edge$iterator0 = new ArrayList$1(hyperEdges); edge$iterator0.i < edge$iterator0.this$01.array.length;) {
        edge = castTo($next_8(edge$iterator0), 77);
        maxRank = max_3(maxRank, edge.rank);
      }
      ++maxRank;
      if (maxRank > 0) {
        increment = (maxRank + 1) * this.edgeSpacing;
        increment < nodeSpacing && !externalLeftLayer && !externalRightLayer && (increment = nodeSpacing);
        rightLayersPosition += increment;
      }
       else 
        externalLeftLayer || externalRightLayer || $layerOnlyContainsDummies(leftLayer) || $layerOnlyContainsDummies(rightLayer) || (rightLayersPosition += nodeSpacing);
      placeNodesHorizontally(rightLayer, rightLayersPosition);
    }
    for (selfLoop$iterator = (outerIter = (new AbstractMap$1(selfLoops.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter)); selfLoop$iterator.val$outerIter2.hasNext_0();) {
      selfLoop = (entry = castTo(selfLoop$iterator.val$outerIter2.next_1(), 21) , castTo(entry.getKey(), 12));
      offset = selfLoop.source.owner.pos;
      $offset(selfLoop.bendPoints, offset);
      for (label$iterator = new ArrayList$1(selfLoop.labels); label$iterator.i < label$iterator.this$01.array.length;) {
        label_0 = castTo($next_8(label$iterator), 33);
        $add_7(label_0.pos, offset);
      }
    }
    for (edge$iterator1 = new ArrayList$1(hyperEdges); edge$iterator1.i < edge$iterator1.this$01.array.length;) {
      edge = castTo($next_8(edge$iterator1), 77);
      edge.isStraight?$calculateNUBSBendPointStraight(edge, xpos):$calculateNUBSBendPoints(this, edge, xpos, rightLayersPosition);
    }
    if (rightLayer) {
      xpos = rightLayersPosition + rightLayer.size_0.x_0 + 10;
    }
     else {
      maxRank = -1;
      for (edge$iterator0 = new ArrayList$1(hyperEdges); edge$iterator0.i < edge$iterator0.this$01.array.length;) {
        edge = castTo($next_8(edge$iterator0), 77);
        maxRank = max_3(maxRank, edge.rank);
      }
      maxRank >= 0 && (xpos += (maxRank + 2) * this.edgeSpacing);
    }
    leftLayer = rightLayer;
    externalLeftLayer = externalRightLayer;
  }
   while (rightLayer);
  for (edge$iterator = new ArrayList$1(startEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
    edge = castTo($next_8(edge$iterator), 12);
    $calculateBezierBendPoints(edge, successingEdge);
  }
  layeredGraph.size_0.x_0 = xpos;
  $done(monitor);
}
;
_.edgeSpacing = 3;
var CENTER_EDGE_LABEL_PROCESSING_ADDITIONS_1, END_EDGE_LABEL_PROCESSING_ADDITIONS_1, INVERTED_PORT_PROCESSING_ADDITIONS_1, NORTH_SOUTH_PORT_PROCESSING_ADDITIONS_1, SELF_LOOP_PROCESSING_ADDITIONS_0;
var Lde_cau_cs_kieler_klay_layered_p5edges_splines_SplineEdgeRouter_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p5edges.splines', 'SplineEdgeRouter', 537);
function SplineEdgeRouter$Dependency(source, target, weight){
  this.source = source;
  this.target = target;
  this.weight = weight;
  $add_11(source.outgoing, this);
  $add_11(target.incoming, this);
}

defineClass(117, 1, {117:1}, SplineEdgeRouter$Dependency);
_.toString_0 = function toString_70(){
  return this.source + ' ->(' + this.weight + ') ' + this.target;
}
;
_.weight = 0;
var Lde_cau_cs_kieler_klay_layered_p5edges_splines_SplineEdgeRouter$Dependency_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p5edges.splines', 'SplineEdgeRouter/Dependency', 117);
function $clinit_SplineEdgeRouter$SideToProcess(){
  $clinit_SplineEdgeRouter$SideToProcess = emptyMethod;
  LEFT_4 = new SplineEdgeRouter$SideToProcess('LEFT', 0);
  RIGHT_4 = new SplineEdgeRouter$SideToProcess('RIGHT', 1);
}

function SplineEdgeRouter$SideToProcess(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function values_45(){
  $clinit_SplineEdgeRouter$SideToProcess();
  return stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_p5edges_splines_SplineEdgeRouter$SideToProcess_2_classLit, 1), $intern_13, 223, 0, [LEFT_4, RIGHT_4]);
}

defineClass(223, 17, {223:1, 3:1, 23:1, 17:1}, SplineEdgeRouter$SideToProcess);
var LEFT_4, RIGHT_4;
var Lde_cau_cs_kieler_klay_layered_p5edges_splines_SplineEdgeRouter$SideToProcess_2_classLit = createForEnum('de.cau.cs.kieler.klay.layered.p5edges.splines', 'SplineEdgeRouter/SideToProcess', 223, Ljava_lang_Enum_2_classLit, values_45);
function $$init_7(this$static){
  this$static.leftPorts = new HashSet;
  this$static.rightPorts = new HashSet;
  this$static.edges = new HashSet;
  this$static.outgoing = new ArrayList;
  this$static.incoming = new ArrayList;
}

function $compareTo_10(this$static, other){
  return this$static.mark - other.mark;
}

function $setRelevantPositions(this$static, sourceY, targetYMin, targetYMax){
  if (sourceY < targetYMin) {
    this$static.centerYPos = 0.5 * (sourceY + targetYMin);
    this$static.topYPos = $intern_72 * this$static.centerYPos + 0.9 * sourceY;
    this$static.bottomYPos = $intern_72 * this$static.centerYPos + 0.9 * targetYMin;
  }
   else {
    this$static.centerYPos = 0.5 * (sourceY + targetYMax);
    this$static.topYPos = $intern_72 * this$static.centerYPos + 0.9 * targetYMax;
    this$static.bottomYPos = $intern_72 * this$static.centerYPos + 0.9 * sourceY;
  }
}

function SplineEdgeRouter$SplineHyperEdge(edge, sourceSide, targetSide){
  var sourceY, targetY;
  $$init_7(this);
  sourceSide == ($clinit_SplineEdgeRouter$SideToProcess() , LEFT_4)?$add_18(this.leftPorts, edge.source):$add_18(this.rightPorts, edge.source);
  targetSide == LEFT_4?$add_18(this.leftPorts, edge.target):$add_18(this.rightPorts, edge.target);
  $add_18(this.edges, edge);
  sourceY = $getAbsoluteAnchor(edge.source).y_0;
  targetY = $getAbsoluteAnchor(edge.target).y_0;
  $setRelevantPositions(this, sourceY, targetY, targetY);
  this.isStraight = isStraight($getAbsoluteAnchor(edge.source).y_0, $getAbsoluteAnchor(edge.target).y_0);
}

function SplineEdgeRouter$SplineHyperEdge_0(singlePort, edges, sourceSide){
  var edge, entry, outerIter, outerIter0, pair, pair$iterator, pair$iterator0, side, targetPort, yMaxPosOfTarget, yMinPosOfTarget, yPosOfSingleSide, yPosOfTarget;
  $$init_7(this);
  sourceSide == ($clinit_SplineEdgeRouter$SideToProcess() , LEFT_4)?$add_18(this.leftPorts, singlePort):$add_18(this.rightPorts, singlePort);
  yMinPosOfTarget = $intern_60;
  yMaxPosOfTarget = 4.9E-324;
  for (pair$iterator0 = (outerIter0 = (new AbstractMap$1(edges.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter0)); pair$iterator0.val$outerIter2.hasNext_0();) {
    pair = (entry = castTo(pair$iterator0.val$outerIter2.next_1(), 21) , castTo(entry.getKey(), 27));
    side = castTo(pair.first, 223);
    edge = castTo(pair.second, 12);
    targetPort = edge.source;
    targetPort == singlePort && (targetPort = edge.target);
    side == LEFT_4?$add_18(this.leftPorts, targetPort):$add_18(this.rightPorts, targetPort);
    yPosOfTarget = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [targetPort.owner.pos, targetPort.pos, targetPort.anchor])).y_0;
    yMinPosOfTarget = yMinPosOfTarget < yPosOfTarget?yMinPosOfTarget:yPosOfTarget;
    yMaxPosOfTarget = yMaxPosOfTarget > yPosOfTarget?yMaxPosOfTarget:yPosOfTarget;
  }
  yPosOfSingleSide = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_core_math_KVector_2_classLit, 1), $intern_48, 10, 0, [singlePort.owner.pos, singlePort.pos, singlePort.anchor])).y_0;
  $setRelevantPositions(this, yPosOfSingleSide, yMinPosOfTarget, yMaxPosOfTarget);
  for (pair$iterator = (outerIter = (new AbstractMap$1(edges.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter)); pair$iterator.val$outerIter2.hasNext_0();) {
    pair = (entry = castTo(pair$iterator.val$outerIter2.next_1(), 21) , castTo(entry.getKey(), 27));
    $add_18(this.edges, castTo(pair.second, 12));
  }
  this.isStraight = false;
}

defineClass(77, 1, {77:1, 23:1}, SplineEdgeRouter$SplineHyperEdge, SplineEdgeRouter$SplineHyperEdge_0);
_.compareTo = function compareTo_12(other){
  return $compareTo_10(this, castTo(other, 77));
}
;
_.bottomYPos = 0;
_.centerYPos = 0;
_.inweight = 0;
_.isStraight = false;
_.mark = 0;
_.outweight = 0;
_.rank = 0;
_.topYPos = 0;
var Lde_cau_cs_kieler_klay_layered_p5edges_splines_SplineEdgeRouter$SplineHyperEdge_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.p5edges.splines', 'SplineEdgeRouter/SplineHyperEdge', 77);
function distPortToNodeEdge(port, side){
  var nodeSize, portPos;
  portPos = $add_7($clone(port.pos), port.anchor);
  nodeSize = port.owner.size_0;
  switch (side.ordinal) {
    case 1:
      return -portPos.y_0;
    case 2:
      return -portPos.x_0 + nodeSize.x_0;
    case 3:
      return -portPos.y_0 + nodeSize.y_0;
    case 4:
      return -portPos.x_0;
    default:return 0;
  }
}

function getMarginOnPortSide(node, side){
  switch (side.ordinal) {
    case 1:
      return node.margin.top_0;
    case 2:
      return node.margin.right;
    case 3:
      return node.margin.bottom;
    case 4:
      return node.margin.left;
    default:return 0;
  }
}

function isBetween(value_0, boundary0, boundary1){
  if ((boundary0 - value_0 <= 0?0 - (boundary0 - value_0):boundary0 - value_0) < $intern_62 || (boundary1 - value_0 <= 0?0 - (boundary1 - value_0):boundary1 - value_0) < $intern_62) {
    return true;
  }
  return boundary0 - value_0 > $intern_62?value_0 - boundary1 > $intern_62:boundary1 - value_0 > $intern_62;
}

function isBetween_0(value_0, boundary0, boundary1){
  return value_0 < boundary0?boundary1 <= value_0:value_0 <= boundary1 || value_0 == boundary0;
}

function portSideToDirection(side){
  switch (side.ordinal) {
    case 1:
      return 4.71238898038469;
    default:case 2:
      return 0;
    case 3:
      return 1.5707963267948966;
    case 4:
      return 3.141592653589793;
  }
}

function $clinit_ContentAlignment(){
  $clinit_ContentAlignment = emptyMethod;
  V_TOP_0 = new ContentAlignment('V_TOP', 0);
  V_CENTER_0 = new ContentAlignment('V_CENTER', 1);
  V_BOTTOM_0 = new ContentAlignment('V_BOTTOM', 2);
  H_LEFT_0 = new ContentAlignment('H_LEFT', 3);
  H_CENTER_0 = new ContentAlignment('H_CENTER', 4);
  H_RIGHT_0 = new ContentAlignment('H_RIGHT', 5);
}

function ContentAlignment(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function values_46(){
  $clinit_ContentAlignment();
  return stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_properties_ContentAlignment_2_classLit, 1), $intern_13, 123, 0, [V_TOP_0, V_CENTER_0, V_BOTTOM_0, H_LEFT_0, H_CENTER_0, H_RIGHT_0]);
}

defineClass(123, 17, {123:1, 3:1, 23:1, 17:1}, ContentAlignment);
var H_CENTER_0, H_LEFT_0, H_RIGHT_0, V_BOTTOM_0, V_CENTER_0, V_TOP_0;
var Lde_cau_cs_kieler_klay_layered_properties_ContentAlignment_2_classLit = createForEnum('de.cau.cs.kieler.klay.layered.properties', 'ContentAlignment', 123, Ljava_lang_Enum_2_classLit, values_46);
function $clinit_ContentAlignment$Map(){
  $clinit_ContentAlignment$Map = emptyMethod;
  $MAP_20 = createValueOfMap(($clinit_ContentAlignment() , stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_properties_ContentAlignment_2_classLit, 1), $intern_13, 123, 0, [V_TOP_0, V_CENTER_0, V_BOTTOM_0, H_LEFT_0, H_CENTER_0, H_RIGHT_0])));
}

var $MAP_20;
function $clinit_EdgeConstraint(){
  $clinit_EdgeConstraint = emptyMethod;
  NONE_2 = new EdgeConstraint('NONE', 0);
  INCOMING_ONLY = new EdgeConstraint('INCOMING_ONLY', 1);
  OUTGOING_ONLY = new EdgeConstraint('OUTGOING_ONLY', 2);
}

function EdgeConstraint(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function values_47(){
  $clinit_EdgeConstraint();
  return stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_properties_EdgeConstraint_2_classLit, 1), $intern_13, 218, 0, [NONE_2, INCOMING_ONLY, OUTGOING_ONLY]);
}

defineClass(218, 17, {218:1, 3:1, 23:1, 17:1}, EdgeConstraint);
var INCOMING_ONLY, NONE_2, OUTGOING_ONLY;
var Lde_cau_cs_kieler_klay_layered_properties_EdgeConstraint_2_classLit = createForEnum('de.cau.cs.kieler.klay.layered.properties', 'EdgeConstraint', 218, Ljava_lang_Enum_2_classLit, values_47);
function $clinit_EdgeLabelSideSelection(){
  $clinit_EdgeLabelSideSelection = emptyMethod;
  ALWAYS_UP = new EdgeLabelSideSelection('ALWAYS_UP', 0);
  ALWAYS_DOWN = new EdgeLabelSideSelection('ALWAYS_DOWN', 1);
  DIRECTION_UP = new EdgeLabelSideSelection('DIRECTION_UP', 2);
  DIRECTION_DOWN = new EdgeLabelSideSelection('DIRECTION_DOWN', 3);
  SMART = new EdgeLabelSideSelection('SMART', 4);
}

function $transpose_1(this$static){
  switch (this$static.ordinal) {
    case 0:
      return ALWAYS_DOWN;
    case 1:
      return ALWAYS_UP;
    case 2:
      return DIRECTION_DOWN;
    case 3:
      return DIRECTION_UP;
    default:return SMART;
  }
}

function EdgeLabelSideSelection(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function values_48(){
  $clinit_EdgeLabelSideSelection();
  return stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_properties_EdgeLabelSideSelection_2_classLit, 1), $intern_13, 115, 0, [ALWAYS_UP, ALWAYS_DOWN, DIRECTION_UP, DIRECTION_DOWN, SMART]);
}

defineClass(115, 17, {115:1, 3:1, 23:1, 17:1}, EdgeLabelSideSelection);
var ALWAYS_DOWN, ALWAYS_UP, DIRECTION_DOWN, DIRECTION_UP, SMART;
var Lde_cau_cs_kieler_klay_layered_properties_EdgeLabelSideSelection_2_classLit = createForEnum('de.cau.cs.kieler.klay.layered.properties', 'EdgeLabelSideSelection', 115, Ljava_lang_Enum_2_classLit, values_48);
function $clinit_EdgeLabelSideSelection$Map(){
  $clinit_EdgeLabelSideSelection$Map = emptyMethod;
  $MAP_21 = createValueOfMap(($clinit_EdgeLabelSideSelection() , stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_properties_EdgeLabelSideSelection_2_classLit, 1), $intern_13, 115, 0, [ALWAYS_UP, ALWAYS_DOWN, DIRECTION_UP, DIRECTION_DOWN, SMART])));
}

var $MAP_21;
function $clinit_FixedAlignment(){
  $clinit_FixedAlignment = emptyMethod;
  NONE_3 = new FixedAlignment('NONE', 0);
  LEFTUP = new FixedAlignment('LEFTUP', 1);
  RIGHTUP = new FixedAlignment('RIGHTUP', 2);
  LEFTDOWN = new FixedAlignment('LEFTDOWN', 3);
  RIGHTDOWN = new FixedAlignment('RIGHTDOWN', 4);
  BALANCED = new FixedAlignment('BALANCED', 5);
}

function FixedAlignment(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function values_49(){
  $clinit_FixedAlignment();
  return stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_properties_FixedAlignment_2_classLit, 1), $intern_13, 124, 0, [NONE_3, LEFTUP, RIGHTUP, LEFTDOWN, RIGHTDOWN, BALANCED]);
}

defineClass(124, 17, {124:1, 3:1, 23:1, 17:1}, FixedAlignment);
var BALANCED, LEFTDOWN, LEFTUP, NONE_3, RIGHTDOWN, RIGHTUP;
var Lde_cau_cs_kieler_klay_layered_properties_FixedAlignment_2_classLit = createForEnum('de.cau.cs.kieler.klay.layered.properties', 'FixedAlignment', 124, Ljava_lang_Enum_2_classLit, values_49);
function $clinit_FixedAlignment$Map(){
  $clinit_FixedAlignment$Map = emptyMethod;
  $MAP_22 = createValueOfMap(($clinit_FixedAlignment() , stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_properties_FixedAlignment_2_classLit, 1), $intern_13, 124, 0, [NONE_3, LEFTUP, RIGHTUP, LEFTDOWN, RIGHTDOWN, BALANCED])));
}

var $MAP_22;
function $clinit_GraphProperties(){
  $clinit_GraphProperties = emptyMethod;
  COMMENTS = new GraphProperties('COMMENTS', 0);
  EXTERNAL_PORTS = new GraphProperties('EXTERNAL_PORTS', 1);
  HYPEREDGES = new GraphProperties('HYPEREDGES', 2);
  HYPERNODES = new GraphProperties('HYPERNODES', 3);
  NON_FREE_PORTS = new GraphProperties('NON_FREE_PORTS', 4);
  NORTH_SOUTH_PORTS = new GraphProperties('NORTH_SOUTH_PORTS', 5);
  SELF_LOOPS = new GraphProperties('SELF_LOOPS', 6);
  CENTER_LABELS = new GraphProperties('CENTER_LABELS', 7);
  END_LABELS = new GraphProperties('END_LABELS', 8);
  PARTITIONS = new GraphProperties('PARTITIONS', 9);
}

function GraphProperties(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function values_50(){
  $clinit_GraphProperties();
  return stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_properties_GraphProperties_2_classLit, 1), $intern_13, 113, 0, [COMMENTS, EXTERNAL_PORTS, HYPEREDGES, HYPERNODES, NON_FREE_PORTS, NORTH_SOUTH_PORTS, SELF_LOOPS, CENTER_LABELS, END_LABELS, PARTITIONS]);
}

defineClass(113, 17, {113:1, 3:1, 23:1, 17:1}, GraphProperties);
var CENTER_LABELS, COMMENTS, END_LABELS, EXTERNAL_PORTS, HYPEREDGES, HYPERNODES, NON_FREE_PORTS, NORTH_SOUTH_PORTS, PARTITIONS, SELF_LOOPS;
var Lde_cau_cs_kieler_klay_layered_properties_GraphProperties_2_classLit = createForEnum('de.cau.cs.kieler.klay.layered.properties', 'GraphProperties', 113, Ljava_lang_Enum_2_classLit, values_50);
function $clinit_GreedySwitchType(){
  $clinit_GreedySwitchType = emptyMethod;
  ONE_SIDED = new GreedySwitchType('ONE_SIDED', 0, true, false, false);
  TWO_SIDED = new GreedySwitchType('TWO_SIDED', 1, false, false, false);
  ONE_SIDED_BEST_OF_UP_OR_DOWN = new GreedySwitchType('ONE_SIDED_BEST_OF_UP_OR_DOWN', 2, true, true, false);
  TWO_SIDED_BEST_OF_UP_OR_DOWN = new GreedySwitchType('TWO_SIDED_BEST_OF_UP_OR_DOWN', 3, false, true, false);
  ONE_SIDED_BEST_OF_UP_OR_DOWN_ORTHOGONAL_HYPEREDGES = new GreedySwitchType('ONE_SIDED_BEST_OF_UP_OR_DOWN_ORTHOGONAL_HYPEREDGES', 4, true, true, true);
  TWO_SIDED_BEST_OF_UP_OR_DOWN_ORTHOGONAL_HYPEREDGES = new GreedySwitchType('TWO_SIDED_BEST_OF_UP_OR_DOWN_ORTHOGONAL_HYPEREDGES', 5, false, true, true);
  ONE_SIDED_ORTHOGONAL_HYPEREDGES = new GreedySwitchType('ONE_SIDED_ORTHOGONAL_HYPEREDGES', 6, true, false, true);
  OFF = new GreedySwitchType('OFF', 7, false, false, false);
}

function GreedySwitchType(enum$name, enum$ordinal, isOneSided, useBestOfUpOrDown, useOrthogonalCounter){
  Enum.call(this, enum$name, enum$ordinal);
  this.isOneSided = isOneSided;
  this.useBestOfUpOrDown = useBestOfUpOrDown;
  this.useHperedgeCounter = useOrthogonalCounter;
}

function values_51(){
  $clinit_GreedySwitchType();
  return stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_properties_GreedySwitchType_2_classLit, 1), $intern_13, 110, 0, [ONE_SIDED, TWO_SIDED, ONE_SIDED_BEST_OF_UP_OR_DOWN, TWO_SIDED_BEST_OF_UP_OR_DOWN, ONE_SIDED_BEST_OF_UP_OR_DOWN_ORTHOGONAL_HYPEREDGES, TWO_SIDED_BEST_OF_UP_OR_DOWN_ORTHOGONAL_HYPEREDGES, ONE_SIDED_ORTHOGONAL_HYPEREDGES, OFF]);
}

defineClass(110, 17, {110:1, 3:1, 23:1, 17:1}, GreedySwitchType);
_.isOneSided = false;
_.useBestOfUpOrDown = false;
_.useHperedgeCounter = false;
var OFF, ONE_SIDED, ONE_SIDED_BEST_OF_UP_OR_DOWN, ONE_SIDED_BEST_OF_UP_OR_DOWN_ORTHOGONAL_HYPEREDGES, ONE_SIDED_ORTHOGONAL_HYPEREDGES, TWO_SIDED, TWO_SIDED_BEST_OF_UP_OR_DOWN, TWO_SIDED_BEST_OF_UP_OR_DOWN_ORTHOGONAL_HYPEREDGES;
var Lde_cau_cs_kieler_klay_layered_properties_GreedySwitchType_2_classLit = createForEnum('de.cau.cs.kieler.klay.layered.properties', 'GreedySwitchType', 110, Ljava_lang_Enum_2_classLit, values_51);
function $clinit_GreedySwitchType$Map(){
  $clinit_GreedySwitchType$Map = emptyMethod;
  $MAP_23 = createValueOfMap(($clinit_GreedySwitchType() , stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_properties_GreedySwitchType_2_classLit, 1), $intern_13, 110, 0, [ONE_SIDED, TWO_SIDED, ONE_SIDED_BEST_OF_UP_OR_DOWN, TWO_SIDED_BEST_OF_UP_OR_DOWN, ONE_SIDED_BEST_OF_UP_OR_DOWN_ORTHOGONAL_HYPEREDGES, TWO_SIDED_BEST_OF_UP_OR_DOWN_ORTHOGONAL_HYPEREDGES, ONE_SIDED_ORTHOGONAL_HYPEREDGES, OFF])));
}

var $MAP_23;
function $clinit_InLayerConstraint(){
  $clinit_InLayerConstraint = emptyMethod;
  NONE_4 = new InLayerConstraint('NONE', 0);
  TOP_0 = new InLayerConstraint('TOP', 1);
  BOTTOM_0 = new InLayerConstraint('BOTTOM', 2);
}

function InLayerConstraint(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function values_52(){
  $clinit_InLayerConstraint();
  return stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_properties_InLayerConstraint_2_classLit, 1), $intern_13, 140, 0, [NONE_4, TOP_0, BOTTOM_0]);
}

defineClass(140, 17, {140:1, 3:1, 23:1, 17:1}, InLayerConstraint);
var BOTTOM_0, NONE_4, TOP_0;
var Lde_cau_cs_kieler_klay_layered_properties_InLayerConstraint_2_classLit = createForEnum('de.cau.cs.kieler.klay.layered.properties', 'InLayerConstraint', 140, Ljava_lang_Enum_2_classLit, values_52);
function $clinit_InteractiveReferencePoint(){
  $clinit_InteractiveReferencePoint = emptyMethod;
  CENTER_3 = new InteractiveReferencePoint('CENTER', 0);
  TOP_LEFT = new InteractiveReferencePoint('TOP_LEFT', 1);
}

function InteractiveReferencePoint(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function values_53(){
  $clinit_InteractiveReferencePoint();
  return stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_properties_InteractiveReferencePoint_2_classLit, 1), $intern_13, 174, 0, [CENTER_3, TOP_LEFT]);
}

defineClass(174, 17, {174:1, 3:1, 23:1, 17:1}, InteractiveReferencePoint);
var CENTER_3, TOP_LEFT;
var Lde_cau_cs_kieler_klay_layered_properties_InteractiveReferencePoint_2_classLit = createForEnum('de.cau.cs.kieler.klay.layered.properties', 'InteractiveReferencePoint', 174, Ljava_lang_Enum_2_classLit, values_53);
function $clinit_InteractiveReferencePoint$Map(){
  $clinit_InteractiveReferencePoint$Map = emptyMethod;
  $MAP_24 = createValueOfMap(($clinit_InteractiveReferencePoint() , stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_properties_InteractiveReferencePoint_2_classLit, 1), $intern_13, 174, 0, [CENTER_3, TOP_LEFT])));
}

var $MAP_24;
function $clinit_InternalProperties(){
  $clinit_InternalProperties = emptyMethod;
  var all, all0;
  ORIGIN = new Property_1('origin');
  CONFIGURATION = new Property_1('processingConfiguration');
  PROCESSORS = new Property_1('processors');
  COMPOUND_NODE = new Property_2('compoundNode', ($clinit_Boolean() , $clinit_Boolean() , FALSE_0));
  INSIDE_CONNECTIONS = new Property_2('insideConnections', (null , FALSE_0));
  NESTED_LGRAPH = new Property_1('nestedLGraph');
  PARENT_LNODE = new Property_1('parentLNode');
  ORIGINAL_BENDPOINTS = new Property_1('originalBendpoints');
  ORIGINAL_DUMMY_NODE_POSITION = new Property_1('originalDummyNodePosition');
  ORIGINAL_LABEL_EDGE = new Property_1('originalLabelEdge');
  REPRESENTED_LABELS = new Property_1('representedLabels');
  LABEL_SIDE_0 = new Property_2('labelSide', ($clinit_LabelSide() , UNKNOWN));
  REVERSED = new Property_2('reversed', (null , FALSE_0));
  RANDOM = new Property_1('random');
  LONG_EDGE_SOURCE = new Property_2('longEdgeSource', null);
  LONG_EDGE_TARGET = new Property_2('longEdgeTarget', null);
  EDGE_CONSTRAINT = new Property_2('edgeConstraint', ($clinit_EdgeConstraint() , NONE_2));
  IN_LAYER_LAYOUT_UNIT = new Property_1('inLayerLayoutUnit');
  IN_LAYER_CONSTRAINT = new Property_2('inLayerConstraint', ($clinit_InLayerConstraint() , NONE_4));
  IN_LAYER_SUCCESSOR_CONSTRAINTS = new Property_2('inLayerSuccessorConstraint', new ArrayList);
  PORT_DUMMY = new Property_1('portDummy');
  CROSSING_HINT = new Property_2('crossingHint', valueOf_0(0));
  GRAPH_PROPERTIES = new Property_2('graphProperties', (all0 = castTo($getEnumConstants(Lde_cau_cs_kieler_klay_layered_properties_GraphProperties_2_classLit), 11) , new EnumSet$EnumSetImpl(all0, castTo(createFrom(all0, all0.length), 11), 0)));
  EXT_PORT_SIDE = new Property_2('externalPortSide', ($clinit_PortSide() , UNDEFINED_4));
  EXT_PORT_SIZE = new Property_2('externalPortSize', new KVector);
  EXT_PORT_REPLACED_DUMMY = new Property_1('externalPortReplacedDummy');
  EXT_PORT_CONNECTIONS = new Property_2('externalPortConnections', (all = castTo($getEnumConstants(Lde_cau_cs_kieler_kiml_options_PortSide_2_classLit), 11) , new EnumSet$EnumSetImpl(all, castTo(createFrom(all, all.length), 11), 0)));
  PORT_RATIO_OR_POSITION_0 = new Property_2('portRatioOrPosition', 0);
  BARYCENTER_ASSOCIATES = new Property_1('barycenterAssociates');
  TOP_COMMENTS = new Property_1('TopSideComments');
  BOTTOM_COMMENTS = new Property_1('BottomSideComments');
  COMMENT_CONN_PORT = new Property_1('CommentConnectionPort');
  INPUT_COLLECT = new Property_2('inputCollect', (null , FALSE_0));
  OUTPUT_COLLECT = new Property_2('outputCollect', (null , FALSE_0));
  CYCLIC = new Property_2('cyclic', (null , FALSE_0));
  BIG_NODE_ORIGINAL_SIZE = new Property_2('bigNodeOriginalSize', new Float_0(0));
  BIG_NODE_INITIAL = new Property_2('bigNodeInitial', (null , FALSE_0));
  BIGNODES_ORIG_LABELS = new Property_2('de.cau.cs.kieler.klay.layered.bigNodeLabels', new ArrayList);
  BIGNODES_POST_PROCESS = new Property_2('de.cau.cs.kieler.klay.layered.postProcess', null);
  CROSS_HIERARCHY_MAP = new Property_1('crossHierarchyMap');
  TARGET_OFFSET = new Property_1('targetOffset');
  SPLINE_LABEL_SIZE = new Property_2('splineLabelSize', new KVector);
  SPLINE_LOOPSIDE = new Property_2('splineLoopSide', ($clinit_LoopSide() , UNDEFINED_6));
  SPLINE_SELFLOOP_COMPONENTS = new Property_2('splineSelfLoopComponents', new ArrayList);
  SPLINE_SELF_LOOP_MARGINS = new Property_2('splineSelfLoopMargins', new Spacing$Margins);
  SPACINGS = new Property_1('spacings');
  PARTITION_DUMMY = new Property_2('partitionConstraint', (null , FALSE_0));
  OFFSET_0 = new Property(($clinit_LayoutOptions() , OFFSET), new Float_0(0));
  SPACING_0 = new Property_0(SPACING, new Float_0(20), new Float_0(1));
  PORT_SPACING_0 = new Property_0(PORT_SPACING, new Float_0(10), new Float_0(1));
  BORDER_SPACING_0 = new Property_0(BORDER_SPACING, new Float_0(12), new Float_0(0));
  PRIORITY_0 = new Property(PRIORITY, valueOf_0(0));
  ASPECT_RATIO_0 = new Property_0(ASPECT_RATIO, new Float_0($intern_54), new Float_0(0));
  EDGE_ROUTING_0 = new Property(EDGE_ROUTING, ($clinit_EdgeRouting() , ORTHOGONAL));
}

var ASPECT_RATIO_0, BARYCENTER_ASSOCIATES, BIGNODES_ORIG_LABELS, BIGNODES_POST_PROCESS, BIG_NODE_INITIAL, BIG_NODE_ORIGINAL_SIZE, BORDER_SPACING_0, BOTTOM_COMMENTS, COMMENT_CONN_PORT, COMPOUND_NODE, CONFIGURATION, CROSSING_HINT, CROSS_HIERARCHY_MAP, CYCLIC, EDGE_CONSTRAINT, EDGE_ROUTING_0, EXT_PORT_CONNECTIONS, EXT_PORT_REPLACED_DUMMY, EXT_PORT_SIDE, EXT_PORT_SIZE, GRAPH_PROPERTIES, INPUT_COLLECT, INSIDE_CONNECTIONS, IN_LAYER_CONSTRAINT, IN_LAYER_LAYOUT_UNIT, IN_LAYER_SUCCESSOR_CONSTRAINTS, LABEL_SIDE_0, LONG_EDGE_SOURCE, LONG_EDGE_TARGET, NESTED_LGRAPH, OFFSET_0, ORIGIN, ORIGINAL_BENDPOINTS, ORIGINAL_DUMMY_NODE_POSITION, ORIGINAL_LABEL_EDGE, OUTPUT_COLLECT, PARENT_LNODE, PARTITION_DUMMY, PORT_DUMMY, PORT_RATIO_OR_POSITION_0, PORT_SPACING_0, PRIORITY_0, PROCESSORS, RANDOM, REPRESENTED_LABELS, REVERSED, SPACING_0, SPACINGS, SPLINE_LABEL_SIZE, SPLINE_LOOPSIDE, SPLINE_SELFLOOP_COMPONENTS, SPLINE_SELF_LOOP_MARGINS, TARGET_OFFSET, TOP_COMMENTS;
function $clinit_LayerConstraint(){
  $clinit_LayerConstraint = emptyMethod;
  NONE_5 = new LayerConstraint('NONE', 0);
  FIRST = new LayerConstraint('FIRST', 1);
  FIRST_SEPARATE = new LayerConstraint('FIRST_SEPARATE', 2);
  LAST = new LayerConstraint('LAST', 3);
  LAST_SEPARATE = new LayerConstraint('LAST_SEPARATE', 4);
}

function LayerConstraint(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function values_54(){
  $clinit_LayerConstraint();
  return stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_properties_LayerConstraint_2_classLit, 1), $intern_13, 85, 0, [NONE_5, FIRST, FIRST_SEPARATE, LAST, LAST_SEPARATE]);
}

defineClass(85, 17, {85:1, 3:1, 23:1, 17:1}, LayerConstraint);
var FIRST, FIRST_SEPARATE, LAST, LAST_SEPARATE, NONE_5;
var Lde_cau_cs_kieler_klay_layered_properties_LayerConstraint_2_classLit = createForEnum('de.cau.cs.kieler.klay.layered.properties', 'LayerConstraint', 85, Ljava_lang_Enum_2_classLit, values_54);
function $clinit_LayerConstraint$Map(){
  $clinit_LayerConstraint$Map = emptyMethod;
  $MAP_25 = createValueOfMap(($clinit_LayerConstraint() , stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_properties_LayerConstraint_2_classLit, 1), $intern_13, 85, 0, [NONE_5, FIRST, FIRST_SEPARATE, LAST, LAST_SEPARATE])));
}

var $MAP_25;
function $clinit_PortType(){
  $clinit_PortType = emptyMethod;
  UNDEFINED_7 = new PortType('UNDEFINED', 0);
  INPUT = new PortType('INPUT', 1);
  OUTPUT = new PortType('OUTPUT', 2);
}

function PortType(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function values_55(){
  $clinit_PortType();
  return stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_properties_PortType_2_classLit, 1), $intern_13, 219, 0, [UNDEFINED_7, INPUT, OUTPUT]);
}

defineClass(219, 17, {219:1, 3:1, 23:1, 17:1}, PortType);
var INPUT, OUTPUT, UNDEFINED_7;
var Lde_cau_cs_kieler_klay_layered_properties_PortType_2_classLit = createForEnum('de.cau.cs.kieler.klay.layered.properties', 'PortType', 219, Ljava_lang_Enum_2_classLit, values_55);
function $clinit_Properties(){
  $clinit_Properties = emptyMethod;
  NODE_PROMOTION_0 = new Property_2('de.cau.cs.kieler.klay.layered.nodePromotion', ($clinit_NodePromotionStrategy() , NONE_0));
  NODE_PROMOTION_BOUNDARY = new Property_4('de.cau.cs.kieler.klay.layered.nodePromotionBoundary', valueOf_0(0), valueOf_0(0), valueOf_0(100));
  RANDOM_SEED = new Property_2('de.cau.cs.kieler.randomSeed', valueOf_0(1));
  OBJ_SPACING_IN_LAYER_FACTOR = new Property_3('de.cau.cs.kieler.klay.layered.inLayerSpacingFactor', new Float_0(1), new Float_0(0));
  EDGE_SPACING_FACTOR = new Property_2('de.cau.cs.kieler.klay.layered.edgeSpacingFactor', new Float_0(0.5));
  EDGE_NODE_SPACING_FACTOR = new Property_2('de.cau.cs.kieler.klay.layered.edgeNodeSpacingFactor', new Float_0($intern_67));
  DISTRIBUTE_NODES = new Property_2('de.cau.cs.kieler.klay.layered.distributeNodes', ($clinit_Boolean() , $clinit_Boolean() , FALSE_0));
  WIDE_NODES_ON_MULTIPLE_LAYERS = new Property_2('de.cau.cs.kieler.klay.layered.wideNodesOnMultipleLayers', ($clinit_WideNodesStrategy() , OFF_0));
  CYCLE_BREAKING = new Property_2('de.cau.cs.kieler.klay.layered.cycleBreaking', ($clinit_CycleBreakingStrategy() , GREEDY));
  NODE_LAYERING = new Property_2('de.cau.cs.kieler.klay.layered.nodeLayering', ($clinit_LayeringStrategy() , NETWORK_SIMPLEX));
  CROSS_MIN = new Property_2('de.cau.cs.kieler.klay.layered.crossMin', ($clinit_CrossingMinimizationStrategy() , LAYER_SWEEP));
  GREEDY_SWITCH_TYPE = new Property_2('de.cau.cs.kieler.klay.layered.greedySwitch', ($clinit_GreedySwitchType() , TWO_SIDED));
  NODE_PLACER = new Property_2('de.cau.cs.kieler.klay.layered.nodePlace', ($clinit_NodePlacementStrategy() , BRANDES_KOEPF));
  LINEAR_SEGMENTS_DEFLECTION_DAMPENING = new Property_4('de.cau.cs.kieler.klay.layered.linearSegmentsDeflectionDampening', new Float_0($intern_66), new Float_0(0), new Float_0(1));
  FIXED_ALIGNMENT = new Property_2('de.cau.cs.kieler.klay.layered.fixedAlignment', ($clinit_FixedAlignment() , NONE_3));
  EDGE_LABEL_SIDE_SELECTION = new Property_2('de.cau.cs.kieler.klay.layered.edgeLabelSideSelection', ($clinit_EdgeLabelSideSelection() , ALWAYS_UP));
  DEBUG_MODE_0 = new Property_2('de.cau.cs.kieler.debugMode', (null , FALSE_0));
  THOROUGHNESS = new Property_3('de.cau.cs.kieler.klay.layered.thoroughness', valueOf_0(10), valueOf_0(1));
  LAYER_CONSTRAINT = new Property_2('de.cau.cs.kieler.klay.layered.layerConstraint', ($clinit_LayerConstraint() , NONE_5));
  MERGE_EDGES = new Property_2('de.cau.cs.kieler.klay.layered.mergeEdges', (null , FALSE_0));
  MERGE_HIERARCHICAL_EDGES = new Property_2('de.cau.cs.kieler.klay.layered.mergeHierarchyEdges', (null , TRUE_0));
  INTERACTIVE_REFERENCE_POINT = new Property_2('de.cau.cs.kieler.klay.layered.interactiveReferencePoint', ($clinit_InteractiveReferencePoint() , CENTER_3));
  FEEDBACK_EDGES = new Property_2('de.cau.cs.kieler.klay.layered.feedBackEdges', (null , FALSE_0));
  ADD_UNNECESSARY_BENDPOINTS = new Property_2('de.cau.cs.kieler.klay.layered.unnecessaryBendpoints', (null , FALSE_0));
  CONTENT_ALIGNMENT = new Property_2('de.cau.cs.kieler.klay.layered.contentAlignment', ($clinit_ContentAlignment() , of_4(V_TOP_0, stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_properties_ContentAlignment_2_classLit, 1), $intern_13, 123, 0, [H_LEFT_0]))));
  SAUSAGE_FOLDING = new Property_2('de.cau.cs.kieler.klay.layered.sausageFolding', (null , FALSE_0));
  SPLINE_SELF_LOOP_PLACEMENT = new Property_2('de.cau.cs.kieler.klay.layered.splines.selfLoopPlacement', ($clinit_SelfLoopPlacement() , NORTH_STACKED));
  COMPACTION_STRATEGY = new Property_2('de.cau.cs.kieler.klay.layered.nodeplace.compactionStrategy', ($clinit_CompactionStrategy() , CLASSIC));
  NORTH_OR_SOUTH_PORT = new Property_2('de.cau.cs.kieler.klay.layered.northOrSouthPort', (null , FALSE_0));
  POST_COMPACTION = new Property_2('de.cau.cs.kieler.klay.layered.postCompaction', ($clinit_GraphCompactionStrategy() , NONE_1));
  POST_COMPACTION_COSTRAINTS = new Property_2('de.cau.cs.kieler.klay.layered.postCompaction.constraints', ($clinit_ConstraintCalculationStrategy() , SCANLINE));
  COMPACT_COMPONENTS = new Property_2('de.cau.cs.kieler.klay.layered.components.compact', (null , FALSE_0));
}

var ADD_UNNECESSARY_BENDPOINTS, COMPACTION_STRATEGY, COMPACT_COMPONENTS, CONTENT_ALIGNMENT, CROSS_MIN, CYCLE_BREAKING, DEBUG_MODE_0, DISTRIBUTE_NODES, EDGE_LABEL_SIDE_SELECTION, EDGE_NODE_SPACING_FACTOR, EDGE_SPACING_FACTOR, FEEDBACK_EDGES, FIXED_ALIGNMENT, GREEDY_SWITCH_TYPE, INTERACTIVE_REFERENCE_POINT, LAYER_CONSTRAINT, LINEAR_SEGMENTS_DEFLECTION_DAMPENING, MERGE_EDGES, MERGE_HIERARCHICAL_EDGES, NODE_LAYERING, NODE_PLACER, NODE_PROMOTION_0, NODE_PROMOTION_BOUNDARY, NORTH_OR_SOUTH_PORT, OBJ_SPACING_IN_LAYER_FACTOR, POST_COMPACTION, POST_COMPACTION_COSTRAINTS, RANDOM_SEED, SAUSAGE_FOLDING, SPLINE_SELF_LOOP_PLACEMENT, THOROUGHNESS, WIDE_NODES_ON_MULTIPLE_LAYERS;
function $clinit_SelfLoopPlacement(){
  $clinit_SelfLoopPlacement = emptyMethod;
  EQUALLY_DISTRIBUTED = new SelfLoopPlacement('EQUALLY_DISTRIBUTED', 0);
  NORTH_STACKED = new SelfLoopPlacement('NORTH_STACKED', 1);
  NORTH_SEQUENCE = new SelfLoopPlacement('NORTH_SEQUENCE', 2);
}

function SelfLoopPlacement(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function values_56(){
  $clinit_SelfLoopPlacement();
  return stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_properties_SelfLoopPlacement_2_classLit, 1), $intern_13, 153, 0, [EQUALLY_DISTRIBUTED, NORTH_STACKED, NORTH_SEQUENCE]);
}

defineClass(153, 17, {153:1, 3:1, 23:1, 17:1}, SelfLoopPlacement);
var EQUALLY_DISTRIBUTED, NORTH_SEQUENCE, NORTH_STACKED;
var Lde_cau_cs_kieler_klay_layered_properties_SelfLoopPlacement_2_classLit = createForEnum('de.cau.cs.kieler.klay.layered.properties', 'SelfLoopPlacement', 153, Ljava_lang_Enum_2_classLit, values_56);
function $clinit_SelfLoopPlacement$Map(){
  $clinit_SelfLoopPlacement$Map = emptyMethod;
  $MAP_26 = createValueOfMap(($clinit_SelfLoopPlacement() , stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_properties_SelfLoopPlacement_2_classLit, 1), $intern_13, 153, 0, [EQUALLY_DISTRIBUTED, NORTH_STACKED, NORTH_SEQUENCE])));
}

var $MAP_26;
function $getHorizontalSpacing(this$static, t1, t2){
  return this$static.nodeTypeSpacings[t1.ordinal][t2.ordinal];
}

function $getVerticalSpacing(this$static, t1, t2){
  return this$static.nodeTypeSpacings[t1.ordinal][t2.ordinal] * this$static.inLayerSpacingFactor;
}

function $getVerticalSpacing_0(this$static, n1, n2){
  return $getHorizontalSpacing(this$static, n1.type_0, n2.type_0) * this$static.inLayerSpacingFactor;
}

function $nodeTypeSpacing(this$static, nt, spacing){
  this$static.nodeTypeSpacings[nt.ordinal][nt.ordinal] = spacing;
}

function $nodeTypeSpacing_0(this$static, n1, n2, spacing){
  this$static.nodeTypeSpacings[n1.ordinal][n2.ordinal] = spacing;
  this$static.nodeTypeSpacings[n2.ordinal][n1.ordinal] = spacing;
}

function Spacings(graph){
  var n;
  this.nodeSpacing = castTo($getProperty(graph, ($clinit_InternalProperties() , SPACING_0)), 15).value_0;
  this.inLayerSpacingFactor = castTo($getProperty(graph, ($clinit_Properties() , OBJ_SPACING_IN_LAYER_FACTOR)), 15).value_0;
  this.edgeEdgeSpacing = this.nodeSpacing * castTo($getProperty(graph, EDGE_SPACING_FACTOR), 15).value_0;
  this.edgeNodeSpacing = this.nodeSpacing * castTo($getProperty(graph, EDGE_NODE_SPACING_FACTOR), 15).value_0;
  castTo($getProperty(graph, PORT_SPACING_0), 15);
  this.externalPortSpacing = castTo($getProperty(graph, PORT_SPACING_0), 15).value_0;
  this.labelSpacing = castTo($getProperty(graph, ($clinit_LayoutOptions() , LABEL_SPACING)), 15).value_0;
  n = ($clinit_LNode$NodeType() , stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_graph_LNode$NodeType_2_classLit, 1), $intern_13, 132, 0, [NORMAL, LONG_EDGE, EXTERNAL_PORT, NORTH_SOUTH_PORT, LABEL, BIG_NODE])).length;
  this.nodeTypeSpacings = initMultidimensionalArray(F_classLit, [$intern_0, $intern_61], [250, 26], 12, [n, n], 2);
  $nodeTypeSpacing(this, NORMAL, this.nodeSpacing);
  $nodeTypeSpacing_0(this, NORMAL, LONG_EDGE, this.edgeNodeSpacing);
  $nodeTypeSpacing_0(this, NORMAL, NORTH_SOUTH_PORT, this.edgeNodeSpacing);
  $nodeTypeSpacing_0(this, NORMAL, EXTERNAL_PORT, this.externalPortSpacing);
  $nodeTypeSpacing_0(this, NORMAL, LABEL, this.edgeNodeSpacing);
  $nodeTypeSpacing_0(this, NORMAL, BIG_NODE, this.edgeNodeSpacing);
  $nodeTypeSpacing(this, LONG_EDGE, this.edgeEdgeSpacing);
  $nodeTypeSpacing_0(this, LONG_EDGE, NORTH_SOUTH_PORT, this.edgeEdgeSpacing);
  $nodeTypeSpacing_0(this, LONG_EDGE, EXTERNAL_PORT, this.externalPortSpacing);
  $nodeTypeSpacing_0(this, LONG_EDGE, LABEL, this.labelSpacing);
  $nodeTypeSpacing_0(this, LONG_EDGE, BIG_NODE, this.edgeNodeSpacing);
  $nodeTypeSpacing(this, NORTH_SOUTH_PORT, this.edgeEdgeSpacing);
  $nodeTypeSpacing_0(this, NORTH_SOUTH_PORT, EXTERNAL_PORT, this.externalPortSpacing);
  $nodeTypeSpacing_0(this, NORTH_SOUTH_PORT, LABEL, this.labelSpacing);
  $nodeTypeSpacing_0(this, NORTH_SOUTH_PORT, BIG_NODE, this.edgeNodeSpacing);
  $nodeTypeSpacing(this, EXTERNAL_PORT, this.externalPortSpacing);
  $nodeTypeSpacing_0(this, EXTERNAL_PORT, LABEL, this.externalPortSpacing);
  $nodeTypeSpacing_0(this, EXTERNAL_PORT, BIG_NODE, this.externalPortSpacing);
  $nodeTypeSpacing(this, LABEL, this.labelSpacing);
  $nodeTypeSpacing_0(this, LABEL, BIG_NODE, this.labelSpacing);
  $nodeTypeSpacing(this, BIG_NODE, this.nodeSpacing);
}

defineClass(134, 1, {134:1}, Spacings);
_.edgeEdgeSpacing = 0;
_.edgeNodeSpacing = 0;
_.externalPortSpacing = 0;
_.inLayerSpacingFactor = 0;
_.labelSpacing = 0;
_.nodeSpacing = 0;
var Lde_cau_cs_kieler_klay_layered_properties_Spacings_2_classLit = createForClass('de.cau.cs.kieler.klay.layered.properties', 'Spacings', 134);
function $clinit_WideNodesStrategy(){
  $clinit_WideNodesStrategy = emptyMethod;
  AGGRESSIVE = new WideNodesStrategy('AGGRESSIVE', 0);
  CAREFUL = new WideNodesStrategy('CAREFUL', 1);
  OFF_0 = new WideNodesStrategy('OFF', 2);
}

function WideNodesStrategy(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function values_57(){
  $clinit_WideNodesStrategy();
  return stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_properties_WideNodesStrategy_2_classLit, 1), $intern_13, 172, 0, [AGGRESSIVE, CAREFUL, OFF_0]);
}

defineClass(172, 17, {172:1, 3:1, 23:1, 17:1}, WideNodesStrategy);
var AGGRESSIVE, CAREFUL, OFF_0;
var Lde_cau_cs_kieler_klay_layered_properties_WideNodesStrategy_2_classLit = createForEnum('de.cau.cs.kieler.klay.layered.properties', 'WideNodesStrategy', 172, Ljava_lang_Enum_2_classLit, values_57);
function $clinit_WideNodesStrategy$Map(){
  $clinit_WideNodesStrategy$Map = emptyMethod;
  $MAP_27 = createValueOfMap(($clinit_WideNodesStrategy() , stampJavaTypeInfo(getClassLiteralForArray(Lde_cau_cs_kieler_klay_layered_properties_WideNodesStrategy_2_classLit, 1), $intern_13, 172, 0, [AGGRESSIVE, CAREFUL, OFF_0])));
}

var $MAP_27;
defineClass(643, 1, {});
var Ljava_io_OutputStream_2_classLit = createForClass('java.io', 'OutputStream', 643);
defineClass(644, 643, {});
var Ljava_io_FilterOutputStream_2_classLit = createForClass('java.io', 'FilterOutputStream', 644);
function PrintStream(){
}

defineClass(291, 644, {}, PrintStream);
var Ljava_io_PrintStream_2_classLit = createForClass('java.io', 'PrintStream', 291);
function $append0(this$static, x_0, start_0, end){
  x_0 == null && (x_0 = 'null');
  this$static.string += '' + ($clinit_String() , x_0.substr(start_0, end - start_0));
}

function $substring(this$static, end){
  return $substring_0(this$static.string, 0, end);
}

function AbstractStringBuilder(string){
  this.string = string;
}

defineClass(255, 1, {});
_.toString_0 = function toString_71(){
  return this.string;
}
;
var Ljava_lang_AbstractStringBuilder_2_classLit = createForClass('java.lang', 'AbstractStringBuilder', 255);
function ArrayIndexOutOfBoundsException(){
  IndexOutOfBoundsException.call(this);
}

defineClass(620, 95, $intern_2, ArrayIndexOutOfBoundsException);
var Ljava_lang_ArrayIndexOutOfBoundsException_2_classLit = createForClass('java.lang', 'ArrayIndexOutOfBoundsException', 620);
function ArrayStoreException(){
  RuntimeException.call(this);
}

function ArrayStoreException_0(message){
  RuntimeException_0.call(this, message);
}

defineClass(290, 72, $intern_2, ArrayStoreException, ArrayStoreException_0);
var Ljava_lang_ArrayStoreException_2_classLit = createForClass('java.lang', 'ArrayStoreException', 290);
function Error_0(message, cause){
  this.cause = cause;
  this.detailMessage = message;
  $fillInStackTrace(this);
}

defineClass(252, 46, $intern_1);
var Ljava_lang_Error_2_classLit = createForClass('java.lang', 'Error', 252);
function AssertionError(){
  $fillInStackTrace(this);
}

function AssertionError_0(message){
  Error_0.call(this, ($clinit_String() , message == null?'null':toString__Ljava_lang_String___devirtual$(message)), instanceOf(message, 46)?castTo(message, 46):null);
}

defineClass(84, 252, $intern_1, AssertionError, AssertionError_0);
var Ljava_lang_AssertionError_2_classLit = createForClass('java.lang', 'AssertionError', 84);
function $clinit_Boolean(){
  $clinit_Boolean = emptyMethod;
  FALSE_0 = ($clinit_Boolean() , false);
  TRUE_0 = true;
}

function $compareTo_11(this$static, b){
  return compare_30(unsafeCast((checkCriticalNotNull(this$static) , this$static)), unsafeCast((checkCriticalNotNull(b) , b)));
}

function compare_30(x_0, y_0){
  $clinit_Boolean();
  return x_0 == y_0?0:x_0?1:-1;
}

function compareTo_Ljava_lang_Object__I__devirtual$(this$static, other){
  $clinit_Boolean();
  return instanceOfString(this$static)?compareTo_15(this$static, castToString(other)):instanceOfDouble(this$static)?$compareTo_12(this$static, castToDouble(other)):instanceOfBoolean(this$static)?$compareTo_11(this$static, castToBoolean(other)):this$static.compareTo(other);
}

function toString_72(x_0){
  $clinit_Boolean();
  return $clinit_String() , '' + x_0;
}

function unsafeCast(value_0){
  $clinit_Boolean();
  return value_0;
}

booleanCastMap = {3:1, 349:1, 23:1};
var FALSE_0, TRUE_0;
var Ljava_lang_Boolean_2_classLit = createForClass('java.lang', 'Boolean', 349);
function $compareTo_12(this$static, b){
  return compare_31((checkCriticalNotNull(this$static) , this$static), (checkCriticalNotNull(b) , b));
}

function compare_31(x_0, y_0){
  if (x_0 < y_0) {
    return -1;
  }
  if (x_0 > y_0) {
    return 1;
  }
  if (x_0 == y_0) {
    return 0;
  }
  return isNaN(x_0)?isNaN(y_0)?0:1:-1;
}

function isNaN_0(x_0){
  return isNaN(x_0);
}

function toString_74(b){
  return $clinit_String() , '' + b;
}

doubleCastMap = {3:1, 23:1, 184:1, 231:1};
var Ljava_lang_Double_2_classLit = createForClass('java.lang', 'Double', 184);
function $compareTo_13(this$static, b){
  return compare_31(this$static.value_0, b.value_0);
}

function Float(value_0){
  this.value_0 = value_0;
}

function Float_0(value_0){
  this.value_0 = value_0;
}

function toString_76(b){
  return $clinit_String() , '' + b;
}

defineClass(15, 231, {3:1, 23:1, 15:1, 231:1}, Float, Float_0);
_.compareTo = function compareTo_13(b){
  return $compareTo_13(this, castTo(b, 15));
}
;
_.equals = function equals_38(o){
  return instanceOf(o, 15) && castTo(o, 15).value_0 == this.value_0;
}
;
_.hashCode_0 = function hashCode_38(){
  return round_int(this.value_0);
}
;
_.toString_0 = function toString_75(){
  return toString_76(this.value_0);
}
;
_.value_0 = 0;
var Ljava_lang_Float_2_classLit = createForClass('java.lang', 'Float', 15);
function IllegalStateException(){
  RuntimeException.call(this);
}

function IllegalStateException_0(s){
  RuntimeException_0.call(this, s);
}

defineClass(100, 72, $intern_2, IllegalStateException, IllegalStateException_0);
var Ljava_lang_IllegalStateException_2_classLit = createForClass('java.lang', 'IllegalStateException', 100);
function $clinit_Integer$BoxedValues(){
  $clinit_Integer$BoxedValues = emptyMethod;
  boxedValues = initUnidimensionalArray(Ljava_lang_Integer_2_classLit, $intern_0, 24, 256, 0, 1);
}

var boxedValues;
function $clinit_Integer$ReverseNibbles(){
  $clinit_Integer$ReverseNibbles = emptyMethod;
  reverseNibbles = stampJavaTypeInfo(getClassLiteralForArray(I_classLit, 1), $intern_37, 26, 12, [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]);
}

var reverseNibbles;
function abs_0(x_0){
  return x_0 <= 0?0 - x_0:x_0;
}

function abs_1(x_0){
  return x_0 < 0?-x_0:x_0;
}

function ceil_0(x_0){
  return Math.ceil(x_0);
}

function floor_0(x_0){
  return Math.floor(x_0);
}

function max_1(x_0, y_0){
  return x_0 > y_0?x_0:y_0;
}

function max_2(x_0, y_0){
  return x_0 > y_0?x_0:y_0;
}

function max_3(x_0, y_0){
  return x_0 > y_0?x_0:y_0;
}

function min_1(x_0, y_0){
  return x_0 < y_0?x_0:y_0;
}

function min_2(x_0, y_0){
  return x_0 < y_0?x_0:y_0;
}

function min_3(x_0, y_0){
  return x_0 < y_0?x_0:y_0;
}

function sqrt_0(x_0){
  return Math.sqrt(x_0);
}

function NegativeArraySizeException(message){
  RuntimeException_0.call(this, message);
}

defineClass(607, 72, $intern_2, NegativeArraySizeException);
var Ljava_lang_NegativeArraySizeException_2_classLit = createForClass('java.lang', 'NegativeArraySizeException', 607);
function NullPointerException(){
  RuntimeException.call(this);
}

function NullPointerException_0(message){
  RuntimeException_0.call(this, message);
}

defineClass(76, 72, {3:1, 54:1, 76:1, 46:1}, NullPointerException, NullPointerException_0);
var Ljava_lang_NullPointerException_2_classLit = createForClass('java.lang', 'NullPointerException', 76);
function NumberFormatException(){
  IllegalArgumentException.call(this);
}

function NumberFormatException_0(message){
  IllegalArgumentException_0.call(this, message);
}

defineClass(130, 29, {3:1, 54:1, 29:1, 130:1, 46:1}, NumberFormatException, NumberFormatException_0);
var Ljava_lang_NumberFormatException_2_classLit = createForClass('java.lang', 'NumberFormatException', 130);
function StackTraceElement(methodName, fileName, lineNumber){
  this.className = 'Unknown';
  this.methodName = methodName;
  this.fileName = fileName;
  this.lineNumber = lineNumber;
}

defineClass(146, 1, {3:1, 146:1}, StackTraceElement);
_.equals = function equals_40(other){
  var st;
  if (instanceOf(other, 146)) {
    st = castTo(other, 146);
    return this.lineNumber == st.lineNumber && equals_50(this.methodName, st.methodName) && equals_50(this.className, st.className) && equals_50(this.fileName, st.fileName);
  }
  return false;
}
;
_.hashCode_0 = function hashCode_40(){
  return hashCode_44(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [valueOf_0(this.lineNumber), this.className, this.methodName, this.fileName]));
}
;
_.toString_0 = function toString_79(){
  return this.className + '.' + this.methodName + '(' + (this.fileName != null?this.fileName:'Unknown Source') + (this.lineNumber >= 0?':' + this.lineNumber:'') + ')';
}
;
_.lineNumber = 0;
var Ljava_lang_StackTraceElement_2_classLit = createForClass('java.lang', 'StackTraceElement', 146);
function $append(this$static, x_0){
  this$static.string += String.fromCharCode(x_0);
  return this$static;
}

function $append_0(this$static, x_0){
  return this$static.string += '' + x_0 , this$static;
}

function $append_1(this$static, x_0, start_0, end){
  $append0(this$static, x_0, start_0, end);
  return this$static;
}

function $append_2(this$static, x_0){
  this$static.string += '' + x_0;
  return this$static;
}

function $append_3(this$static, x_0){
  this$static.string += '' + x_0;
  return this$static;
}

function StringBuilder(){
  AbstractStringBuilder.call(this, '');
}

function StringBuilder_0(){
  AbstractStringBuilder.call(this, '');
}

function StringBuilder_1(s){
  AbstractStringBuilder.call(this, s);
}

defineClass(102, 255, {345:1}, StringBuilder, StringBuilder_0, StringBuilder_1);
var Ljava_lang_StringBuilder_2_classLit = createForClass('java.lang', 'StringBuilder', 102);
function $clinit_System(){
  $clinit_System = emptyMethod;
  err = new PrintStream;
  out_0 = new PrintStream;
}

function arraycopy(src_0, srcOfs, dest, destOfs, len){
  $clinit_System();
  var destComp, destEnd, destType, destlen, srcComp, srcType, srclen;
  checkCriticalNotNull_0(src_0, 'src');
  checkCriticalNotNull_0(dest, 'dest');
  srcType = getClass__Ljava_lang_Class___devirtual$(src_0);
  destType = getClass__Ljava_lang_Class___devirtual$(dest);
  checkCriticalArrayType_0((srcType.modifiers & 4) != 0, 'srcType is not an array');
  checkCriticalArrayType_0((destType.modifiers & 4) != 0, 'destType is not an array');
  srcComp = srcType.componentType;
  destComp = destType.componentType;
  checkCriticalArrayType_0((srcComp.modifiers & 1) != 0?srcComp == destComp:(destComp.modifiers & 1) == 0, "Array types don't match");
  srclen = src_0.length;
  destlen = dest.length;
  if (srcOfs < 0 || destOfs < 0 || len < 0 || srcOfs + len > srclen || destOfs + len > destlen) {
    throw new IndexOutOfBoundsException;
  }
  if (((srcComp.modifiers & 1) == 0 || (srcComp.modifiers & 4) != 0) && srcType != destType) {
    if (src_0 === dest && srcOfs < destOfs) {
      srcOfs += len;
      for (destEnd = destOfs + len; destEnd-- > destOfs;) {
        dest[destEnd] = src_0[--srcOfs];
      }
    }
     else {
      for (destEnd = destOfs + len; destOfs < destEnd;) {
        dest[destOfs++] = src_0[srcOfs++];
      }
    }
  }
   else 
    len > 0 && copy_0(src_0, srcOfs, dest, destOfs, len, true);
}

var err, out_0;
function UnsupportedOperationException(){
  RuntimeException.call(this);
}

function UnsupportedOperationException_0(message){
  RuntimeException_0.call(this, message);
}

defineClass(45, 72, {3:1, 54:1, 46:1, 45:1}, UnsupportedOperationException, UnsupportedOperationException_0);
var Ljava_lang_UnsupportedOperationException_2_classLit = createForClass('java.lang', 'UnsupportedOperationException', 45);
function $containsKey_1(this$static, key){
  return instanceOfString(key)?key == null?!!$getEntry(this$static.hashCodeMap, null):$contains_8(this$static.stringMap, key):!!$getEntry(this$static.hashCodeMap, key);
}

function $containsValue_0(this$static, value_0, entries){
  var entry, entry$iterator;
  for (entry$iterator = entries.iterator_0(); entry$iterator.hasNext_0();) {
    entry = castTo(entry$iterator.next_1(), 21);
    if (this$static.equals_0(value_0, entry.getValue())) {
      return true;
    }
  }
  return false;
}

function $get_9(this$static, key){
  return instanceOfString(key)?$getStringValue(this$static, key):getEntryValueOrNull($getEntry(this$static.hashCodeMap, key));
}

function $getStringValue(this$static, key){
  return key == null?getEntryValueOrNull($getEntry(this$static.hashCodeMap, null)):$get_14(this$static.stringMap, key);
}

function $put_2(this$static, key, value_0){
  return instanceOfString(key)?$putStringValue(this$static, key, value_0):$put_5(this$static.hashCodeMap, key, value_0);
}

function $putStringValue(this$static, key, value_0){
  return key == null?$put_5(this$static.hashCodeMap, null, value_0):$put_6(this$static.stringMap, key, value_0);
}

function $remove_9(this$static, key){
  return instanceOfString(key)?$removeStringValue(this$static, key):$remove_18(this$static.hashCodeMap, key);
}

function $removeStringValue(this$static, key){
  return key == null?$remove_18(this$static.hashCodeMap, null):$remove_19(this$static.stringMap, key);
}

function $reset_3(this$static){
  var modCount;
  this$static.hashCodeMap = new InternalHashCodeMap(this$static);
  this$static.stringMap = new InternalStringMap(this$static);
  modCount = this$static['_gwt_modCount'] | 0;
  this$static['_gwt_modCount'] = modCount + 1;
}

function $size_0(this$static){
  return this$static.hashCodeMap.size_0 + this$static.stringMap.size_0;
}

function AbstractHashMap(ignored, alsoIgnored){
  checkCriticalArgument_0(ignored >= 0, 'Negative initial capacity');
  checkCriticalArgument_0(alsoIgnored >= 0, 'Non-positive load factor');
  $reset_3(this);
}

defineClass(213, 637, $intern_19);
_.clear_0 = function clear_24(){
  $reset_3(this);
}
;
_.containsKey = function containsKey_6(key){
  return $containsKey_1(this, key);
}
;
_.containsValue = function containsValue_2(value_0){
  return $containsValue_0(this, value_0, this.stringMap) || $containsValue_0(this, value_0, this.hashCodeMap);
}
;
_.entrySet_0 = function entrySet_2(){
  return new AbstractHashMap$EntrySet(this);
}
;
_.get_1 = function get_18(key){
  return $get_9(this, key);
}
;
_.put = function put_1(key, value_0){
  return $put_2(this, key, value_0);
}
;
_.remove_0 = function remove_50(key){
  return $remove_9(this, key);
}
;
_.size_1 = function size_35(){
  return $size_0(this);
}
;
var Ljava_util_AbstractHashMap_2_classLit = createForClass('java.util', 'AbstractHashMap', 213);
function $contains_2(this$static, o){
  if (instanceOf(o, 21)) {
    return $containsEntry(this$static.this$01, castTo(o, 21));
  }
  return false;
}

function AbstractHashMap$EntrySet(this$0){
  this.this$01 = this$0;
}

defineClass(120, 640, $intern_21, AbstractHashMap$EntrySet);
_.clear_0 = function clear_25(){
  this.this$01.clear_0();
}
;
_.contains = function contains_25(o){
  return $contains_2(this, o);
}
;
_.iterator_0 = function iterator_49(){
  return new AbstractHashMap$EntrySetIterator(this.this$01);
}
;
_.remove_1 = function remove_51(entry){
  var key;
  if ($contains_2(this, entry)) {
    key = castTo(entry, 21).getKey();
    this.this$01.remove_0(key);
    return true;
  }
  return false;
}
;
_.size_1 = function size_36(){
  return this.this$01.size_1();
}
;
var Ljava_util_AbstractHashMap$EntrySet_2_classLit = createForClass('java.util', 'AbstractHashMap/EntrySet', 120);
function $computeHasNext(this$static){
  if (this$static.current.hasNext_0()) {
    return true;
  }
  if (this$static.current != this$static.stringMapEntries) {
    return false;
  }
  this$static.current = new InternalHashCodeMap$1(this$static.this$01.hashCodeMap);
  return this$static.current.hasNext_0();
}

function $next_6(this$static){
  var rv;
  checkStructuralChange(this$static.this$01, this$static);
  checkCriticalElement(this$static.hasNext);
  this$static.last = this$static.current;
  rv = castTo(this$static.current.next_1(), 21);
  this$static.hasNext = $computeHasNext(this$static);
  return rv;
}

function $remove_10(this$static){
  checkCritcalState(!!this$static.last);
  checkStructuralChange(this$static.this$01, this$static);
  this$static.last.remove();
  this$static.last = null;
  this$static.hasNext = $computeHasNext(this$static);
  recordLastKnownStructure(this$static.this$01, this$static);
}

function AbstractHashMap$EntrySetIterator(this$0){
  var modCount;
  this.this$01 = this$0;
  this.stringMapEntries = new InternalStringMap$1(this.this$01.stringMap);
  this.current = this.stringMapEntries;
  this.hasNext = $computeHasNext(this);
  modCount = this$0['_gwt_modCount'];
  this['_gwt_modCount'] = modCount;
}

defineClass(148, 1, $intern_18, AbstractHashMap$EntrySetIterator);
_.next_1 = function next_25(){
  return $next_6(this);
}
;
_.hasNext_0 = function hasNext_24(){
  return this.hasNext;
}
;
_.remove = function remove_52(){
  $remove_10(this);
}
;
_.hasNext = false;
var Ljava_util_AbstractHashMap$EntrySetIterator_2_classLit = createForClass('java.util', 'AbstractHashMap/EntrySetIterator', 148);
function $remove_11(this$static){
  checkCritcalState(this$static.last != -1);
  this$static.this$01_0.remove_2(this$static.last);
  this$static.i = this$static.last;
  this$static.last = -1;
}

function AbstractList$IteratorImpl(this$0){
  this.this$01_0 = this$0;
}

defineClass(162, 1, $intern_18, AbstractList$IteratorImpl);
_.hasNext_0 = function hasNext_25(){
  return this.i < this.this$01_0.size_1();
}
;
_.next_1 = function next_26(){
  return checkCriticalElement(this.hasNext_0()) , this.this$01_0.get_2(this.last = this.i++);
}
;
_.remove = function remove_53(){
  $remove_11(this);
}
;
_.i = 0;
_.last = -1;
var Ljava_util_AbstractList$IteratorImpl_2_classLit = createForClass('java.util', 'AbstractList/IteratorImpl', 162);
function $add_15(this$static, o){
  this$static.this$01.add_2(this$static.i, o);
  ++this$static.i;
  this$static.last = -1;
}

function $hasNext_2(this$static){
  return this$static.i < this$static.this$01_0.size_1();
}

function $next_7(this$static){
  return checkCriticalElement(this$static.i < this$static.this$01_0.size_1()) , this$static.this$01_0.get_2(this$static.last = this$static.i++);
}

function $previous_1(this$static){
  checkCriticalElement(this$static.i > 0);
  return this$static.this$01.get_2(this$static.last = --this$static.i);
}

function $set_4(this$static, o){
  checkCritcalState(this$static.last != -1);
  this$static.this$01.set_2(this$static.last, o);
}

function AbstractList$ListIteratorImpl(this$0, start_0){
  this.this$01 = this$0;
  AbstractList$IteratorImpl.call(this, this$0);
  checkCriticalPositionIndex(start_0, this$0.size_1());
  this.i = start_0;
}

defineClass(43, 162, $intern_24, AbstractList$ListIteratorImpl);
_.add_0 = function add_27(o){
  $add_15(this, o);
}
;
_.hasPrevious = function hasPrevious_5(){
  return this.i > 0;
}
;
_.nextIndex_0 = function nextIndex_6(){
  return this.i;
}
;
_.previous_0 = function previous_6(){
  return $previous_1(this);
}
;
_.previousIndex = function previousIndex_5(){
  return this.i - 1;
}
;
_.set_1 = function set_13(o){
  $set_4(this, o);
}
;
var Ljava_util_AbstractList$ListIteratorImpl_2_classLit = createForClass('java.util', 'AbstractList/ListIteratorImpl', 43);
function AbstractList$SubList(wrapped, fromIndex, toIndex){
  checkCriticalPositionIndexes(fromIndex, toIndex, wrapped.size_1());
  this.wrapped = wrapped;
  this.fromIndex = fromIndex;
  this.size_0 = toIndex - fromIndex;
}

defineClass(258, 646, $intern_22, AbstractList$SubList);
_.add_2 = function add_28(index_0, element){
  checkCriticalPositionIndex(index_0, this.size_0);
  this.wrapped.add_2(this.fromIndex + index_0, element);
  ++this.size_0;
}
;
_.get_2 = function get_19(index_0){
  checkCriticalElementIndex(index_0, this.size_0);
  return this.wrapped.get_2(this.fromIndex + index_0);
}
;
_.remove_2 = function remove_54(index_0){
  var result;
  checkCriticalElementIndex(index_0, this.size_0);
  result = this.wrapped.remove_2(this.fromIndex + index_0);
  --this.size_0;
  return result;
}
;
_.set_2 = function set_14(index_0, element){
  checkCriticalElementIndex(index_0, this.size_0);
  return this.wrapped.set_2(this.fromIndex + index_0, element);
}
;
_.size_1 = function size_37(){
  return this.size_0;
}
;
_.fromIndex = 0;
_.size_0 = 0;
var Ljava_util_AbstractList$SubList_2_classLit = createForClass('java.util', 'AbstractList/SubList', 258);
function AbstractMap$1(this$0){
  this.this$01 = this$0;
}

defineClass(36, 640, $intern_21, AbstractMap$1);
_.clear_0 = function clear_26(){
  this.this$01.clear_0();
}
;
_.contains = function contains_26(key){
  return this.this$01.containsKey(key);
}
;
_.iterator_0 = function iterator_50(){
  var outerIter;
  return outerIter = this.this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter);
}
;
_.remove_1 = function remove_55(key){
  if (this.this$01.containsKey(key)) {
    this.this$01.remove_0(key);
    return true;
  }
  return false;
}
;
_.size_1 = function size_38(){
  return this.this$01.size_1();
}
;
var Ljava_util_AbstractMap$1_2_classLit = createForClass('java.util', 'AbstractMap/1', 36);
function AbstractMap$1$1(val$outerIter){
  this.val$outerIter2 = val$outerIter;
}

defineClass(39, 1, $intern_18, AbstractMap$1$1);
_.hasNext_0 = function hasNext_26(){
  return this.val$outerIter2.hasNext_0();
}
;
_.next_1 = function next_27(){
  var entry;
  return entry = castTo(this.val$outerIter2.next_1(), 21) , entry.getKey();
}
;
_.remove = function remove_56(){
  this.val$outerIter2.remove();
}
;
var Ljava_util_AbstractMap$1$1_2_classLit = createForClass('java.util', 'AbstractMap/1/1', 39);
function AbstractMap$2(this$0){
  this.this$01 = this$0;
}

defineClass(211, 639, $intern_20, AbstractMap$2);
_.clear_0 = function clear_27(){
  this.this$01.clear_0();
}
;
_.contains = function contains_27(value_0){
  return this.this$01.containsValue(value_0);
}
;
_.iterator_0 = function iterator_51(){
  var outerIter;
  return outerIter = this.this$01.entrySet_0().iterator_0() , new AbstractMap$2$1(outerIter);
}
;
_.size_1 = function size_39(){
  return this.this$01.size_1();
}
;
var Ljava_util_AbstractMap$2_2_classLit = createForClass('java.util', 'AbstractMap/2', 211);
function AbstractMap$2$1(val$outerIter){
  this.val$outerIter2 = val$outerIter;
}

defineClass(212, 1, $intern_18, AbstractMap$2$1);
_.hasNext_0 = function hasNext_27(){
  return this.val$outerIter2.hasNext_0();
}
;
_.next_1 = function next_28(){
  var entry;
  return entry = castTo(this.val$outerIter2.next_1(), 21) , entry.getValue();
}
;
_.remove = function remove_57(){
  this.val$outerIter2.remove();
}
;
var Ljava_util_AbstractMap$2$1_2_classLit = createForClass('java.util', 'AbstractMap/2/1', 212);
function $setValue(this$static, value_0){
  var oldValue;
  oldValue = this$static.value_0;
  this$static.value_0 = value_0;
  return oldValue;
}

defineClass(210, 1, {210:1, 21:1});
_.equals = function equals_42(other){
  var entry;
  if (!instanceOf(other, 21)) {
    return false;
  }
  entry = castTo(other, 21);
  return equals_50(this.key, entry.getKey()) && equals_50(this.value_0, entry.getValue());
}
;
_.getKey = function getKey_1(){
  return this.key;
}
;
_.getValue = function getValue_1(){
  return this.value_0;
}
;
_.hashCode_0 = function hashCode_42(){
  return hashCode_52(this.key) ^ hashCode_52(this.value_0);
}
;
_.setValue = function setValue_2(value_0){
  return $setValue(this, value_0);
}
;
_.toString_0 = function toString_81(){
  return this.key + '=' + this.value_0;
}
;
var Ljava_util_AbstractMap$AbstractEntry_2_classLit = createForClass('java.util', 'AbstractMap/AbstractEntry', 210);
function AbstractMap$SimpleEntry(key, value_0){
  this.key = key;
  this.value_0 = value_0;
}

defineClass(163, 210, {210:1, 163:1, 21:1}, AbstractMap$SimpleEntry);
var Ljava_util_AbstractMap$SimpleEntry_2_classLit = createForClass('java.util', 'AbstractMap/SimpleEntry', 163);
defineClass(651, 1, $intern_26);
_.equals = function equals_43(other){
  var entry;
  if (!instanceOf(other, 21)) {
    return false;
  }
  entry = castTo(other, 21);
  return equals_50(this.getKey(), entry.getKey()) && equals_50(this.getValue(), entry.getValue());
}
;
_.hashCode_0 = function hashCode_43(){
  return hashCode_52(this.getKey()) ^ hashCode_52(this.getValue());
}
;
_.toString_0 = function toString_82(){
  return this.getKey() + '=' + this.getValue();
}
;
var Ljava_util_AbstractMapEntry_2_classLit = createForClass('java.util', 'AbstractMapEntry', 651);
function $containsEntry_0(this$static, entry){
  var key, lookupEntry;
  key = entry.getKey();
  lookupEntry = $getEntry_0(this$static, key);
  return !!lookupEntry && equals_50(lookupEntry.value_0, entry.getValue());
}

function $containsKey_2(this$static, k){
  return !!$getEntry_0(this$static, k);
}

defineClass(638, 637, $intern_19);
_.containsEntry = function containsEntry_0(entry){
  return $containsEntry_0(this, entry);
}
;
_.containsKey = function containsKey_7(k){
  return $containsKey_2(this, k);
}
;
_.entrySet_0 = function entrySet_3(){
  return new AbstractNavigableMap$EntrySet(this);
}
;
_.get_1 = function get_20(k){
  return getEntryValueOrNull($getEntry_0(this, k));
}
;
_.keySet_0 = function keySet_5(){
  return new AbstractNavigableMap$NavigableKeySet(this);
}
;
var Ljava_util_AbstractNavigableMap_2_classLit = createForClass('java.util', 'AbstractNavigableMap', 638);
function AbstractNavigableMap$EntrySet(this$0){
  this.this$01_0 = this$0;
}

defineClass(287, 640, $intern_21, AbstractNavigableMap$EntrySet);
_.contains = function contains_28(o){
  return instanceOf(o, 21) && $containsEntry_0(this.this$01_0, castTo(o, 21));
}
;
_.iterator_0 = function iterator_52(){
  return new TreeMap$EntryIterator(this.this$01_0);
}
;
_.remove_1 = function remove_58(o){
  var entry;
  if (instanceOf(o, 21)) {
    entry = castTo(o, 21);
    return $removeEntry(this.this$01_0, entry);
  }
  return false;
}
;
_.size_1 = function size_40(){
  return this.this$01_0.size_0;
}
;
var Ljava_util_AbstractNavigableMap$EntrySet_2_classLit = createForClass('java.util', 'AbstractNavigableMap/EntrySet', 287);
function AbstractNavigableMap$NavigableKeySet(map_0){
  this.map_0 = map_0;
}

defineClass(229, 640, $intern_25, AbstractNavigableMap$NavigableKeySet);
_.clear_0 = function clear_28(){
  $clear_7(this.map_0);
}
;
_.contains = function contains_29(o){
  return $containsKey_2(this.map_0, o);
}
;
_.iterator_0 = function iterator_53(){
  var entryIterator;
  return entryIterator = new TreeMap$EntryIterator((new TreeMap$EntrySet(this.map_0)).this$01_0) , new AbstractNavigableMap$NavigableKeySet$1(entryIterator);
}
;
_.remove_1 = function remove_59(o){
  if ($containsKey_2(this.map_0, o)) {
    $remove_23(this.map_0, o);
    return true;
  }
  return false;
}
;
_.size_1 = function size_41(){
  return this.map_0.size_0;
}
;
var Ljava_util_AbstractNavigableMap$NavigableKeySet_2_classLit = createForClass('java.util', 'AbstractNavigableMap/NavigableKeySet', 229);
function AbstractNavigableMap$NavigableKeySet$1(val$entryIterator){
  this.val$entryIterator2 = val$entryIterator;
}

defineClass(230, 1, $intern_18, AbstractNavigableMap$NavigableKeySet$1);
_.hasNext_0 = function hasNext_28(){
  return $hasNext_2(this.val$entryIterator2.iter);
}
;
_.next_1 = function next_29(){
  var entry;
  return entry = $next_12(this.val$entryIterator2) , entry.getKey();
}
;
_.remove = function remove_60(){
  $remove_24(this.val$entryIterator2);
}
;
var Ljava_util_AbstractNavigableMap$NavigableKeySet$1_2_classLit = createForClass('java.util', 'AbstractNavigableMap/NavigableKeySet/1', 230);
function $hasNext_3(this$static){
  return this$static.i < this$static.this$01.array.length;
}

function $next_8(this$static){
  checkCriticalElement(this$static.i < this$static.this$01.array.length);
  this$static.last = this$static.i++;
  return this$static.this$01.array[this$static.last];
}

function $remove_12(this$static){
  checkCritcalState(this$static.last != -1);
  this$static.this$01.remove_2(this$static.i = this$static.last);
  this$static.last = -1;
}

function ArrayList$1(this$0){
  this.this$01 = this$0;
}

defineClass(4, 1, $intern_18, ArrayList$1);
_.hasNext_0 = function hasNext_29(){
  return $hasNext_3(this);
}
;
_.next_1 = function next_30(){
  return $next_8(this);
}
;
_.remove = function remove_61(){
  $remove_12(this);
}
;
_.i = 0;
_.last = -1;
var Ljava_util_ArrayList$1_2_classLit = createForClass('java.util', 'ArrayList/1', 4);
function copyOf_2(original, newLength){
  var len, copy;
  checkCriticalArraySize(newLength);
  return len = getCopyLength(original, 0, newLength) , copy = initUnidimensionalArray(I_classLit, $intern_37, 26, newLength, 12, 1) , copy_0(original, 0, copy, 0, len, true) , copy;
}

function fill(a, val){
  fill_0(a, a.length, val);
}

function fill_0(a, toIndex, val){
  var i;
  for (i = 0; i < toIndex; ++i) {
    a[i] = val;
  }
}

function fill_1(a){
  fill_2(a, a.length);
}

function fill_2(a, toIndex){
  var i;
  for (i = 0; i < toIndex; ++i) {
    a[i] = 0;
  }
}

function fill_3(a, toIndex){
  var i;
  for (i = 0; i < toIndex; ++i) {
    a[i] = null;
  }
}

function fill_4(a){
  fill_3(a, a.length);
}

function fill_5(a, toIndex){
  var i;
  for (i = 0; i < toIndex; ++i) {
    a[i] = false;
  }
}

function fill_6(a){
  fill_5(a, a.length);
}

function getCopyLength(array, from, to){
  var len;
  checkCriticalArgument_1(from <= to, '%s > %s', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_12, 1, 4, [valueOf_0(from), valueOf_0(to)]));
  len = array.length;
  to = to < len?to:len;
  checkCriticalPositionIndexes(from, to, len);
  return to - from;
}

function hashCode_44(a){
  var e, e$index, e$max, hashCode;
  hashCode = 1;
  for (e$index = 0 , e$max = a.length; e$index < e$max; ++e$index) {
    e = a[e$index];
    hashCode = 31 * hashCode + (e != null?hashCode__I__devirtual$(e):0);
    hashCode = hashCode | 0;
  }
  return hashCode;
}

function insertionSort(array, low, high, comp){
  var i, j, t;
  for (i = low + 1; i < high; ++i) {
    for (j = i; j > low && comp.compare_0(array[j - 1], array[j]) > 0; --j) {
      t = array[j];
      setCheck(array, j, array[j - 1]);
      setCheck(array, j - 1, t);
    }
  }
}

function merge(src_0, srcLow, srcMid, srcHigh, dest, destLow, destHigh, comp){
  var topIdx;
  topIdx = srcMid;
  while (destLow < destHigh) {
    topIdx >= srcHigh || srcLow < srcMid && comp.compare_0(src_0[srcLow], src_0[topIdx]) <= 0?setCheck(dest, destLow++, src_0[srcLow++]):setCheck(dest, destLow++, src_0[topIdx++]);
  }
}

function mergeSort(x_0, fromIndex, toIndex, comp){
  var temp, len, copy, result;
  !comp && (comp = ($clinit_Comparators() , $clinit_Comparators() , NATURAL));
  temp = (len = getCopyLength(x_0, fromIndex, toIndex) , copy = (result = new Array(toIndex - fromIndex) , stampJavaTypeInfo_0(result, x_0)) , copy_0(x_0, fromIndex, copy, 0, len, true) , copy);
  mergeSort_0(temp, x_0, fromIndex, toIndex, -fromIndex, comp);
}

function mergeSort_0(temp, array, low, high, ofs, comp){
  var length_0, tempHigh, tempLow, tempMid;
  length_0 = high - low;
  if (length_0 < 7) {
    insertionSort(array, low, high, comp);
    return;
  }
  tempLow = low + ofs;
  tempHigh = high + ofs;
  tempMid = tempLow + (tempHigh - tempLow >> 1);
  mergeSort_0(array, temp, tempLow, tempMid, -ofs, comp);
  mergeSort_0(array, temp, tempMid, tempHigh, -ofs, comp);
  if (comp.compare_0(temp[tempMid - 1], temp[tempMid]) <= 0) {
    while (low < high) {
      setCheck(array, low++, temp[tempLow++]);
    }
    return;
  }
  merge(temp, tempLow, tempMid, tempHigh, array, low, high, comp);
}

function nativeNumberSort(array){
  array.sort(function(a, b){
    return a - b;
  }
  );
}

function sort_0(x_0, c){
  mergeSort(x_0, 0, x_0.length, c);
}

function $get_10(this$static, index_0){
  checkCriticalElementIndex(index_0, this$static.array.length);
  return this$static.array[index_0];
}

function $toArray_2(this$static, out){
  var i, result, size_0;
  size_0 = this$static.array.length;
  out.length < size_0 && (out = (result = new Array(size_0) , stampJavaTypeInfo_0(result, out)));
  for (i = 0; i < size_0; ++i) {
    setCheck(out, i, this$static.array[i]);
  }
  out.length > size_0 && setCheck(out, size_0, null);
  return out;
}

function Arrays$ArrayList(array){
  this.array = array;
}

defineClass(94, 646, $intern_73, Arrays$ArrayList);
_.contains = function contains_30(o){
  return $indexOf(this, o) != -1;
}
;
_.get_2 = function get_21(index_0){
  return $get_10(this, index_0);
}
;
_.set_2 = function set_15(index_0, value_0){
  var was;
  was = (checkCriticalElementIndex(index_0, this.array.length) , this.array[index_0]);
  setCheck(this.array, index_0, value_0);
  return was;
}
;
_.size_1 = function size_42(){
  return this.array.length;
}
;
_.toArray = function toArray_12(){
  return $toArray_2(this, initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, this.array.length, 4, 1));
}
;
_.toArray_0 = function toArray_13(out){
  return $toArray_2(this, out);
}
;
var Ljava_util_Arrays$ArrayList_2_classLit = createForClass('java.util', 'Arrays/ArrayList', 94);
function $clinit_Collections(){
  $clinit_Collections = emptyMethod;
  EMPTY_LIST = new Collections$EmptyList;
  EMPTY_MAP = new Collections$EmptyMap;
  EMPTY_SET = new Collections$EmptySet;
}

function addAll_8(c, a){
  $clinit_Collections();
  var e, e$index, e$max, result;
  result = false;
  for (e$index = 0 , e$max = a.length; e$index < e$max; ++e$index) {
    e = a[e$index];
    result = result | c.add_1(e);
  }
  return result;
}

function hashCode_45(collection){
  $clinit_Collections();
  var e, e$iterator, hashCode;
  hashCode = 0;
  for (e$iterator = collection.iterator_0(); e$iterator.hasNext_0();) {
    e = e$iterator.next_1();
    hashCode = hashCode + (e != null?hashCode__I__devirtual$(e):0);
    hashCode = hashCode | 0;
  }
  return hashCode;
}

function hashCode_46(list){
  $clinit_Collections();
  var e, e$iterator, hashCode;
  hashCode = 1;
  for (e$iterator = list.iterator_0(); e$iterator.hasNext_0();) {
    e = e$iterator.next_1();
    hashCode = 31 * hashCode + (e != null?hashCode__I__devirtual$(e):0);
    hashCode = hashCode | 0;
  }
  return hashCode;
}

function replaceContents(target, x_0){
  var i, size_0;
  size_0 = target.size_1();
  for (i = 0; i < size_0; i++) {
    target.set_2(i, x_0[i]);
  }
}

function reverse_3(l){
  var t;
  $clinit_Collections();
  var head, headElem, iBack, iFront, tail, tailElem;
  if (instanceOf(l, 67)) {
    for (iFront = 0 , iBack = l.size_1() - 1; iFront < iBack; ++iFront , --iBack) {
      t = l.get_2(iFront);
      l.set_2(iFront, l.get_2(iBack));
      l.set_2(iBack, t);
    }
  }
   else {
    head = l.listIterator_0();
    tail = l.listIterator_1(l.size_1());
    while (head.nextIndex_0() < tail.previousIndex()) {
      headElem = head.next_1();
      tailElem = tail.previous_0();
      head.set_1(tailElem);
      tail.set_1(headElem);
    }
  }
}

function reverseOrder(cmp){
  $clinit_Collections();
  if (!cmp) {
    return $clinit_Collections$ReverseComparator() , INSTANCE_3;
  }
  return new Collections$2(cmp);
}

function singletonMap(key, value_0){
  $clinit_Collections();
  var map_0;
  map_0 = new HashMap_0(1);
  instanceOfString(key)?$putStringValue(map_0, key, value_0):$put_5(map_0.hashCodeMap, key, value_0);
  return new Collections$UnmodifiableMap(map_0);
}

function sort_1(target, c){
  $clinit_Collections();
  var x_0;
  x_0 = target.toArray();
  mergeSort(x_0, 0, x_0.length, c);
  replaceContents(target, x_0);
}

function unmodifiableList(list){
  $clinit_Collections();
  return instanceOf(list, 67)?new Collections$UnmodifiableRandomAccessList(list):new Collections$UnmodifiableList(list);
}

var EMPTY_LIST, EMPTY_MAP, EMPTY_SET;
function Collections$2(val$cmp){
  this.val$cmp1 = val$cmp;
}

defineClass(413, 1, $intern_9, Collections$2);
_.compare_0 = function compare_34(t1, t2){
  return $compare_1(t2, t1);
}
;
var Ljava_util_Collections$2_2_classLit = createForClass('java.util', 'Collections/2', 413);
function Collections$EmptyList(){
}

defineClass(406, 646, $intern_73, Collections$EmptyList);
_.contains = function contains_31(object){
  return false;
}
;
_.get_2 = function get_22(location_0){
  checkCriticalElementIndex(location_0, 0);
  return null;
}
;
_.iterator_0 = function iterator_54(){
  return $clinit_Collections() , $clinit_Collections$EmptyListIterator() , INSTANCE_2;
}
;
_.listIterator_0 = function listIterator_13(){
  return $clinit_Collections() , $clinit_Collections$EmptyListIterator() , INSTANCE_2;
}
;
_.size_1 = function size_43(){
  return 0;
}
;
var Ljava_util_Collections$EmptyList_2_classLit = createForClass('java.util', 'Collections/EmptyList', 406);
function $clinit_Collections$EmptyListIterator(){
  $clinit_Collections$EmptyListIterator = emptyMethod;
  INSTANCE_2 = new Collections$EmptyListIterator;
}

function Collections$EmptyListIterator(){
}

defineClass(407, 1, $intern_24, Collections$EmptyListIterator);
_.add_0 = function add_29(o){
  throw new UnsupportedOperationException;
}
;
_.hasNext_0 = function hasNext_30(){
  return false;
}
;
_.hasPrevious = function hasPrevious_6(){
  return false;
}
;
_.next_1 = function next_31(){
  throw new NoSuchElementException;
}
;
_.nextIndex_0 = function nextIndex_7(){
  return 0;
}
;
_.previous_0 = function previous_7(){
  throw new NoSuchElementException;
}
;
_.previousIndex = function previousIndex_6(){
  return -1;
}
;
_.remove = function remove_62(){
  throw new IllegalStateException;
}
;
_.set_1 = function set_16(o){
  throw new IllegalStateException;
}
;
var INSTANCE_2;
var Ljava_util_Collections$EmptyListIterator_2_classLit = createForClass('java.util', 'Collections/EmptyListIterator', 407);
function Collections$EmptyMap(){
}

defineClass(409, 637, $intern_33, Collections$EmptyMap);
_.containsKey = function containsKey_8(key){
  return false;
}
;
_.containsValue = function containsValue_3(value_0){
  return false;
}
;
_.entrySet_0 = function entrySet_4(){
  return $clinit_Collections() , EMPTY_SET;
}
;
_.get_1 = function get_23(key){
  return null;
}
;
_.keySet_0 = function keySet_6(){
  return $clinit_Collections() , EMPTY_SET;
}
;
_.size_1 = function size_44(){
  return 0;
}
;
_.values_0 = function values_58(){
  return $clinit_Collections() , EMPTY_LIST;
}
;
var Ljava_util_Collections$EmptyMap_2_classLit = createForClass('java.util', 'Collections/EmptyMap', 409);
function Collections$EmptySet(){
}

defineClass(408, 640, $intern_34, Collections$EmptySet);
_.contains = function contains_32(object){
  return false;
}
;
_.iterator_0 = function iterator_55(){
  return $clinit_Collections() , $clinit_Collections$EmptyListIterator() , INSTANCE_2;
}
;
_.size_1 = function size_45(){
  return 0;
}
;
var Ljava_util_Collections$EmptySet_2_classLit = createForClass('java.util', 'Collections/EmptySet', 408);
function $clinit_Collections$ReverseComparator(){
  $clinit_Collections$ReverseComparator = emptyMethod;
  INSTANCE_3 = new Collections$ReverseComparator;
}

function $compare_17(o1, o2){
  return compareTo_Ljava_lang_Object__I__devirtual$(o2, o1);
}

function Collections$ReverseComparator(){
}

defineClass(410, 1, $intern_9, Collections$ReverseComparator);
_.compare_0 = function compare_35(o1, o2){
  return $compare_17(castTo(o1, 23), castTo(o2, 23));
}
;
var INSTANCE_3;
var Ljava_util_Collections$ReverseComparator_2_classLit = createForClass('java.util', 'Collections/ReverseComparator', 410);
function Collections$SingletonList(element){
  this.element = element;
}

defineClass(411, 646, {3:1, 22:1, 19:1, 20:1}, Collections$SingletonList);
_.contains = function contains_33(item_0){
  return equals_50(this.element, item_0);
}
;
_.get_2 = function get_24(index_0){
  checkCriticalElementIndex(index_0, 1);
  return this.element;
}
;
_.size_1 = function size_46(){
  return 1;
}
;
var Ljava_util_Collections$SingletonList_2_classLit = createForClass('java.util', 'Collections/SingletonList', 411);
function $add_16(){
  throw new UnsupportedOperationException;
}

function $addAll_7(){
  throw new UnsupportedOperationException;
}

function $clear_4(){
  throw new UnsupportedOperationException;
}

function $remove_13(){
  throw new UnsupportedOperationException;
}

function Collections$UnmodifiableCollection(coll){
  this.coll = coll;
}

defineClass(217, 1, $intern_20, Collections$UnmodifiableCollection);
_.add_1 = function add_30(o){
  return $add_16();
}
;
_.addAll = function addAll_9(c){
  return $addAll_7();
}
;
_.clear_0 = function clear_29(){
  $clear_4();
}
;
_.contains = function contains_34(o){
  return this.coll.contains(o);
}
;
_.containsAll = function containsAll_7(c){
  return this.coll.containsAll(c);
}
;
_.isEmpty = function isEmpty_19(){
  return this.coll.isEmpty();
}
;
_.iterator_0 = function iterator_56(){
  return new Collections$UnmodifiableCollectionIterator(this.coll.iterator_0());
}
;
_.remove_1 = function remove_63(o){
  return $remove_13();
}
;
_.size_1 = function size_47(){
  return this.coll.size_1();
}
;
_.toArray = function toArray_14(){
  return this.coll.toArray();
}
;
_.toArray_0 = function toArray_15(a){
  return this.coll.toArray_0(a);
}
;
_.toString_0 = function toString_83(){
  return toString__Ljava_lang_String___devirtual$(this.coll);
}
;
var Ljava_util_Collections$UnmodifiableCollection_2_classLit = createForClass('java.util', 'Collections/UnmodifiableCollection', 217);
function $remove_14(){
  throw new UnsupportedOperationException;
}

function Collections$UnmodifiableCollectionIterator(it){
  this.it = it;
}

defineClass(152, 1, $intern_18, Collections$UnmodifiableCollectionIterator);
_.hasNext_0 = function hasNext_31(){
  return this.it.hasNext_0();
}
;
_.next_1 = function next_32(){
  return this.it.next_1();
}
;
_.remove = function remove_64(){
  $remove_14();
}
;
var Ljava_util_Collections$UnmodifiableCollectionIterator_2_classLit = createForClass('java.util', 'Collections/UnmodifiableCollectionIterator', 152);
function Collections$UnmodifiableList(list){
  Collections$UnmodifiableCollection.call(this, list);
  this.list = list;
}

defineClass(233, 217, $intern_22, Collections$UnmodifiableList);
_.add_2 = function add_31(index_0, element){
  throw new UnsupportedOperationException;
}
;
_.equals = function equals_44(o){
  return this.list.equals(o);
}
;
_.get_2 = function get_25(index_0){
  return this.list.get_2(index_0);
}
;
_.hashCode_0 = function hashCode_47(){
  return this.list.hashCode_0();
}
;
_.isEmpty = function isEmpty_20(){
  return this.list.isEmpty();
}
;
_.listIterator_0 = function listIterator_14(){
  return new Collections$UnmodifiableListIterator(this.list.listIterator_1(0));
}
;
_.listIterator_1 = function listIterator_15(from){
  return new Collections$UnmodifiableListIterator(this.list.listIterator_1(from));
}
;
_.remove_2 = function remove_65(index_0){
  throw new UnsupportedOperationException;
}
;
_.set_2 = function set_17(index_0, element){
  throw new UnsupportedOperationException;
}
;
_.subList = function subList_6(fromIndex, toIndex){
  return new Collections$UnmodifiableList(this.list.subList(fromIndex, toIndex));
}
;
var Ljava_util_Collections$UnmodifiableList_2_classLit = createForClass('java.util', 'Collections/UnmodifiableList', 233);
function Collections$UnmodifiableListIterator(lit){
  Collections$UnmodifiableCollectionIterator.call(this, lit);
  this.lit = lit;
}

defineClass(309, 152, $intern_24, Collections$UnmodifiableListIterator);
_.add_0 = function add_32(o){
  throw new UnsupportedOperationException;
}
;
_.hasPrevious = function hasPrevious_7(){
  return this.lit.hasPrevious();
}
;
_.nextIndex_0 = function nextIndex_8(){
  return this.lit.nextIndex_0();
}
;
_.previous_0 = function previous_8(){
  return this.lit.previous_0();
}
;
_.previousIndex = function previousIndex_7(){
  return this.lit.previousIndex();
}
;
_.set_1 = function set_18(o){
  throw new UnsupportedOperationException;
}
;
var Ljava_util_Collections$UnmodifiableListIterator_2_classLit = createForClass('java.util', 'Collections/UnmodifiableListIterator', 309);
function $containsValue_1(this$static, val){
  return this$static.map_0.containsValue(val);
}

function $entrySet_2(this$static){
  !this$static.entrySet && (this$static.entrySet = new Collections$UnmodifiableMap$UnmodifiableEntrySet(this$static.map_0.entrySet_0()));
  return this$static.entrySet;
}

function $equals_6(this$static, o){
  return this$static.map_0.equals(o);
}

function $keySet_1(this$static){
  !this$static.keySet && (this$static.keySet = new Collections$UnmodifiableSet(this$static.map_0.keySet_0()));
  return this$static.keySet;
}

function $values_1(this$static){
  !this$static.values && (this$static.values = new Collections$UnmodifiableCollection(this$static.map_0.values_0()));
  return this$static.values;
}

function Collections$UnmodifiableMap(map_0){
  this.map_0 = map_0;
}

defineClass(305, 1, $intern_19, Collections$UnmodifiableMap);
_.clear_0 = function clear_30(){
  throw new UnsupportedOperationException;
}
;
_.containsKey = function containsKey_9(key){
  return this.map_0.containsKey(key);
}
;
_.containsValue = function containsValue_4(val){
  return $containsValue_1(this, val);
}
;
_.entrySet_0 = function entrySet_5(){
  return $entrySet_2(this);
}
;
_.equals = function equals_45(o){
  return $equals_6(this, o);
}
;
_.get_1 = function get_26(key){
  return this.map_0.get_1(key);
}
;
_.hashCode_0 = function hashCode_48(){
  return this.map_0.hashCode_0();
}
;
_.isEmpty = function isEmpty_21(){
  return this.map_0.isEmpty();
}
;
_.keySet_0 = function keySet_7(){
  return $keySet_1(this);
}
;
_.put = function put_2(key, value_0){
  throw new UnsupportedOperationException;
}
;
_.remove_0 = function remove_66(key){
  throw new UnsupportedOperationException;
}
;
_.size_1 = function size_48(){
  return this.map_0.size_1();
}
;
_.toString_0 = function toString_84(){
  return toString__Ljava_lang_String___devirtual$(this.map_0);
}
;
_.values_0 = function values_59(){
  return $values_1(this);
}
;
var Ljava_util_Collections$UnmodifiableMap_2_classLit = createForClass('java.util', 'Collections/UnmodifiableMap', 305);
function $contains_3(this$static, o){
  return this$static.coll.contains(o);
}

function $containsAll_0(this$static, c){
  return this$static.coll.containsAll(c);
}

function $equals_7(this$static, o){
  return this$static.coll.equals(o);
}

function $toArray_3(this$static, a){
  return this$static.coll.toArray_0(a);
}

function Collections$UnmodifiableSet(set_0){
  Collections$UnmodifiableCollection.call(this, set_0);
}

defineClass(151, 217, $intern_21, Collections$UnmodifiableSet);
_.equals = function equals_46(o){
  return $equals_7(this, o);
}
;
_.hashCode_0 = function hashCode_49(){
  return this.coll.hashCode_0();
}
;
var Ljava_util_Collections$UnmodifiableSet_2_classLit = createForClass('java.util', 'Collections/UnmodifiableSet', 151);
function $contains_4(this$static, o){
  return this$static.coll.contains(o);
}

function $containsAll_1(this$static, o){
  return this$static.coll.containsAll(o);
}

function $toArray_4(this$static){
  var array;
  array = this$static.coll.toArray();
  $wrap(array, array.length);
  return array;
}

function $toArray_5(this$static, a){
  var result;
  result = this$static.coll.toArray_0(a);
  $wrap(result, this$static.coll.size_1());
  return result;
}

function $wrap(array, size_0){
  var i;
  for (i = 0; i < size_0; ++i) {
    setCheck(array, i, new Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry(castTo(array[i], 21)));
  }
}

function Collections$UnmodifiableMap$UnmodifiableEntrySet(s){
  Collections$UnmodifiableSet.call(this, s);
}

defineClass(412, 151, $intern_21, Collections$UnmodifiableMap$UnmodifiableEntrySet);
_.contains = function contains_35(o){
  return $contains_4(this, o);
}
;
_.containsAll = function containsAll_8(o){
  return $containsAll_1(this, o);
}
;
_.iterator_0 = function iterator_57(){
  var it;
  return it = this.coll.iterator_0() , new Collections$UnmodifiableMap$UnmodifiableEntrySet$1(it);
}
;
_.toArray = function toArray_16(){
  return $toArray_4(this);
}
;
_.toArray_0 = function toArray_17(a){
  return $toArray_5(this, a);
}
;
var Ljava_util_Collections$UnmodifiableMap$UnmodifiableEntrySet_2_classLit = createForClass('java.util', 'Collections/UnmodifiableMap/UnmodifiableEntrySet', 412);
function Collections$UnmodifiableMap$UnmodifiableEntrySet$1(val$it){
  this.val$it2 = val$it;
}

defineClass(263, 1, $intern_18, Collections$UnmodifiableMap$UnmodifiableEntrySet$1);
_.next_1 = function next_33(){
  return new Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry(castTo(this.val$it2.next_1(), 21));
}
;
_.hasNext_0 = function hasNext_32(){
  return this.val$it2.hasNext_0();
}
;
_.remove = function remove_67(){
  throw new UnsupportedOperationException;
}
;
var Ljava_util_Collections$UnmodifiableMap$UnmodifiableEntrySet$1_2_classLit = createForClass('java.util', 'Collections/UnmodifiableMap/UnmodifiableEntrySet/1', 263);
function Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry(entry){
  this.entry = entry;
}

defineClass(306, 1, $intern_26, Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry);
_.equals = function equals_47(o){
  return this.entry.equals(o);
}
;
_.getKey = function getKey_2(){
  return this.entry.getKey();
}
;
_.getValue = function getValue_2(){
  return this.entry.getValue();
}
;
_.hashCode_0 = function hashCode_50(){
  return this.entry.hashCode_0();
}
;
_.setValue = function setValue_3(value_0){
  throw new UnsupportedOperationException;
}
;
_.toString_0 = function toString_85(){
  return toString__Ljava_lang_String___devirtual$(this.entry);
}
;
var Ljava_util_Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry_2_classLit = createForClass('java.util', 'Collections/UnmodifiableMap/UnmodifiableEntrySet/UnmodifiableEntry', 306);
function Collections$UnmodifiableRandomAccessList(list){
  Collections$UnmodifiableList.call(this, list);
}

defineClass(307, 233, $intern_23, Collections$UnmodifiableRandomAccessList);
var Ljava_util_Collections$UnmodifiableRandomAccessList_2_classLit = createForClass('java.util', 'Collections/UnmodifiableRandomAccessList', 307);
function Collections$UnmodifiableSortedSet(sortedSet){
  Collections$UnmodifiableSet.call(this, sortedSet);
  this.sortedSet = sortedSet;
}

defineClass(308, 151, $intern_25, Collections$UnmodifiableSortedSet);
_.equals = function equals_48(o){
  return this.sortedSet.equals(o);
}
;
_.hashCode_0 = function hashCode_51(){
  return this.sortedSet.hashCode_0();
}
;
var Ljava_util_Collections$UnmodifiableSortedSet_2_classLit = createForClass('java.util', 'Collections/UnmodifiableSortedSet', 308);
function $clinit_Comparators(){
  $clinit_Comparators = emptyMethod;
  NATURAL = new Comparators$1;
}

var NATURAL;
function Comparators$1(){
}

defineClass(522, 1, $intern_9, Comparators$1);
_.compare_0 = function compare_36(o1, o2){
  checkCriticalNotNull(o1);
  checkCriticalNotNull(o2);
  return compareTo_Ljava_lang_Object__I__devirtual$(castTo(o1, 23), o2);
}
;
var Ljava_util_Comparators$1_2_classLit = createForClass('java.util', 'Comparators/1', 522);
function checkStructuralChange(host, iterator){
  if (iterator['_gwt_modCount'] != host['_gwt_modCount']) {
    throw new ConcurrentModificationException;
  }
}

function recordLastKnownStructure(host, iterator){
  var modCount;
  modCount = host['_gwt_modCount'];
  iterator['_gwt_modCount'] = modCount;
}

function structureChanged(map_0){
  var modCount;
  modCount = map_0['_gwt_modCount'] | 0;
  map_0['_gwt_modCount'] = modCount + 1;
}

function ConcurrentModificationException(){
  RuntimeException.call(this);
}

defineClass(202, 72, $intern_2, ConcurrentModificationException);
var Ljava_util_ConcurrentModificationException_2_classLit = createForClass('java.util', 'ConcurrentModificationException', 202);
function EmptyStackException(){
  RuntimeException.call(this);
}

defineClass(608, 72, $intern_2, EmptyStackException);
var Ljava_util_EmptyStackException_2_classLit = createForClass('java.util', 'EmptyStackException', 608);
function $clear_5(this$static){
  $clear_0(this$static.keySet);
  this$static.values = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, this$static.values.length, 4, 1);
}

function $get_11(this$static, k){
  return $contains_6(this$static.keySet, k)?this$static.values[castTo(k, 17).ordinal]:null;
}

function $put_3(this$static, key, value_0){
  $add_17(this$static.keySet, key);
  return $set_5(this$static, key.ordinal, value_0);
}

function $put_4(this$static, key, value_0){
  return $put_3(this$static, castTo(key, 17), value_0);
}

function $remove_15(this$static, key){
  return $remove_16(this$static.keySet, key)?$set_5(this$static, castTo(key, 17).ordinal, null):null;
}

function $set_5(this$static, ordinal, value_0){
  var was;
  was = this$static.values[ordinal];
  this$static.values[ordinal] = value_0;
  return was;
}

function EnumMap(type_0){
  var all;
  this.keySet = (all = castTo(type_0.enumConstantsFunc && type_0.enumConstantsFunc(), 11) , new EnumSet$EnumSetImpl(all, castTo(createFrom(all, all.length), 11), 0));
  this.values = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, this.keySet.all.length, 4, 1);
}

defineClass(319, 637, $intern_19, EnumMap);
_.put = function put_3(key, value_0){
  return $put_4(this, key, value_0);
}
;
_.clear_0 = function clear_31(){
  $clear_5(this);
}
;
_.containsKey = function containsKey_10(key){
  return $contains_6(this.keySet, key);
}
;
_.containsValue = function containsValue_5(value_0){
  var key, key$iterator;
  for (key$iterator = new EnumSet$EnumSetImpl$IteratorImpl(this.keySet); key$iterator.i < key$iterator.this$11.all.length;) {
    key = $next_9(key$iterator);
    if (equals_50(value_0, this.values[key.ordinal])) {
      return true;
    }
  }
  return false;
}
;
_.entrySet_0 = function entrySet_6(){
  return new EnumMap$EntrySet(this);
}
;
_.get_1 = function get_27(k){
  return $get_11(this, k);
}
;
_.remove_0 = function remove_68(key){
  return $remove_15(this, key);
}
;
_.size_1 = function size_49(){
  return this.keySet.size_0;
}
;
var Ljava_util_EnumMap_2_classLit = createForClass('java.util', 'EnumMap', 319);
function $contains_5(this$static, o){
  if (instanceOf(o, 21)) {
    return $containsEntry(this$static.this$01, castTo(o, 21));
  }
  return false;
}

function EnumMap$EntrySet(this$0){
  this.this$01 = this$0;
}

defineClass(236, 640, $intern_21, EnumMap$EntrySet);
_.clear_0 = function clear_32(){
  $clear_5(this.this$01);
}
;
_.contains = function contains_36(o){
  return $contains_5(this, o);
}
;
_.iterator_0 = function iterator_58(){
  return new EnumMap$EntrySetIterator(this.this$01);
}
;
_.remove_1 = function remove_69(entry){
  var key;
  if ($contains_5(this, entry)) {
    key = castTo(entry, 21).getKey();
    $remove_15(this.this$01, key);
    return true;
  }
  return false;
}
;
_.size_1 = function size_50(){
  return this.this$01.keySet.size_0;
}
;
var Ljava_util_EnumMap$EntrySet_2_classLit = createForClass('java.util', 'EnumMap/EntrySet', 236);
function EnumMap$EntrySetIterator(this$0){
  this.this$01 = this$0;
  this.it = new EnumSet$EnumSetImpl$IteratorImpl(this.this$01.keySet);
}

defineClass(237, 1, $intern_18, EnumMap$EntrySetIterator);
_.next_1 = function next_34(){
  return this.key = $next_9(this.it) , new EnumMap$MapEntry(this.this$01, this.key);
}
;
_.hasNext_0 = function hasNext_33(){
  return $hasNext_4(this.it);
}
;
_.remove = function remove_70(){
  checkCritcalState(!!this.key);
  $remove_15(this.this$01, this.key);
  this.key = null;
}
;
var Ljava_util_EnumMap$EntrySetIterator_2_classLit = createForClass('java.util', 'EnumMap/EntrySetIterator', 237);
function EnumMap$MapEntry(this$0, key){
  this.this$01 = this$0;
  this.key = key;
}

defineClass(238, 651, $intern_26, EnumMap$MapEntry);
_.getKey = function getKey_3(){
  return this.key;
}
;
_.getValue = function getValue_3(){
  return this.this$01.values[this.key.ordinal];
}
;
_.setValue = function setValue_4(value_0){
  return $set_5(this.this$01, this.key.ordinal, value_0);
}
;
var Ljava_util_EnumMap$MapEntry_2_classLit = createForClass('java.util', 'EnumMap/MapEntry', 238);
function allOf(elementType){
  var all, set_0;
  all = castTo(elementType.enumConstantsFunc && elementType.enumConstantsFunc(), 11);
  set_0 = castTo(clone_2(all, all.length), 11);
  return new EnumSet$EnumSetImpl(all, set_0, all.length);
}

function of_3(first){
  var all, set_0, clazz, superclass;
  set_0 = (all = castTo($getEnumConstants((clazz = first.___clazz , superclass = clazz.enumSuperclass , superclass == Ljava_lang_Enum_2_classLit?clazz:superclass)), 11) , new EnumSet$EnumSetImpl(all, castTo(createFrom(all, all.length), 11), 0));
  $add_17(set_0, first);
  return set_0;
}

function of_4(first, rest){
  var set_0;
  set_0 = of_3(first);
  addAll_8(set_0, rest);
  return set_0;
}

defineClass(86, 640, {22:1, 19:1, 86:1, 18:1});
var Ljava_util_EnumSet_2_classLit = createForClass('java.util', 'EnumSet', 86);
function $add_17(this$static, e){
  var ordinal;
  checkCriticalNotNull(e);
  ordinal = e.ordinal;
  if (!this$static.set_0[ordinal]) {
    setCheck(this$static.set_0, ordinal, e);
    ++this$static.size_0;
    return true;
  }
  return false;
}

function $clone_0(this$static){
  var clonedSet;
  clonedSet = castTo(clone_2(this$static.set_0, this$static.set_0.length), 11);
  return new EnumSet$EnumSetImpl(this$static.all, clonedSet, this$static.size_0);
}

function $contains_6(this$static, o){
  return instanceOf(o, 17) && $containsEnum(this$static, castTo(o, 17));
}

function $containsEnum(this$static, e){
  return !!e && this$static.set_0[e.ordinal] == e;
}

function $remove_16(this$static, o){
  return instanceOf(o, 17) && $removeEnum(this$static, castTo(o, 17));
}

function $removeEnum(this$static, e){
  if (!!e && this$static.set_0[e.ordinal] == e) {
    setCheck(this$static.set_0, e.ordinal, null);
    --this$static.size_0;
    return true;
  }
  return false;
}

function EnumSet$EnumSetImpl(all, set_0, size_0){
  this.all = all;
  this.set_0 = set_0;
  this.size_0 = size_0;
}

defineClass(65, 86, {22:1, 19:1, 86:1, 65:1, 18:1}, EnumSet$EnumSetImpl);
_.add_1 = function add_33(e){
  return $add_17(this, castTo(e, 17));
}
;
_.contains = function contains_37(o){
  return $contains_6(this, o);
}
;
_.iterator_0 = function iterator_59(){
  return new EnumSet$EnumSetImpl$IteratorImpl(this);
}
;
_.remove_1 = function remove_71(o){
  return $remove_16(this, o);
}
;
_.size_1 = function size_51(){
  return this.size_0;
}
;
_.size_0 = 0;
var Ljava_util_EnumSet$EnumSetImpl_2_classLit = createForClass('java.util', 'EnumSet/EnumSetImpl', 65);
function $findNext(this$static){
  var c;
  ++this$static.i;
  for (c = this$static.this$11.all.length; this$static.i < c; ++this$static.i) {
    if (this$static.this$11.set_0[this$static.i]) {
      return;
    }
  }
}

function $hasNext_4(this$static){
  return this$static.i < this$static.this$11.all.length;
}

function $next_9(this$static){
  checkCriticalElement(this$static.i < this$static.this$11.all.length);
  this$static.last = this$static.i;
  $findNext(this$static);
  return this$static.this$11.set_0[this$static.last];
}

function EnumSet$EnumSetImpl$IteratorImpl(this$1){
  this.this$11 = this$1;
  $findNext(this);
}

defineClass(167, 1, $intern_18, EnumSet$EnumSetImpl$IteratorImpl);
_.next_1 = function next_35(){
  return $next_9(this);
}
;
_.hasNext_0 = function hasNext_34(){
  return $hasNext_4(this);
}
;
_.remove = function remove_72(){
  checkCritcalState(this.last != -1);
  setCheck(this.this$11.set_0, this.last, null);
  --this.this$11.size_0;
  this.last = -1;
}
;
_.i = -1;
_.last = -1;
var Ljava_util_EnumSet$EnumSetImpl$IteratorImpl_2_classLit = createForClass('java.util', 'EnumSet/EnumSetImpl/IteratorImpl', 167);
function HashMap(){
  $reset_3(this);
}

function HashMap_0(ignored){
  AbstractHashMap.call(this, ignored, 0);
}

function HashMap_1(toBeCopied){
  $reset_3(this);
  $putAll(this, toBeCopied);
}

defineClass(30, 213, $intern_74, HashMap, HashMap_0, HashMap_1);
_.equals_0 = function equals_49(value1, value2){
  return maskUndefined(value1) === maskUndefined(value2) || value1 != null && equals_Ljava_lang_Object__Z__devirtual$(value1, value2);
}
;
_.getHashCode = function getHashCode(key){
  var hashCode;
  hashCode = hashCode__I__devirtual$(key);
  return hashCode | 0;
}
;
var Ljava_util_HashMap_2_classLit = createForClass('java.util', 'HashMap', 30);
function $add_18(this$static, o){
  var old;
  old = this$static.map_0.put(o, this$static);
  return old == null;
}

function $contains_7(this$static, o){
  return this$static.map_0.containsKey(o);
}

function $remove_17(this$static, o){
  return this$static.map_0.remove_0(o) != null;
}

function HashSet(){
  this.map_0 = new HashMap;
}

function HashSet_0(initialCapacity){
  this.map_0 = new HashMap_0(initialCapacity);
}

function HashSet_1(c){
  this.map_0 = new HashMap_0(c.size_1());
  $addAll(this, c);
}

function HashSet_2(map_0){
  this.map_0 = map_0;
}

defineClass(50, 640, $intern_75, HashSet, HashSet_0, HashSet_1);
_.add_1 = function add_34(o){
  return $add_18(this, o);
}
;
_.clear_0 = function clear_33(){
  this.map_0.clear_0();
}
;
_.clone = function clone_0(){
  return new HashSet_1(this);
}
;
_.contains = function contains_38(o){
  return $contains_7(this, o);
}
;
_.isEmpty = function isEmpty_22(){
  return this.map_0.size_1() == 0;
}
;
_.iterator_0 = function iterator_60(){
  var outerIter;
  return outerIter = (new AbstractMap$1(this.map_0)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter);
}
;
_.remove_1 = function remove_73(o){
  return $remove_17(this, o);
}
;
_.size_1 = function size_52(){
  return this.map_0.size_1();
}
;
_.toString_0 = function toString_86(){
  return $toString_5(new AbstractMap$1(this.map_0));
}
;
var Ljava_util_HashSet_2_classLit = createForClass('java.util', 'HashSet', 50);
function $findEntryInChain(this$static, key, chain){
  var entry, entry$index, entry$max;
  for (entry$index = 0 , entry$max = chain.length; entry$index < entry$max; ++entry$index) {
    entry = chain[entry$index];
    if (this$static.host.equals_0(key, entry.getKey())) {
      return entry;
    }
  }
  return null;
}

function $getChainOrEmpty(this$static, hashCode){
  var chain;
  chain = $get_12(this$static.backingMap, hashCode);
  return chain == null?[]:chain;
}

function $getEntry(this$static, key){
  return $findEntryInChain(this$static, key, $getChainOrEmpty(this$static, key == null?0:this$static.host.getHashCode(key)));
}

function $put_5(this$static, key, value_0){
  var chain, chain0, entry, hashCode;
  hashCode = key == null?0:this$static.host.getHashCode(key);
  chain0 = (chain = $get_12(this$static.backingMap, hashCode) , chain == null?[]:chain);
  if (chain0.length == 0) {
    $set_6(this$static.backingMap, hashCode, chain0);
  }
   else {
    entry = $findEntryInChain(this$static, key, chain0);
    if (entry) {
      return entry.setValue(value_0);
    }
  }
  setCheck(chain0, chain0.length, new AbstractMap$SimpleEntry(key, value_0));
  ++this$static.size_0;
  structureChanged(this$static.host);
  return null;
}

function $remove_18(this$static, key){
  var chain, chain0, entry, hashCode, i;
  hashCode = key == null?0:this$static.host.getHashCode(key);
  chain0 = (chain = $get_12(this$static.backingMap, hashCode) , chain == null?[]:chain);
  for (i = 0; i < chain0.length; i++) {
    entry = chain0[i];
    if (this$static.host.equals_0(key, entry.getKey())) {
      if (chain0.length == 1) {
        chain0.length = 0;
        this$static.backingMap['delete'](hashCode);
      }
       else {
        chain0.splice(i, 1);
      }
      --this$static.size_0;
      structureChanged(this$static.host);
      return entry.getValue();
    }
  }
  return null;
}

function InternalHashCodeMap(host){
  this.backingMap = newJsMap();
  this.host = host;
}

defineClass(418, 1, $intern_30, InternalHashCodeMap);
_.iterator_0 = function iterator_61(){
  return new InternalHashCodeMap$1(this);
}
;
_.size_0 = 0;
var Ljava_util_InternalHashCodeMap_2_classLit = createForClass('java.util', 'InternalHashCodeMap', 418);
function InternalHashCodeMap$1(this$0){
  this.this$01 = this$0;
  this.chains = this.this$01.backingMap.entries();
  this.chain = [];
}

defineClass(312, 1, $intern_18, InternalHashCodeMap$1);
_.next_1 = function next_36(){
  return this.lastEntry = this.chain[this.itemIndex++] , this.lastEntry;
}
;
_.hasNext_0 = function hasNext_35(){
  var current;
  if (this.itemIndex < this.chain.length) {
    return true;
  }
  current = this.chains.next();
  if (!current.done) {
    this.chain = current.value[1];
    this.itemIndex = 0;
    return true;
  }
  return false;
}
;
_.remove = function remove_74(){
  $remove_18(this.this$01, this.lastEntry.getKey());
  this.itemIndex != 0 && --this.itemIndex;
}
;
_.itemIndex = 0;
_.lastEntry = null;
var Ljava_util_InternalHashCodeMap$1_2_classLit = createForClass('java.util', 'InternalHashCodeMap/1', 312);
function $get_12(this$static, key){
  return this$static.get(key);
}

function $get_13(this$static, key){
  return this$static.get(key);
}

function $set_6(this$static, key, value_0){
  this$static.set(key, value_0);
}

function $set_7(this$static, key, value_0){
  this$static.set(key, value_0);
}

function $clinit_InternalJsMapFactory(){
  $clinit_InternalJsMapFactory = emptyMethod;
  jsMapCtor = getJsMapConstructor();
}

function canHandleObjectCreateAndProto(){
  if (!Object.create || !Object.getOwnPropertyNames) {
    return false;
  }
  var protoField = '__proto__';
  var map_0 = Object.create(null);
  if (map_0[protoField] !== undefined) {
    return false;
  }
  var keys_0 = Object.getOwnPropertyNames(map_0);
  if (keys_0.length != 0) {
    return false;
  }
  map_0[protoField] = 42;
  if (map_0[protoField] !== 42) {
    return false;
  }
  if (Object.getOwnPropertyNames(map_0).length == 0) {
    return false;
  }
  return true;
}

function getJsMapConstructor(){
  function isCorrectIterationProtocol(){
    try {
      return (new Map).entries().next().done;
    }
     catch (e) {
      return false;
    }
  }

  if (typeof Map === 'function' && Map.prototype.entries && isCorrectIterationProtocol()) {
    return Map;
  }
   else {
    return getJsMapPolyFill();
  }
}

function getJsMapPolyFill(){
  function Stringmap(){
    this.obj = this.createObject();
  }

  ;
  Stringmap.prototype.createObject = function(key){
    return Object.create(null);
  }
  ;
  Stringmap.prototype.get = function(key){
    return this.obj[key];
  }
  ;
  Stringmap.prototype.set = function(key, value_0){
    this.obj[key] = value_0;
  }
  ;
  Stringmap.prototype['delete'] = function(key){
    delete this.obj[key];
  }
  ;
  Stringmap.prototype.keys = function(){
    return Object.getOwnPropertyNames(this.obj);
  }
  ;
  Stringmap.prototype.entries = function(){
    var keys_0 = this.keys();
    var map_0 = this;
    var nextIndex = 0;
    return {'next':function(){
      if (nextIndex >= keys_0.length)
        return {'done':true};
      var key = keys_0[nextIndex++];
      return {'value':[key, map_0.get(key)], 'done':false};
    }
    };
  }
  ;
  if (!canHandleObjectCreateAndProto()) {
    Stringmap.prototype.createObject = function(){
      return {};
    }
    ;
    Stringmap.prototype.get = function(key){
      return this.obj[':' + key];
    }
    ;
    Stringmap.prototype.set = function(key, value_0){
      this.obj[':' + key] = value_0;
    }
    ;
    Stringmap.prototype['delete'] = function(key){
      delete this.obj[':' + key];
    }
    ;
    Stringmap.prototype.keys = function(){
      var result = [];
      for (var key in this.obj) {
        key.charCodeAt(0) == 58 && result.push(key.substring(1));
      }
      return result;
    }
    ;
  }
  return Stringmap;
}

function newJsMap(){
  $clinit_InternalJsMapFactory();
  return new jsMapCtor;
}

var jsMapCtor;
function $contains_8(this$static, key){
  return !($get_13(this$static.backingMap, key) === undefined);
}

function $get_14(this$static, key){
  return $get_13(this$static.backingMap, key);
}

function $put_6(this$static, key, value_0){
  var oldValue;
  oldValue = $get_13(this$static.backingMap, key);
  $set_7(this$static.backingMap, key, value_0 === undefined?null:value_0);
  if (oldValue === undefined) {
    ++this$static.size_0;
    structureChanged(this$static.host);
  }
   else {
    ++this$static.valueMod;
  }
  return oldValue;
}

function $remove_19(this$static, key){
  var value_0;
  value_0 = $get_13(this$static.backingMap, key);
  if (value_0 === undefined) {
    ++this$static.valueMod;
  }
   else {
    this$static.backingMap['delete'](key);
    --this$static.size_0;
    structureChanged(this$static.host);
  }
  return value_0;
}

function InternalStringMap(host){
  this.backingMap = newJsMap();
  this.host = host;
}

defineClass(382, 1, $intern_30, InternalStringMap);
_.iterator_0 = function iterator_62(){
  return new InternalStringMap$1(this);
}
;
_.size_0 = 0;
_.valueMod = 0;
var Ljava_util_InternalStringMap_2_classLit = createForClass('java.util', 'InternalStringMap', 382);
function InternalStringMap$1(this$0){
  this.this$01 = this$0;
  this.entries_0 = this.this$01.backingMap.entries();
  this.current = this.entries_0.next();
}

defineClass(293, 1, $intern_18, InternalStringMap$1);
_.next_1 = function next_37(){
  return this.last = this.current , this.current = this.entries_0.next() , new InternalStringMap$2(this.this$01, this.last, this.this$01.valueMod);
}
;
_.hasNext_0 = function hasNext_36(){
  return !this.current.done;
}
;
_.remove = function remove_75(){
  $remove_19(this.this$01, this.last.value[0]);
}
;
var Ljava_util_InternalStringMap$1_2_classLit = createForClass('java.util', 'InternalStringMap/1', 293);
function InternalStringMap$2(this$0, val$entry, val$lastValueMod){
  this.this$01 = this$0;
  this.val$entry2 = val$entry;
  this.val$lastValueMod3 = val$lastValueMod;
}

defineClass(383, 651, $intern_26, InternalStringMap$2);
_.getKey = function getKey_4(){
  return this.val$entry2.value[0];
}
;
_.getValue = function getValue_4(){
  if (this.this$01.valueMod != this.val$lastValueMod3) {
    return $get_14(this.this$01, this.val$entry2.value[0]);
  }
  return this.val$entry2.value[1];
}
;
_.setValue = function setValue_5(object){
  return $put_6(this.this$01, this.val$entry2.value[0], object);
}
;
_.val$lastValueMod3 = 0;
var Ljava_util_InternalStringMap$2_2_classLit = createForClass('java.util', 'InternalStringMap/2', 383);
function $$init_8(this$static){
  this$static.head = new LinkedHashMap$ChainEntry(this$static);
  this$static.map_0 = new HashMap;
}

function $clear_6(this$static){
  $reset_3(this$static.map_0);
  this$static.head.prev = this$static.head;
  this$static.head.next_0 = this$static.head;
}

function $get_15(this$static, key){
  var entry;
  entry = castTo($get_9(this$static.map_0, key), 176);
  if (entry) {
    $recordAccess(this$static, entry);
    return entry.value_0;
  }
  return null;
}

function $put_7(this$static, key, value_0){
  var newEntry, old, oldValue;
  old = castTo($get_9(this$static.map_0, key), 176);
  if (!old) {
    newEntry = new LinkedHashMap$ChainEntry_0(this$static, key, value_0);
    $put_2(this$static.map_0, key, newEntry);
    $addToEnd(newEntry);
    return null;
  }
   else {
    oldValue = $setValue(old, value_0);
    $recordAccess(this$static, old);
    return oldValue;
  }
}

function $recordAccess(this$static, entry){
  if (this$static.accessOrder) {
    $remove_21(entry);
    $addToEnd(entry);
  }
}

function $remove_20(this$static, key){
  var entry;
  entry = castTo($remove_9(this$static.map_0, key), 176);
  if (entry) {
    $remove_21(entry);
    return entry.value_0;
  }
  return null;
}

function LinkedHashMap(){
  HashMap.call(this);
  $$init_8(this);
  this.head.prev = this.head;
  this.head.next_0 = this.head;
}

function LinkedHashMap_0(ignored){
  AbstractHashMap.call(this, ignored, 0);
  $$init_8(this);
  this.head.prev = this.head;
  this.head.next_0 = this.head;
}

defineClass(155, 30, $intern_74, LinkedHashMap, LinkedHashMap_0);
_.clear_0 = function clear_34(){
  $clear_6(this);
}
;
_.containsKey = function containsKey_11(key){
  return $containsKey_1(this.map_0, key);
}
;
_.containsValue = function containsValue_6(value_0){
  var node;
  node = this.head.next_0;
  while (node != this.head) {
    if (equals_50(node.value_0, value_0)) {
      return true;
    }
    node = node.next_0;
  }
  return false;
}
;
_.entrySet_0 = function entrySet_7(){
  return new LinkedHashMap$EntrySet(this);
}
;
_.get_1 = function get_28(key){
  return $get_15(this, key);
}
;
_.put = function put_4(key, value_0){
  return $put_7(this, key, value_0);
}
;
_.remove_0 = function remove_76(key){
  return $remove_20(this, key);
}
;
_.size_1 = function size_53(){
  return $size_0(this.map_0);
}
;
_.accessOrder = false;
var Ljava_util_LinkedHashMap_2_classLit = createForClass('java.util', 'LinkedHashMap', 155);
function $addToEnd(this$static){
  var tail;
  tail = this$static.this$01.head.prev;
  this$static.prev = tail;
  this$static.next_0 = this$static.this$01.head;
  tail.next_0 = this$static.this$01.head.prev = this$static;
}

function $remove_21(this$static){
  this$static.next_0.prev = this$static.prev;
  this$static.prev.next_0 = this$static.next_0;
  this$static.next_0 = this$static.prev = null;
}

function LinkedHashMap$ChainEntry(this$0){
  LinkedHashMap$ChainEntry_0.call(this, this$0, null, null);
}

function LinkedHashMap$ChainEntry_0(this$0, key, value_0){
  this.this$01 = this$0;
  AbstractMap$SimpleEntry.call(this, key, value_0);
}

defineClass(176, 163, {210:1, 163:1, 176:1, 21:1}, LinkedHashMap$ChainEntry, LinkedHashMap$ChainEntry_0);
var Ljava_util_LinkedHashMap$ChainEntry_2_classLit = createForClass('java.util', 'LinkedHashMap/ChainEntry', 176);
function $contains_9(this$static, o){
  if (instanceOf(o, 21)) {
    return $containsEntry(this$static.this$01, castTo(o, 21));
  }
  return false;
}

function LinkedHashMap$EntrySet(this$0){
  this.this$01 = this$0;
}

defineClass(270, 640, $intern_21, LinkedHashMap$EntrySet);
_.clear_0 = function clear_35(){
  $clear_6(this.this$01);
}
;
_.contains = function contains_39(o){
  return $contains_9(this, o);
}
;
_.iterator_0 = function iterator_63(){
  return new LinkedHashMap$EntrySet$EntryIterator(this);
}
;
_.remove_1 = function remove_77(entry){
  var key;
  if ($contains_9(this, entry)) {
    key = castTo(entry, 21).getKey();
    $remove_20(this.this$01, key);
    return true;
  }
  return false;
}
;
_.size_1 = function size_54(){
  return $size_0(this.this$01.map_0);
}
;
var Ljava_util_LinkedHashMap$EntrySet_2_classLit = createForClass('java.util', 'LinkedHashMap/EntrySet', 270);
function $next_10(this$static){
  checkStructuralChange(this$static.this$11.this$01.map_0, this$static);
  checkCriticalElement(this$static.next_0 != this$static.this$11.this$01.head);
  this$static.last = this$static.next_0;
  this$static.next_0 = this$static.next_0.next_0;
  return this$static.last;
}

function LinkedHashMap$EntrySet$EntryIterator(this$1){
  this.this$11 = this$1;
  this.next_0 = this$1.this$01.head.next_0;
  recordLastKnownStructure(this$1.this$01.map_0, this);
}

defineClass(271, 1, $intern_18, LinkedHashMap$EntrySet$EntryIterator);
_.next_1 = function next_38(){
  return $next_10(this);
}
;
_.hasNext_0 = function hasNext_37(){
  return this.next_0 != this.this$11.this$01.head;
}
;
_.remove = function remove_78(){
  checkCritcalState(!!this.last);
  checkStructuralChange(this.this$11.this$01.map_0, this);
  $remove_21(this.last);
  $remove_9(this.this$11.this$01.map_0, this.last.key);
  recordLastKnownStructure(this.this$11.this$01.map_0, this);
  this.last = null;
}
;
var Ljava_util_LinkedHashMap$EntrySet$EntryIterator_2_classLit = createForClass('java.util', 'LinkedHashMap/EntrySet/EntryIterator', 271);
function LinkedHashSet(){
  HashSet_2.call(this, new LinkedHashMap);
}

function LinkedHashSet_0(ignored){
  HashSet_2.call(this, new LinkedHashMap_0(ignored));
}

function LinkedHashSet_1(c){
  HashSet_2.call(this, new LinkedHashMap);
  $addAll(this, c);
}

defineClass(70, 50, $intern_75, LinkedHashSet, LinkedHashSet_0, LinkedHashSet_1);
_.clone = function clone_1(){
  return new LinkedHashSet_1(this);
}
;
var Ljava_util_LinkedHashSet_2_classLit = createForClass('java.util', 'LinkedHashSet', 70);
function $add_19(this$static, o){
  $addNode_0(this$static.this$01, o, this$static.currentNode.prev, this$static.currentNode);
  ++this$static.currentIndex;
  this$static.lastNode = null;
}

function $next_11(this$static){
  checkCriticalElement(this$static.currentNode != this$static.this$01.tail);
  this$static.lastNode = this$static.currentNode;
  this$static.currentNode = this$static.currentNode.next_0;
  ++this$static.currentIndex;
  return this$static.lastNode.value_0;
}

function $previous_2(this$static){
  checkCriticalElement(this$static.currentNode.prev != this$static.this$01.header);
  this$static.lastNode = this$static.currentNode = this$static.currentNode.prev;
  --this$static.currentIndex;
  return this$static.lastNode.value_0;
}

function $remove_22(this$static){
  var nextNode;
  checkCritcalState(!!this$static.lastNode);
  nextNode = this$static.lastNode.next_0;
  $removeNode_0(this$static.this$01, this$static.lastNode);
  this$static.currentNode == this$static.lastNode?(this$static.currentNode = nextNode):--this$static.currentIndex;
  this$static.lastNode = null;
}

function LinkedList$ListIteratorImpl(this$0, index_0, startNode){
  this.this$01 = this$0;
  this.currentNode = startNode;
  this.currentIndex = index_0;
}

defineClass(372, 1, $intern_24, LinkedList$ListIteratorImpl);
_.add_0 = function add_35(o){
  $add_19(this, o);
}
;
_.hasNext_0 = function hasNext_38(){
  return this.currentNode != this.this$01.tail;
}
;
_.hasPrevious = function hasPrevious_8(){
  return this.currentNode.prev != this.this$01.header;
}
;
_.next_1 = function next_39(){
  return $next_11(this);
}
;
_.nextIndex_0 = function nextIndex_9(){
  return this.currentIndex;
}
;
_.previous_0 = function previous_9(){
  return $previous_2(this);
}
;
_.previousIndex = function previousIndex_8(){
  return this.currentIndex - 1;
}
;
_.remove = function remove_79(){
  $remove_22(this);
}
;
_.set_1 = function set_19(o){
  checkCritcalState(!!this.lastNode);
  this.lastNode.value_0 = o;
}
;
_.currentIndex = 0;
_.lastNode = null;
var Ljava_util_LinkedList$ListIteratorImpl_2_classLit = createForClass('java.util', 'LinkedList/ListIteratorImpl', 372);
function LinkedList$Node(){
}

defineClass(259, 1, {}, LinkedList$Node);
var Ljava_util_LinkedList$Node_2_classLit = createForClass('java.util', 'LinkedList/Node', 259);
function NoSuchElementException(){
  RuntimeException.call(this);
}

defineClass(74, 72, {3:1, 54:1, 46:1, 74:1}, NoSuchElementException);
var Ljava_util_NoSuchElementException_2_classLit = createForClass('java.util', 'NoSuchElementException', 74);
function equals_50(a, b){
  return maskUndefined(a) === maskUndefined(b) || a != null && equals_Ljava_lang_Object__Z__devirtual$(a, b);
}

function hashCode_52(o){
  return o != null?hashCode__I__devirtual$(o):0;
}

function $clinit_Random(){
  $clinit_Random = emptyMethod;
  var i, i0, twoToTheXMinus24Tmp, twoToTheXMinus48Tmp;
  twoToTheXMinus24 = initUnidimensionalArray(D_classLit, $intern_11, 26, 25, 12, 1);
  twoToTheXMinus48 = initUnidimensionalArray(D_classLit, $intern_11, 26, 33, 12, 1);
  twoToTheXMinus48Tmp = 1.52587890625E-5;
  for (i0 = 32; i0 >= 0; i0--) {
    twoToTheXMinus48[i0] = twoToTheXMinus48Tmp;
    twoToTheXMinus48Tmp *= 0.5;
  }
  twoToTheXMinus24Tmp = 1;
  for (i = 24; i >= 0; i--) {
    twoToTheXMinus24[i] = twoToTheXMinus24Tmp;
    twoToTheXMinus24Tmp *= 0.5;
  }
}

function $nextDouble(this$static){
  return $nextInternal(this$static, 26) * 1.4901161193847656E-8 + $nextInternal(this$static, 27) * 1.1102230246251565E-16;
}

function $nextInt(this$static, n){
  var bits, val;
  checkCriticalArgument(n > 0);
  if ((n & -n) == n) {
    return round_int(n * $nextInternal(this$static, 31) * 4.6566128730773926E-10);
  }
  do {
    bits = $nextInternal(this$static, 31);
    val = bits % n;
  }
   while (bits - val + (n - 1) < 0);
  return round_int(val);
}

function $nextInternal(this$static, bits){
  var carry, dval, h, hi, l, lo;
  hi = this$static.seedhi * $intern_76 + this$static.seedlo * 1502;
  lo = this$static.seedlo * $intern_76 + 11;
  carry = Math.floor(lo * $intern_65);
  hi += carry;
  lo -= carry * $intern_77;
  hi %= $intern_77;
  this$static.seedhi = hi;
  this$static.seedlo = lo;
  if (bits <= 24) {
    return floor_0(this$static.seedhi * twoToTheXMinus24[bits]);
  }
   else {
    h = this$static.seedhi * (1 << bits - 24);
    l = floor_0(this$static.seedlo * twoToTheXMinus48[bits]);
    dval = h + l;
    dval >= 2147483648 && (dval -= 4294967296);
    return dval;
  }
}

function $setSeed(this$static, seedhi, seedlo){
  this$static.seedhi = seedhi ^ 1502;
  this$static.seedlo = seedlo ^ $intern_76;
}

function Random(){
  $clinit_Random();
  var hi, lo, seed;
  seed = uniqueSeed++ + now_2();
  hi = round_int(Math.floor(seed * $intern_65)) & $intern_78;
  lo = round_int(seed - hi * $intern_77);
  this.seedhi = hi ^ 1502;
  this.seedlo = lo ^ $intern_76;
}

function Random_0(seed){
  $clinit_Random();
  $setSeed(this, toInt(and_0(createLongEmul(shr(isSmallLong0(seed)?toBigLong(seed):seed, 24)), $intern_78)), toInt(and_0(seed, $intern_78)));
}

defineClass(154, 1, {154:1}, Random, Random_0);
_.seedhi = 0;
_.seedlo = 0;
var twoToTheXMinus24, twoToTheXMinus48, uniqueSeed = 0;
var Ljava_util_Random_2_classLit = createForClass('java.util', 'Random', 154);
function checkArrayElementIndex(index_0, size_0){
  if (index_0 < 0 || index_0 >= size_0) {
    throw new ArrayIndexOutOfBoundsException;
  }
}

defineClass(606, 646, $intern_79);
_.add_2 = function add_36(index_0, o){
  checkArrayElementIndex(index_0, this.arrayList.array.length + 1);
  $add_10(this.arrayList, index_0, o);
}
;
_.add_1 = function add_37(o){
  return $add_11(this.arrayList, o);
}
;
_.addAll = function addAll_10(c){
  return $addAll_6(this.arrayList, c);
}
;
_.clear_0 = function clear_36(){
  this.arrayList.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_12, 1, 0, 4, 1);
}
;
_.contains = function contains_40(elem){
  return $indexOf_0(this.arrayList, elem, 0) != -1;
}
;
_.containsAll = function containsAll_9(c){
  return $containsAll(this.arrayList, c);
}
;
_.get_2 = function get_29(index_0){
  checkArrayElementIndex(index_0, this.arrayList.array.length);
  return $get_8(this.arrayList, index_0);
}
;
_.isEmpty = function isEmpty_23(){
  return this.arrayList.array.length == 0;
}
;
_.iterator_0 = function iterator_64(){
  return new ArrayList$1(this.arrayList);
}
;
_.remove_2 = function remove_80(index_0){
  return checkArrayElementIndex(index_0, this.arrayList.array.length) , $remove_6(this.arrayList, index_0);
}
;
_.removeRange = function removeRange_2(fromIndex, endIndex){
  $removeRange(this.arrayList, fromIndex, endIndex);
}
;
_.set_2 = function set_20(index_0, elem){
  checkArrayElementIndex(index_0, this.arrayList.array.length);
  return $set_3(this.arrayList, index_0, elem);
}
;
_.size_1 = function size_55(){
  return this.arrayList.array.length;
}
;
_.subList = function subList_7(fromIndex, toIndex){
  return new AbstractList$SubList(this.arrayList, fromIndex, toIndex);
}
;
_.toArray = function toArray_18(){
  return $toArray_0(this.arrayList);
}
;
_.toArray_0 = function toArray_19(a){
  return $toArray_1(this.arrayList, a);
}
;
_.toString_0 = function toString_87(){
  return $toString_5(this.arrayList);
}
;
var Ljava_util_Vector_2_classLit = createForClass('java.util', 'Vector', 606);
function $pop(this$static){
  var sz;
  sz = this$static.arrayList.array.length;
  if (sz > 0) {
    return checkArrayElementIndex(sz - 1, this$static.arrayList.array.length) , $remove_6(this$static.arrayList, sz - 1);
  }
   else {
    throw new EmptyStackException;
  }
}

function $push(this$static, o){
  $add_11(this$static.arrayList, o);
  return o;
}

function Stack(){
  this.arrayList = new ArrayList;
}

defineClass(337, 606, $intern_79, Stack);
var Ljava_util_Stack_2_classLit = createForClass('java.util', 'Stack', 337);
function $clear_7(this$static){
  this$static.root = null;
  this$static.size_0 = 0;
}

function $getEntry_0(this$static, key){
  var c, childNum, tree;
  tree = this$static.root;
  while (tree) {
    c = this$static.cmp.compare_0(key, tree.key);
    if (c == 0) {
      return tree;
    }
    childNum = c < 0?0:1;
    tree = tree.child[childNum];
  }
  return null;
}

function $getNodeAfter(this$static, key){
  var c, foundNode, node;
  foundNode = null;
  node = this$static.root;
  while (node) {
    c = this$static.cmp.compare_0(key, node.key);
    if (c >= 0) {
      node = node.child[1];
    }
     else {
      foundNode = node;
      node = node.child[0];
    }
  }
  return foundNode;
}

function $getNodeBefore(this$static, key){
  var c, foundNode, node;
  foundNode = null;
  node = this$static.root;
  while (node) {
    c = this$static.cmp.compare_0(key, node.key);
    if (c <= 0) {
      node = node.child[0];
    }
     else {
      foundNode = node;
      node = node.child[1];
    }
  }
  return foundNode;
}

function $inOrderAdd(this$static, list, type_0, current, fromKey, fromInclusive, toKey, toInclusive){
  var leftNode, rightNode;
  if (!current) {
    return;
  }
  leftNode = current.child[0];
  !!leftNode && $inOrderAdd(this$static, list, type_0, leftNode, fromKey, fromInclusive, toKey, toInclusive);
  $inRange(this$static, type_0, current.key, fromKey, fromInclusive, toKey, toInclusive) && list.add_1(current);
  rightNode = current.child[1];
  !!rightNode && $inOrderAdd(this$static, list, type_0, rightNode, fromKey, fromInclusive, toKey, toInclusive);
}

function $inRange(this$static, type_0, key, fromKey, fromInclusive, toKey, toInclusive){
  var compare, compare0;
  if (type_0.fromKeyValid() && (compare0 = this$static.cmp.compare_0(key, fromKey) , compare0 < 0 || !fromInclusive && compare0 == 0)) {
    return false;
  }
  if (type_0.toKeyValid() && (compare = this$static.cmp.compare_0(key, toKey) , compare > 0 || !toInclusive && compare == 0)) {
    return false;
  }
  return true;
}

function $insert(this$static, tree, newNode, state){
  var c, childNum;
  if (!tree) {
    return newNode;
  }
   else {
    c = this$static.cmp.compare_0(newNode.key, tree.key);
    if (c == 0) {
      state.value_0 = $setValue(tree, newNode.value_0);
      state.found = true;
      return tree;
    }
    childNum = c < 0?0:1;
    tree.child[childNum] = $insert(this$static, tree.child[childNum], newNode, state);
    if ($isRed(tree.child[childNum])) {
      if ($isRed(tree.child[1 - childNum])) {
        tree.isRed = true;
        tree.child[0].isRed = false;
        tree.child[1].isRed = false;
      }
       else {
        $isRed(tree.child[childNum].child[childNum])?(tree = $rotateSingle(tree, 1 - childNum)):$isRed(tree.child[childNum].child[1 - childNum]) && (tree = $rotateDouble(tree, 1 - childNum));
      }
    }
  }
  return tree;
}

function $isRed(node){
  return !!node && node.isRed;
}

function $put_8(this$static, key, value_0){
  var node, state;
  node = new TreeMap$Node(key, value_0);
  state = new TreeMap$State;
  this$static.root = $insert(this$static, this$static.root, node, state);
  state.found || ++this$static.size_0;
  this$static.root.isRed = false;
  return state.value_0;
}

function $remove_23(this$static, k){
  var state;
  state = new TreeMap$State;
  $removeWithState(this$static, k, state);
  return state.value_0;
}

function $removeEntry(this$static, entry){
  var state;
  state = new TreeMap$State;
  state.matchValue = true;
  state.value_0 = entry.getValue();
  return $removeWithState(this$static, entry.getKey(), state);
}

function $removeWithState(this$static, key, state){
  var c, dir_0, dir2, found, grandparent, head, last, newNode, node, parent_0, sibling;
  if (!this$static.root) {
    return false;
  }
  found = null;
  parent_0 = null;
  head = new TreeMap$Node(null, null);
  dir_0 = 1;
  head.child[1] = this$static.root;
  node = head;
  while (node.child[dir_0]) {
    last = dir_0;
    grandparent = parent_0;
    parent_0 = node;
    node = node.child[dir_0];
    c = this$static.cmp.compare_0(key, node.key);
    dir_0 = c < 0?0:1;
    c == 0 && (!state.matchValue || equals_50(node.value_0, state.value_0)) && (found = node);
    if (!(!!node && node.isRed) && !$isRed(node.child[dir_0])) {
      if ($isRed(node.child[1 - dir_0])) {
        parent_0 = parent_0.child[last] = $rotateSingle(node, dir_0);
      }
       else if (!$isRed(node.child[1 - dir_0])) {
        sibling = parent_0.child[1 - last];
        if (sibling) {
          if (!$isRed(sibling.child[1 - last]) && !$isRed(sibling.child[last])) {
            parent_0.isRed = false;
            sibling.isRed = true;
            node.isRed = true;
          }
           else {
            dir2 = grandparent.child[1] == parent_0?1:0;
            $isRed(sibling.child[last])?(grandparent.child[dir2] = $rotateDouble(parent_0, last)):$isRed(sibling.child[1 - last]) && (grandparent.child[dir2] = $rotateSingle(parent_0, last));
            node.isRed = grandparent.child[dir2].isRed = true;
            grandparent.child[dir2].child[0].isRed = false;
            grandparent.child[dir2].child[1].isRed = false;
          }
        }
      }
    }
  }
  if (found) {
    state.found = true;
    state.value_0 = found.value_0;
    if (node != found) {
      newNode = new TreeMap$Node(node.key, node.value_0);
      $replaceNode(this$static, head, found, newNode);
      parent_0 == found && (parent_0 = newNode);
    }
    parent_0.child[parent_0.child[1] == node?1:0] = node.child[!node.child[0]?1:0];
    --this$static.size_0;
  }
  this$static.root = head.child[1];
  !!this$static.root && (this$static.root.isRed = false);
  return state.found;
}

function $replaceNode(this$static, head, node, newNode){
  var direction, parent_0;
  parent_0 = head;
  direction = parent_0.key == null || this$static.cmp.compare_0(node.key, parent_0.key) > 0?1:0;
  while (parent_0.child[direction] != node) {
    parent_0 = parent_0.child[direction];
    direction = this$static.cmp.compare_0(node.key, parent_0.key) > 0?1:0;
  }
  parent_0.child[direction] = newNode;
  newNode.isRed = node.isRed;
  newNode.child[0] = node.child[0];
  newNode.child[1] = node.child[1];
  node.child[0] = null;
  node.child[1] = null;
}

function $rotateDouble(tree, rotateDirection){
  var otherChildDir;
  otherChildDir = 1 - rotateDirection;
  tree.child[otherChildDir] = $rotateSingle(tree.child[otherChildDir], otherChildDir);
  return $rotateSingle(tree, rotateDirection);
}

function $rotateSingle(tree, rotateDirection){
  var otherChildDir, save;
  otherChildDir = 1 - rotateDirection;
  save = tree.child[otherChildDir];
  tree.child[otherChildDir] = save.child[rotateDirection];
  save.child[rotateDirection] = tree;
  tree.isRed = true;
  save.isRed = false;
  return save;
}

function TreeMap(){
  TreeMap_0.call(this, null);
}

function TreeMap_0(c){
  this.root = null;
  !c && (c = ($clinit_Comparators() , $clinit_Comparators() , NATURAL));
  this.cmp = c;
}

defineClass(253, 638, $intern_33, TreeMap, TreeMap_0);
_.clear_0 = function clear_37(){
  $clear_7(this);
}
;
_.entrySet_0 = function entrySet_8(){
  return new TreeMap$EntrySet(this);
}
;
_.put = function put_5(key, value_0){
  return $put_8(this, key, value_0);
}
;
_.remove_0 = function remove_81(k){
  return $remove_23(this, k);
}
;
_.size_1 = function size_56(){
  return this.size_0;
}
;
_.size_0 = 0;
var Ljava_util_TreeMap_2_classLit = createForClass('java.util', 'TreeMap', 253);
function $next_12(this$static){
  return this$static.last = castTo($next_7(this$static.iter), 21);
}

function $remove_24(this$static){
  $remove_11(this$static.iter);
  $removeEntry(this$static.this$01, this$static.last);
  this$static.last = null;
}

function TreeMap$EntryIterator(this$0){
  TreeMap$EntryIterator_0.call(this, this$0, ($clinit_TreeMap$SubMapType() , All));
}

function TreeMap$EntryIterator_0(this$0, type_0){
  var list;
  this.this$01 = this$0;
  list = new ArrayList;
  $inOrderAdd(this$0, list, type_0, this$0.root, null, false, null, false);
  this.iter = new AbstractList$ListIteratorImpl(list, 0);
}

defineClass(182, 1, $intern_18, TreeMap$EntryIterator);
_.next_1 = function next_40(){
  return $next_12(this);
}
;
_.hasNext_0 = function hasNext_39(){
  return $hasNext_2(this.iter);
}
;
_.remove = function remove_82(){
  $remove_24(this);
}
;
var Ljava_util_TreeMap$EntryIterator_2_classLit = createForClass('java.util', 'TreeMap/EntryIterator', 182);
function TreeMap$EntrySet(this$0){
  this.this$01 = this$0;
  AbstractNavigableMap$EntrySet.call(this, this$0);
}

defineClass(209, 287, $intern_21, TreeMap$EntrySet);
_.clear_0 = function clear_38(){
  $clear_7(this.this$01);
}
;
var Ljava_util_TreeMap$EntrySet_2_classLit = createForClass('java.util', 'TreeMap/EntrySet', 209);
function TreeMap$Node(key, value_0){
  AbstractMap$SimpleEntry.call(this, key, value_0);
  this.child = initUnidimensionalArray(Ljava_util_TreeMap$Node_2_classLit, $intern_12, 183, 2, 0, 1);
  this.isRed = true;
}

defineClass(183, 163, {210:1, 163:1, 21:1, 183:1}, TreeMap$Node);
_.isRed = false;
var Ljava_util_TreeMap$Node_2_classLit = createForClass('java.util', 'TreeMap/Node', 183);
function TreeMap$State(){
}

defineClass(254, 1, {}, TreeMap$State);
_.toString_0 = function toString_88(){
  return 'State: mv=' + this.matchValue + ' value=' + this.value_0 + ' done=' + this.done_0 + ' found=' + this.found;
}
;
_.done_0 = false;
_.found = false;
_.matchValue = false;
var Ljava_util_TreeMap$State_2_classLit = createForClass('java.util', 'TreeMap/State', 254);
function $clinit_TreeMap$SubMapType(){
  $clinit_TreeMap$SubMapType = emptyMethod;
  All = new TreeMap$SubMapType('All', 0);
  Head = new TreeMap$SubMapType$1;
  Range_0 = new TreeMap$SubMapType$2;
  Tail = new TreeMap$SubMapType$3;
}

function TreeMap$SubMapType(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function values_60(){
  $clinit_TreeMap$SubMapType();
  return stampJavaTypeInfo(getClassLiteralForArray(Ljava_util_TreeMap$SubMapType_2_classLit, 1), $intern_13, 138, 0, [All, Head, Range_0, Tail]);
}

defineClass(138, 17, $intern_80, TreeMap$SubMapType);
_.fromKeyValid = function fromKeyValid(){
  return false;
}
;
_.toKeyValid = function toKeyValid(){
  return false;
}
;
var All, Head, Range_0, Tail;
var Ljava_util_TreeMap$SubMapType_2_classLit = createForEnum('java.util', 'TreeMap/SubMapType', 138, Ljava_lang_Enum_2_classLit, values_60);
function TreeMap$SubMapType$1(){
  TreeMap$SubMapType.call(this, 'Head', 1);
}

defineClass(352, 138, $intern_80, TreeMap$SubMapType$1);
_.toKeyValid = function toKeyValid_0(){
  return true;
}
;
var Ljava_util_TreeMap$SubMapType$1_2_classLit = createForEnum('java.util', 'TreeMap/SubMapType/1', 352, Ljava_util_TreeMap$SubMapType_2_classLit, null);
function TreeMap$SubMapType$2(){
  TreeMap$SubMapType.call(this, 'Range', 2);
}

defineClass(353, 138, $intern_80, TreeMap$SubMapType$2);
_.fromKeyValid = function fromKeyValid_0(){
  return true;
}
;
_.toKeyValid = function toKeyValid_1(){
  return true;
}
;
var Ljava_util_TreeMap$SubMapType$2_2_classLit = createForEnum('java.util', 'TreeMap/SubMapType/2', 353, Ljava_util_TreeMap$SubMapType_2_classLit, null);
function TreeMap$SubMapType$3(){
  TreeMap$SubMapType.call(this, 'Tail', 3);
}

defineClass(354, 138, $intern_80, TreeMap$SubMapType$3);
_.fromKeyValid = function fromKeyValid_1(){
  return true;
}
;
var Ljava_util_TreeMap$SubMapType$3_2_classLit = createForEnum('java.util', 'TreeMap/SubMapType/3', 354, Ljava_util_TreeMap$SubMapType_2_classLit, null);
function $add_20(this$static, o){
  return $put_8(this$static.map_0, o, ($clinit_Boolean() , FALSE_0)) == null;
}

function $higher(this$static, e){
  return getEntryKeyOrNull($getNodeAfter(this$static.map_0, e));
}

function $lower(this$static, e){
  return getEntryKeyOrNull($getNodeBefore(this$static.map_0, e));
}

function $remove_25(this$static, o){
  return $remove_23(this$static.map_0, o) != null;
}

function TreeSet(){
  this.map_0 = new TreeMap;
}

function TreeSet_0(c){
  this.map_0 = new TreeMap_0(c);
}

defineClass(191, 640, {3:1, 22:1, 19:1, 18:1, 137:1, 191:1}, TreeSet, TreeSet_0);
_.add_1 = function add_38(o){
  return $add_20(this, o);
}
;
_.clear_0 = function clear_39(){
  $clear_7(this.map_0);
}
;
_.contains = function contains_41(o){
  return $containsKey_2(this.map_0, o);
}
;
_.iterator_0 = function iterator_65(){
  var entryIterator;
  return entryIterator = new TreeMap$EntryIterator((new TreeMap$EntrySet((new AbstractNavigableMap$NavigableKeySet(this.map_0)).map_0)).this$01_0) , new AbstractNavigableMap$NavigableKeySet$1(entryIterator);
}
;
_.remove_1 = function remove_83(o){
  return $remove_25(this, o);
}
;
_.size_1 = function size_57(){
  return this.map_0.size_0;
}
;
var Ljava_util_TreeSet_2_classLit = createForClass('java.util', 'TreeSet', 191);
function now_2(){
  if (Date.now) {
    return Date.now();
  }
  return (new Date).getTime();
}

function getObjectIdentityHashCode(o){
  return o.$H || (o.$H = ++sNextHashId);
}

var sNextHashId = 0;
function $clinit_StringHashCache(){
  $clinit_StringHashCache = emptyMethod;
  back_0 = {};
  front = {};
}

function compute(str){
  var hashCode, i, n, nBatch;
  hashCode = 0;
  n = ($clinit_String() , str.length);
  nBatch = n - 4;
  i = 0;
  while (i < nBatch) {
    hashCode = str.charCodeAt(i + 3) + 31 * (str.charCodeAt(i + 2) + 31 * (str.charCodeAt(i + 1) + 31 * (str.charCodeAt(i) + 31 * hashCode)));
    hashCode = hashCode | 0;
    i += 4;
  }
  while (i < n) {
    hashCode = hashCode * 31 + charAt(str, i++);
  }
  hashCode = hashCode | 0;
  return hashCode;
}

function getHashCode_0(str){
  $clinit_StringHashCache();
  var hashCode, key, result;
  key = ':' + str;
  result = front[key];
  if (!(result === undefined)) {
    return result;
  }
  result = back_0[key];
  hashCode = result === undefined?compute(str):result;
  increment_0();
  front[key] = hashCode;
  return hashCode;
}

function increment_0(){
  if (count_3 == 256) {
    back_0 = front;
    front = {};
    count_3 = 0;
  }
  ++count_3;
}

var back_0, count_3 = 0, front;
var I_classLit = createForPrimitive('int', 'I');
var Z_classLit = createForPrimitive('boolean', 'Z');
var C_classLit = createForPrimitive('char', 'C');
var D_classLit = createForPrimitive('double', 'D');
var F_classLit = createForPrimitive('float', 'F');
var $entry = entry_0;
var gwtOnLoad = gwtOnLoad = gwtOnLoad_0;
addInitFunctions(init);
setGwtProperty('permProps', [[['locale', 'default'], ['user.agent', 'gecko1_8']]]);

var $moduleName, $moduleBase, $stats = function(){}, $sessionId = function(){};
gwtOnLoad(null,'klay',null);
})();
